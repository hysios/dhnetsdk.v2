/*!
 * <File comment goes here!!>
 * 
 * Copyright (c) 2005 by <your name/ organization here>
 */
#ifndef DHNETSDK_H
#define DHNETSDK_H


#if (defined(WIN32) || defined(_WIN32) || defined(_WIN64))
    #include <windows.h>
    #ifdef NETSDK_EXPORTS
        #define CLIENT_NET_API  __declspec(dllexport)
    #else
        #define CLIENT_NET_API  __declspec(dllimport)
    #endif

    #define CALLBACK        __stdcall
    #define CALL_METHOD     __stdcall  //__cdecl

    #define INT64           __int64
    #define TP_U64          unsigned __int64

    #ifndef LLONG
        #ifdef _WIN64
            #define LLONG   INT64
        #else 
            #define LLONG   LONG
        #endif
    #endif

    #ifndef LDWORD
        #ifdef _WIN64
            #define LDWORD  INT64
        #else 
            #define LDWORD  DWORD
        #endif
    #endif
#else    //non-windows
#ifdef __cplusplus
    #define CLIENT_NET_API  extern "C"
#else
	#define CLIENT_NET_API  
	#define bool unsigned char
	#define LINUX64_JNA
#endif
    #define CALL_METHOD 
    #define CALLBACK

    #ifndef INTERNAL_COMPILE
        #define RELEASE_HEADER
    #endif
 
    #ifdef RELEASE_HEADER
        #define WORD        unsigned short
        #define DWORD       unsigned int
        #define LONG        int
        #define LPDWORD     DWORD*

        #ifdef __OBJC__
            #include "objc/objc.h"
        #else
            #define BOOL    int
        #endif

        #ifndef TRUE
        #define TRUE        1
        #endif

        #ifndef FALSE
        #define FALSE       0
        #endif
        #define BYTE        unsigned char
        #define UINT        unsigned int
        #define HDC         void*
        #define HWND        void*
        #define LPVOID      void*

        #ifndef NULL
        #define NULL        0
        #endif

        #define LLONG       long
        #define INT64       long long
        #define TP_U64      unsigned long long
        #define LDWORD      long 

        #ifndef MAX_PATH
        #define MAX_PATH    260
        #endif

        #ifndef DEF_RECT
        typedef struct  tagRECT
        {
            LONG left;
            LONG top;
            LONG right;
            LONG bottom;
        } RECT;
        #define DEF_RECT
        #endif
    #else	//Internal translation
        #include "../Platform/osIndependent.h"
        #define INT64       int64
        #define TP_U64      uint64
    #endif // RELEASE_HEADER
#endif // linux

#ifndef LDWORD
    #if (defined(WIN32) || defined(_WIN32) || defined(_WIN64))
        #ifdef _WIN64
            #define LDWORD  __int64
        #else //WIN32 
            #define LDWORD  DWORD
        #endif
    #else    //linux
        #define LDWORD      long 
    #endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

/************************************************************************
 ** Constant Definition
 ***********************************************************************/
#define DH_SERIALNO_LEN                     48          // Device SN string length
#define DH_MAX_DISKNUM                      256         // Max HDD number
#define DH_MAX_SDCARDNUM                    32          // Max SD card number
#define DH_MAX_BURNING_DEV_NUM              32          // Max burner amount
#define DH_BURNING_DEV_NAMELEN              32          // Burner name max length 
#define DH_MAX_LINK                         6           
#define DH_MAX_CHANNUM                      16          // Max channel amount
#define DH_MAX_DECODER_CHANNUM              64          // decoder device max channel number
#define DH_MAX_ALARMIN                      128         // Max alarm input amount 
#define DH_MAX_ALARMOUT                     64          // Max alarm output amount 
#define DH_MAX_RIGHT_NUM                    100         // Max user right amount
#define DH_MAX_GROUP_NUM                    20          // Max user group amount
#define DH_MAX_USER_NUM                     200         // Max user account amount
#define DH_RIGHT_NAME_LENGTH                32          // Right name length
#define DH_USER_NAME_LENGTH                 8           // User name length 
#define DH_USER_PSW_LENGTH                  8           // User password length 
#define DH_CUSTOM_NAME_LENGTH               32          // Custom name length
#define DH_USER_NAME_LEN_EX                 32          // User name length ,for extension
#define DH_USER_PSW_LEN_EX                  32          // User password length ,for extension
#define DH_MEMO_LENGTH                      32          // Note length 
#define DH_MAX_STRING_LEN                   128         
#define MAX_STRING_LINE_LEN                 6           // Max six rows
#define MAX_PER_STRING_LEN                  20          // Line max length 
#define DH_MAX_MAIL_NAME_LEN                64          // The user name length the new mail structure supported
#define DH_MAX_MAIL_PSW_LEN                 64          // Password length the new mail structhre supported
#define DH_SPEEDLIMIT_TYPE_LEN              32          // speed limit string max length
#define DH_VEHICLE_TYPE_LEN                 32          // vehicle info type max length
#define DH_VEHICLE_INFO_LEN                 32          // vehicle info string max length
#define DH_VEHICLE_DRIVERNO_LEN             32          // Driver no string max length=
#define DH_MAX_CROSSING_NUM                 128         // Max supported crossing num 
#define DH_MAX_CROSSING_ID                  32          // Max crossing ID length 
#define DH_MAX_CARD_INFO_LEN                256         // max card info length
#define DH_MAX_CHANNUM_EX                   32          // extended max channel number
#define DH_MAX_SAERCH_IP_NUM                256         // max number of IP for saerch
#define DH_MAX_HARDDISK_TYPE_LEN            32          // hard disk type maximum length
#define DH_MAX_HARDDISK_SERIAL_LEN          32          // hard disk serial maximum length
#define DH_MAX_SIM_LEN                      16          // value of SIM maximum length
#define DH_MAX_SIM_NUM                      10          // pick up SIM maximum number
#define DH_MAX_VERSION_LEN                  32          // version maximum length
#define DH_MAX_MDN_LEN                      36          // value of MDN maximum length
#define DH_MAX_NETINTERFACE_NUM             64          // support the card number
#define DH_EVENT_NAME_LEN                   128         // length of event name
#define DH_STORAGE_NAME_LEN                 128         // length of storage name
#define DH_MAX_CARPORTLIGHT_NUM             4           // carport light maximum number
#define DH_STATION_NAME_LEN                 32          // length of station name
#define PTZ_PRESET_NAME_LEN                 64          // Length of PTZ preset name
#define DH_MAX_GUARD_DETECT_ID_COUNT        64          // Max Station Detection ID Number
#define DH_MAX_VERSION_STR                  64          // Max length of version string
#define DH_MAX_AUDIO_MATRIX_OUTPUT          8           // The Maximum OutPut Channels Of Each Audio Matrix
#define DH_MAX_CHANNEL_COUNT                16          // Supports maximum number of channels
#define DH_COMMON_STRING_4                  4           // Common string length 4
#define DH_COMMON_STRING_8                  8           // Common string length 8
#define DH_COMMON_STRING_16                 16          // Common string length 16
#define DH_COMMON_STRING_32                 32          // Common string length 32
#define DH_COMMON_STRING_36			  		36          // Common string length 36
#define DH_COMMON_STRING_64                 64          // Common string length 64
#define DH_COMMON_STRING_128                128         // Common string length 128
#define DH_COMMON_STRING_256                256         // Common string length 256
#define DH_COMMON_STRING_512                512         // Common string length 512
#define DH_COMMON_STRING_1024               1024        // Common string length 1024
#define DH_COMMON_STRING_2048               2048        // Common string length 2048
#define DH_MAX_ACCESS_NAME_LEN              64          // Length of access name
#define DH_MAX_EXALARMCHANNEL_NAME_LEN      128         // Length of extension module alarm channel name
#define DH_MAX_ALARM_SUBSYSTEM_NUM          256         // Max Alarm Sub System Number
#define DH_MAX_BELL_NUM                     4           // Max Bell Number
#define DH_MAX_KEYBOARD_NUM                 256         // Max Keyboard Number
#define MAX_GOURP_NUM                       128         // Face library max number
#define MAX_PWD_MODIFIEDTIME_LEN		    20			// max password modifiedtime length	
#define MAX_ONVIF_USER_NUM				    20			// Onvif user upper limit number
#define DH_MAX_POS_EXCHANGE_INFO            64          // Max NET_POSEXCHANGE_INFO array Number
#define NET_INTERFACE_DEFAULT_TIMEOUT       3000        // Interface default timeout
#define DH_MAX_BUSCARD_NUM                  64          // The max of length of bus card number
#define DH_MAX_POS_MAC_NUM                  8           // The max of POS Mac number
#define DH_MAX_MARK_FILE_NAME_LEN           124         // the max of video control mark-file
#define NET_MAX_ATTACHMENT_NUM              8           // the max of car attachment number
#define NET_MAX_ANNUUALINSPECTION_NUM       8           // the max of car AnnualInspection number
#define NET_MAX_EVENT_PIC_NUM               6           // the max of traffic event picture number
#define NET_MAX_MONTH_NUM                   31          // the max of month number
#define NET_IPADDRSTR_LEN                   46          // the max length of ipaddr  ipv4-mapped-on-ipv6 
#define NET_MAX_AP_NUM                      3           // the max of access-point number
#define MAX_WEP_KEY_NUM                     4           // the max of WEP password number
#define MAX_CARNO_LEN                       20          // the max length of car no
#define MAX_COACHNO_LEN                     12          // the max length of coach no 
#define MAX_WORKPATTERN_NUM                 2           // the max of work pattern number
#define MAX_NETPORT_NUM						5			// the max of NetPort number
#define MAX_ANTIFLICKERMODE_COUNT           8           // The max number of anti-flicker mode
#define MAX_CATEGORY_LEN                    64          // Max category len
#define MAX_DANGER_GRADE_NUM				8		    // Max package danger grade number
#define MAX_INSIDE_OBJECT_TYPE_NUM		    32			// Max package goods type number
#define MAX_PATH_LEN					    260			// Max path len
#define MAX_XRAY_CHANNEL_NUM				10			// Max Xray channel num 
#define MAX_HISTORY_TEMPERATURE_NUM			64		    // Max history temperature num
#define MAX_TEMPERATURE_POINT_NUM			8			// Max temperature point num
#define MAX_GROUP_LEN					    128			// Max group len
#define MAX_ILLEGAL_LOGIN_IP_LEN			40			// Max illegal login IP len
#define DH_COMMON_STRING_20    		    	20			// Common string length 20
#define MAX_EVENT_ID_LEN					52			// Max Chinese standard event ID len
#define MAX_HUMANTRAIT_EVENT_LEN			36          // Max human trait event len
#define DH_COMMON_STRING_24                 24          // Common string length 24
#define MAX_TEMPERATUREEX_POINT_NUM			12			// Max temperature num
#define MAX_PIRPARAM_NUM					10          // Max pirParam num
#define MAX_ENCRYPT_SYSTEM_INFO_CONTENT_LEN 8192	    // Max encrypt system info content len
#define MAX_LOCAL_EXT_ALARM_NAME_LEN	  64			// Max local ext alarm name len
#define MAX_TASK_ID_LEN					  64			// Max task ID len
#define MAX_FILE_PATH_LEN				  256			// Max file path len
#define MAX_IMAGE_INFO_NUM				  8				// Max image info num
#define MAX_DIAL_RESULT_LEN				  2048			// Max dialresult len
#define MAX_COUNTRY_CODE_LEN				4			// Max country code len
#define MAX_PROVINCE_CODE_LEN				64			// Max province code len
#define MAX_CITY_CODE_LEN					64			// Max city code len
#define MAX_AREA_CODE_LEN					64			// Max area code len
#define MAX_REQ_INFO_LEN					1600		// Max req info len
#define MAX_SIP_SVR_ID_LEN					24			// Max SIP server ID len 
#define MAX_SIP_DOMAIN_LEN				    128			// Max SIP domain len
#define MAX_SIP_SVR_IP_LEN				    128			// Max SIP server IP len
#define MAX_SIP_SERVER_DEVICE_ID_LEN		24			// Max device ID len
#define MAX_REG_PASSWORD_LEN			    24			// Max register password len
#define MAX_CIVIL_CODE_LEN				    24			// Max civil code len
#define MAX_INTERVIDEO_ID_LEN			    24			// Max intervideo ID len
#define	MAX_CHANNEL_ID_LEN					24			// Max channel ID len
#define MAX_SIP_SERVER_NUM				    5		    // Max SIP server info num
#define	MAX_GB28181_PROTOCOL_VERSION	    16			// Max GB28181 protocol version len
#define DH_MAX_FACEDETECT_FEATURE_NUM       32          // max number of detected human face feature
#define MAX_ATTACHMENT_NUM				    8			// Max number of attachment
#define MAX_ERRORCODE_NUM                 512           // Max number of error code
#define MAX_PUSH_STREAM_AUTH_SSID			80			// Max SSID len of push stream client

// Remote configuration structure corresponding constant 
#define DH_MAX_MAIL_ADDR_LEN                128           // Mail address max length
#define DH_MAX_MAIL_SUBJECT_LEN             64            // Mail subject max length 
#define DH_MAX_IPADDR_LEN                   16            // IP address string length 
#define DH_MAX_IPADDR_LEN_EX                40            // extension IP address support IPV6
#define DH_MACADDR_LEN                      40            // MACE address string length
#define DH_MAX_URL_LEN                      128           // URL string length 
#define DH_MAX_DEV_ID_LEN                   48            // Device serial number max length 
#define DH_MAX_HOST_NAMELEN                 64            // Host name length 
#define DH_MAX_HOST_PSWLEN                  32            // Password length 
#define DH_MAX_NAME_LEN                     16            // Universal name string length 
#define DH_MAX_ETHERNET_NUM                 2             // Ethernet max amount 
#define DH_MAX_ETHERNET_NUM_EX              10            // extended Ethernet max amount
#define DH_DEV_SERIALNO_LEN                 48            // Serial number string length 
#define DH_DEV_CLASS_LEN                    16            // Device type string (such as IPC) length 
#define DH_DEV_TYPE_LEN                     32            // Device type string length 
#define DH_N_WEEKS                          7             // The days in one week 
#define DH_N_TSECT                          6             // Time period amount 
#define DH_N_REC_TSECT                      6             // Record period amount 
#define DH_N_COL_TSECT                      2             // Color period amount 
#define DH_CHAN_NAME_LEN                    32            // Channel name length. DVR DSP capacity limit. Max 32 bytes.        
#define DH_N_ENCODE_AUX                     3             // Extra stream amount 
#define DH_N_TALK                           1             // Max audio talk channel amount 
#define DH_N_COVERS                         1             // Privacy mask zone amount 
#define DH_N_CHANNEL                        16            // Max channel amount 
#define DH_N_ALARM_TSECT                    2             // Alarm prompt period amount 
#define DH_MAX_ALARMOUT_NUM                 16            // Alarm output ports max amount 
#define DH_MAX_AUDIO_IN_NUM                 16            // Audio input ports max amount 
#define DH_MAX_VIDEO_IN_NUM                 16            // Video input ports max amount 
#define DH_MAX_ALARM_IN_NUM                 16            // Alarm input ports max amount 
#define DH_MAX_DISK_NUM                     16            // HDD max amount. Now the value is 16.
#define DH_MAX_DECODER_NUM                  16            // Decoder(485) max amount 
#define DH_MAX_232FUNCS                     10            // 232 COM function max amount 
#define DH_MAX_232_NUM                      2             // 232 COM port max amount 
#define DH_MAX_232_NUM_EX                   16            // extended 232 COM port max amount 
#define DH_MAX_DECPRO_LIST_SIZE             100           // Decoder protocol list max amount 
#define DH_FTP_MAXDIRLEN                    240           // FTP file folder max length 
#define DH_MATRIX_MAXOUT                    16            // Matrix output ports max amount
#define DH_TOUR_GROUP_NUM                   6             // Matrix output ports max amount 
#define DH_MAX_DDNS_NUM                     10            // DDNS max amount the device supported 
#define DH_MAX_SERVER_TYPE_LEN              32            // DDNS type and max string length 
#define DH_MAX_DOMAIN_NAME_LEN              256           // DDNS domain name and max string length 
#define DH_MAX_DDNS_ALIAS_LEN               32            // DDNS alias and max string length 
#define DH_MAX_DEFAULT_DOMAIN_LEN           60            // DDNS default domain, max sring length    
#define DH_MOTION_ROW                       32            // Motion detection zone row amount 
#define DH_MOTION_COL                       32            // Motion detection zone column amount 
#define DH_STATIC_ROW                       32            // Static detection zone row amount 
#define DH_STATIC_COL                       32            // Static detection zone column amount 
#define DH_FTP_USERNAME_LEN                 64            // FTP setup:user name max length 
#define DH_FTP_PASSWORD_LEN                 64            // FTP setup:password max length 
#define DH_TIME_SECTION                     2             // FTP setup:time periods in each day.
#define DH_FTP_MAX_PATH                     240           // FTP setup:file path max length 
#define DH_FTP_MAX_SUB_PATH                 128           // FTP setup:sub path max length
#define DH_INTERVIDEO_UCOM_CHANID           32            // Platform embedded setup:U China Net Communication (CNC)channel ID
#define DH_INTERVIDEO_UCOM_DEVID            32            // Platform embedded setup:UCNC device ID
#define DH_INTERVIDEO_UCOM_REGPSW           16            // Platform embedded setup:UCNC registration password 
#define DH_INTERVIDEO_UCOM_USERNAME         32            // Platform embedded setup:UCNC user name 
#define DH_INTERVIDEO_UCOM_USERPSW          32            // Platform embedded setup: UCNC password 
#define DH_INTERVIDEO_NSS_IP                32            // Platform embedded setup:ZTE Netview IP
#define DH_INTERVIDEO_NSS_SERIAL            32            // Serial Platform embedded setup:ZTE Netview  serial
#define DH_INTERVIDEO_NSS_USER              32            // User Platform embedded setup:ZTE Netview user
#define DH_INTERVIDEO_NSS_PWD               50            // Password Platform embedded setup:ZTE Netview password
#define DH_MAX_VIDEO_COVER_NUM              16            // Privacy mask zones max amount 
#define DH_MAX_WATERMAKE_DATA               4096          // Watermark data max length 
#define DH_MAX_WATERMAKE_LETTER             128           // Watermark text max length
#define DH_MAX_WLANDEVICE_NUM               10            // Max searched wireless device amount 
#define DH_MAX_WLANDEVICE_NUM_EX            32            // Max searched wireless device amount
#define MAX_WLAN_DEVICE_NUM					128			  // Max searched wireless device amount
#define DH_MAX_ALARM_NAME                   64            // Address length 
#define DH_MAX_REGISTER_SERVER_NUM          10            // Auto registration server amount 
#define DH_SNIFFER_FRAMEID_NUM              6             // 6 FRAME ID options
#define DH_SNIFFER_CONTENT_NUM              4             // 4 sniffer in each FRAME
#define DH_SNIFFER_CONTENT_NUM_EX           8             // 8 sniffer in each FRAME
#define DH_SNIFFER_PROTOCOL_SIZE            20            // protocol length
#define DH_MAX_PROTOCOL_NAME_LENGTH         20
#define DH_SNIFFER_GROUP_NUM                4             // 4 group sniffer setup 
#define MAX_PATH_STOR                       240           // Remote folder length 
#define DH_ALARM_OCCUR_TIME_LEN             40            // New alarm upload time length 
#define DH_VIDEO_OSD_NAME_NUM               64            // Overlay name length. Now it supports 32-digit English and 16-digit Chinese.
#define DH_VIDEO_CUSTOM_OSD_NUM             8             // The self-defined amount supported excluding time and channel.
#define DH_VIDEO_CUSTOM_OSD_NUM_EX          256           // The self-defined amount supported excluding time and channel.
#define DH_CONTROL_AUTO_REGISTER_NUM        100           // Targeted initiatives to support the number of registration servers
#define DH_MMS_RECEIVER_NUM                 100           // Support the number of messages the recipient
#define DH_MMS_SMSACTIVATION_NUM            100           // Support the number of SMS sender
#define DH_MMS_DIALINACTIVATION_NUM         100           // Support for dial-up number of the sender
#define DH_MAX_ALARMOUT_NUM_EX              32            // Alarm output amount max limit
#define DH_MAX_VIDEO_IN_NUM_EX              32            // Video input amount max limit
#define DH_MAX_ALARM_IN_NUM_EX              32            // Alarm input amount max limit
#define DH_MAX_IPADDR_OR_DOMAIN_LEN         64            // IP or domain name length
#define DH_MAX_CALLID                       32            // Call ID
#define DH_MAX_OBJECT_LIST                  16            // the upper limit number of object id that detected by device in intelligent analysis 
#define DH_MAX_OBJECT_NUM				    32			  // Max number of object
#define DH_MAX_RULE_LIST                    16            // the upper limit number of device rule in intelligent analysis 
#define DH_MAX_POLYGON_NUM                  16            // the max number of polygon's culmination
#define DH_MAX_DETECT_LINE_NUM              20            // rule detect line's max point number
#define DH_MAX_DETECT_REGION_NUM            20            // rule detect region's max point number
#define MAX_CARGO_CHANNEL_NUM			    8			  // Max Cargo Channel Num
#define DH_MAX_TRACK_LINE_NUM               20            // object moving track's max point number
#define DH_MAX_CANDIDATE_NUM                50            // max candidate number
#define DH_MAX_PERSON_IMAGE_NUM             48            // max image of every person
#define DH_MAX_FENCE_LINE_NUM               2             // max fence line number
#define MAX_SMART_VALUE_NUM                 30            // the max number of smart disk information
#define DH_MACHINE_NAME_NUM                 64            // Device name length
#define DH_INTERVIDEO_AMP_DEVICESERIAL      48            // Platform embedded setup, AMP,Device serial num length
#define DH_INTERVIDEO_AMP_DEVICENAME        16            // Platform embedded setup, AMP,Device Name length
#define DH_INTERVIDEO_AMP_USER              32            // Platform embedded setup, AMP,User Name Length
#define DH_INTERVIDEO_AMP_PWD               32            // Platform embedded setup, AMP,password length
#define MAX_SUBMODULE_NUM                   32            // Max number of submodule information
#define DH_MAX_CARWAY_NUM                   8             // traffic snapshot,the max car way number
#define DH_MAX_SNAP_SIGNAL_NUM              3             // one car way max time for snapshot
#define DH_MAX_CARD_NUM                     128           // max number of card
#define DH_MAX_CARDINFO_LEN                 32            // max length of card information
#define MAX_COMPANION_CARD_NUM              6             // max number of companion card information
#define DH_MAX_CONTROLER_NUM                64            // max supported controller number
#define DH_MAX_LIGHT_NUM                    32            // max control light group number
#define DH_MAX_SNMP_COMMON_LEN              64            // max Snmp read or write buffer
#define DH_MAX_DDNS_STATE_LEN               128           // max DDNS state buffer
#define DH_MAX_PHONE_NO_LEN                 16            // max phone len
#define DH_MAX_MSGTYPE_LEN                  32            // max type len
#define DH_MAX_MSG_LEN                      256           // max message len
#define DH_MAX_DRIVINGDIRECTION             256           // max drivingdirection len
#define DH_MAX_GRAB_INTERVAL_NUM            4             // max snapshot count
#define DH_MAX_FLASH_NUM                    5             // max flash count
#define DH_MAX_LANE_NUM                     8             // max number of road in every channel
#define DH_MAX_ISCSI_PATH_NUM               64            // max ISCSI remote path number
#define DH_MAX_WIRELESS_CHN_NUM             256           // max wireless channel number
#define DH_PROTOCOL3_BASE                   100           // protocol 3 base value
#define DH_PROTOCOL3_SUPPORT                11            // prococol 3 support
#define DH_MAX_CHANMASK                     64            // max channel mask
#define DH_MAX_STAFF_NUM                    20            // max of compressed video configuration staff number
#define DH_MAX_CALIBRATEBOX_NUM             10            // max of compressed video configuration calibrate region
#define DH_MAX_EXCLUDEREGION_NUM            10            // max of compressed video configuration exclude region
#define DH_MAX_POLYLINE_NUM                 20            // number of compressed video configuration poly line
#define DH_MAX_COLOR_NUM                    16            // color maximum number
#define MAX_OBJFILTER_NUM                   16            // max number of  filter type 
#define DH_MAX_SYNOPSIS_STATE_NAME          64            // string state length of compressed video 
#define DH_MAX_SYNOPSIS_QUERY_FILE_COUNT    10            // the file number limit
#define DH_MAX_SSID_LEN                     36            // length of SSID
#define DH_MAX_APPIN_LEN                    16            // length of PIN
#define DH_NETINTERFACE_NAME_LEN            260           // length of net port
#define DH_NETINTERFACE_TYPE_LEN            260           // length of net type
#define DH_MAX_CONNECT_STATUS_LEN           260           // length of connect status
#define DH_MAX_MODE_LEN                     64            // length of 3G mode support
#define DH_MAX_MODE_NUM                     64            // number of 3G mode support
#define DH_MAX_COMPRESSION_TYPES_NUM        16            // max number of video compression types
#define DH_MAX_CAPTURE_SIZE_NUM             64            // number of video resolution 
#define DH_NODE_NAME_LEN                    64            // length of node name
#define MAX_CALIBPOINTS_NUM                 256           // max number of point support
#define DH_MAX_ATTR_NUM                     32            // the maximum number display element attributes
#define DH_MAX_CLOUDCONNECT_STATE_LEN       128           // length of cloud connect state
#define DH_MAX_IPADDR_EX_LEN                128           // IP entended maximum length
#define DH_MAX_PLATE_NUMBER_LEN             32            // plate string length    
#define DH_MAX_AUTHORITY_LIST_NUM           16            // max in authority list   
#define DH_MAX_CITY_NAME_LEN                64            // max length of city name
#define DH_MAX_PROVINCE_NAME_LEN            64            // max length of province name
#define DH_MAX_PERSON_ID_LEN                32            // max length of person ID
#define MAX_FACE_AREA_NUM                   8             // max number if face area
#define MAX_FACE_DB_NUM                     8             // max number of face DB
#define MAX_EVENT_NAME                      128           // max event name
#define DH_MAX_ETH_NAME                     64            // max network card name
#define DH_MAX_PERSON_NAME_LEN              64            // max length of person name
#define DH_N_SCHEDULE_TSECT                 8             // element number of schedule    
#define DH_MAX_URL_NUM                      8             // max URL number
#define DH_MAX_LOWER_MITRIX_NUM             16            // max lower mitrix number
#define DH_MAX_BURN_CHANNEL_NUM             32            // max burn channel number
#define DH_MAX_NET_STRORAGE_BLOCK_NUM       64            // max remote storage block number 
#define DH_MAX_CASE_PERSON_NUM              32            // max number of case person
#define DH_MAX_MULTIPLAYBACK_CHANNEL_NUM    64            // max channel number of multiplayback channel
#define DH_MAX_MULTIPLAYBACK_SPLIT_NUM      32            // max split number of multipalyback channel
#define DH_MAX_AUDIO_ENCODE_TYPE            64            // Max audio encoding type quantity
#define MAX_LOG_PATH_LEN                    260           // Max log path name length
#define MAX_CARD_RECORD_FIELD_NUM           16            // Card No. Max Domain Quantity
#define DH_BATTERY_NUM_MAX                  16            // max battery number    
#define DH_POWER_NUM_MAX                    16            // max power number    
#define DH_MAX_AUDIO_PATH                   260           // max path of audio file
#define DH_MAX_DOORNAME_LEN                 128           // max length of door access name
#define DH_MAX_CARDPWD_LEN                  64            // max length of door access name
#define NET_MAX_FISHEYE_MOUNTMODE_NUM       4             // Max fish eye installation mode number
#define NET_MAX_FISHEYE_CALIBRATEMODE_NUM   16            // Max fish eye correction mode number
#define NET_MAX_FISHEYE_EPTZCMD_NUM         64            // Max fish eye electronic PTZ operation number  
#define POINT_NUM_IN_PAIR                   2             // Point Number in Pair
#define MAX_POINT_PAIR_NUM                  128           // Point Max Quantity
#define CHANNEL_NUM_IN_POINT_GROUP          2             // Point Video Channel Number
#define MAX_POINT_GROUP_NUM                 32            // Point Group Max Quantity. Each two channel splicing requires one group of point. 
#define MAX_LANE_INFO_NUM                   32            // Max lane info number
#define MAX_LANE_DIRECTION_NUM              8             // Lane direction total
#define DH_MAX_MONITORWALL_NUM              32            // TV wall max quantity
#define DH_MAX_OPTIONAL_URL_NUM             8             // The max number of alternate URL
#define DH_MAX_CAMERA_CHANNEL_NUM           1024          // Max channel amount
#define MAX_SIMILARITY_COUNT			   1024			  // Max similarity count
#define MAX_FEATURESTATE_NUM		        4			  // Max feature state count
#define MAX_FILE_SUMMARY_NUM                32            // Max file summary amount  
#define MAX_AUDIO_ENCODE_NUM                64            // Max audio encode amount
#define MAX_MONITORWALL_NAME_LEN            64            // Max length of TV Wall name
#define MAX_FLASH_LIGHT_NUM                 8             // Max flash light amount
#define MAX_STROBOSCOPIC_LIGHT_NUM          8             // Max stroboscopic light amount
#define MAX_MOSAIC_NUM                      8             // Max counts of mosaic 
#define MAX_MOSAIC_CHANNEL_NUM              256           // Max counts of channels which supported video mosaic
#define MAX_FIREWARNING_INFO_NUM            4             // Max Counts of fire-warning info
#define MAX_AXLE_NUM                        8             // Max counts of axle 
#define DH_MAX_BULLET_HOLES                 10            // MAX counts of bullet holes
#define MAX_PLATE_NUM                       64            // MAX Plate counts in picture
#define MAX_PREVIEW_CHANNEL_NUM             64            // MAX preview channel number
#define MAX_EVENT_RESTORE_UUID              36            // Event restore uuid array size
#define MAX_EVENT_RESTORE_CODE_NUM          8             // Max event restore code num
#define MAX_EVENT_RESOTER_CODE_TYPE         32            // Event restore code type array size
#define MAX_SNAP_TYPE                       3             // snap type number
#define MAX_MAINFORMAT_NUM                  4             // main format number
#define CUSTOM_TITLE_LEN                    1024          // custom title name len 
#define MAX_CUSTOM_TITLE_NUM                8             // max custom title num
#define FORMAT_TYPE_LEN                     16            // max length of  format type
#define MAX_CHANNEL_NAME_LEN                256           // max length of channel name
#define MAX_VIRTUALINFO_DOMAIN_LEN          64            // virtual information domain length
#define MAX_VIRTUALINFO_TITLE_LEN           64            // virtual information net title length
#define MAX_VIRTUALINFO_USERNAME_LEN        32            // virtual information username length
#define MAX_VIRTUALINFO_PASSWORD_LEN        32            // virtual information password length
#define MAX_VIRTUALINFO_PHONENUM_LEN        12            // virtual information mobile phone length
#define MAX_VIRTUALINFO_IMEI_LEN            16            // virtual information international mobile device indicator length
#define MAX_VIRTUALINFO_IMSI_LEN            16            // virtual information international mobile user indicator length
#define MAX_VIRTUALINFO_LATITUDE_LEN        16            // virtual information latitude length
#define MAX_VIRTUALINFO_LONGITUDE_LEN       16            // virtual information longitude length
#define MAX_VIRTUALINFO_NUM                 1024          // MAX virtual information number
#define MAX_CALL_ID_LEN                     64            // Call ID length
#define MAX_FACE_DATA_LEN                   2048          // Max face detection data len
#define MAX_FACE_DATA_NUM                   20            // Max face detection data number 
#define MAX_PHOTO_COUNT                     5             // Max face photo data number 
#define MAX_FINGERPRINT_NUM                 10            // Max fingerprint number
#define MAX_RINGFILE_NUM                    64            // max ring file num
#define MAX_VIDEOIN_CONFLICT_NUM            128           // max conflict of videoin number 
#define MAX_COURSE_LOGIC_CHANNEL            64            // max course-media logic channel number
#define MAX_COMMON_STRING_8                 8             // Universal String Length 8
#define MAX_COMMON_STRING_16                16            // Universal String Length 16
#define MAX_COMMON_STRING_32                32            // Universal String Length 32
#define MAX_COMMON_STRING_64                64            // Universal String Length 64
#define MAX_MAN_LIST_COUNT                  64            // Max count of man list
#define MAX_COMMON_STRING_128               128           // Universal String Length 128
#define MAX_STREAM_NUM                      4             // MAX Stream Number
#define MAX_CELL_PHONE_NUMBER_LEN           32            // max cell phone number
#define MAX_MAIL_LEN                        64            // max mail len
#define MAX_USER_NAME_LEN                   128           // max user name len
#define MAX_PWD_LEN                         128           // max password len
#define MAX_SECURITY_CODE_LEN               16            // max security code len
#define MAX_PWD_SPEC_CHARS_ARRAY_LEN        128           // max len of special chars list in passwd specification 
#define MAX_PWD_BASIC_CHARS_ARRAY_LEN       128           // max len of basic chars list supported in passwd specification        
#define MAX_COMMON_STRING_512               512           // Universal String Length 512
#define MAX_RFIDELETAG_CARDID_LEN           16            // max length of car id
#define MAX_RFIDELETAG_DATE_LEN             16            // max length of date
#define MAX_LINK_NAME_LEN                   16            // link name length
#define MAX_SERVER_ADDRESS_LEN              64            // server IP length
#define LINK_LAYER_VPN_NUM                  64            // link layer VPN config num
#define MAX_SERVER_IP_LEN                   32            // server IP length
#define MAX_SCENICSPOT_POINTS_NUM           256           // Total number of points
#define MAX_ACCESSSUBCONTROLLER_NUM         64            // the max count of access sub-controller
#define MAX_ACCESSDOOR_NUM                  128           // the max count of door number
#define MAX_ACCESS_READER_NUM               32            // the max count of reader
#define MAX_ACCESS_POINT_NUM                32            // the max count of Repeat route point
#define MAX_CONFIG_NAME_LEN                 128           // max length of configuration's name.
#define MAX_PLATE_NUMBER_LEN                64            // max plate number len
#define MAX_MASTER_OF_CAR_LEN               32            // max master of car len
#define MAX_USER_TYPE_LEN                   32            // max user type len
#define MAX_SUB_USER_TYPE_LEN				64			  // max sub user type len
#define MAX_REMARKS_LEN						64			  // max remarks info len
#define MAX_PARK_CHARGE_LEN                 32            // max park charge len
#define MAX_IN_TIME_LEN                     32            // max in time len
#define MAX_OUT_TIME_LEN                    32            // max out time len
#define MAX_CUSTOM_LEN                      128           // max custom len
#define MAX_DEAL_NUM_LEN                    32            // max deal num len
#define MAX_STORE_NO_LEN                    32            // max store name No len
#define MAX_STORE_NAME_LEN                  32            // max store name len
#define MAX_STORE_EMPLOYEE_ID_LEN           32            // max store employee ID len
#define MAX_PRODUCT_NO_LEN                  32            // max product name No len 
#define MAX_PRODUCT_NAME_LEN                32            // max product name len
#define MAX_PRODUCT_CATEGORY_LEN            32            // max product category len
#define DH_MAX_FINGER_PRINT                 10            // Max length of finger print array
#define MAX_SUBCHANNEL_NUM                  16            // max sensor
#define MAX_NAME_LENGTH                     32            // max name len
#define MAX_SNAP_URL_LEN                    128           // max snap URL len
#define MAX_CODE_LEN                        64            // max good code number len
#define MAX_PERSON_INFO_NUM                 4             // max person info num
#define MAX_GOOD_INFO_NUM                   128           // max good info num
#define MAX_SUB_TAG_NUM                     20            // max sub tag number
#define MAX_MANUFACTURER_LEN                32            // max manufacturer len 
#define MAX_MACHISTORY_SSID_LEN             24            // max mac history SSID len
#define MAX_MACHISTORY_SSID_NUM	            5             // max history SSID num
#define MAX_ROUTE_NUM                       16            // max Route number
#define MAX_MCU_NUM                         10            // max MCU number
#define MAX_ALARM_CHANNEL_NAME_LEN			64            // max alarm name len
#define MAX_INSIDEOBJECT_NUM			    32			  // max inside object number
#define DH_PRETASK_CHANNEL					4			  // max channel number of video synopsis Pre-task
#define MAX_AGE_NUM							2		      // max age num
#define MAX_EMOTION_NUM					    8			  // max emotion num
#define MAX_CLASS_NUMBER_LEN				32			  // max class number len
#define MAX_PHONENUMBER_LEN					16			  // max phone number len
#define MAX_NASFILE_NUM                   	8             // max NAS file num
#define MAX_CROWD_DETECTION_NAME_LEN		128			  // max crowd detection event name len
#define	MAX_CROWD_LIST_NUM					5			  // max crowd list num
#define MAX_REGION_LIST_NUM					8			  // max region list num
#define MAX_RECORD_ENCRYPT_PASSWD_LEN	    128			  // max record encrypt password len
#define MAX_EVENT_NAME_LEN					128	   	      // Max event name len
#define MAX_ABSTRACT_INFO_NUM			    100			  // max number of reabstract info
#define MAX_ACCESS_FLOOR_NUM                64            // Max floor number
#define MAX_TARGET_OBJECT_NUM			    100			  // Max target object information
#define MAX_MACADDR_NUM					  	8			  // max mac address number
#define MAX_ADD_DEVICE_NUM                  16            // max add device number
#define MAX_LINK_DEVICE_NUM               	1024          // max link device number
#define MAX_DEVICE_CHANNEL_NUM            	1024          // max device channel number
#define MAX_PLATE_TAILNUM			        10			  // Maximum limit number
#define MAX_OBJECT_NUM_EX				    100			  // max object number
#define MAX_LOCAL_IP_LEN					64			  // max local ip len
#define MAX_LV_NAME_NUM					    64			  // max Logic volume name num
#define MAX_LV_NAME_LEN					    128			  // max Logic volume name len
#define	MAX_KEY_LEN						    64			  // Max key len
#define MAX_FILE_FINDER_PATH_NUM			10			  // Max file finder path num
#define	MAX_FILE_FINDER_PATH_LEN			256			  // Max file finder path len
#define MAX_FILE_LIST_NUM					16			  // Max file list num
#define MAX_FILE_LIST_LEN					256			  // Max file list len
#define MAX_PARKINGLOCK_STATE_NUM		    6			  // Max parking lock state num
#define MAX_COMMON_STRING_256				256           // Universal String Length 256
#define MAX_COMMON_STRING_2048				2048          // Universal String Length 2048
#define MAX_RESOURCE_LEN                    64            // max resource len
#define MAX_COMPANY_NAME_LEN                200           // max length of company name
#define MAX_CONTACT_LEN                     16            // max contact len
#define MAX_RADAR_SD_NUM                  	24			  // Maximum number of SD per radar link
#define MAX_FLEXION_INFO_NUM			    512			  // Maximum number of inflection information 
#define MAX_CALIBRATE_PLOYGON_AREA_NUM      20            // Maximum point number of calibrate ploygon area
#define MAX_CALIBRATE_RECT_NUM              10            // Maximum number of calibrate rect
#define MAX_SCENE_NUM                       32            // max scene number
#define MAX_SNAP_SHOT_NUM				  	8			  // max snapshot number
#define MAX_AIRPORT_VEHICLE_OBJECT_NUM	  	16			  // Maximum number of airport-vehicle object

// Search type, corresponding to CLIENT_QueryDevState
#define DH_DEVSTATE_COMM_ALARM            0x0001           // Search general alarm status(including external alarm,video loss, motion detection)
#define DH_DEVSTATE_SHELTER_ALARM         0x0002           // Search camera masking alarm status
#define DH_DEVSTATE_RECORDING             0x0003           // Search record status 
#define DH_DEVSTATE_DISK                  0x0004           // Search HDD information 
#define DH_DEVSTATE_RESOURCE              0x0005           // Search system resources status 
#define DH_DEVSTATE_BITRATE               0x0006           // Search channel bit stream 
#define DH_DEVSTATE_CONN                  0x0007           // Search device connection status 
#define DH_DEVSTATE_PROTOCAL_VER          0x0008           // Search network protocol version number , pBuf = int*
#define DH_DEVSTATE_TALK_ECTYPE           0x0009           // Search the audio talk format the device supported. Please refer to structure DHDEV_TALKFORMAT_LIST
#define DH_DEVSTATE_SD_CARD               0x000A           // Search SD card information(FOR IPC series)
#define DH_DEVSTATE_BURNING_DEV           0x000B           // Search burner information
#define DH_DEVSTATE_BURNING_PROGRESS      0x000C           // Search burning information
#define DH_DEVSTATE_PLATFORM              0x000D           // Search the embedded platform the device supported
#define DH_DEVSTATE_CAMERA                0x000E           // Search camera property information ( for IPC series),pBuf = DHDEV_CAMERA_INFO *,there can be several structure.
#define DH_DEVSTATE_SOFTWARE              0x000F           // Search device software version information
#define DH_DEVSTATE_LANGUAGE              0x0010           // Search the audio type the device supported 
#define DH_DEVSTATE_DSP                   0x0011           // Search DSP capacity description 
#define DH_DEVSTATE_OEM                   0x0012           // Search OEM information 
#define DH_DEVSTATE_NET                   0x0013           // Search network running status information 
#define DH_DEVSTATE_TYPE                  0x0014           // Search function attributes(for IPC serirs)
#define DH_DEVSTATE_SNAP                  0x0015           // Search snapshot function attribute(For IPC series)
#define DH_DEVSTATE_RECORD_TIME           0x0016           // Query the first time and the recent video time
#define DH_DEVSTATE_NET_RSSI              0x0017           // Query the wireless network signal strength,Please refer to structure DHDEV_WIRELESS_RSS_INFO
#define DH_DEVSTATE_BURNING_ATTACH        0x0018           // Burning options inquiry
#define DH_DEVSTATE_BACKUP_DEV            0x0019           // Query the list of backup device
#define DH_DEVSTATE_BACKUP_DEV_INFO       0x001a           // Query the backup device information
#define DH_DEVSTATE_BACKUP_FEEDBACK       0x001b           // backup rate of progress
#define DH_DEVSTATE_ATM_QUERY_TRADE       0x001c           // Query ATM trade type
#define DH_DEVSTATE_SIP                   0x001d           // Query sip state
#define DH_DEVSTATE_VICHILE_STATE         0x001e           // Query wifi state of mobile DVR
#define DH_DEVSTATE_TEST_EMAIL            0x001f           // Query Email Function
#define DH_DEVSTATE_SMART_HARD_DISK       0x0020           // Query Hard Disk Information
#define DH_DEVSTATE_TEST_SNAPPICTURE      0x0021           // Query Snap Picture Function
#define DH_DEVSTATE_STATIC_ALARM          0x0022           // Query static alarm state
#define DH_DEVSTATE_SUBMODULE_INFO        0x0023           // Query submodule information
#define DH_DEVSTATE_DISKDAMAGE            0x0024           // Query hard disk damage ability     
#define DH_DEVSTATE_IPC                   0x0025           // Query device supported IPC ability,see struct DH_DEV_IPC_INFO 
#define DH_DEVSTATE_ALARM_ARM_DISARM      0x0026           // Query alarm arm disarm state
#define DH_DEVSTATE_ACC_POWEROFF_ALARM    0x0027           // Query ACC power off state(return a DWORD type value, 1 means power off,0 means power on)
#define DH_DEVSTATE_TEST_FTP_SERVER       0x0028           // FTP server connect test
#define DH_DEVSTATE_3GFLOW_EXCEED         0x0029           // Query 3G Flow exceed state info(see struct DHDEV_3GFLOW_EXCEED_STATE_INFO)
#define DH_DEVSTATE_3GFLOW_INFO           0x002a           // Query 3G Flow info(see struct DH_DEV_3GFLOW_INFO)
#define DH_DEVSTATE_VIHICLE_INFO_UPLOAD   0x002b           // Vihicle information uploading
#define DH_DEVSTATE_SPEED_LIMIT           0x002c           // Speed limit alarm
#define DH_DEVSTATE_DSP_EX                0x002d           // Query DSP expended cap(struct DHDEV_DSP_ENCODECAP_EX)
#define DH_DEVSTATE_3GMODULE_INFO         0x002e           // Query 3G module info(struct DH_DEV_3GMODLE_INFO)
#define DH_DEVSTATE_MULTI_DDNS            0x002f           // Query multi DDNS status(struct DH_DEV_MULTI_DDNS_INFO)
#define DH_DEVSTATE_CONFIG_URL            0x0030           // Query Device URL info(struct DH_DEV_URL_INFO)
#define DH_DEVSTATE_HARDKEY               0x0031           // Query Hard key state(struct DHDEV_HARDKEY_STATE)
#define DH_DEVSTATE_ISCSI_PATH            0x0032           // Query ISCSI path(struct DHDEV_ISCSI_PATHLIST)
#define DH_DEVSTATE_DLPREVIEW_SLIPT_CAP   0x0033           // Query local preview split capability(struct DEVICE_LOCALPREVIEW_SLIPT_CAP)
#define DH_DEVSTATE_WIFI_ROUTE_CAP        0x0034           // Query wifi capablity(struct DHDEV_WIFI_ROUTE_CAP)
#define DH_DEVSTATE_ONLINE                0x0035           // Query device online state(return a DWORD value, 1-online, 0-offline)
#define DH_DEVSTATE_PTZ_LOCATION          0x0036           // Query ptz state(struct DH_PTZ_LOCATION_INFO)
#define DH_DEVSTATE_MONITOR_INFO          0x0037           // Query monitor state(state DHDEV_MONITOR_INFO)
#define DH_DEVSTATE_SUBDEVICE             0x0300           // Query subdevcie(fan,cpu...) state(struct CFG_DEVICESTATUS_INFO)
#define DH_DEVSTATE_RAID_INFO             0x0038           // Query RAID state(struct ALARM_RAID_INFO)  
#define DH_DEVSTATE_TEST_DDNSDOMAIN       0x0039           // test DDNS domain enable
#define DH_DEVSTATE_VIRTUALCAMERA         0x003a           // query virtual camera state(struct DHDEV_VIRTUALCAMERA_STATE_INFO)
#define DH_DEVSTATE_TRAFFICWORKSTATE      0x003b           // get device's state of video/coil module(struct DHDEV_TRAFFICWORKSTATE_INFO)
#define DH_DEVSTATE_ALARM_CAMERA_MOVE     0x003c           // get camera move alarm state(struct ALARM_CAMERA_MOVE_INFO)
#define DH_DEVSTATE_ALARM                 0x003e           // get external alarm(struct NET_CLIENT_ALARM_STATE) 
#define DH_DEVSTATE_VIDEOLOST             0x003f           // get video loss alarm(struct NET_CLIENT_VIDEOLOST_STATE) 
#define DH_DEVSTATE_MOTIONDETECT          0x0040           // get motion alarm(struct NET_CLIENT_MOTIONDETECT_STATE)
#define DH_DEVSTATE_DETAILEDMOTION        0x0041           // get detailed motion alarm(struct NET_CLIENT_DETAILEDMOTION_STATE)
#define DH_DEVSTATE_VEHICLE_INFO          0x0042           // get vehicle device state(struct DHDEV_VEHICLE_INFO)
#define DH_DEVSTATE_VIDEOBLIND            0x0043           // get blind alarm(struct NET_CLIENT_VIDEOBLIND_STATE)
#define DH_DEVSTATE_3GSTATE_INFO          0x0044           // Query 3G state(struct DHDEV_VEHICLE_3GMODULE)
#define DH_DEVSTATE_NETINTERFACE          0x0045           // Query net interface(struct DHDEV_NETINTERFACE_INFO)
#define DH_DEVSTATE_PICINPIC_CHN          0x0046           // Query picinpic channel(struct DWORD)
#define DH_DEVSTATE_COMPOSITE_CHN         0x0047           // Query splice screen(struct DH_COMPOSITE_CHANNEL)
#define DH_DEVSTATE_WHOLE_RECORDING       0x0048           // Query whole recording status(struct BOOL),as long as ther is a channel running,it indicates that the overall state
#define DH_DEVSTATE_WHOLE_ENCODING        0x0049           // Query whole encoding(struct BOOL),as long as ther is a channel running,it indicates that the overall state
#define DH_DEVSTATE_DISK_RECORDE_TIME     0x004a           // Query disk record time(pBuf = DEV_DISK_RECORD_TIME*)
#define DH_DEVSTATE_BURNER_DOOR           0x004b           // whether have pop-up optical dirve(struct NET_DEVSTATE_BURNERDOOR)
#define DH_DEVSTATE_GET_DATA_CHECK        0x004c           // get data validation process(struct NET_DEVSTATE_DATA_CHECK)
#define DH_DEVSTATE_ALARM_IN_CHANNEL      0x004f           // Query alarm input channel information(struct NET_ALARM_IN_CHANNEL)
#define DH_DEVSTATE_ALARM_CHN_COUNT       0x0050           // Query alarm channel number(struct NET_ALARM_CHANNEL_COUNT)
#define DH_DEVSTATE_PTZ_VIEW_RANGE        0x0051           // Query PTZ view range status(struct DH_OUT_PTZ_VIEW_RANGE_STATUS)
#define DH_DEVSTATE_DEV_CHN_COUNT         0x0052           // Query device channel information(struct NET_DEV_CHN_COUNT_INFO)
#define DH_DEVSTATE_RTSP_URL              0x0053           // Query RTSP URL list supported by device, struct DEV_RTSPURL_LIST
#define DH_DEVSTATE_LIMIT_LOGIN_TIME      0x0054           // Query online overtime of device logging in and return a BYTE, UNIT:MIN ,0 means no limite and The non-zero positive integer means restrictions on the number of minutes
#define DH_DEVSTATE_GET_COMM_COUNT        0x0055           // get com count (struct NET_GET_COMM_COUNT)
#define DH_DEVSTATE_RECORDING_DETAIL      0x0056           // Query recording status detail information(pBuf = NET_RECORD_STATE_DETAIL*)
#define DH_DEVSTATE_PTZ_PRESET_LIST       0x0057           // get state PTZ preset list (struct NET_PTZ_PRESET_LIST)
#define DH_DEVSTATE_EXTERNAL_DEVICE       0x0058           // exteral device information (pBuf = NET_EXTERNAL_DEVICE*)
#define DH_DEVSTATE_GET_UPGRADE_STATE     0x0059           // get device upgrade state(struct DHDEV_UPGRADE_STATE_INFO)
#define DH_DEVSTATE_MULTIPLAYBACK_SPLIT_CAP  0x005a        // get mulipalyback split (struct NET_MULTIPLAYBACK_SPLIT_CAP )
#define DH_DEVSTATE_BURN_SESSION_NUM      0x005b           // get burn session number(pBuf = int*)
#define DH_DEVSTATE_PROTECTIVE_CAPSULE    0x005c           // Search protective capsule status(corresponding structure ALARM_PROTECTIVE_CAPSULE_INFO)
#define DH_DEVSTATE_GET_DOORWORK_MODE     0x005d           // get access controlmode( corresponding NET_GET_DOORWORK_MODE)
#define DH_DEVSTATE_PTZ_ZOOM_INFO         0x005e           // Query PTZ optical zoom value( corresponding to DH_OUT_PTZ_ZOOM_INFO )
#define DH_DEVSTATE_POWER_STATE           0x0152           // Query power state(struct DH_POWER_STATUS)
#define DH_DEVSTATE_ALL_ALARM_CHANNELS_STATE    0x153      // Query alarm channel state(struct NET_CLIENT_ALARM_CHANNELS_STATE)
#define DH_DEVSTATE_ALARMKEYBOARD_COUNT   0x0154           // Query alarm keyboard count connected on com(struct NET_ALARMKEYBOARD_COUNT)
#define DH_DEVSTATE_EXALARMCHANNELS       0x0155           // Query mapping relationship of extension alarm module channel (struct NET_EXALARMCHANNELS)
#define DH_DEVSTATE_GET_BYPASS            0x0156           // Query channel bypass state(struct NET_DEVSTATE_GET_BYPASS)
#define DH_DEVSTATE_ACTIVATEDDEFENCEAREA  0x0157           // get active sector information(struct NET_ACTIVATEDDEFENCEAREA)
#define DH_DEVSTATE_DEV_RECORDSET         0x0158           // Query device recording information(struct NET_CTRL_RECORDSET_PARAM)
#define DH_DEVSTATE_DOOR_STATE            0x0159           // Query door access state(struct NET_DOOR_STATUS_INFO)
#define DH_DEVSTATE_ANALOGALARM_CHANNELS  0x1560           // analog alarm input channel mapping (struct NET_ANALOGALARM_CHANNELS)
#define DH_DEVSTATE_GET_SENSORLIST        0x1561           // Get device supported sensor list(corresponding NET_SENSOR_LIST)
#define DH_DEVSTATE_ALARM_CHANNELS        0x1562           // Search switch alarm template channel mapping relation(corresponding structure  NET_ALARM_CHANNELS)
                                                           // If device su not support search extension alarm module channel, may use this function to search extension channel logic channel no. and use as local alarm channel use
#define DH_DEVSTATE_GET_ALARM_SUBSYSTEM_ACTIVATESTATUS    0x1563     // Get current system enabling status( corresponding NET_GET_ALARM_SUBSYSTEM_ACTIVATE_STATUES)
#define DH_DEVSTATE_AIRCONDITION_STATE    0x1564           // Get air conditioning status(corresponding to NET_GET_AIRCONDITION_STATE)
#define DH_DEVSTATE_ALARMSUBSYSTEM_STATE  0x1565           // Get sub system status(corresponding to NET_ALARM_SUBSYSTEM_STATE)
#define DH_DEVSTATE_ALARM_FAULT_STATE     0x1566           // Get failure status(corresponding to NET_ALARM_FAULT_STATE_INFO)
#define DH_DEVSTATE_DEFENCE_STATE         0x1567           // Get zone status(corresponding to NET_DEFENCE_STATE_INFO, and bypass status change event, local alarm event, alarm signal event status description is different, cannot mix, for specific device use only)
#define DH_DEVSTATE_CLUSTER_STATE         0x1568           // Get collection status(corresponding to NET_CLUSTER_STATE_INFO)
#define DH_DEVSTATE_SCADA_POINT_LIST      0x1569           // Get spot chart path info(corresponding to NET_SCADA_POINT_LIST_INFO)
#define DH_DEVSTATE_SCADA_INFO            0x156a           // Get monitor spot info(corresponding to NET_SCADA_INFO)
#define DH_DEVSTATE_SCADA_CAPS            0x156b           // Get SCADA capacityset(corresponding to NET_SCADA_CAPS)
#define DH_DEVSTATE_GET_CODEID_COUNT      0x156c           // Get successful code item number(corresponding  NET_GET_CODEID_COUNT)
#define DH_DEVSTATE_GET_CODEID_LIST       0x156d           // Search code info(corresponding  NET_GET_CODEID_LIST)
#define DH_DEVSTATE_ANALOGALARM_DATA      0x156e           // Search analog channel data(corresponding  NET_GET_ANALOGALARM_DATA)
#define DH_DEVSTATE_VTP_CALLSTATE         0x156f           // Access the call state of the video phone (Corresponding to NET_GET_VTP_CALLSTATE)
#define DH_DEVSTATE_SCADA_INFO_BY_ID      0x1570           // query point info by device id(corresponding to NET_SCADA_INFO_BY_ID)
#define DH_DEVSTATE_SCADA_DEVICE_LIST     0x1571           // query scada device id(corresponding to NET_SCADA_DEVICE_LIST)
#define DH_DEVSTATE_DEV_RECORDSET_EX      0x1572           // Search device record set info (with binary data) (Corresponding to NET_CTRL_RECORDSET_PARAM)
#define DH_DEVSTATE_ACCESS_LOCK_VER       0x1573           // Get door locker software version (Corresponding to NET_ACCESS_LOCK_VER)
#define DH_DEVSTATE_MONITORWALL_TVINFO    0x1574           // get monitorwall TV info(Corresponding to NET_CTRL_MONITORWALL_TVINFO)
#define DH_DEVSTATE_GET_ALL_POS           0x1575           // get all configuration of users's Pos devices (Corresponding to NET_POS_ALL_INFO)
#define DH_DEVSTATE_GET_ROAD_LIST         0x1576           // get city and road code info(Corresponding to NET_ROAD_LIST_INFO)
#define DH_DEVSTATE_GET_HEAT_MAP          0x1577           // get heatmap information(Corresponding to NET_QUERY_HEAT_MAP)
#define DH_DEVSTATE_GET_WORK_STATE        0x1578           // get device work state (Corresponding to NET_QUERY_WORK_STATE)
#define DH_DEVSTATE_GET_WIRESSLESS_STATE  0x1579           // get wireless device work state(Corresponding to NET_GET_WIRELESS_DEVICE_STATE)
#define DH_DEVSTATE_GET_REDUNDANCE_POWER_INFO  0x157a      // get redundance power info(Corresponding to NET_GET_REDUNDANCE_POWER_INFO)
#define DH_DEVSTATE_GET_ACCESSORY_STATUS  0x157b           // get accessory status(corresponding to NET_GET_ACCESSORY_STATUS) 

//////////////////////////////////////////////////////////////////////////
// To set structure. The macro of dwSize
#define _setdwSize(stu) ((stu).dwSize = sizeof(stu))

//////////////////////////////////////////////////////////////////////////

#define CFG_MAX_ACCESSCONTROL_NUM				8							// The Max Number of AccessControl
#define CFG_MAX_SUMMARY_LEN						1024						// The Max Length of the summary information superimposed on the JPEG picture
#define CFG_MAX_DBKEY_NUM						64							// The Max Number of DBKey
#define CFG_MAX_CHANNELNAME_LEN					64							// The Max Length of ChannelName
#define CFG_MAX_VIDEO_CHANNEL_NUM				256							// The Max Number of Video Channel
#define CFG_MAX_CHANNEL_COUNT					16                          // The Max Number of Channel
#define CFG_MAX_PSTN_SERVER_NUM                 8							// The Max Number of PSTN Server

//Three Status BOOL
typedef enum tagNET_THREE_STATUS_BOOL
{
    BOOL_STATUS_FALSE  = 0 , 
    BOOL_STATUS_TRUE       ,
    BOOL_STATUS_UNKNOWN    ,  //unknown
}NET_THREE_STATUS_BOOL;

//////////////////////////////////////////////////////////////////////////

// Air Conditioning Work Mode
typedef enum __EM_AIRCONDITION_MODE
{
    AIRCONDITION_MODE_UNKNOWN = 0,
    AIRCONDITION_MODE_AUTO,             // Auto
    AIRCONDITION_MODE_HOT,              // Cool
    AIRCONDITION_MODE_COLD,             // Heat
    AIRCONDITION_MODE_WET,              // Arefaction
    AIRCONDITION_MODE_WIND,             // Vent
} EM_AIRCONDITION_MODE;

// Air Conditioning Fan Mode
typedef enum __EM_AIRCONDITION_WINDMODE
{
    AIRCONDITION_WINDMODE_UNKNOWN = 0,
    AIRCONDITION_WINDMODE_STOP,          // Stop
    AIRCONDITION_WINDMODE_AUTO,          // Auto
    AIRCONDITION_WINDMODE_HIGH,          // High Speed
    AIRCONDITION_WINDMODE_MIDDLE,        // Medium Speed
    AIRCONDITION_WINDMODE_LOW,           // Low Speed
} EM_AIRCONDITION_WINDMODE;

// Air Conditioning Working Status Info
typedef struct tagNET_AIRCONDITION_STATE_INFO
{
    DWORD				        dwSize;
    BOOL                        bIsOnline;                      // Online
    BOOL                        bIsON;                          // Enable
    int                         nTemperature;                   // Temperature
    EM_AIRCONDITION_MODE        emAirconditionMode;             // Work Mode
    EM_AIRCONDITION_WINDMODE    emAirconditionWindMode;         // Air Fan Mode
    float                       fActualTemperature;             // Environment Temperature
}NET_AIRCONDITION_STATE_INFO;

// Get Air Working Status(corresponding to DH_DEVSTATE_AIRCONDITION_STATE command)
typedef struct tagNET_GET_AIRCONDITION_STATE
{
    DWORD				dwSize;
    char				szDeviceID[DH_MAX_DEV_ID_LEN];			// Device SN
    NET_AIRCONDITION_STATE_INFO stuAirConditionState;           // Air conditioning working status info
}NET_GET_AIRCONDITION_STATE;

// Switch alarm channel info
typedef struct tagNET_ALARM_CHANNEL_INFO 
{
	DWORD			dwSize;
	int				nSlot;					        // Root address, 0 means local channel, 1 means connected to 1st serial extension channel, 2, 3... and so on
	int				nChannel;				        // Non local alarm channel on extension module channel no., from 0 
	char			szName[DH_COMMON_STRING_128];	// Channel name
}NET_ALARM_CHANNEL_INFO;

// Local(far or close)switch alarm channel and logic channel no. mapping relation
typedef struct tagNET_ALARM_CHANNELS 
{
	DWORD			dwSize;
	int				nMaxAlarmChannels;		// Max channel
	int				nRetAlarmChannels;		// Return channel no.
	NET_ALARM_CHANNEL_INFO*	pstuChannelInfo;// Channel info, user allocate memory
}NET_ALARM_CHANNELS;

// Alarm Sub System Status Type
typedef enum __EM_ALARM_SUBSYSTEM_STATE_TYPE
{
    ALARM_SUBSYSTEM_STATE_UNKNOWN = 0,
	ALARM_SUBSYSTEM_STATE_ACTIVE,           // Activated
	ALARM_SUBSYSTEM_STATE_INACTIVE,         // Not activated
	ALARM_SUBSYSTEM_STATE_UNDISTRIBUTED,    // Not distributed
}EM_ALARM_SUBSYSTEM_STATE_TYPE;

// Alarm Sub System Status, CLIENT_QueryDevStatecorresponding to command DH_DEVSTATE_ALARMSUBSYSTEM_STATE
typedef struct tagNET_ALARM_SUBSYSTEM_STATE
{
    DWORD          dwSize;
	int            nMaxAlarmSubSystem;                                  // Valid Sub System Number
	EM_ALARM_SUBSYSTEM_STATE_TYPE  emState[DH_MAX_ALARM_SUBSYSTEM_NUM]; // Sub System Status Info
}NET_ALARM_SUBSYSTEM_STATE;


// Failure Type
typedef enum __EM_ALARM_FAULT_STATE_TYPE
{
    EM_ALARM_FAULT_STATE_ALL = 0,                       // All Types
    EM_ALARM_FAULT_STATE_CONNECTFAULT,                  // Connection Failure
    EM_ALARM_FAULT_STATE_BELLFAULT,                     // Bell Failure
    EM_ALARM_FAULT_STATE_KBFAULT,                       // Keyboard Failure
    EM_ALARM_FAULT_STATE_KBTAMPER,                      // Keyboard Vandal-proof
    EM_ALARM_FAULT_STATE_SENSORSHORTOUT,                // Sensor Short circuit
    EM_ALARM_FAULT_STATE_SENSORTAMPER,                  // Sensor Vandal-proof
}EM_ALARM_FAULT_STATE_TYPE;

// Alarm Failure Status, Input Parameter
typedef struct tagNET_IN_ALARM_FAULT_STATE
{
    DWORD           dwSize;
    EM_ALARM_FAULT_STATE_TYPE   emType;                 // Type to search
}NET_IN_ALARM_FAULT_STATE;

// Alarm Failure Status, Output Parameter
typedef struct tagNET_OUT_ALARM_FAULT_STATE
{
    DWORD           dwSize;
    int             nConnectFaultState;                 // 0: Unknown, 1: Normal, 2:Failure
    int             nBell;                              // Bell valid number 
    int             anBellState[DH_MAX_BELL_NUM];       // Bell failure status info 0: Unknown, 1: Normal, 2:Failure
    int             nFaultKeyboard;                     // Keyboard failure valid number
    int             anFaultKeyboard[DH_MAX_KEYBOARD_NUM];  // Keyboard failure info 0: Unknown, 1: Normal, 2:Failure
    int             nTamperKeyboard;                       // Keyboard valid vandal-proof number 
    int             anTamperKeyboard[DH_MAX_KEYBOARD_NUM]; // Keyboard vandal-proof info 0: Unknown, 1: Normal, 2:Failure
    int             nShortOutSensor;                    // Sensor valid short circuit number
    int             anShortOutSensor[DH_MAX_ALARMIN];   // Sensor short circuit info 0: Unknown, 1: Normal, 2:Failure
    int             nTamperSensor;                      // Sensor valid vandal-proof number
    int             anTamperSensor[DH_MAX_ALARMIN];     // Sensor vandal-proof info 0: Unknown, 1: Normal, 2:Failure
}NET_OUT_ALARM_FAULT_STATE;

// Alarm failure status, CLIENT_QueryDevStatecorresponding to command DH_DEVSTATE_ALARM_FAULT_STATE
typedef struct tagNET_ALARM_FAULT_STATE_INFO
{
    DWORD           dwSize;
    NET_IN_ALARM_FAULT_STATE    stuIn;                  // Input parameter
    NET_OUT_ALARM_FAULT_STATE   stuOut;                 // Output parameter
}NET_ALARM_FAULT_STATE_INFO;

// Zone Status Type
typedef enum __EM_DEFENCE_STATE_TYPE
{
    EM_DEFENCE_STATE_UNKNOWN = 0,
    EM_DEFENCE_STATE_BYPASS,                            // Bypass
    EM_DEFENCE_STATE_OPEN,                              // Open, for alarm under disarming
    EM_DEFENCE_STATE_CLOSE,                             // Close
    EM_DEFENCE_STATE_ALARMING,                          // Alarm, for alarm under arming
	EM_DEFENCE_STATE_ISOLATED,							// Isolated
    EM_DEFENCE_STATE_SHORT,								// Short
    EM_DEFENCE_STATE_BREAK,								// Break
    EM_DEFENCE_STATE_INTRUDED,							// Intruded
}EM_DEFENCE_STATE_TYPE;

// Zone Status Info Input Parameter
typedef struct tagNET_IN_DEFENCE_STATE_INFO 
{
    DWORD           dwSize;
    int             nDefenceNum;                        // Zone valid number, -1means search all zones
    int             anDefence[DH_MAX_ALARMIN];          // Zone number to search
}NET_IN_DEFENCE_STATE_INFO;

// Zone Status Info Output Parameter
typedef struct tagNET_OUT_DEFENCE_STATE_INFO
{
    DWORD           dwSize;
    int             nDefenceNum;                            // Zone valid number    
	EM_DEFENCE_STATE_TYPE  anDefenceState[DH_MAX_ALARMIN];  // Zone status info
}NET_OUT_DEFENCE_STATE_INFO;

// Get Zone Status Info Input Parameter
typedef struct tagNET_IN_GET_DEFENCE_STATE_INFO 
{
    int             nDefenceNum;                 // Zone valid number, -1means search all zones
    int             anDefence[512];   // Zone number to search
    BYTE			byReserved[512];				//Reserved
}NET_IN_GET_DEFENCE_STATE_INFO;

// Get Zone Status Info Output Parameter
typedef struct tagNET_OUT_GET_DEFENCE_STATE_INFO
{
    int             nDefenceNum;                            // Zone valid number 
    EM_DEFENCE_STATE_TYPE  anDefenceState[512];  //  Zone status info.
    BYTE			byReserved[512];				//Reserved
}NET_OUT_GET_DEFENCE_STATE_INFO;

// Zpne status info, CLIENT_QueryDevStatecorresponding to command DH_DEVSTATE_DEFENCE_STATE
typedef struct tagNET_DEFENCE_STATE_INFO 
{
    DWORD           dwSize;					   // Struct size
    NET_IN_DEFENCE_STATE_INFO   stuIn;         // Input parameter
    NET_OUT_DEFENCE_STATE_INFO  stuOut;        // Output parameter
}NET_DEFENCE_STATE_INFO;

// Zone status info, CLIENT_QueryDevState corresponding to command DH_DEVSTATE_DEFENCE_STATE
typedef struct tagNET_GET_DEFENCE_STATE_INFO 
{
    DWORD           dwSize;
    NET_IN_GET_DEFENCE_STATE_INFO   stuIn;         // Input parameter
    NET_OUT_GET_DEFENCE_STATE_INFO  stuOut;        // Output parameter
}NET_GET_DEFENCE_STATE_INFO;

// Type of video phone call
typedef enum tagEM_NET_VTP_CALL_TYPE
{
    EM_NET_VTP_CALL_TYPE_SIP = 0,              // SIP calling
    EM_NET_VTP_CALL_TYPE_GSM,                  // GSM calling
    EM_NET_VTP_CALL_TYPE_PRIVATE,              // private protocol calling
}EM_NET_VTP_CALL_TYPE;

// Type of video phone call
typedef enum tagEM_NET_VTP_CALL_STATE_TYPE
{
    EM_NET_VTP_CALL_STATE_UNKNOWN = 0,
    EM_NET_VTP_CALL_STATE_IDLE,                // Initial State
    EM_NET_VTP_CALL_STATE_CALLING,             // State of calling(the opposite side not response)
    EM_NET_VTP_CALL_STATE_CALLED,              // State of called
    EM_NET_VTP_CALL_STATE_RINGING,             // State of calling back (the opposite side responsed but no answer)
    EM_NET_VTP_CALL_STATE_CONNECTING,          // State of answering 
    EM_NET_VTP_CALL_STATE_CONNECTING2,         // 2 states in the call (call state after change of media)
    EM_NET_VTP_CALL_STATE_DISCONNECT,          // State of call off
}EM_NET_VTP_CALL_STATE_TYPE;

// Obtain the calling state of video phone (Corresponding to DH_DEVSTATE_VTP_CALLSTATE)
typedef struct tagNET_GET_VTP_CALLSTATE 
{
    DWORD                       dwSize;
    EM_NET_VTP_CALL_TYPE        emCallType;                     // the call type to be queried, input parameter
    char                        szCallID[DH_COMMON_STRING_128]; // the unique identification to be queried, input parameter
    const char*                 szTargetID;                     // the device to be transmit,  ID= NULL equals to no transmitting,  input parameter
    EM_NET_VTP_CALL_STATE_TYPE  emCallState;                    // State of calling
}NET_GET_VTP_CALLSTATE;

// Configuration type,corresponding to CLIENT_QueryRemotDevState
#define DH_DEVSTATE_ALARM_REMOTE          0x1000        // get the remote device external alarm(struct ALARM_REMOTE_ALARM_INFO)
#define DH_DEVSTATE_ALARM_FRONTDISCONNECT 0x1001 // get the front IPC disconnect alarm (struct ALARM_FRONTDISCONNET_INFO)

// Configuration type,corresponding to CLIENT_GetDevConfig and CLIENT_SetDevConfig
#define DH_DEV_DEVICECFG                  0x0001        // Device property setup 
#define DH_DEV_NETCFG                     0x0002        // Network setup 
#define DH_DEV_CHANNELCFG                 0x0003        // Video channel setup
#define DH_DEV_PREVIEWCFG                 0x0004        // Preview parameter setup
#define DH_DEV_RECORDCFG                  0x0005        // Record setup
#define DH_DEV_COMMCFG                    0x0006        // COM property setup 
#define DH_DEV_ALARMCFG                   0x0007        // Alarm property setup
#define DH_DEV_TIMECFG                    0x0008        // DVR time setup 
#define DH_DEV_TALKCFG                    0x0009        // Audio talk parameter setup 
#define DH_DEV_AUTOMTCFG                  0x000A        // Auto matrix setup
#define DH_DEV_VEDIO_MARTIX               0x000B        // Local matrix control strategy setup
#define DH_DEV_MULTI_DDNS                 0x000C        //  Multiple DDNS setup 
#define DH_DEV_SNAP_CFG                   0x000D        // Snapshot corresponding setup 
#define DH_DEV_WEB_URL_CFG                0x000E        // HTTP path setup 
#define DH_DEV_FTP_PROTO_CFG              0x000F        // FTP upload setup 
#define DH_DEV_INTERVIDEO_CFG             0x0010        // Plaform embedded setup. Now the channel parameter represents the platform type. 
// channel=4:Bell alcatel;channel=10:ZTE Netview;channel=11:U CNC  channel = 51 AMP
#define DH_DEV_VIDEO_COVER                0x0011        // Privacy mask setup
#define DH_DEV_TRANS_STRATEGY             0x0012        // Transmission strategy. Video quality\Fluency
#define DH_DEV_DOWNLOAD_STRATEGY          0x0013        //  Record download strategy setup:high-speed\general download
#define DH_DEV_WATERMAKE_CFG              0x0014        // Video watermark setup
#define DH_DEV_WLAN_CFG                   0x0015        // Wireless network setup 
#define DH_DEV_WLAN_DEVICE_CFG            0x0016        // Search wireless device setup 
#define DH_DEV_REGISTER_CFG               0x0017        // Auto register parameter setup 
#define DH_DEV_CAMERA_CFG                 0x0018        // Camera property setup 
#define DH_DEV_INFRARED_CFG               0x0019        // IR alarm setup 
#define DH_DEV_SNIFFER_CFG                0x001A        // Sniffer setup 
#define DH_DEV_MAIL_CFG                   0x001B        // Mail setup 
#define DH_DEV_DNS_CFG                    0x001C        // DNS setup 
#define DH_DEV_NTP_CFG                    0x001D        // NTP setup
#define DH_DEV_AUDIO_DETECT_CFG           0x001E        // Audio detection setup 
#define DH_DEV_STORAGE_STATION_CFG        0x001F        // Storage position setup 
#define DH_DEV_PTZ_OPT_CFG                0x0020        // PTZ operation property(It is invalid now. Please use CLIENT_GetPtzOptAttr to get PTZ operation property.)
#define DH_DEV_DST_CFG                    0x0021        // Daylight Saving Time (DST)setup
#define DH_DEV_ALARM_CENTER_CFG           0x0022        // Alarm center setup
#define DH_DEV_VIDEO_OSD_CFG              0x0023        // VIdeo OSD setup
#define DH_DEV_CDMAGPRS_CFG               0x0024        // CDMA\GPRS configuration
#define DH_DEV_IPFILTER_CFG               0x0025        // IP Filter configuration
#define DH_DEV_TALK_ENCODE_CFG            0x0026        // Talk encode configuration
#define DH_DEV_RECORD_PACKET_CFG          0x0027        // The length of the video package configuration
#define DH_DEV_MMS_CFG                    0x0028        // SMS MMS configuration 
#define DH_DEV_SMSACTIVATION_CFG          0x0029        // SMS to activate the wireless connection configuration
#define DH_DEV_DIALINACTIVATION_CFG       0x002A        // Dial-up activation of a wireless connection configuration
#define DH_DEV_SNIFFER_CFG_EX             0x0030        // Capture network configuration
#define DH_DEV_DOWNLOAD_RATE_CFG          0x0031        // Download speed limit
#define DH_DEV_PANORAMA_SWITCH_CFG        0x0032        // Panorama switch alarm configuration
#define DH_DEV_LOST_FOCUS_CFG             0x0033        // Lose focus alarm configuration
#define DH_DEV_ALARM_DECODE_CFG           0x0034        // Alarm decoder configuration
#define DH_DEV_VIDEOOUT_CFG               0x0035        // Video output configuration
#define DH_DEV_POINT_CFG                  0x0036        // Preset enable configuration
#define DH_DEV_IP_COLLISION_CFG           0x0037        // IP conflication configurationIp
#define DH_DEV_OSD_ENABLE_CFG             0x0038        // OSD overlay enable configuration
#define DH_DEV_LOCALALARM_CFG             0x0039        // Local alarm configuration(Structure DH_ALARMIN_CFG_EX)
#define DH_DEV_NETALARM_CFG               0x003A        // Network alarm configuration(Structure DH_ALARMIN_CFG_EX)
#define DH_DEV_MOTIONALARM_CFG            0x003B        // Motion detection configuration(Structure DH_MOTION_DETECT_CFG_EX)
#define DH_DEV_VIDEOLOSTALARM_CFG         0x003C        // Video loss configuration(Structure DH_VIDEO_LOST_CFG_EX)
#define DH_DEV_BLINDALARM_CFG             0x003D        // Camera masking configuration(Structure DH_BLIND_CFG_EX)
#define DH_DEV_DISKALARM_CFG              0x003E        // HDD alarm configuration(Structure DH_DISK_ALARM_CFG_EX)
#define DH_DEV_NETBROKENALARM_CFG         0x003F        // Network disconnection alarm configuration(Structure DH_NETBROKEN_ALARM_CFG_EX)
#define DH_DEV_ENCODER_CFG                0x0040        // Digital channel info of front encoders(Hybrid DVR use,Structure DEV_ENCODER_CFG)
#define DH_DEV_TV_ADJUST_CFG              0x0041        // TV adjust configuration(Now the channel parameter represents the TV numble(from 0), Structure DHDEV_TVADJUST_CFG)
#define DH_DEV_ABOUT_VEHICLE_CFG          0x0042        // about vehicle configuration
#define DH_DEV_ATM_OVERLAY_ABILITY        0x0043        // ATM ability information
#define DH_DEV_ATM_OVERLAY_CFG            0x0044        // ATM overlay configuration
#define DH_DEV_DECODER_TOUR_CFG           0x0045        // Decoder tour configuration
#define DH_DEV_SIP_CFG                    0x0046        // SIP configuration
#define DH_DEV_VICHILE_WIFI_AP_CFG        0x0047        // wifi ap configuration
#define DH_DEV_STATICALARM_CFG            0x0048        // Static 
#define DH_DEV_DECODE_POLICY_CFG          0x0049        // decode policy configuration(Structure DHDEV_DECODEPOLICY_CFG,channel start with 0) 
#define DH_DEV_MACHINE_CFG                0x004A        // Device relative config (Structure DHDEV_MACHINE_CFG)
#define DH_DEV_MAC_COLLISION_CFG          0x004B        // MACconflication configuration(Structure ALARM_MAC_COLLISION_CFG)
#define DH_DEV_RTSP_CFG                   0x004C        // RTSP configuration(structure DHDEV_RTSP_CFG)
#define DH_DEV_232_COM_CARD_CFG           0x004E        // 232 com card signal event configuration(structure COM_CARD_SIGNAL_LINK_CFG)
#define DH_DEV_485_COM_CARD_CFG           0x004F        // 485 com card signal event configuration(structure COM_CARD_SIGNAL_LINK_CFG)
#define DH_DEV_FTP_PROTO_CFG_EX           0x0050        // extend FTP upload setup(Structure DHDEV_FTP_PROTO_CFG_EX)
#define DH_DEV_SYSLOG_REMOTE_SERVER       0x0051        // SYSLOG remote server config (Structure DHDEV_SYSLOG_REMOTE_SERVER)
#define DH_DEV_COMMCFG_EX                 0x0052        // Extended com configuration(structure DHDEV_COMM_CFG_EX)
#define DH_DEV_NETCARD_CFG                0x0053        // net card configuration(structure DHDEV_NETCARD_CFG)
#define DH_DEV_BACKUP_VIDEO_FORMAT        0x0054        // Video backup format(structure DHDEV_BACKUP_VIDEO_FORMAT)
#define DH_DEV_STREAM_ENCRYPT_CFG         0x0055        // stream encrypt configuration(structure DHEDV_STREAM_ENCRYPT)
#define DH_DEV_IPFILTER_CFG_EX            0x0056        // IP filter extended configuration(structure DHDEV_IPIFILTER_CFG_EX)
#define DH_DEV_CUSTOM_CFG                 0x0057        // custom configuration(structure DHDEV_CUSTOM_CFG)
#define DH_DEV_WLAN_DEVICE_CFG_EX         0x0058        // Search wireless device extended setup(structure DHDEV_WLAN_DEVICE_LIST_EX)
#define DH_DEV_ACC_POWEROFF_CFG           0x0059        // ACC power off configuration(structure DHDEV_ACC_POWEROFF_CFG)
#define DH_DEV_EXPLOSION_PROOF_CFG        0x005a        // explosion proof alarm configuration(structure DHDEV_EXPLOSION_PROOF_CFG)
#define DH_DEV_NETCFG_EX                  0x005b        // Network extended setup(struct DHDEV_NET_CFG_EX)
#define DH_DEV_LIGHTCONTROL_CFG           0x005c        // light control config(struct DHDEV_LIGHTCONTROL_CFG)
#define DH_DEV_3GFLOW_CFG                 0x005d        // 3G flow info config(struct DHDEV_3GFLOW_INFO_CFG)
#define DH_DEV_IPV6_CFG                   0x005e        // IPv6 config(struct DHDEV_IPV6_CFG)
#define DH_DEV_SNMP_CFG                   0x005f        // Snmp config(struct DHDEV_NET_SNMP_CFG)
#define DH_DEV_SNAP_CONTROL_CFG           0x0060        // snap control config(struct DHDEV_SNAP_CONTROL_CFG)
#define DH_DEV_GPS_MODE_CFG               0x0061        // GPS mode config(struct DHDEV_GPS_MODE_CFG)
#define DH_DEV_SNAP_UPLOAD_CFG            0x0062        // Snap upload config(struct DHDEV_SNAP_UPLOAD_CFG)
#define DH_DEV_SPEED_LIMIT_CFG            0x0063        // Speed limit config(struct DHDEV_SPEED_LIMIT_CFG)
#define DH_DEV_ISCSI_CFG                  0x0064        // iSCSI config(struct DHDEV_ISCSI_CFG), need reboot
#define DH_DEV_WIRELESS_ROUTING_CFG       0x0065        // wifi config(struc DHDEV_WIRELESS_ROUTING_CFG)
#define DH_DEV_ENCLOSURE_CFG              0x0066        // enclosure config(stuct DHDEV_ENCLOSURE_CFG)
#define DH_DEV_ENCLOSURE_VERSION_CFG      0x0067        // enclosure version config(struct DHDEV_ENCLOSURE_VERSION_CFG)
#define DH_DEV_RIAD_EVENT_CFG             0x0068        // Raid event config(struct DHDEV_RAID_EVENT_CFG)
#define DH_DEV_FIRE_ALARM_CFG             0x0069        // fire alarm config(struct DHDEV_FIRE_ALARM_CFG)
#define DH_DEV_LOCALALARM_NAME_CFG        0x006a        // local alarm name config(string like "Name1&&name2&&name3...")
#define DH_DEV_URGENCY_RECORD_CFG         0x0070        // urgency storage config(struct DHDEV_URGENCY_RECORD_CFG)
#define DH_DEV_ELEVATOR_ATTRI_CFG         0x0071        // elevator parameter config(struct DHDEV_ELEVATOR_ATTRI_CFG)
#define DH_DEV_ATM_OVERLAY_CFG_EX         0x0072        // TM overlay function. For latest ATM series product only.  Support devices of 32-channel or higher.( struct DHDEV_ATM_OVERLAY_CONFIG_EX)
#define DH_DEV_MACFILTER_CFG              0x0073        // MAC filter config(struct DHDEV_MACFILTER_CFG)
#define DH_DEV_MACIPFILTER_CFG            0x0074        // MAC,IP filter config(need ip,mac one to one corresponding)(struct DHDEV_MACIPFILTER_CFG)
#define DH_DEV_STREAM_ENCRYPT_TIME_CFG    0x0075        // stream encrypt(encryot plan)(struct DHEDV_STREAM_ENCRYPT)
#define DH_DEV_LIMIT_BIT_RATE_CFG         0x0076        // limit bit rate config(struct DHDEV_LIMIT_BIT_RATE) 
#define DH_DEV_SNAP_CFG_EX                0x0077        // snap extern config(struct DHDEV_SNAP_CFG_EX)
#define DH_DEV_DECODER_URL_CFG            0x0078        // decoder url config(struct DHDEV_DECODER_URL_CFG)
#define DH_DEV_TOUR_ENABLE_CFG            0x0079        // toyr enable config(struct DHDEV_TOUR_ENABLE_CFG)
#define DH_DEV_VICHILE_WIFI_AP_CFG_EX     0x007a        // wifi ap extern config(struct DHDEV_VEHICLE_WIFI_AP_CFG_EX)
#define DH_DEV_ENCODER_CFG_EX             0x007b        // encoder extern config(struct DEV_ENCODER_CFG_EX)

// Here are some ITC_HWS000 configurations 
#define DH_DEV_ITC_HWS000_RA_CFG            0x007c      // ITC_HWS000 RA config(corresponding int value)
#define DH_DEV_ITC_HWS000_HS_CFG            0x007d      // ITC_HWS000 HS config(corresponding int value)
#define DH_DEV_ITC_HWS000_LS_CFG            0x007e      // ITC_HWS000 LS config(corresponding int value)
#define DH_DEV_ITC_HWS000_FL_CFG            0x007f      // ITC_HWS000 FL config(corresponding int value)
#define DH_DEV_ITC_HWS000_OC_CFG            0x0080      // ITC_HWS000 OC config(corresponding int value)
#define DH_DEV_ITC_HWS000_LC_CFG            0x0081      // ITC_HWS000 LC config(corresponding int value)
#define DH_DEV_ITC_HWS000_AC_CFG            0x0082      // ITC_HWS000 AC config(corresponding int value)
#define DH_DEV_ITC_HWS000_FC_CFG            0x0083      // ITC_HWS000 FC config(corresponding int value)
#define DH_DEV_ITC_HWS000_ALL_CFG           0x0084      // Query all the values (corresponding struct DEV_ITC_HWS000_ALL_CFG)
#define DH_DEV_ITC_HWS000_CLEAR_COUNT_CFG   0x0085      // Clear the counts(OC,LC,AC,FC corresponding int value)

#define DH_DEV_IPV4_CFG					  	0x0086		// IPV4 config(corresponding struct  DEV_IPV4_CFG)
#define DH_DEV_ENCODER_CFG_EX2				0x0087		// encoder extern config(struct DEV_ENCODER_CFG_EX2)
#define DH_DEV_WLAN_DEVICE_CFG_EX2			0x0088        // Search wireless device extended setup(structure DHDEV_WLAN_DEVICE_LIST_EX2)

#define DH_DEV_USER_END_CFG                 1000
#define DH_DEV_ITC_HWS000_CFG_ITEM_NUM      8           // the max count of ITC_HWS000's config item
// the config for all the values
typedef struct tagDEV_ITC_HWS000_ALL_CFG
{
    DWORD dwSize;                                // struct size
    int nValue[DH_DEV_ITC_HWS000_CFG_ITEM_NUM];  // the array of values
                                                 // start form the index 0, a sequence of RA, HS, LS, FL, OC, LC, AC, FC
}DEV_ITC_HWS000_ALL_CFG;

// Alarm type, corresponding to CLIENT_StartListen
#define DH_COMM_ALARM                       0x1100      // General alarm(Including external alarm, video loss and motion detection)
#define DH_SHELTER_ALARM                    0x1101      // Camera masking alarm 
#define DH_DISK_FULL_ALARM                  0x1102      // HDD full alarm 
#define DH_DISK_ERROR_ALARM                 0x1103      // HDD malfunction alarm 
#define DH_SOUND_DETECT_ALARM               0x1104      // Audio detection alarm 
#define DH_ALARM_DECODER_ALARM              0x1105      // Alarm decoder alarm 

// Extensive alarm type,corresponding to CLIENT_StartListenEx
#define DH_ALARM_ALARM_EX                   0x2101      // External alarm 
#define DH_MOTION_ALARM_EX                  0x2102      // Motion detection alarm 
#define DH_VIDEOLOST_ALARM_EX               0x2103      // Video loss alarm 
#define DH_SHELTER_ALARM_EX                 0x2104      // Camera masking alarm 
#define DH_SOUND_DETECT_ALARM_EX            0x2105      // Audio detection alarm 
#define DH_DISKFULL_ALARM_EX                0x2106      // HDD full alarm 
#define DH_DISKERROR_ALARM_EX               0x2107      // HDD malfunction alarm 
#define DH_ENCODER_ALARM_EX                 0x210A      // Encoder alarm 
#define DH_URGENCY_ALARM_EX                 0x210B      // Emergency alarm 
#define DH_WIRELESS_ALARM_EX                0x210C      // Wireless alarm 
#define DH_NEW_SOUND_DETECT_ALARM_EX        0x210D      // New auido detection alarm. Please refer to DH_NEW_SOUND_ALARM_STATE for alarm information structure;
#define DH_ALARM_DECODER_ALARM_EX           0x210E      // Alarm decoder alarm 
#define DH_DECODER_DECODE_ABILITY           0x210F      // NVD:Decoding capacity
#define DH_FDDI_DECODER_ABILITY             0x2110      // Fiber encoder alarm
#define DH_PANORAMA_SWITCH_ALARM_EX         0x2111      // Panorama switch alarm
#define DH_LOSTFOCUS_ALARM_EX               0x2112      // Lost focus alarm
#define DH_OEMSTATE_EX                      0x2113      // oem state
#define DH_DSP_ALARM_EX                     0x2114      // DSP alarm
#define DH_ATMPOS_BROKEN_EX                 0x2115      // atm and pos disconnection alarm, 0:disconnection 1:connection
#define DH_RECORD_CHANGED_EX                0x2116      // Record state changed alarm
#define DH_CONFIG_CHANGED_EX                0x2117      // Device config changed alarm
#define DH_DEVICE_REBOOT_EX                 0x2118      // Device rebooting alarm
#define DH_WINGDING_ALARM_EX                0x2119      // CoilFault alarm
#define DH_TRAF_CONGESTION_ALARM_EX         0x211A      // traffic congestion alarm
#define DH_TRAF_EXCEPTION_ALARM_EX          0x211B      // traffic exception alarm
#define DH_EQUIPMENT_FILL_ALARM_EX          0x211C      // FlashFault alarm
#define DH_ALARM_ARM_DISARM_STATE           0x211D      // alarm arm disarm 
#define DH_ALARM_ACC_POWEROFF               0x211E      // ACC power off alarm
#define DH_ALARM_3GFLOW_EXCEED              0x211F      // Alarm of 3G flow exceed(see struct DHDEV_3GFLOW_EXCEED_STATE_INFO)
#define DH_ALARM_SPEED_LIMIT                0x2120      // Speed limit alarm 
#define DH_ALARM_VEHICLE_INFO_UPLOAD        0x2121      // Vehicle information uploading 
#define DH_STATIC_ALARM_EX                  0x2122      // Static detection alarm
#define DH_PTZ_LOCATION_EX                  0x2123      // ptz location info
#define DH_ALARM_CARD_RECORD_UPLOAD         0x2124      // card record info(struct ALARM_CARD_RECORD_INFO_UPLOAD)
#define DH_ALARM_ATM_INFO_UPLOAD            0x2125      // ATM trade info(struct ALARM_ATM_INFO_UPLOAD)
#define DH_ALARM_ENCLOSURE                  0x2126      // enclosure alarm(struct ALARM_ENCLOSURE_INFO)
#define DH_ALARM_SIP_STATE                  0x2127      // SIP state alarm(struct ALARM_SIP_STATE)
#define DH_ALARM_RAID_STATE                 0x2128      // RAID state alarm(struct ALARM_RAID_INFO)
#define DH_ALARM_CROSSING_SPEED_LIMIT       0x2129      // crossing speed limit alarm(struct ALARM_SPEED_LIMIT)
#define DH_ALARM_OVER_LOADING               0x212A      // over loading alarm(struct ALARM_OVER_LOADING)
#define DH_ALARM_HARD_BRAKING               0x212B      // hard brake alarm(struct ALARM_HARD_BRAKING)
#define DH_ALARM_SMOKE_SENSOR               0x212C      // smoke sensor alarm(struct ALARM_SMOKE_SENSOR)
#define DH_ALARM_TRAFFIC_LIGHT_FAULT        0x212D      // traffic light fault alarm(struct ALARM_TRAFFIC_LIGHT_FAULT) 
#define DH_ALARM_TRAFFIC_FLUX_STAT          0x212E      // traffic flux alarm(struct ALARM_TRAFFIC_FLUX_LANE_INFO)
#define DH_ALARM_CAMERA_MOVE                0x212F      // camera move alarm(struct ALARM_CAMERA_MOVE_INFO)
#define DH_ALARM_DETAILEDMOTION             0x2130      // detailed motion alarm(struct ALARM_DETAILEDMOTION_CHNL_INFO)
#define DH_ALARM_STORAGE_FAILURE            0x2131      // storage failure alarm(struct ALARM_STORAGE_FAILURE)
#define DH_ALARM_FRONTDISCONNECT            0x2132      // front IPC disconnect alarm(struct ALARM_FRONTDISCONNET_INFO)
#define DH_ALARM_ALARM_EX_REMOTE            0x2133      // remote external alarm
#define DH_ALARM_BATTERYLOWPOWER            0x2134      // battery low power alarm(struct ALARM_BATTERYLOWPOWER_INFO)
#define DH_ALARM_TEMPERATURE                0x2135      // temperature alarm(struct ALARM_TEMPERATURE_INFO)
#define DH_ALARM_TIREDDRIVE                 0x2136      // tired drive alarm(struct ALARM_TIREDDRIVE_INFO)
#define DH_ALARM_LOST_RECORD                0x2137      // Alarm of record loss (corresponding structure ALARM_LOST_RECORD)
#define DH_ALARM_HIGH_CPU                   0x2138      // Alarm of High CPU Occupancy rate (corresponding structure ALARM_HIGH_CPU) 
#define DH_ALARM_LOST_NETPACKET             0x2139      // Alarm of net package loss (corresponding structure ALARM_LOST_NETPACKET)
#define DH_ALARM_HIGH_MEMORY                0x213A      // Alarm of high memory occupancy rate(corresponding structure ALARM_HIGH_MEMORY)
#define DH_LONG_TIME_NO_OPERATION           0x213B      // WEB user have no operation for long time (no extended info)
#define DH_BLACKLIST_SNAP                   0x213C      // blacklist snap(corresponding to DH_BLACKLIST_SNAP_INFO)         
#define DH_ALARM_DISK                       0x213E      // alarm of disk(corresponding to ALARM_DISK_INFO)
#define DH_ALARM_FILE_SYSTEM                0x213F      // alarm of file system(corresponding to ALARM_FILE_SYSTEM_INFO)
#define DH_ALARM_IVS                        0x2140      // alarm of ivs(corresponding to ALARM_IVS_INFO)
#define DH_ALARM_GOODS_WEIGHT_UPLOAD        0x2141      // goods weight (corresponding to ALARM_GOODS_WEIGHT_UPLOAD_INFO)
#define DH_ALARM_GOODS_WEIGHT               0x2142      // alarm of goods weight(corresponding to ALARM_GOODS_WEIGHT_INFO)
#define DH_GPS_STATUS                       0x2143      // GPS orientation info(corresponding to NET_GPS_STATUS_INFO)
#define DH_ALARM_DISKBURNED_FULL            0x2144      // alarm disk burned full(corresponding to ALARM_DISKBURNED_FULL_INFO)
#define DH_ALARM_STORAGE_LOW_SPACE          0x2145      // storage low space(corresponding to ALARM_STORAGE_LOW_SPACE_INFO)
#define DH_ALARM_DISK_FLUX                  0x2160      // disk flux abnormal(corresponding to ALARM_DISK_FLUX)
#define DH_ALARM_NET_FLUX                   0x2161      // net flux abnormal(corresponding to ALARM_NET_FLUX)
#define DH_ALARM_FAN_SPEED                  0x2162      // fan speed abnormal(corresponding to ALARM_FAN_SPEED)
#define DH_ALARM_STORAGE_FAILURE_EX         0x2163      // storage mistake(corresponding to ALARM_STORAGE_FAILURE_EX)
#define DH_ALARM_RECORD_FAILED              0x2164      // record abnormal(corresponding to ALARM_RECORD_FAILED_INFO)
#define DH_ALARM_STORAGE_BREAK_DOWN         0x2165      // storage break down(corresponding to ALARM_STORAGE_BREAK_DOWN_INFO)
#define DH_ALARM_VIDEO_ININVALID            0x2166      // ALARM_VIDEO_ININVALID_INFO
#define DH_ALARM_VEHICLE_TURNOVER           0x2167      // vehicle turnover arm event(struct ALARM_VEHICEL_TURNOVER_EVENT_INFO)
#define DH_ALARM_VEHICLE_COLLISION          0x2168      // vehicle collision event(struct ALARM_VEHICEL_COLLISION_EVENT_INFO)
#define DH_ALARM_VEHICLE_CONFIRM            0x2169      // vehicle confirm information event(struct ALARM_VEHICEL_CONFIRM_INFO)
#define DH_ALARM_VEHICLE_LARGE_ANGLE        0x2170      // vehicle camero large angle event(struct ALARM_VEHICEL_LARGE_ANGLE)
#define DH_ALARM_TALKING_INVITE             0x2171      // device talking invite event (struct ALARM_TALKING_INVITE_INFO)
#define DH_ALARM_ALARM_EX2                  0x2175      // local alarm event (struct ALARM_ALARM_INFO_EX2, upgrade DH_ALARM_ALARM_EX)
#define DH_ALARM_VIDEO_TIMING               0x2176      // video timing detecting event(struct ALARM_VIDEO_TIMING)
#define DH_ALARM_COMM_PORT                  0x2177      // COM event(struct ALARM_COMM_PORT_EVENT_INFO)
#define DH_ALARM_AUDIO_ANOMALY              0x2178      // audio anomaly event(struct ALARM_AUDIO_ANOMALY)
#define DH_ALARM_AUDIO_MUTATION             0x2179      // audio mutation event(struct ALARM_AUDIO_MUTATION)
#define DH_EVENT_TYREINFO                   0x2180      // Tyre information report event (struct EVENT_TYRE_INFO)
#define DH_ALARM_POWER_ABNORMAL             0x2181      // Redundant power supplies abnormal alarm(struct ALARM_POWER_ABNORMAL_INFO)
#define DH_EVENT_REGISTER_OFF               0x2182      // On-board equipment active offline events(struct  EVENT_REGISTER_OFF_INFO)
#define DH_ALARM_NO_DISK                    0x2183      // No hard disk alarm(struct ALARM_NO_DISK_INFO)
#define DH_ALARM_FALLING                    0x2184      // The fall alarm(struct ALARM_FALLING_INFO)
#define DH_ALARM_PROTECTIVE_CAPSULE         0x2185      // Protective capsule event(corresponding structure ALARM_PROTECTIVE_CAPSULE_INFO)
#define DH_ALARM_NO_RESPONSE                0x2186      // Call Non-response alarm(corresponding to ALARM_NO_RESPONSE_INFO)
#define DH_ALARM_CONFIG_ENABLE_CHANGE       0x2187      // Config enable to change reported event(corresponding to structure  ALARM_CONFIG_ENABLE_CHANGE_INFO)
#define DH_EVENT_CROSSLINE_DETECTION        0x2188      // Cross warning line event( Corresponding to structure ALARM_EVENT_CROSSLINE_INFO )
#define DH_EVENT_CROSSREGION_DETECTION      0x2189      // Warning zone event(Corresponding to structure ALARM_EVENT_CROSSREGION_INFO )
#define DH_EVENT_LEFT_DETECTION             0x218a      // Abandoned object event(Corresponding to structure ALARM_EVENT_LEFT_INFO )
#define DH_EVENT_FACE_DETECTION             0x218b      // Human face detect event(Corresponding to structure ALARM_EVENT_FACE_INFO ) 
#define DH_ALARM_IPC                        0x218c      // IPC alarm,IPC upload local alarm via DVR or NVR(Corresponding to structure ALARM_IPC_INFO)
#define DH_EVENT_TAKENAWAYDETECTION         0x218d      // Missing object event(Corresponding to structure ALARM_TAKENAWAY_DETECTION_INFO)
#define DH_EVENT_VIDEOABNORMALDETECTION     0x218e      // Video abnormal event(Corresponding to structure ALARM_VIDEOABNORMAL_DETECTION_INFO)
#define DH_EVENT_MOTIONDETECT               0x218f      // Video motion detect event  (Corresponding to structure ALARM_MOTIONDETECT_INFO)
#define DH_ALARM_PIR                        0x2190      // PIR alarm (Corresponding to BYTE*, pBuf length dwBufLen)
#define DH_ALARM_STORAGE_HOT_PLUG           0x2191      // Storage hot swap event(Corresponding to structure ALARM_STORAGE_HOT_PLUG_INFO)
#define DH_ALARM_FLOW_RATE                  0x2192      // the event of rate of flow(Corresponding to structure ALARM_FLOW_RATE_INFO)
#define DH_ALARM_MOVEDETECTION              0x2193      // Move detection event(Corresponding to structure ALARM_MOVE_DETECTION_INFO)
#define DH_ALARM_WANDERDETECTION            0x2194      // WanderDetection event(Corresponding to structure ALARM_WANDERDETECTION_INFO)
#define DH_ALARM_CROSSFENCEDETECTION        0x2195      // cross fence(Corresponding to ALARM_CROSSFENCEDETECTION_INFO)
#define DH_ALARM_PARKINGDETECTION           0x2196      // parking detection event(Corresponding to ALARM_PARKINGDETECTION_INFO)
#define DH_ALARM_RIOTERDETECTION            0x2197      // Rioter detection event(Corresponding to ALARM_RIOTERDETECTION_INFO)
#define DH_ALARM_STORAGE_NOT_EXIST          0x3167      // A storage group does not exist(struct ALARM_STORAGE_NOT_EXIST_INFO)
#define DH_ALARM_NET_ABORT                  0x3169      // Network fault event(struct ALARM_NETABORT_INFO)
#define DH_ALARM_IP_CONFLICT                0x3170      // IP conflict event(struct ALARM_IP_CONFLICT_INFO)
#define DH_ALARM_MAC_CONFLICT               0x3171      // MAC conflict event(struct ALARM_MAC_CONFLICT_INFO)
#define DH_ALARM_POWERFAULT                 0x3172      // power fault event(struct ALARM_POWERFAULT_INFO)
#define DH_ALARM_CHASSISINTRUDED            0x3173      // Chassis intrusion, tamper alarm events(struct ALARM_CHASSISINTRUDED_INFO)
#define DH_ALARM_ALARMEXTENDED              0x3174      // Native extension alarm events(struct ALARM_ALARMEXTENDED_INFO)
#define DH_ALARM_ARMMODE_CHANGE_EVENT       0x3175      // Cloth removal state change events(struct ALARM_ARMMODE_CHANGE_INFO)
#define DH_ALARM_BYPASSMODE_CHANGE_EVENT    0x3176      // The bypass state change events(struct ALARM_BYPASSMODE_CHANGE_INFO)
#define DH_ALARM_ACCESS_CTL_NOT_CLOSE       0x3177      // Entrance guard did not close events(struct ALARM_ACCESS_CTL_NOT_CLOSE_INFO)
#define DH_ALARM_ACCESS_CTL_BREAK_IN        0x3178      // break-in event(struct ALARM_ACCESS_CTL_BREAK_IN_INFO)
#define DH_ALARM_ACCESS_CTL_REPEAT_ENTER    0x3179      //access Again and again event(struct ALARM_ACCESS_CTL_REPEAT_ENTER_INFO)
#define DH_ALARM_ACCESS_CTL_DURESS          0x3180      // Stress CARDS event(struct ALARM_ACCESS_CTL_DURESS_INFO)
#define DH_ALARM_ACCESS_CTL_EVENT           0x3181      // Access event(struct ALARM_ACCESS_CTL_EVENT_INFO)
#define DH_URGENCY_ALARM_EX2                0x3182      // Emergency ALARM EX2(upgrade DH_URGENCY_ALARM_EX,struct ALARM_URGENCY_ALARM_EX2, Artificially triggered emergency, general processing is linked external communication function requests for help
#define DH_ALARM_INPUT_SOURCE_SIGNAL        0x3183      // Alarm input source signal events (as long as there is input will generate the event, whether to play the current mode, unable to block, struct ALARM_INPUT_SOURCE_SIGNAL_INFO)
#define DH_ALARM_ANALOGALARM_EVENT          0x3184      // analog alarm(struct ALARM_ANALOGALARM_EVENT_INFO)
#define DH_ALARM_ACCESS_CTL_STATUS          0x3185      // Access control status event(corresponding structure ALARM_ACCESS_CTL_STATUS_INFO)
#define DH_ALARM_ACCESS_SNAP                0x3186      // Access control snapshot event(corresponding to ALARM_ACCESS_SNAP_INFO)
#define DH_ALARM_ALARMCLEAR                 0x3187      // Cancel alarm(corresponding to structure ALARM_ALARMCLEAR_INFO)
#define DH_ALARM_CIDEVENT                   0x3188      // CID event(corresponding to structure ALARM_CIDEVENT_INFO)
#define DH_ALARM_TALKING_HANGUP             0x3189      // Device hand up evnt(corresponding to structure ALARM_TALKING_HANGUP_INFO)
#define DH_ALARM_BANKCARDINSERT             0x318a      // Bank card evnt(corresponding to structure ALARM_BANKCARDINSERT_INFO)
#define DH_ALARM_RCEMERGENCY_CALL           0x318b      // Emergency call alarm event(corresponding to structure ALARM_RCEMERGENCY_CALL_INFO)
#define DH_ALARM_OPENDOORGROUP              0x318c      // Multi-people group unlock event(corresponding to  structure ALARM_OPEN_DOOR_GROUP_INFO)
#define DH_ALARM_FINGER_PRINT               0x318d      // get fingerprint event(corresponding to  structure ALARM_CAPTURE_FINGER_PRINT_INFO)
#define DH_ALARM_CARD_RECORD                0x318e      // card no. record event(corresponding to  structure  ALARM_CARD_RECORD_INFO)
#define DH_ALARM_SUBSYSTEM_STATE_CHANGE     0x318f      // sub system status change event(corresponding to  structure ALARM_SUBSYSTEM_STATE_CHANGE_INFO)
#define DH_ALARM_BATTERYPOWER_EVENT         0x3190      // battery scheduled warning event(corresponding to  structure ALARM_BATTERYPOWER_INFO)
#define DH_ALARM_BELLSTATUS_EVENT           0x3191      // bell status event(corresponding to  structure ALARM_BELLSTATUS_INFO)
#define DH_ALARM_DEFENCE_STATE_CHANGE_EVENT 0x3192      // zone status change event(corresponding to  structure ALARM_DEFENCE_STATUS_CHANGE_INFO), 
                                                        // customized need, and arm/disarm change event, bypass event status have different definitions,
                                                        // The status via CLIENT_QueryDevState() port DH_DEVSTATE_DEFENCE_STATE command get
#define DH_ALARM_TICKET_STATISTIC           0x3193      // ticket statistics info event(corresponding to  structure  ALARM_TICKET_STATISTIC)
#define DH_ALARM_LOGIN_FAILIUR              0x3194      // login failed event(corresponding to  structure ALARM_LOGIN_FAILIUR_INFO)
#define DH_ALARM_MODULE_LOST                0x3195      // expansion module offline event(corresponding to  structure  ALARM_MODULE_LOST_INFO)
#define DH_ALARM_PSTN_BREAK_LINE            0x3196      // PSTN offline event(corresponding to  structure ALARM_PSTN_BREAK_LINE_INFO)
#define DH_ALARM_ANALOG_PULSE               0x3197      // analog alarm event(instant event), specific sensor  trigger(corresponding to  structure ALARM_ANALOGPULSE_INFO)
#define DH_ALARM_MISSION_CONFIRM            0x3198      // task confirmation event(corresponding to  structure  ALARM_MISSION_CONFIRM_INFO)
#define DH_ALARM_DEVICE_MSG_NOTIFY          0x3199      // device to platform notice event(corresponding to  structure  ALARM_DEVICE_MSG_NOTIFY_INFO)
#define DH_ALARM_VEHICLE_STANDING_OVER_TIME 0x319A      // parking timeout event(corresponding to  structure  ALARM_VEHICLE_STANDING_OVER_TIME_INFO)
#define DH_ALARM_ENCLOSURE_ALARM            0x319B      // e-fence event(corresponding to  structure  ALARM_ENCLOSURE_ALARM_INFO)
#define DH_ALARM_GUARD_DETECT               0x319C      // station detection event, one in station first report the start event, and last on in station report stop event before leave (corresponding to  structure ALARM_GUARD_DETECT_INFO)
#define DH_ALARM_GUARD_INFO_UPDATE          0x319D      // station info update event, report if people in station(corresponding to  structure ALARM_GUARD_UPDATE_INFO)  
#define DH_ALARM_NODE_ACTIVE                0x319E      // Node activation event (corresponding to structure ALARM_NODE_ACTIVE_INFO)
#define DH_ALARM_VIDEO_STATIC               0x319F      // Video static detection event (corresponding to structure ALARM_VIDEO_STATIC_INFO)
#define DH_ALARM_REGISTER_REONLINE          0x31a0      // Active registration device re-login event (corresponding to structure ALARM_REGISTER_REONLINE_INFO)
#define DH_ALARM_ISCSI_STATUS               0x31a1      // ISCSI alarm event (corresponding to structure ALARM_ISCSI_STATUS_INFO)
#define DH_ALARM_SCADA_DEV_ALARM            0x31a2      // detection collection device alarm event (corresponding to structure ALARM_SCADA_DEV_INFO)
#define DH_ALARM_AUXILIARY_DEV_STATE        0x31a3      // Sub device status(corresponding structure ALARM_AUXILIARY_DEV_STATE)
#define DH_ALARM_PARKING_CARD               0x31a4      // Parking swipe card event(corresponding structure ALARM_PARKING_CARD)
#define DH_ALARM_PROFILE_ALARM_TRANSMIT     0x31a5      // Alarm transmit event(corresponding structure ALARM_PROFILE_ALARM_TRANSMIT_INFO)
#define DH_ALARM_VEHICLE_ACC                0x31a6      // Vehicle acc event(corresponding structure ALARM_VEHICLE_ACC_INFO)
#define DH_ALARM_TRAFFIC_SUSPICIOUSCAR      0x31a7      // suspiciouscar event(corresponding structure ALARM_TRAFFIC_SUSPICIOUSCAR_INFO)
#define DH_ALARM_ACCESS_LOCK_STATUS         0x31a8      // the event of latch state (corresponding structure  ALARM_ACCESS_LOCK_STATUS_INFO)
#define DH_ALARM_FINACE_SCHEME              0x31a9      // Finace scheme event(corresponding structure ALARM_FINACE_SCHEME_INFO)
#define DH_ALARM_HEATIMG_TEMPER             0x31aa      // Thermal temperature abnormal event alarm(Corresponding to structure ALARM_HEATIMG_TEMPER_INFO)
#define DH_ALARM_TALKING_IGNORE_INVITE      0x31ab      // Device cancel bidirectional talk query event(Corresponding to structure ALARM_TALKING_IGNORE_INVITE_INFO)
#define DH_ALARM_BUS_SHARP_TURN             0x31ac      // Vehicle Abrupt-turn event(Corresponding to structure ALARM_BUS_SHARP_TURN_INFO)
#define DH_ALARM_BUS_SCRAM                  0x31ad      // vehicle abrupt stop event(Corresponding to structure ALARM_BUS_SCRAM_INFO)
#define DH_ALARM_BUS_SHARP_ACCELERATE       0x31ae      // Vehicle abrupt speed up event(Corresponding to structure ALARM_BUS_SHARP_ACCELERATE_INFO)
#define DH_ALARM_BUS_SHARP_DECELERATE       0x31af      // Vehicle abrupt slow down event (Corresponding to structure ALARM_BUS_SHARP_DECELERATE_INFO)
#define DH_ALARM_ACCESS_CARD_OPERATE        0x31b0      // A&C data operation event (Corresponding to structure ALARM_ACCESS_CARD_OPERATE_INFO)
#define DH_ALARM_POLICE_CHECK               0x31b1      // Policeman check in event(Corresponding to structure ALARM_POLICE_CHECK_INFO)
#define DH_ALARM_NET                        0x31b2      // Network alarm event(Corresponding to structure ALARM_NET_INFO)
#define DH_ALARM_NEW_FILE                   0x31b3      // New file event(Corresponding to structure ALARM_NEW_FILE_INFO)
#define DH_ALARM_FIREWARNING                0x31b5      // Thermal fire position (Corresponding to structure ALARM_FIREWARNING_INFO)
#define DH_ALARM_RECORD_LOSS                0x31b6      // Record loss event: the HDD is OK, delete results from misoperation.  (Corresponding to structure ALARM_RECORD_LOSS_INFO)
#define DH_ALARM_VIDEO_FRAME_LOSS           0x31b7      // Frame loss event: it results from poor network environment or insufficient encode capability (Corresponding to structure ALARM_VIDEO_FRAME_LOSS_INFO)
#define DH_ALARM_RECORD_VOLUME_FAILURE      0x31b8      // Abnormal record results from HDD volume(Corresponding to structure ALARM_RECORD_VOLUME_FAILURE_INFO)
#define DH_EVENT_SNAP_UPLOAD                0x31b9      // Image upload completion event(Corresponding to structure EVENT_SNAP_UPLOAD_INFO)
#define DH_ALARM_AUDIO_DETECT               0x31ba      // Audio detect event(Corresponding to structure ALARM_AUDIO_DETECT )
#define DH_ALARM_UPLOADPIC_FAILCOUNT        0x31bb      // Failure data amount during the image upload process (Corresponding to structure ALARM_UPLOADPIC_FAILCOUNT_INFO)
#define DH_ALARM_POS_MANAGE                 0x31bc      // POS management event(Corresponding to ALARM_POS_MANAGE_INFO )
#define DH_ALARM_REMOTE_CTRL_STATUS         0x31bd      // remote control status(Corresponding to ALARM_REMOTE_CTRL_STATUS )
#define DH_ALARM_PASSENGER_CARD_CHECK       0x31be      // desuetude, passenger card check(Corresponding to structure ALARM_PASSENGER_CARD_CHECK )
#define DH_ALARM_SOUND                      0x31bf      // Sound event(Corresponding to ALARM_SOUND )
#define DH_ALARM_LOCK_BREAK                 0x31c0      // Lock break event(Corresponding to ALARM_LOCK_BREAK_INFO )
#define DH_ALARM_HUMAN_INSIDE               0x31c1      // Human Inside event((Corresponding to structure ALARM_HUMAN_INSIDE_INFO)
#define DH_ALARM_HUMAN_TUMBLE_INSIDE        0x31c2      // Human tumble Inside(Corresponding to structure ALARM_HUMAN_TUMBLE_INSIDE_INFO)
#define DH_ALARM_DISABLE_LOCKIN             0x31c3      // Lock entry trigger event(Corresponding to structure ALARM_DISABLE_LOCKIN_INFO)
#define DH_ALARM_DISABLE_LOCKOUT            0x31c4      // Lock go out trigger(Corresponding to structure ALARM_DISABLE_LOCKOUT_INFO)
#define DH_ALARM_UPLOAD_PIC_FAILED          0x31c5      // break rules data upload failed (Corresponding to ALARM_UPLOAD_PIC_FAILED_INFO )
#define DH_ALARM_FLOW_METER                 0x31c6      // flow meter info event (ALARM_FLOW_METER_INFO)
#define DH_ALARM_WIFI_SEARCH                0x31c7      // search around wifi device(Corresponding to ALARM_WIFI_SEARCH_INFO)
#define DH_ALARM_WIRELESSDEV_LOWPOWER       0x31C8      // lowpower of wirelessdevice(ALARM_WIRELESSDEV_LOWPOWER_INFO)
#define DH_ALARM_PTZ_DIAGNOSES               0x31c9     // PTZ Diagnoses event(Corresponding to ALARM_PTZ_DIAGNOSES_INFO)
#define DH_ALARM_FLASH_LIGHT_FAULT          0x31ca      // flash light fault event (Corresponding to ALARM_FLASH_LIGHT_FAULT_INFO)
#define DH_ALARM_STROBOSCOPIC_LIGTHT_FAULT  0x31cb      // stroboscopic light fault event (Corresponding to ALARM_STROBOSCOPIC_LIGTHT_FAULT_INFO)
#define DH_ALARM_HUMAM_NUMBER_STATISTIC     0x31cc      // NumberStat event (Corresponding to ALARM_HUMAN_NUMBER_STATISTIC_INFO)
#define DH_ALARM_VIDEOUNFOCUS               0x31ce      // Video unfocus (Corresponding ALARM_VIDEOUNFOCUS_INFO)
#define DH_ALARM_BUF_DROP_FRAME             0x31cd      // Video recond buffer drop frame event(Corresponding to ALARM_BUF_DROP_FRAME_INFO)
#define DH_ALARM_DOUBLE_DEV_VERSION_ABNORMAL 0x31cf     // Abnormal event when master broad'version and slave broad'version different  (Corresponding to ALARM_DOUBLE_DEV_VERSION_ABNORMAL_INFO)
#define DH_ALARM_DCSSWITCH                  0x31d0      // Switch with master and slave(Corresponding to ALARM_DCSSWITCH_INFO)
#define DH_ALARM_RADAR_CONNECT_STATE        0x31d1      // Radar connect state(Corresponding to ALARM_RADAR_CONNECT_STATE_INFO)
#define DH_ALARM_DEFENCE_ARMMODE_CHANGE     0x31d2      // Defence arming status change(Corresponding to ALARM_DEFENCE_ARMMODECHANGE_INFO)
#define DH_ALARM_SUBSYSTEM_ARMMODE_CHANGE   0x31d3      // Subsystem arming status change(Corresponding to ALARM_SUBSYSTEM_ARMMODECHANGE_INFO)
#define DH_ALARM_RFID_INFO                  0x31d4      // infrared detection information event (Corresponding ALARM_RFID_INFO)
#define DH_ALARM_SMOKE_DETECTION            0x31d5      // smoke detection(Corresponding ALARM_SMOKE_DETECTION_INFO)
#define DH_ALARM_BETWEENRULE_TEMP_DIFF      0x31d6      // TemperatureDifference Between Rule (Corresponding ALARM_BETWEENRULE_DIFFTEMPER_INFO)
#define DH_ALARM_TRAFFIC_PIC_ANALYSE        0x31d7      // Traffic picture analyse(Corresponding ALARM_PIC_ANALYSE_INFO)
#define DH_ALARM_HOTSPOT_WARNING            0x31d8      // Hotspot warning(Corresponding ALARM_HOTSPOT_WARNING_INFO)
#define DH_ALARM_COLDSPOT_WARNING           0x31d9      // coldspot warning(Corresponding ALARM_COLDSPOT_WARNING_INFO)
#define DH_ALARM_FIREWARNING_INFO           0x31da      // firewarning (Corresponding ALARM_FIREWARNING_INFO_DETAIL)
#define DH_ALARM_FACE_OVERHEATING           0x31db      // face overheating(Corresponding ALARM_FACE_OVERHEATING_INFO)
#define DH_ALARM_SENSOR_ABNORMAL            0x31dc      // Sensor abnormal(Corresponding ALARM_SENSOR_ABNORMAL_INFO)
#define DH_ALARM_PATIENTDETECTION           0x31de      // patient detection(Corresponding ALARM_PATIENTDETECTION_INFO)
#define DH_ALARM_RADAR_HIGH_SPEED           0x31df      // radar high speed detection(Corresponding to ALARM_RADAR_HIGH_SPEED_INFO)
#define DH_ALARM_POLLING_ALARM              0x31e0      // Polling Alarm (Corresponding to ALARM_POLLING_ALARM_INFO)
#define DH_ALARM_ITC_HWS000                 0x31e1      // the alarm event for ITC_HWS000 (Corresponding ALARM_ITC_HWS000)
#define DH_ALARM_TRAFFICSTROBESTATE         0x31e2      // Traffic Strobe State(Corresponding to ALARM_TRAFFICSTROBESTATE_INFO)
#define DH_ALARM_TELEPHONE_CHECK            0x31e3      // telephone number check event(Corresponding to ALARM_TELEPHONE_CHECK_INFO)
#define DH_ALARM_PASTE_DETECTION            0x31e4      // Paste Detection(Corresponding to ALARM_PASTE_DETECTION_INFO )
#define DH_ALARM_SHOOTINGSCORERECOGNITION   0x31e5      // the alarm event for Shooting (Corresponding to ALARM_PIC_SHOOTINGSCORERECOGNITION_INFO)
#define DH_ALARM_SWIPEOVERTIME              0x31e6      // the alarm event for swipe overtime(Corresponding to ALARM_SWIPE_OVERTIME_INFO)
#define DH_ALARM_DRIVING_WITHOUTCARD        0x31e7      // the alarm event for driving without card(Corresponding to ALARM_DRIVING_WITHOUTCARD_INFO)
#define DH_ALARM_TRAFFIC_PEDESTRIAN_RUN_REDLIGHT_DETECTION 0x31e8  //red light event (Corresponding to ALARM_TRAFFIC_PEDESTRIAN_RUN_REDLIGHT_DETECTION_INFO)
#define DH_ALARM_FIGHTDETECTION             0x31e9      //the alarm event for fight detection(Corresponding to NET_ALARM_FIGHTDETECTION)
#define DH_ALARM_OIL_4G_OVERFLOW            0x31ea      //the alarm event for fushan oil 4G over flow threshold(Corresponding to NET_ALARM_OIL_4G_OVERFLOW_INFO)
#define DH_ALARM_ACCESSIDENTIFY             0x31eb      //VTO access identify(Corresponding to NET_ALARM_ACCESSIDENTIFY_INFO)
#define DH_ALARM_POWER_SWITCHER_ALARM       0x31ec      // the alarm event for Abnormal power switcher (Corresponding to DEV_ALRAM_POWERSWITCHER_INFO)
#define DH_ALARM_SCENNE_CHANGE_ALARM        0x31ed      // the alarm event for scene change (Corresponding to ALARM_PIC_SCENECHANGE_INFO)
#define DH_ALARM_WIFI_VIRTUALINFO_SEARCH    0x31ef      // the alarm event for WIFI virtual information(Corresponding to ALARM_WIFI_VIRTUALINFO_SEARCH_INFO)
#define DH_ALARM_TRAFFIC_OVERSPEED          0x31f0      // traffic overspeed event(Corresponding to event  ALARM_TRAFFIC_OVERSPEED_INFO)
#define DH_ALARM_TRAFFIC_UNDERSPEED         0x31f1      // traffic underspeed event(Corresponding to event  ALARM_TRAFFIC_NDERSPEED_INFO)
#define DH_ALARM_TRAFFIC_PEDESTRAIN         0x31f2      // traffic pedestrain event(Corresponding to event  ALARM_TRAFFIC_PEDESTRAIN_INFO)
#define DH_ALARM_TRAFFIC_JAM                0x31f3      // traffic jam event(Corresponding to event  ALARM_TRAFFIC_JAM_INFO)
#define DH_ALARM_TRAFFIC_PARKING            0x31f4      // traffic parking event(Corresponding to event  ALARM_TRAFFIC_PARKING_INFO)
#define DH_ALARM_TRAFFIC_THROW              0x31f5      // traffic throw event(Corresponding to event  ALARM_TRAFFIC_THROW_INFO)
#define DH_ALARM_TRAFFIC_RETROGRADE         0x31f6      // traffic retrograde event(Corresponding to event  ALARM_TRAFFIC_RETROGRADE_INFO)
#define DH_ALARM_VTSTATE_UPDATE             0x31f7      // VTS state update(Corresponding to ALARM_VTSTATE_UPDATE_INFO)
#define DH_ALARM_CALL_NO_ANSWERED           0x31f8      // the alarm event for call no answer, under directly connected(Corresponding to NET_ALARM_CALL_NO_ANSWERED_INFO)
#define DH_ALARM_USER_LOCK_EVENT            0x31f9      // User Lock Alarm Event
#define DH_ALARM_RETROGRADE_DETECTION       0x31fa      // retrogade dection event(Corresponding to ALARM_RETROGRADE_DETECTION_INFO)
#define DH_ALARM_AIO_APP_CONFIG_EVENT       0x31fb      // AIO App config event(Corresponding to NET_ALARM_AIO_APP_CONFIG_EVENT)
#define DH_ALARM_RAID_STATE_EX              0x31fc      // RAID state alarm(Corresponding to struct ALARM_RAID_INFO_EX)
#define DH_ALARM_STORAGE_IPC_FAILURE        0x31fd      // IPC storage failure alarm(IPC SD Card Abnormal Alarm)(Corresponding to struct ALARM_STORAGE_IPC_FAILURE_INFO)
#define DH_ALARM_DEVICE_STAY                0x31fe      // Still amarm, if the device coordinates are not changed in the specified time, the still alarm information is triggered(Corresponding to struct ALARM_DEVICE_STAY_INFO)    
#define DH_ALARM_SUB_WAY_DOOR_STATE         0x31ff      // the door state of subway(Corresponding to ALARM_SUB_WAY_DOOR_STATE_INFO)
#define DH_ALARM_SUB_WAY_PECE_SWITCH        0x3200      // the PECE switch state of subway(Corresponding to ALARM_SUB_WAY_PECE_SWITCH_INFO)
#define DH_ALARM_SUB_WAY_FIRE_ALARM         0x3201      // the fire alarm of subway(Corresponding to ALARM_SUB_WAY_FIRE_ALARM_INFO)
#define DH_ALARM_SUB_WAY_EMER_HANDLE        0x3202      // the emer handle state(Corresponding to ALARM_SUB_WAY_EMER_HANDLE_INFO)
#define DH_ALARM_SUB_WAY_CAB_COVER          0x3203      // the cab cover state(Corresponding to ALARM_SUB_WAY_CAB_COVER_INFO)
#define DH_ALARM_SUB_WAY_DERA_OBST          0x3204      // the dera or obst of subway(Corresponding to ALARM_SUB_WAY_DERA_OBST_INFO)
#define DH_ALARM_SUB_WAY_PECU_CALL          0x3205      // the PECU call state(Corresponding to ALARM_SUB_WAY_PECU_CALL_INFO)
#define DH_ALARM_BOX                        0x3206      // the Alarm Box(Corresponding to ALARM_BOX_INFO)
#define DH_ALARM_DOOR_CLOSEDMANUALLY        0x3207      // door closed manually(Corresponding to  ALARM_DOOR_CLOSEDMANUALLY_INFO)
#define DH_ALARM_DOOR_NOTCLOSED_LONGTIME    0x3208      // door not closed long time(Corresponding to ALARM_DOOR_NOTCLOSED_LONGTIME_INFO)
#define DH_ALARM_UNDER_VOLTAGE              0x3209      // the under voltage alarm ( Corresponding to ALARM_UNDER_VOLTAGE_INFO )
#define DH_ALARM_OVER_VOLTAGE               0x320a      // the over voltage alarm  ( Corresponding to ALARM_OVER_VOLTAGE_INFO )
#define DH_ALARM_CUT_LINE                   0x320b      // the cut line alarm(Corresponding to ALARM_CUT_LINE_INFO)
#define DH_ALARM_VIDEOMOTION_EVENT          0x320c      // video motion event(Corresponding to ALARM_VIDEOMOTION_EVENT_INFO)
#define DH_ALARM_WIDE_VIEW_REGION_EVENT     0x320d      // WideViewRegions event(Corresponding to ALARM_WIDE_VIEW_REGION_EVENT_INFO)
#define DH_ALARM_FIBRE_OPTIC_ABORT          0x320e      // the fibre optic abort alarm(Corresponding to ALARM_FIBRE_OPTIC_ABORT)
#define DH_ALARM_TAIL_DETECTION             0x320f      // tail detection(Corresponding ALARM_TAIL_DETECTION_INFO)
#define DH_ALARM_BITRATES_OVERLIMIT         0x3210      // alarm when camera bitrate is over channel decoding specification(Corresponding to ALARM_BITRATES_OVERLIMIT_INFO)
#define DH_ALARM_RECORD_CHANGED_EX          0x3211      // Record state changed alarm(Corresponding to ALARM_RECORD_CHANGED_INFO_EX)
#define DH_ALARM_HIGH_DECIBEL               0x3212      // High decibel alarm(Corresponding to ALARM_HIGH_DECIBEL_INFO)
#define DH_ALARM_SHAKE_DETECTION            0x3213      // Shake detection alarm(Corresponding to ALARM_SHAKE_DETECTION_INFO)
#define DH_ALARM_TUMBLE_DETECTION           0x3214      // tumble detection alarm(Corresponding to ALARM_TUMBLE_DETECTION_INFO)
#define DH_ALARM_ACCESS_CTL_MALICIOUS       0x3215      // Open door with malice(Corresponding to ALARM_ACCESS_CTL_MALICIOUS)
#define DH_ALARM_ACCESS_CTL_USERID_REGISTER 0x3216      // UserID Register(Corresponding to ALARM_ACCESS_CTL_USERID_REGISTER)
#define DH_ALARM_ACCESS_CTL_REVERSELOCK     0x3217      // ReverseLock alarm(Corresponding to ALARM_ACCESS_CTL_REVERSELOCK)
#define DH_ALARM_ACCESS_CTL_USERID_DELETE   0x3218      // UserID delete(Corresponding to ALARM_ACCESS_CTL_USERID_DELETE)
#define DH_ALARM_ACCESS_DOOR_BELL           0x3219      // Door bell (Corresponding to ALARM_ACCESS_DOOR_BELL_INFO)
#define DH_ALARM_ACCESS_FACTORY_RESET       0x321a      // Wireless Dev Facroty Reset (Corresponding to ALARM_ACCESS_FACTORY_RESET_INFO)
#define DH_ALARM_POLICE_RECORD_PROGRESS     0x321b        // MPT record file transfer progress(Corresponding to ALARM_POLICE_RECORD_PROGRESS_INFO)
#define DH_ALARM_POLICE_PLUGIN              0x321c        // MPT plugin in or out event(Corresponding to ALARM_POLICE_PLUGIN_INFO)
#define DH_ALARM_GPS_NOT_ALIGNED            0x321d        // GPS not aligned alarm (Corresponding to ALARM_GPS_NOT_ALIGNED_INFO)
#define DH_ALARM_WIRELESS_NOT_CONNECTED     0x321e        // WireLess(include wifi, 3G/4G) not connected alarm (Corresponding to ALARM_WIRELESS_NOT_CONNECTED_INFO)
#define DH_ALARM_CABINET                    0x321f        // Cloud Cabinet event(Corresponding to ALARM_CABINET_INFO)
#define DH_SWITCH_SCREEN                    0x3220        // Switch screen event.
#define DH_ALARM_NEAR_DISTANCE_DETECTION    0x3221        // alarm of near distance detection (Corresponding to ALARM_NEAR_DISTANCE_INFO)
#define DH_ALARM_MAN_STAND_DETECTION        0x3222        // alarm of stereo standing (Corresponding to ALARM_MAN_STAND_INFO)
#define DH_ALARM_MAN_NUM_DETECTION          0x3223        // alarm of regional population statistics  (Corresponding to ALARM_MAN_NUM_INFO)
#define DH_MCS_GENERAL_CAPACITY_LOW         0x3224        // MCS general capacity low event(Corresponding to ALARM_MCS_GENERAL_CAPACITY_LOW_INFO)
#define DH_MCS_DATA_NODE_OFFLINE            0x3225        // MCS data node offline event(Corresponding to ALARM_MCS_DATA_NODE_OFFLINE_INFO)
#define DH_MCS_DISK_OFFLINE                 0x3226        // MCS disk offline event(Corresponding to ALARM_MCS_DISK_OFFLINE_INFO)
#define DH_MCS_DISK_SLOW                    0x3227        // MCS disk slow event(Corresponding to ALARM_MCS_DISK_SLOW_INFO)
#define DH_MCS_DISK_BROKEN                  0x3228        // MCS disk broken event(Corresponding to ALARM_MCS_DISK_BROKEN_INFO)
#define DH_MCS_DISK_UNKNOW_ERROR            0x3229        // MCS disk unknown error event(Corresponding to ALARM_MCS_DISK_UNKNOW_ERROR_INFO)
#define DH_MCS_METADATA_SERVER_ABNORMAL     0x322a        // MCS metadata server abnormal event(Corresponding to ALARM_MCS_METADATA_SERVER_ABNORMAL_INFO)
#define DH_MCS_CATALOG_SERVER_ABNORMAL      0x322b        // MCS catalog server abnormal event(Corresponding to ALARM_MCS_CATALOG_SERVER_ABNORMAL_INFO)
#define DH_MCS_GENERAL_CAPACITY_RESUME      0x322c        // MCS general capacity resume event(Corresponding to ALARM_MCS_GENERAL_CAPACITY_RESUME_INFO)
#define DH_MCS_DATA_NODE_ONLINE             0x322d        // MCS data node online event(Corresponding to ALARM_MCS_DATA_NODE_ONLINE_INFO)
#define DH_MCS_DISK_ONLINE                  0x322e        // MCS disk online event(Corresponding to ALARM_MCS_DISK_ONLINE_INFO)
#define DH_MCS_METADATA_SLAVE_ONLINE        0x322f        // MCS metadata slave online event(Corresponding to ALARM_MCS_METADATA_SLAVE_ONLINE_INFO)
#define DH_MCS_CATALOG_SERVER_ONLINE        0x3230        // MCS catalog server online event(Corresponding to ALARM_MCS_CATALOG_SERVER_ONLINE_INFO)
#define DH_ALARM_OFFLINE_LOGSYNC            0x3231        // alarm of off Line logsync(Corresponding to ALARM_OFFLINE_LOGSYNC_INFO)
#define DH_ALARM_UPGRADE_STATE              0x3232        // event of device upgrade(Corresponding to ALARM_UPGRADE_STATE)
#define DH_ALARM_LABELINFO                  0x3233        // IPC added new(2017.4),RFID tag information acquisition event (Corresponding to DH_ALARM_LABELINFO)
#define DH_ALARM_TIRED_PHYSIOLOGICAL        0x3234        // alarm of Tired Physiological(Corresponding to ALARM_TIRED_PHYSIOLOGICAL)
#define DH_ALARM_CALLING_WHEN_DRIVING       0x3235        // alarm of Calling When Driving(Corresponding to ALARM_CALLING_WHEN_DRIVING)
#define DH_ALARM_TRAFFIC_DRIVER_SMOKING     0x3236        // alarm of Traffic Driver Smoking(Corresponding to ALARM_TRAFFIC_DRIVER_SMOKING)
#define DH_ALARM_TRAFFIC_DRIVER_LOWER_HEAD  0x3237        // alarm of Traffic Driver Lower Head(Corresponding to ALARM_TRAFFIC_DRIVER_LOWER_HEAD)
#define DH_ALARM_TRAFFIC_DRIVER_LOOK_AROUND 0x3238        // alarm of Traffic Driver Look Around(Corresponding to ALARM_TRAFFIC_DRIVER_LOOK_AROUND)
#define DH_ALARM_TRAFFIC_DRIVER_LEAVE_POST  0x3239        // alarm of Traffic Driver Leave Post(Corresponding to ALARM_TRAFFIC_DRIVER_LEAVE_POST)
#define DH_ALARM_TRAFFIC_DRIVER_YAWN        0x323a        // alarm of Traffic Driver Yawn(Corresponding to ALARM_TRAFFIC_DRIVER_YAWN)
#define DH_ALARM_AUTO_INSPECTION            0x323b        // Device auto inspection(Corresponding to ALARM_AUTO_INSPECTION) 
#define DH_ALARM_TRAFFIC_VEHICLE_POSITION   0x323c        // Vehicle Position Event(Corresponding to ALARM_TRAFFIC_VEHICLE_POSITION)
#define DH_ALARM_FACE_VERIFICATION_ACCESS_SNAP     0x323d // alarm of face verification access snap(Corresponding to ALARM_FACE_VERIFICATION_ACCESS_SNAP_INFO)
#define DH_ALARM_VIDEOBLIND                 0x323e        // alarm of video blind(Corresponding to ALARM_VIDEO_BLIND_INFO)
#define DH_ALARM_DRIVER_NOTCONFIRM          0x323f        // alarm of driver not confirm(Corresponding to ALARM_DRIVER_NOTCONFIRM_INFO)
#define DH_ALARM_FACEINFO_COLLECT           0x3240        // alarm of face info collect(Corresponding to ALARM_FACEINFO_COLLECT_INFO)
#define DH_ALARM_HIGH_SPEED				  	0x3241			// alarm of high speed(Corresponding to ALARM_HIGH_SPEED_INFO)
#define DH_ALARM_VIDEO_LOSS					0x3242			// alarm of video loss(Corresponding to ALARM_VIDEO_LOSS_INFO)
#define DH_ALARM_MPTBASE_CONNECT            0x3243          // alarm of the connection status between device ant base(Corresponding to ALARM_MPTBASE_CONNECT) 
#define DH_ALARM_LATEST_SHUTDOWN            0x3244          // alarm of the latest status of shut down (Corresponding to ALARM_LATEST_SHUTDOWN)

#define DH_ALARM_ROBOT_COLLISION	        0x3245			// alarm of robot collision(Corresponding to ALARM_ROBOT_COLLISION)
#define DH_ALARM_ROBOT_FALLENDOWN		    0x3246			// alarm of robot fallendown(Corresponding to ALARM_ROBOT_FALLENDOWN)
#define DH_ALARM_ROBOT_UNRECOGNIZED2DCODE   0x3247			// alarm of robot unrecognized 2DCODE(Corresponding to ALARM_ROBOT_UNRECOGNIZED2DCODE) 
#define DH_ALARM_ROBOT_WRONG2DCODE	        0x3248			// alarm of wrong 2DCODE(Corresponding to ALARM_ROBOT_WRONG2DCODE)
#define DH_ALARM_ROBOT_ROADBLOCKED	        0x3249		    // alarm of robot roadblocked(Corresponding to ALARM_ROBOT_ROADBLOCKED) 
#define DH_ALARM_ROBOT_FAULT				0x324a			// alarm of robot fault(Corresponding to ALARM_ROBOT_FAULT)
#define DH_ALARM_ROBOT_OVERLOAD			    0x324b			// alarm of robot overload(Corresponding to ALARM_ROBOT_OVERLOAD)
#define DH_ALARM_ROBOT_YAWEXCEPTION		    0x324c			// alarm of robot yawexception(Corresponding to ALARM_ROBOT_YAWEXCEPTION)


#define DH_ALARM_ROBOT_LOADTIMEOUT		    0x324e			// alarm of robot LoadTimeout(Corresponding to ALARM_ROBOT_LOADTIMEOUT)
#define DH_ALARM_ROBOT_UNLOADTIMEOUT		0x324f			// alarm of robot UnLoadTimeout(Corresponding to ALARM_ROBOT_UNLOADTIMEOUT)
#define DH_ALARM_ROBOT_MAPUPDATE	    	0x3250			// alarm of robot MapUpdate(Corresponding to ALARM_ROBOT_MAPUPDATE)
#define	DH_ALARM_ROBOT_BRAKE				0x3252			// alarm of robot brake(Corresponding to ALARM_ROBOT_BRAKE)
#define	DH_ALARM_ROBOT_MANUAL_INTERVENTION	0x3253			// alarm of robot manual intervention(Corresponding to ALARM_ROBOT_MANUAL_INTERVENTION)
// -----------------------------------------------


#define DH_ALARM_VIDEO_TALK_PATH		    0x324d			// alarm of the video talk path(Corresponding to ALARM_VIDEO_TALK_PATH_INFO)
#define DH_ALARM_CGIRECORD                  0x3251          // cgi triggered manual video recording(Corresponding to ALARM_CGIRECORD)
#define DH_ALARM_BATTERY_TEMPERATURE	    0x3254			// alarm of battery temperature(corresponding to ALARM_BATTERY_TEMPERATURE_INFO)
#define DH_ALARM_TIRE_PRESSURE	            0x3255			// alarm of tire pressure(corresponding to ALARM_TIRE_PRESSURE_INFO )
#define DH_ALARM_VTH_CONFLICT				0x3256			// alarm of VTH Conflict(corresponding to ALARM_VTH_CONFLICT_INFO)
#define DH_ALARM_ACCESS_CTL_BLACKLIST       0x3257          // alarm of access event form blacklist(corresponding to ALARM_ACCESS_CTL_BLACKLIST)
#define DH_ALARM_ROBOT_EMERGENCY_STOP		0x3258			// alarm of robot emergency stop(corresponding to ALARM_ROBOT_EMERFEBCY_STOP)
#define	DH_ALARM_ROBOT_PATH_PLAN_FAILED		0x3259			// alarm of robot path plan failed(corresponding to ALARM_ROBOT_PATH_PLAN_FAILED)
#define DH_ALARM_ROBOT_LOCAL_MAP_UPLOAD		0x325a			// alarm of robot local map upload(corresponding to ALARM_ROBOT_LOCAL_MAP_UPLOAD)
#define	DH_ALARM_ROBOT_SHELF_ERROR	        0x325b			// alarm of robot shelf error(corresponding to ALARM_ROBOT_SHELF_ERROR)
#define	DH_ALARM_ROBOT_SENSOR_ERROR	        0x325c			// alarm of robot sensor error(corresponding to ALARM_ROBOT_SENSOR_ERROR)
#define DH_ALARM_ROBOT_DERAILMENT           0x325d          // alarm of robot derailment(corresponding to ALARM_ROBOT_DERAILMENT)
#define DH_ALARM_ROBOT_MOTOR_UNINIT         0x325e          // alarm of robot motor lock the gate(corresponding to ALARM_ROBOT_MOTOR_UNINIT)
#define DH_ALARM_ROBOT_PREVENT_FALLING      0x325f          // alarm of Robot prevent falling(corresponding to ALARM_ROBOT_PREVENT_FALLING)
#define DH_ALARM_ROBOT_LOCATION_EXCEPTION   0x3260			// alarm of robot location exception(Corresponding to ALARM_ROBOT_LOCATION_EXCEPTION )
#define DH_ALARM_ROBOT_UPGRADER_FAIL        0x3261          // alarm of Robot upgrader fail(corresponding to ALARM_ROBOT_UPGRADER_FAIL)
#define DH_ALARM_ROBOT_CHARGING_ERROR       0x3262          // alarm of robot charging error(Corresponding to ALARM_ROBOT_CHARGING_ERROR)
#define DH_ALARM_ROBOT_STATIONCHARGING_ERROR       0x3263   // alarm of robot station charging error(Corresponding to ALARM_ROBOT_STATIONCHARGING_ERROR)
#define DH_ALARM_ROBOT_CAMERA_ABNORMAL      0x3264          // alarm of robot camera abnormal(Corresponding to ALARM_ROBOT_CAMERA_ABNORMAL)
#define DH_ALARM_ROBOT_ERROR_REPORT         0x3265          // alarm of robot error report(Corresponding to ALARM_ROBOT_ERROR_REPORT)
#define DH_ALARM_ROBOT_DOOR_CONTROL_REQUEST 0x3266			// alarm of robot door control request(Corresponding to ALARM_ROBOT_DOOR_CONTROL_REQUEST_INFO)
#define DH_ALARM_ROBOT_FAILEDTO_CONTROLROOM 0x3267          // alarm of robot failed to open charging room door(Corresponding to ALARM_ROBOT_FAILEDTO_CONTROLROOM)
#define	DH_ALARM_ROBOT_ABNORMAL2DCODE	    0x3268			// alarm of robot abnormal 2Dcode(Corresponding to ALARM_ROBOT_ABNORMAL2DCODE)
#define	DH_ALARM_ROBOT_SECURITYDOGINVALID	0x3269			// alarm of robot security dog invalid(Corresponding to ALARM_ROBOT_SECURITYDOGINVALID)
#define	DH_ALARM_ROBOT_LOCKAREA_BLOCKED  	0x326a			// alarm of robot lock area blocked(Corresponding to ALARM_ROBOT_LOCKAREA_BLOCKED)
#define	DH_ALARM_ROBOT_REQUEST_CANCLE_TASK  0x326b			// alarm of robot cancle the platform task(Corresponding to ALARM_ROBOT_REQUEST_CANCLE_TASK)
#define	DH_ALARM_ROBOT_FORK_BLOCK	        0x326c			// alarm of robot fork block(Corresponding to ALARM_ROBOT_FORK_BLOCK)
#define	DH_ALARM_ROBOT_SHUT_DOWN	        0x326d			// alarm of robot shut down(Corresponding to ALARM_ROBOT_SHUT_DOWN)
#define	DH_ALARM_ROBOT_LASER_HEAD_DIRTY	    0x326e			// alarm of robot laser head dirty(Corresponding to ALARM_ROBOT_LASER_HEAD_DIRTY)
#define	DH_ALARM_ROBOT_UNTRACK	            0x326f			// alarm of robot untrack(Corresponding to ALARM_ROBOT_UNTRACK)
#define	DH_ALARM_ROBOT_IN_ELEVATOR	        0x3270			// alarm of robot in elevator(Corresponding to ALARM_ROBOT_IN_ELEVATOR)
#define	DH_ALARM_ROBOT_CORRECT_LOACATION	0x3271			// alarm of robot correct location(Corresponding to ALARM_ROBOT_CORRECT_LOACATION)


#define DH_ALARM_USERLOCK					0x3300			// alarm of user lock(corresponding to ALARM_USERLOCK_INFO)
#define DH_ALARM_DOWNLOAD_REMOTE_FILE		0x3301			// alarm of download remote file(corresponding to ALARM_DOWNLOAD_REMOTE_FILE_INFO)
#define DH_ALARM_NASFILE_STATUS             0x3302          // alarm of NAS file status (Corresponding to ALARM_NASFILE_STATUS_INFO)
#define DH_ALARM_TALKING_CANCELCALL         0x3303          // alarm of Cancel talking call(Corresponding to ALARM_TALKING_CANCELCALL_INFO)
#define DH_ALARM_ACCESS_CTL_UNAUTHORIZED_MALICIOUSWIP      0x3304 // alarm of unauthorized maliciouswip(Corresponding to ALARM_ACCESS_CTL_UNAUTHORIZED_MALICIOUSWIP) 
#define DH_ALARM_CROWD_DETECTION			0x3305			// alarm of crowd detection(Corresponding to ALARM_CROWD_DETECTION_INFO)
#define DH_ALARM_FACE_FEATURE_ABSTRACT		0x3306			// alarm of face feature abstract(Corresponding to ALARM_FACE_FEATURE_ABSTRACT_INFO)
#define	DH_ALARM_RECORD_SCHEDULE_CHANGE		0x3307			// alarm of record schedule change (Corresponding to ALARM_RECORD_SCHEDULE_CHANGE_INFO)
#define DH_ALARM_NTP_CHANGE					0x3308			// alarm of NTP change (Corresponding to ALARM_NTP_CHANGE_INFO)
#define DH_ALARM_HDD_TEMPERATUREALARM		0x3309			// alarm of HDD Temperature Alarm(Corresponding to ALARM_HDD_TEMPERATUREALARM_INFO)
#define DH_ALARM_HDD_HEALTHALARM			0x330a			// alarm of HDD Health Alarm(Corresponding to ALARM_HDD_HEALTHALARM_INFO)
#define DH_ALARM_HDD_SHAKEALARM     		0x330b			// alarm of HDD Shake Alarm(Corresponding to ALARM_HDD_SHAKEALARM_INFO)
#define DH_ALARM_PATROL_STATUS				0x330c			// alarm of Patrol Status Alarm(Corresponding to ALARM_PATROL_STATUS_INFO) 
#define DH_ALARM_CITIZEN_PICTURE_COMPARE    0x330d          // citizen picture compare(Corresponding to ALARM_CITIZEN_PICTURE_COMPARE_INFO)

/*  start  reserved 58 events*/
#define DH_ALARM_AREAARM_MODECHANGE         0x330e          // alarm of area arm mode change(Corresponding to ALARM_AREAARM_MODECHANGE_INFO)
#define DH_ALARM_ZONEMODULELOST             0x330f          // alarm of zone module lost(Corresponding to ALARM_ZONEMODULE_LOST_INFO)
#define DH_ALARM_AREAALARM                  0x3310          // alarm of area alarm(Corresponding to ALARM_AREAALARM_INFO)
#define DH_ALARM_ZONEOPEN                   0x3311          // alarm of zone open(Corresponding to ALARM_ZONEOPEN_INFO)
#define DH_ALARM_SYSTEMTAMPER               0x3312          // alarm of system tamper(Corresponding to ALARM_SYSTEMTAMPER_INFO)
#define DH_ALARM_ALARMREGION_MAXEVENTID     0x3348          // Maximum of new event, useless
/*  end	   reserved 58 events*/

#define DH_ALARM_LAW_ENFORCEMENT_INFO		0x3349			// alarm of Law EnforcementInfo (corresponding to ALARM_LAW_ENFORCEMENT_INFO)
#define DH_ALARM_CONGESTION_DETECTION		0x334A			// alarm of congestion detection(Corresponding to ALARM_CONGESTION_DETECTION_INFO)
#define DH_ALARM_VEHICLELIMIT_DETECTION		0x334B			// alarm of vehicle limit detection(Corresponding to ALARM_VEHICLELIMIT_DETECTION_INFO)
#define DH_ALARM_TRAFFIC_PARKING_TIMEOUT	0x334C			// alarm of parking timeout(Corresponding to ALARM_TRAFFIC_PARKING_TIMEOUT_INFO)

#define DH_ALARM_DISTANCE_DETECTION			0x334e			// alarm of distance detection(Corresponding to ALARM_DISTANCE_DETECTION_INFO)
#define DH_ALARM_STAY_DETECTION				0x334f			// alarm of stay detection(Corresponding to ALARM_STAY_DETECTION_INFO)
#define DH_ALARM_DEVBOARDHOTPLUG			0x3350			// alarm of board hot plug(Corresponding to ALARM_DEVBOARDHOTPLUG_INFO)
#define DH_ALARM_HOMESCENE_CHANGE			0x3351			// alarm of scene change(Corresponding to ALARM_HOMESCENE_CHANGE_INFO)
#define DH_ALARM_STORAGE_WORKDIRECTORY_SWITCH 0x3352        // alarm of storage work directory switch(Corresponding to ALARM_STORAGE_WORKDIRECTORY_SWITCH_INFO)
#define DH_ALARM_TRAFFIC_LINKAGEALARM		0x3353			// alarm of linkage alarm(Corresponding to ALARM_TRAFFIC_LINKAGEALARM_INFO)
#define DH_ALARM_COAXIAL_ALARM_LOCAL		0x3354			// alarm of coaxial alarm local(Corresponding to ALARM_COAXIAL_ALARM_LOCAL_INFO)
#define DH_ALARM_NAS_FILE_REMOVE_STATUS	    0x3355			// alarm of NAS File Remove Status(Corresponding to ALARM_NAS_FILE_REMOVE_STATUS_INFO)
#define DH_ALARM_NAS_APK_INSTALL_REQUEST    0x3356			// alarm of NAS APK Install Request(Corresponding to ALARM_NAS_APK_INSTALL_REQUEST_INFO)
#define DH_ALARM_NAS_APK_INSTALL_STATUS	    0x3357			// alarm of NAS APK Install Status(Corresponding to ALARM__APK_INSTALL_STATUS_INFO)
#define DH_ALARM_FILE_COMPRESS_STATUS	    0x3358			// alarm of File Compress Status(Corresponding to ALARM_FILE_COMPRESSS_STATUS_INFO)
#define DH_ALARM_STRANGER_ALARM				0x3359			// alarm of stranger alarm(Corresponding to ALARM_STRANGER_ALARM_INFO)
#define DH_ALARM_QR_CODE_CHECK              0x335a          // alarm of QR code check(Corresponding to ALARM_QR_CODE_CHECK_INFO)
#define DH_ALARM_ACCESS_CTL_LOCK_MODE       0x335b          // alarm of door lock mode(Corresponding to ALARM_ACCESS_CTL_LOCK_MODE_INFO)
#define DH_ALARM_LOCK_ROOM_NUM_BIND         0x335c          // alarm of room number binding(Corresponding to ALARM_LOCK_ROOM_NUM_BIND_INFO)
#define DH_ALARM_LEAVE_DETECTION			0x335d		    // alarm of leave detectionCorresponding to ALARM_LEAVE_DETECTION_INFO
#define DH_ALARM_TRAFFICGZJJ_QUEUE_LEN		0x335e		    // alarm of Traffic guangzhoujiaotong queue len(Corresponding to ALARM_TRAFFICGZJJ_QUEUE_LEN_INFO)
#define DH_ALARM_TRAFFIC_XINKONG			0x335f		    // alarm of TrafficXinKongCorresponding to ALARM_TRAFFIC_XINKONG_INFO

/*  start  radar adaptor event,reserved 64 events*/
#define DH_ALARM_RADAR_REGIONDETECTION		0x3370			// alarm of radar region detection(Corresponding to ALARM_RADAR_REGIONDETECTION_INFO)
#define DH_ALARM_RADAR_MAXEVENTID		    0x3433			// Maximum of new event, useless
/*  end  radar adaptor event,reserved 64 events*/

#define DH_ALARM_JABLOTRON_ALARM			0x3434			// alarm of Jablotron alarm(Corresponding to ALARM_JABLOTRONALARM_INFO)
#define DH_ALARM_FACE_RECOGNITION           0x3435          // alarm of face recognition(Corresponding to ALARM_FACE_RECOGNITION_INFO) 
#define DH_ALARM_VEHICLE_OILLEVEL           0x3436          // alarm of vehicle oil level(Corresponding to ALARM_VEHICLE_OILLEVEL_INFO) 
#define DH_ALARM_VEHICLE_LOAD				0x3437          // alarm of vehicle load(Corresponding to ALARM_VEHICLE_LOAD_INFO) 
#define DH_ALARM_VEHICLE_STATE				0x3438          // alarm of vehicle state(Corresponding to ALARM_VEHICLE_STATE_INFO) 
#define DH_ALARM_IMSI_CHECK					0x3439          // alarm of IMSI check(Corresponding to ALARM_IMSI_CHECK_INFO) 
#define DH_ALARM_BLIND_ALARM				0x343A          // alarm of vehicle into blind area(Corresponding to ALARM_BLIND_ALARM_INFO) 
#define DH_ALARM_VEHICLE_MAINTAINCE			0x343B          // alarm of vehicle maintaince(Corresponding to ALARM_VEHICLE_MAINTAINCE_INFO) 
#define DH_ALARM_PARKINGLOCK_STATE			0x343C          // alarm of parkinglock state(Corresponding to ALARM_PARKINGLOCK_STATE_INFO) 
#define DH_ALARM_FIRE_DETECTION				0x343D			// alarm of fire detection Corresponding to ALARM_FIRE_DETECTION_INFO
#define DH_ALARM_NAS_SERVER_STATE			0x343E			// alarm of NAS server state(Corresponding to ALARM_NAS_SERVER_STATE_INFO)
#define DH_ALARM_VOLUME_GROUP_FAULT			0x343F			// alarm of volume group fault(Corresponding to ALARM_VOLUME_GROUP_FAULT_INFO)
#define DH_ALARM_DISK_CHECK					0x3440			// alarm of disk check(Corresponding to ALARM_DISK_CHECK_INFO)
#define DH_ALARM_PHONECALL_DETECT			0x3441			// alarm of phone call detect (Corresponding to ALARM_PHONECALL_DETECT_INFO)
#define DH_ALARM_FLOATINGOBJECT_DETECTION   0x3442			// alarm of flotage detection(Corresponding to ALARM_FLOATINGOBJECT_DETECTION_INFO)
#define DH_ALARM_WATER_LEVEL_DETECTION		0x3443			// alarm of water level detection(Corresponding to ALARM_WATER_LEVEL_DETECTION_INFO)
#define DH_ALARM_LOW_SPEED					0x3444		    // alarm of Low Speed alarm(corresponding to ALARM_LOW_SPEED_INFO)
#define DH_ALARM_TRAFFIC_VEHICLEINOUT		0x3445		    // alarm of vehicle enter or leave lane(corresponding to ALARM_TRAFFIC_VEHICLEINOUT_INFO)
#define DH_ALARM_TRAFFIC_JUNCTION			0x3446			// alarm of traffic junction(corresponding to ALARM_TAFFIC_JUNCTION_INFO)
#define DH_ALARM_DOOR_CONTROL				0x3447			// alarm of door control(corresponding to ALARM_DOOR_CONTROL_INFO)
#define DH_ALARM_ARMSTATE					0x3448			// alarm of arm state (corresponding to ALARM_ARMSTATE_INFO)
#define DH_ALARM_TICKET_INFO_REPORT			0x3449			// alarm of ticket info report(Corresponding to ALARM_TICKET_INFO_REPORT)
#define DH_ALARM_TRAFFIC_LAMP_WORK_STATE    0x344E          // alarm of traffic lamp work state(Corresponding to ALARM_TRAFFIC_LAMP_WORK_STATE_INFO)
#define DH_ALARM_ENGINE_FAILURE_STATUS		0x344F			// alarm of engine failure status(Corresponding to ALARM_ENGINE_FAILURE_STATUS_INFO)
#define DH_ALARM_HIGH_TOSS_DETECT           0x3450          // alarm of high toss detection(Corresponding to ALARM_HIGH_TOSS_DETECT_INFO)

#define DH_CONFIG_RESULT_EVENT_EX            0x3000        // Modify the return code of the setup. Please refer to DEV_SET_RESULT for returned structure.
#define DH_REBOOT_EVENT_EX                   0x3001        // Device reboot event. Current modification becomes valid until sending out the reboot command. 
#define DH_AUTO_TALK_START_EX                0x3002        // Device automatically invites to begin audio talk 
#define DH_AUTO_TALK_STOP_EX                 0x3003        // Device actively stop audio talk 
#define DH_CONFIG_CHANGE_EX                  0x3004        // Device setup changes.
#define DH_IPSEARCH_EVENT_EX                 0x3005        // IP search event, the return value format is:DevName::Manufacturer::MAC::IP::Port::DevType::POEPort::SubMask::GateWay&&DevName::Manufacturer::MAC::IP::Port::DevType::POEPort::SubMask::GateWay &&
#define DH_AUTO_RECONNECT_FAILD              0x3006        // reconnect failed
#define DH_REALPLAY_FAILD_EVENT              0x3007        // real play failed
#define DH_PLAYBACK_FAILD_EVENT              0x3008        // playback failed
#define DH_IVS_TRAFFIC_REALFLOWINFO          0x3009        // traffic real flow info ALARM_IVS_TRAFFIC_REALFLOW_INFO
#define DH_DEVICE_ABORT_EVENT                0x300a        // Client end is out, corresponding to structure  DEV_CLIENT_ABORT_INFO
#define DH_TALK_FAILD_EVENT                  0x300b        // failed to request talk, corresponding to  structure  DEV_TALK_RESULT
#define DH_START_LISTEN_FINISH_EVENT         0x300c        // start listen interface finish asyn notify event, info pointer is NULL
#define DH_YUEQINGLIGHTING_STATE_EVENT       0x300d        // Statistical light switch time, corresponding to DEV_YUEQINGLIGHTING_STATE_INFO
#define DH_ALARM_VIOLATE_NO_FLY_TIME         0x300e        // violate NoFlyTime event, corresponding to ALARM_VIOLATE_NO_FLY_TIME_INFO
#define DH_ALARM_BOX_ALARM			         0x300f		   // alarm box alarm (corresponding to ALARM_BOX_ALARM_INFO )
#define	DH_ALARM_SOSALERT					 0x3010		   // SOS alert(corresponding to ALARM_SOSALERT_INFO)
#define DH_ALARM_GYROABNORMALATTITUDE		 0x3011		   // The Vehicle's emergency braking and carwheel are caused alarm(corresponding to ALARM_GYROABNORMALATTITUDE_INFO)
#define DH_ALARM_ALARMOUTPUT				 0x3012		   // Output channel change(corresponding to ALARM_ALARMOUTPUT_INFO)
#define DH_ALARM_PSTNREPORTFAILURE			 0x3013		   // PSTN report failure(corresponding to ALARM_PSTNREPORTFAILURE_INFO)
#define DH_ALARM_NOGSMFIELD					 0x3014		   // Communicating module offline or no sim card(corresponding to ALARM_NOGSMFIELD_INFO)
#define DH_ALARM_SMARTMOTION_HUMAN 			 0x3015		   // Smart video motion detection(human) (corresponding to ALARM_SMARTMOTION_HUMAN_INFO)
#define DH_ALARM_SMARTMOTION_VEHICLE		 0x3016		   // Smart video motion detection(vehicle) (corresponding to ALARM_SMARTMOTION_VEHICLE_INFO)
#define DH_ALARM_MOTION_RECORD_ALARM         0x3017		   // Video motion record alarm (corresponding to ALARM_MOTION_RECORD_INFO)
#define DH_ALARM_SMARTHOME_GET_AUTHORIZED	 0x3018		   // device notify platform to get authorized QRCode info ( corresponding to DEV_EVENT_SMARTHOME_GET_AUTHORIZED )
#define DH_ALARM_SMARTHOME_UPDATE_SCENE		 0x3019		   // device notify platform to update scene list ( corresponding to ALARM_SMARTHOME_UPDATE_SCENE )
#define DH_ALARM_ASG						 0x3020		   // ASG alarm (corresponding to ALARM_ASG_INFO)		
#define DH_ALARM_ASGSTAY                    0X3021         // ASG stay( corresponding to ALARM_ASGSTAY_INFO )
#define DH_ALARM_ASGFOLLOWING               0X3022         // ASG following( corresponding to ALARM_ASGFOLLOWING_INFO )
#define DH_ALARM_ASGCLIMBOVER               0X3023         // ASG limb over( corresponding to ALARM_ASGCLIMBOVER_INFO )
#define DH_ALARM_ASGBREAKDOWN               0X3024         // ASG break down( corresponding to ALARM_ASGBREAKDOWN_INFO )		

// Alarm type of alarm upload function,corresponding to CLIENT_StartService.NEW_ALARM_UPLOAD structure.
#define DH_UPLOAD_ALARM                      0x4000        // External alarm         
#define DH_UPLOAD_MOTION_ALARM               0x4001        // Motion detection alarm 
#define DH_UPLOAD_VIDEOLOST_ALARM            0x4002        // Video loss alarm 
#define DH_UPLOAD_SHELTER_ALARM              0x4003        // Camera masking alarm 
#define DH_UPLOAD_SOUND_DETECT_ALARM         0x4004        // Audio detection alarm 
#define DH_UPLOAD_DISKFULL_ALARM             0x4005        // HDD full alarm 
#define DH_UPLOAD_DISKERROR_ALARM            0x4006        // HDD malfunction alarm 
#define DH_UPLOAD_ENCODER_ALARM              0x4007        // Encoder alarm 
#define DH_UPLOAD_DECODER_ALARM              0x400B        // Alarm decoder alarm 
#define DH_UPLOAD_EVENT                      0x400C        // Scheduled upload 
#define DH_UPLOAD_IVS                        0x400D        // intelligent alarm,corresponding to ALARM_UPLOAD_IVS_INFO
#define DH_UPLOAD_SMOKESENSOR_ALARM          0x400E        // Smoke alarm, struct ALARM_UPLOAD_SMOKESENSOR_INFO
#define DH_UPLOAD_ALARM_EX                   0x400F        // External alarm extension, corresponding structure  ALARM_UPLOAD_ALARMEX_INFO 
#define DH_UPLOAD_REMOTE_LOGIN_FAILD_ALARM   0x4010        // Remote login failed alarm, corresponding structure ALARM_UPLOAD_LOGIN_FAILED_INFO
#define DH_UPLOAD_CUSTOM                     0x4011        // Extension string is defined by the client.,pParam:extension data pointer,dwParamLen:extension data length
#define DH_UPLOAD_FRONTDISCONNECT_ALARM      0x4012        // front device disconnect alarm, corresponding structure NEW_ALARM_UPLOAD
#define DH_UPLOAD_ALARM_IPC                  0x4013        // IPC External alarm, corresponding structure NEW_ALARM_UPLOAD
#define DH_UPLOAD_NET_ALARM                  0x4014        // Net Alarm input(trigger through network,different from device's local alarm input), corresponding structure NEW_ALARM_UPLOAD
#define DH_UPLOAD_ALARM_RAID                 0x4015        // Raid abnormal event, corresponding structure NEW_ALARM_UPLOAD
#define DH_UPLOAD_SCENE_CHANGE               0x4016        // Scene change event, corresponding structure NEW_ALARM_UPLOAD         
#define DH_UPLOAD_PIRDETECTION				 0x4017		   // pir device detection alarm , corresponding structure ALARM_UPLOAD_PIRDETECTION_INFO
#define DH_UPLOAD_PIRTAMPER					 0x4018		   // pir device prevention and dismantling alarm , corresponding structure ALARM_UPLOAD_PIRTAMPER_INFO
#define DH_UPLOAD_PIRCLOAK					 0x4019		   // pir device light occlusion alarm, corresponding structure ALARM_UPLOAD_PIRCLOAK_INFO
#define DH_UPLOAD_PIRSHOCK					 0x401A		   // pir device shock alarm, corresponding structure ALARM_UPLOAD_PIRSHOCK_INFO
#define DH_UPLOAD_PIRFAILURE				 0x401B		   // pir device sensor failure alarm, corresponding structure ALARM_UPLOAD_PIRFAILURE_INFO
#define DH_UPLOAD_PIRBATTERYLOW				 0x401C		   // pir device low battery power alarm, corresponding structure ALARM_UPLOAD_PIRBATTERYLOW_INFO
#define DH_UPLOAD_PIRMISSINGCALL			 0x401D		   // pir device missing call alarm, corresponding structure ALARM_UPLOAD_PIRMISSINGCALL_INFO
#define DH_UPLOAD_VIDEO_UNFOCUS				 0x401E		   // video unfocus alarm, corresponding structure ALARM_UPLOAD_VIDEO_UNFOCUS_INFO
#define DH_UPLOAD_ALARMPIR					 0x401F			// PIR alarm, corresponding to ALARM_UPLOAD_ALARMPIR_INFO
#define DH_UPLOAD_ALARM_EX2                  0x4020        // local alarm event, corresponding to struct ALARM_ALARM_INFO_EX2, upgrade DH_ALARM_ALARM_EX
#define DH_UPLOAD_BYPASSMODE_CHANGE_EVENT    0x4021        // The bypass state change events, corresponding to struct ALARM_BYPASSMODE_CHANGE_INFO
#define DH_UPLOAD_CHASSISINTRUDED            0x4022        // Chassis intrusion, tamper alarm events, corresponding to struct ALARM_CHASSISINTRUDED_INFO
#define DH_UPLOAD_RCEMERGENCY_CALL           0x4023        // Emergency call alarm event, corresponding to structure ALARM_RCEMERGENCY_CALL_INFO
#define DH_UPLOAD_ARMMODE_CHANGE_EVENT       0x4024        // Cloth removal state change events, corresponding to struct ALARM_ARMMODE_CHANGE_INFO
#define DH_UPLOAD_SUBSYSTEM_ARMMODE_CHANGE   0x4025        // Subsystem arming status change, corresponding to ALARM_SUBSYSTEM_ARMMODECHANGE_INFO
#define DH_UPLOAD_DEFENCE_ARMMODE_CHANGE     0x4026        // Defence arming status change, corresponding to ALARM_DEFENCE_ARMMODECHANGE_INFO
#define DH_UPLOAD_POWERFAULT                 0x4027        // power fault event, corresponding to struct ALARM_POWERFAULT_INFO
#define DH_UPLOAD_HEARTBEAT_ALARM            0x4028        // Heart beat alarm,corresponding to struct ALARM_UPLOAD_HEARTBEAT_INFO
#define DH_UPLOAD_ONLINE_ALARM               0x4029        // Online alarm,corresponding to struct ALARM_UPLOAD_ONLINE_INFO

// order Bus status corresponding to event report(CLIENT_AttachBusState)
#define DH_ALARM_BUS_DRIVER_CHECK           0x0001      // driver sign up event(corresponding to  structure  ALARM_BUS_DRIVER_CHECK_INFO)
#define DH_ALARM_BUS_IMPORT_SITE            0x0002      // in station(corresponding to  structure  ALARM_BUS_IMPORT_SITE_INFO)
#define DH_ALARM_BUS_EXPORT_SITE            0x0003      // out event (corresponding to  structure  ALARM_BUS_EXPORT_SITE_INFO)
#define DH_ALARM_BUS_ABNORMAL               0x0004      // Abnormal vehicle event (corresponding to structure ALARM_BUS_ABNORMAL_INFO)
#define DH_ALARM_BUS_DOOR_OPEN              0x0005      // Unlock car door event (corresponding to structure ALARM_VEHICLE_DOOR_OPEN_INFO)
#define DH_ALARM_BUS_CUR_MILEAGE            0x0006      // Current mileage event(corresponding to structure ALARM_BUS_CUR_MILEAGE_INFO)
#define DH_ALARM_BUS_CUR_OIL                0x0007      // Current oil event(corresponding to structure ALARM_BUS_CUR_OIL_INFO)
#define DH_ALARM_BUS_LOW_OIL                0x0008      // Low oil event(corresponding to structure ALARM_BUS_LOW_OIL_INFO)
#define DH_ALARM_BUS_PASSENGER_CARD_CHECK   0x0009      // Passenger card check event(corresponding to structure ALARM_PASSENGER_CARD_CHECK )
#define DH_ALARM_BUS_VEHICLE_STANDING_OVER_TIME 0x000a  // vehicle standing over time(corresponding to structure ALARM_VEHICLE_STANDING_OVER_TIME_INFO )
#define DH_ALARM_BUS_DRIVE_AFTER_WORK       0x000b      // not work time(corresponding to structure ALARM_DVRIVE_AFTER_WORK )
#define DH_ALARM_BUS_PAD_SHUTDOWN           0x000c      // PAD shutdown event; DVR notify PadShutdown event, PAD will delay shutdown automatically by receiving this event(corresponding to structure ALARM_BUS_PAD_SHUTDOWN_INFO)
#define DH_ALARM_BUS_TIRED_DRIVE_CHECK      0x000d      // tired drive event(corresponding to ALARM_TIRED_DRIVE_CHECK_INFO )
#define DH_ALARM_BUS_STEAL_OIL              0x000e      // steal oil event(corresponding to ALARM_BUS_STEAL_OIL_INFO)
#define DH_ALARM_BUS_CIRCUIT_SHIFT			0x000f		// Circuit shift event(corresponding to ALARM_BUS_CIRCUIT_SHIFT_INFO)
#define DH_ALARM_BUS_ROUTE_OVERTIME			0x0010		// Route overtime event(corresponding to ALARM_BUS_ROUTE_OVERTIME_INFO)
#define DH_ALARM_BUS_VEHICLE_CARRY_ALARM	0x0011		// Vehicle Carry Alarm event(corresponding to ALARM_BUS_VEHICLE_CARRY_ALARM_INFO)
#define DH_ALARM_BUS_VEHICLE_PAULIN_ALARM	0x0012		// Vehicle Paulin Alarm event(corresponding to ALARM_BUS_VEHICLE_PAULIN_ALARM_INFO)
#define DH_ALARM_BUS_VEHICLE_LIFT_ALARM		0x0013		// Vehicle Lift Alarm event(corresponding to ALARM_BUS_VEHICLE_LIFT_ALARM_INFO)

// Asynchronous interface callback type
#define RESPONSE_DECODER_CTRL_TV            0x00000001    // refer to CLIENT_CtrlDecTVScreen interface
#define RESPONSE_DECODER_SWITCH_TV          0x00000002    // refer to CLIENT_SwitchDecTVEncoder interface
#define RESPONSE_DECODER_PLAYBACK           0x00000003    // refer to CLIENT_DecTVPlayback interface
#define RESPONSE_EXCHANGE_DATA              0x00000004    // correspoding CLIENT_ExchangeData interface
#define RESPONSE_ASYN_QUERY_RECORDFILE      0x00000005    // correspoding CLIENT_StartQueryRecordFile interface

// CLIENT_FileTransmit Interface transmission file type
#define DH_DEV_UPGRADEFILETRANS_START       0x0000        // Begin sending update file(Corresponding structure DHDEV_UPGRADE_FILE_INFO)
#define DH_DEV_UPGRADEFILETRANS_SEND        0x0001        // Send update file  
#define DH_DEV_UPGRADEFILETRANS_STOP        0x0002        // Stop sending update file
#define DH_DEV_BLACKWHITETRANS_START        0x0003        // begin to send blackwhite list(Corresponding structure DHDEV_BLACKWHITE_LIST_INFO)
#define DH_DEV_BLACKWHITETRANS_SEND         0x0004        // send blackwhite list
#define DH_DEV_BLACKWHITETRANS_STOP         0x0005        // stop to send blackwhite list
#define DH_DEV_BLACKWHITE_LOAD              0x0006        // blackwhite list load (Corresponding structure DHDEV_LOAD_BLACKWHITE_LIST_INFO)
#define DH_DEV_BLACKWHITE_LOAD_STOP         0x0007        // blackwhite list load stop
#define DH_DEV_FILETRANS_STOP               0x002B        // Stop file upload
#define DH_DEV_FILETRANS_BURN               0x002C        // Burn File Upload

// Resolution list. Use to AND & OR of resolution subnet mask 
#define    DH_CAPTURE_SIZE_D1       0x00000001
#define DH_CAPTURE_SIZE_HD1         0x00000002
#define DH_CAPTURE_SIZE_BCIF        0x00000004
#define DH_CAPTURE_SIZE_CIF         0x00000008
#define DH_CAPTURE_SIZE_QCIF        0x00000010    
#define DH_CAPTURE_SIZE_VGA         0x00000020    
#define DH_CAPTURE_SIZE_QVGA        0x00000040
#define DH_CAPTURE_SIZE_SVCD        0x00000080
#define DH_CAPTURE_SIZE_QQVGA       0x00000100
#define DH_CAPTURE_SIZE_SVGA        0x00000200
#define DH_CAPTURE_SIZE_XVGA        0x00000400
#define DH_CAPTURE_SIZE_WXGA        0x00000800
#define DH_CAPTURE_SIZE_SXGA        0x00001000
#define DH_CAPTURE_SIZE_WSXGA       0x00002000   
#define DH_CAPTURE_SIZE_UXGA        0x00004000
#define DH_CAPTURE_SIZE_WUXGA       0x00008000
#define DH_CAPTURE_SIZE_LFT         0x00010000
#define DH_CAPTURE_SIZE_720         0x00020000
#define DH_CAPTURE_SIZE_1080        0x00040000
#define DH_CAPTURE_SIZE_1_3M        0x00080000
#define DH_CAPTURE_SIZE_2M          0x00100000
#define DH_CAPTURE_SIZE_5M          0x00200000
#define DH_CAPTURE_SIZE_3M          0x00400000    
#define DH_CAPTURE_SIZE_5_0M        0x00800000
#define DH_CPTRUTE_SIZE_1_2M        0x01000000
#define DH_CPTRUTE_SIZE_1408_1024   0x02000000
#define DH_CPTRUTE_SIZE_8M          0x04000000    
#define DH_CPTRUTE_SIZE_2560_1920   0x08000000
#define DH_CAPTURE_SIZE_960H        0x10000000    
#define DH_CAPTURE_SIZE_960_720     0x20000000                

// Encode mode list. Use to work AND & OR operation of encode mode mask.
#define DH_CAPTURE_COMP_DIVX_MPEG4    0x00000001
#define DH_CAPTURE_COMP_MS_MPEG4      0x00000002
#define DH_CAPTURE_COMP_MPEG2         0x00000004
#define DH_CAPTURE_COMP_MPEG1         0x00000008
#define DH_CAPTURE_COMP_H263          0x00000010
#define DH_CAPTURE_COMP_MJPG          0x00000020
#define DH_CAPTURE_COMP_FCC_MPEG4     0x00000040
#define DH_CAPTURE_COMP_H264          0x00000080
#define DH_CAPTURE_COMP_H265          0x00000100
#define DH_CAPTURE_COMP_SVAC          0x00000200

// Alarm activation operation. Use to work AND & OR operation of alarm activation operation.
#define DH_ALARM_UPLOAD                0x00000001
#define DH_ALARM_RECORD                0x00000002
#define DH_ALARM_PTZ                   0x00000004
#define DH_ALARM_MAIL                  0x00000008
#define DH_ALARM_TOUR                  0x00000010
#define DH_ALARM_TIP                   0x00000020
#define DH_ALARM_OUT                   0x00000040
#define DH_ALARM_FTP_UL                0x00000080
#define DH_ALARM_BEEP                  0x00000100
#define DH_ALARM_VOICE                 0x00000200
#define DH_ALARM_SNAP                  0x00000400

// Restore default setup mask. Can use to AND & OR operation, interface CLIENT_ControlDevice enum type DH_CTRL_RESTOREDEFAULT
#define DH_RESTORE_COMMON              0x00000001    // General setup
#define DH_RESTORE_CODING              0x00000002    // Encode setup
#define DH_RESTORE_VIDEO               0x00000004    // Record setup
#define DH_RESTORE_COMM                0x00000008    // COM setup
#define DH_RESTORE_NETWORK             0x00000010    // network setup
#define DH_RESTORE_ALARM               0x00000020    // Alarm setup
#define DH_RESTORE_VIDEODETECT         0x00000040    // Video detection
#define DH_RESTORE_PTZ                 0x00000080    // PTZ control 
#define DH_RESTORE_OUTPUTMODE          0x00000100    // Output mode
#define DH_RESTORE_CHANNELNAME         0x00000200    // Channel name
#define DH_RESTORE_VIDEOINOPTIONS      0x00000400    // Camera attribute
#define DH_RESTORE_CPS                 0x00000800    // TrafficSnapshot
#define DH_RESTORE_INTELLIGENT         0x00001000    // Intelligent Component
#define DH_RESTORE_REMOTEDEVICE        0x00002000    // Remote device configuration
#define DH_RESTORE_DECODERVIDEOOUT     0x00004000    // decode video out
#define DH_RESTORE_LINKMODE            0x00008000    // link mode
#define DH_RESTORE_COMPOSITE           0x00010000    // split screen   
#define DH_RESTORE_ALL                 0x80000000    // Reset all

// PTZ property list. Lower four bytes subnet mask 
#define PTZ_DIRECTION                  0x00000001    // Direction
#define PTZ_ZOOM                       0x00000002    // Zoom
#define PTZ_FOCUS                      0x00000004    // Focus
#define PTZ_IRIS                       0x00000008    // Aperture
#define PTZ_ALARM                      0x00000010    // Alarm function 
#define PTZ_LIGHT                      0x00000020    // Light 
#define PTZ_SETPRESET                  0x00000040    // Set preset 
#define PTZ_CLEARPRESET                0x00000080    // Delete preset
#define PTZ_GOTOPRESET                 0x00000100    // Go to a preset
#define PTZ_AUTOPANON                  0x00000200    // Enable pan
#define PTZ_AUTOPANOFF                 0x00000400    // isable pan
#define PTZ_SETLIMIT                   0x00000800    // Set limit
#define PTZ_AUTOSCANON                 0x00001000    // Enable auto scan
#define PTZ_AUTOSCANOFF                0x00002000    // Disable auto scan 
#define PTZ_ADDTOUR                    0x00004000    // Add tour point
#define PTZ_DELETETOUR                 0x00008000    // Delete tour point
#define PTZ_STARTTOUR                  0x00010000    // Begin tour
#define PTZ_STOPTOUR                   0x00020000    // Stop tour
#define PTZ_CLEARTOUR                  0x00040000    // Delete tour
#define PTZ_SETPATTERN                 0x00080000    // Set pattern
#define PTZ_STARTPATTERN               0x00100000    // Enbale pattern
#define PTZ_STOPPATTERN                0x00200000    // Disable pattern
#define PTZ_CLEARPATTERN               0x00400000    // Delete pattern
#define PTZ_POSITION                   0x00800000    // Position 
#define PTZ_AUX                        0x01000000    // auxiliary button 
#define PTZ_MENU                       0x02000000    // Speed dome menu 
#define PTZ_EXIT                       0x04000000    // Exit speed dome menu 
#define PTZ_ENTER                      0x08000000    // Confirm
#define PTZ_ESC                        0x10000000    // Cancel 
#define PTZ_MENUUPDOWN                 0x20000000    // Menu up/down
#define PTZ_MENULEFTRIGHT              0x40000000    // Menu left/right 
#define PTZ_OPT_NUM                    0x80000000    // Operation amount

// Higher four bytes subnet mask
#define PTZ_DEV                        0x00000001    // PTZ control 
#define PTZ_MATRIX                     0x00000002    // Matrix control 

// Snapshot video encode type
#define CODETYPE_MPEG4                    0
#define CODETYPE_H264                     1
#define CODETYPE_JPG                      2

// Bit stream control control list
#define DH_CAPTURE_BRC_CBR                0
#define DH_CAPTURE_BRC_VBR                1
//#define DH_CAPTURE_BRC_MBR              2

//The frame type mask definition
#define FRAME_TYPE_MOTION                       0x00000001      // MD frame
#define FRAME_TYPE_HUMAN						0x00000002	  // MD frame(human)
#define FRAME_TYPE_VEHICLE						0x00000004	  // MD frame(vehicle)

// the type of intelligent analysis event 
#define EVENT_IVS_ALL                           0x00000001      // subscription all event
#define EVENT_IVS_CROSSLINEDETECTION            0x00000002      // cross line event(Corresponding to DEV_EVENT_CROSSLINE_INFO)
#define EVENT_IVS_CROSSREGIONDETECTION          0x00000003      // cross region event(Corresponding to DEV_EVENT_CROSSREGION_INFO)
#define EVENT_IVS_PASTEDETECTION                0x00000004      // past event(Corresponding to DEV_EVENT_PASTE_INFO)
#define EVENT_IVS_LEFTDETECTION                 0x00000005      // left event(Corresponding to DEV_EVENT_LEFT_INFO)
#define EVENT_IVS_STAYDETECTION                 0x00000006      // stay event(Corresponding to DEV_EVENT_STAY_INFO)
#define EVENT_IVS_WANDERDETECTION               0x00000007      // wander event(Corresponding to DEV_EVENT_WANDER_INFO)
#define EVENT_IVS_PRESERVATION                  0x00000008      // reservation event(Corresponding to DEV_EVENT_PRESERVATION_INFO) 
#define EVENT_IVS_MOVEDETECTION                 0x00000009      // move event(Corresponding to DEV_EVENT_MOVE_INFO)
#define EVENT_IVS_TAILDETECTION                 0x0000000A      // tail event(Corresponding to DEV_EVENT_TAIL_INFO)
#define EVENT_IVS_RIOTERDETECTION               0x0000000B      // rioter event(Corresponding to DEV_EVENT_RIOTERL_INFO)
#define EVENT_IVS_FIREDETECTION                 0x0000000C      // fire event(Corresponding to DEV_EVENT_FIRE_INFO)
#define EVENT_IVS_SMOKEDETECTION                0x0000000D      // smoke event(Corresponding to DEV_EVENT_SMOKE_INFO)
#define EVENT_IVS_FIGHTDETECTION                0x0000000E      // fight event(Corresponding to DEV_EVENT_FIGHT_INFO)
#define EVENT_IVS_FLOWSTAT                      0x0000000F      // flow stat event(Corresponding to DEV_EVENT_FLOWSTAT_INFO)
#define EVENT_IVS_NUMBERSTAT                    0x00000010      // number stat event(Corresponding to DEV_EVENT_NUMBERSTAT_INFO)
#define EVENT_IVS_CAMERACOVERDDETECTION         0x00000011      // camera cover event
#define EVENT_IVS_CAMERAMOVEDDETECTION          0x00000012      // camera move event
#define EVENT_IVS_VIDEOABNORMALDETECTION        0x00000013      // video abnormal event(Corresponding to DEV_EVENT_VIDEOABNORMALDETECTION_INFO)
#define EVENT_IVS_VIDEOBADDETECTION             0x00000014      // video bad event
#define EVENT_IVS_TRAFFICCONTROL                0x00000015      // traffic control event(Corresponding to DEV_EVENT_TRAFFICCONTROL_INFO)
#define EVENT_IVS_TRAFFICACCIDENT               0x00000016      // traffic accident event(Corresponding to DEV_EVENT_TRAFFICACCIDENT_INFO)
#define EVENT_IVS_TRAFFICJUNCTION               0x00000017      // traffic junction event(Corresponding to DEV_EVENT_TRAFFICJUNCTION_INFO)
#define EVENT_IVS_TRAFFICGATE                   0x00000018      // traffic gate event(Corresponding to DEV_EVENT_TRAFFICGATE_INFO)
#define EVENT_TRAFFICSNAPSHOT                   0x00000019      // traffic snapshot(Corresponding to DEV_EVENT_TRAFFICSNAPSHOT_INFO)
#define EVENT_IVS_FACEDETECT                    0x0000001A      // face detection(Corresponding to DEV_EVENT_FACEDETECT_INFO)
#define EVENT_IVS_TRAFFICJAM                    0x0000001B      // traffic-Jam(Corresponding to DEV_EVENT_TRAFFICJAM_INFO)
#define EVENT_IVS_TRAFFIC_NONMOTORINMOTORROUTE  0x0000001C      // Non-motor vehicles occupy the lanes(Corresponding to DEV_EVENT_TRAFFIC_NONMOTORINMOTORROUTE_INFO)
#define EVENT_IVS_TRAFFIC_RUNREDLIGHT           0x00000100      // traffic-RunRedLight(Corresponding to DEV_EVENT_TRAFFIC_RUNREDLIGHT_INFO)
#define EVENT_IVS_TRAFFIC_OVERLINE              0x00000101      // traffic-Overline(Corresponding to DEV_EVENT_TRAFFIC_OVERLINE_INFO)
#define EVENT_IVS_TRAFFIC_RETROGRADE            0x00000102      // traffic-Retrograde(Corresponding to DEV_EVENT_TRAFFIC_RETROGRADE_INFO)
#define EVENT_IVS_TRAFFIC_TURNLEFT              0x00000103      // traffic-TurnLeft(Corresponding to DEV_EVENT_TRAFFIC_TURNLEFT_INFO)
#define EVENT_IVS_TRAFFIC_TURNRIGHT             0x00000104      // traffic-TurnRight(Corresponding to DEV_EVENT_TRAFFIC_TURNRIGHT_INFO)    
#define EVENT_IVS_TRAFFIC_UTURN                 0x00000105      // traffic-Uturn(Corresponding to DEV_EVENT_TRAFFIC_UTURN_INFO)
#define EVENT_IVS_TRAFFIC_OVERSPEED             0x00000106      // traffic-Overspeed(Corresponding to DEV_EVENT_TRAFFIC_OVERSPEED_INFO)
#define EVENT_IVS_TRAFFIC_UNDERSPEED            0x00000107      // traffic-Underspeed(Corresponding to DEV_EVENT_TRAFFIC_UNDERSPEED_INFO)
#define EVENT_IVS_TRAFFIC_PARKING               0x00000108      // traffic-Parking(Corresponding to DEV_EVENT_TRAFFIC_PARKING_INFO)
#define EVENT_IVS_TRAFFIC_WRONGROUTE            0x00000109      // traffic-WrongRoute(Corresponding to DEV_EVENT_TRAFFIC_WRONGROUTE_INFO)
#define EVENT_IVS_TRAFFIC_CROSSLANE             0x0000010A      // traffic-CrossLane(Corresponding to DEV_EVENT_TRAFFIC_CROSSLANE_INFO)
#define EVENT_IVS_TRAFFIC_OVERYELLOWLINE        0x0000010B      // traffic-OverYellowLine(Corresponding to DEV_EVENT_TRAFFIC_OVERYELLOWLINE_INFO)
#define EVENT_IVS_TRAFFIC_DRIVINGONSHOULDER     0x0000010C      // traffic-DrivingOnShoulder(Corresponding to DEV_EVENT_TRAFFIC_DRIVINGONSHOULDER_INFO)   
#define EVENT_IVS_TRAFFIC_YELLOWPLATEINLANE     0x0000010E      // traffic-YellowPlateInLane(Corresponding to DEV_EVENT_TRAFFIC_YELLOWPLATEINLANE_INFO)
#define EVENT_IVS_TRAFFIC_PEDESTRAINPRIORITY    0x0000010F      // Traffic offense-Pedestral has higher priority at the  crosswalk(Corresponding to DEV_EVENT_TRAFFIC_PEDESTRAINPRIORITY_INFO)
#define EVENT_IVS_CROSSFENCEDETECTION           0x0000011F      // cross fence(Corresponding to DEV_EVENT_CROSSFENCEDETECTION_INFO) 
#define EVENT_IVS_ELECTROSPARKDETECTION         0x00000110      // ElectroSpark event(Corresponding to DEV_EVENT_ELECTROSPARK_INFO) 
#define EVENT_IVS_TRAFFIC_NOPASSING             0x00000111      // no passing(Corresponding to DEV_EVENT_TRAFFIC_NOPASSING_INFO)
#define EVENT_IVS_ABNORMALRUNDETECTION          0x00000112      // abnormal run(Corresponding to DEV_EVENT_ABNORMALRUNDETECTION_INFO)
#define EVENT_IVS_RETROGRADEDETECTION           0x00000113      // retrograde(Corresponding to DEV_EVENT_RETROGRADEDETECTION_INFO)
#define EVENT_IVS_INREGIONDETECTION             0x00000114      // in region detection(Corresponding to DEV_EVENT_INREGIONDETECTION_INFO)
#define EVENT_IVS_TAKENAWAYDETECTION            0x00000115      // taking away things(Corresponding to DEV_EVENT_TAKENAWAYDETECTION_INFO)
#define EVENT_IVS_PARKINGDETECTION              0x00000116      // parking(Corresponding to DEV_EVENT_PARKINGDETECTION_INFO)
#define EVENT_IVS_FACERECOGNITION               0x00000117      // face recognition(Corresponding to DEV_EVENT_FACERECOGNITION_INFO)
#define EVENT_IVS_TRAFFIC_MANUALSNAP            0x00000118      // manual snap(Corresponding to DEV_EVENT_TRAFFIC_MANUALSNAP_INFO)
#define EVENT_IVS_TRAFFIC_FLOWSTATE             0x00000119      // traffic flow state(Corresponding to DEV_EVENT_TRAFFIC_FLOW_STATE)
#define EVENT_IVS_TRAFFIC_STAY                  0x0000011A      // traffic stay(Corresponding to DEV_EVENT_TRAFFIC_STAY_INFO)
#define EVENT_IVS_TRAFFIC_VEHICLEINROUTE        0x0000011B      // traffic vehicle route(Corresponding to DEV_EVENT_TRAFFIC_VEHICLEINROUTE_INFO)
#define EVENT_ALARM_MOTIONDETECT                0x0000011C      // motion detect(Corresponding to DEV_EVENT_ALARM_INFO)
#define EVENT_ALARM_LOCALALARM                  0x0000011D      // local alarm(Corresponding to DEV_EVENT_ALARM_INFO)
#define EVENT_IVS_PRISONERRISEDETECTION         0x0000011E      // prisoner rise detect(Corresponding to DEV_EVENT_PRISONERRISEDETECTION_INFO)
#define EVENT_IVS_TRAFFIC_TOLLGATE              0x00000120      // traffic tollgate(Corresponding to DEV_EVENT_TRAFFICJUNCTION_INFO)
#define EVENT_IVS_DENSITYDETECTION              0x00000121      // density detection of persons(Corresponding to DEV_EVENT_DENSITYDETECTION_INFO)
#define EVENT_IVS_VIDEODIAGNOSIS                0x00000122      // video diagnosis result(Corresponding to NET_VIDEODIAGNOSIS_COMMON_INFO and NET_REAL_DIAGNOSIS_RESULT)
#define EVENT_IVS_QUEUEDETECTION                0x00000123      // queue detection(Corresponding to DEV_EVENT_QUEUEDETECTION_INFO)
#define EVENT_IVS_TRAFFIC_VEHICLEINBUSROUTE     0x00000124      // take up in bus route(Corresponding to DEV_EVENT_TRAFFIC_VEHICLEINBUSROUTE_INFO)
#define EVENT_IVS_TRAFFIC_BACKING               0x00000125      // illegal astern(Corresponding to DEV_EVENT_IVS_TRAFFIC_BACKING_INFO) 
#define EVENT_IVS_AUDIO_ABNORMALDETECTION       0x00000126      // audio abnormity(Corresponding to DEV_EVENT_IVS_AUDIO_ABNORMALDETECTION_INFO)
#define EVENT_IVS_TRAFFIC_RUNYELLOWLIGHT        0x00000127      // run yellow light(Corresponding to DEV_EVENT_TRAFFIC_RUNYELLOWLIGHT_INFO)
#define EVENT_IVS_CLIMBDETECTION                0x00000128      // climb detection(Corresponding to DEV_EVENT_IVS_CLIMB_INFO) 
#define EVENT_IVS_LEAVEDETECTION                0x00000129      // leave detection(Corresponding to DEV_EVENT_IVS_LEAVE_INFO)
#define EVENT_IVS_TRAFFIC_PARKINGONYELLOWBOX    0x0000012A      // parking on yellow box(Corresponding to DEV_EVENT_TRAFFIC_PARKINGONYELLOWBOX_INFO)
#define EVENT_IVS_TRAFFIC_PARKINGSPACEPARKING   0x0000012B      // parking space parking(Corresponding to DEV_EVENT_TRAFFIC_PARKINGSPACEPARKING_INFO)
#define EVENT_IVS_TRAFFIC_PARKINGSPACENOPARKING 0x0000012C      // parking space no parking(Corresponding to DEV_EVENT_TRAFFIC_PARKINGSPACENOPARKING_INFO)
#define EVENT_IVS_TRAFFIC_PEDESTRAIN            0x0000012D      // passerby(Corresponding to DEV_EVENT_TRAFFIC_PEDESTRAIN_INFO)
#define EVENT_IVS_TRAFFIC_THROW                 0x0000012E      // throw(Corresponding to DEV_EVENT_TRAFFIC_THROW_INFO)
#define EVENT_IVS_TRAFFIC_IDLE                  0x0000012F      // idle(Corresponding to DEV_EVENT_TRAFFIC_IDLE_INFO)
#define EVENT_ALARM_VEHICLEACC                  0x00000130      // Vehicle ACC power outage alarm events(Corresponding to DEV_EVENT_ALARM_VEHICLEACC_INFO)
#define EVENT_ALARM_VEHICLE_TURNOVER            0x00000131      // Vehicle rollover alarm events(Corresponding to DEV_EVENT_VEHICEL_ALARM_INFO)
#define EVENT_ALARM_VEHICLE_COLLISION           0x00000132      // Vehicle crash alarm events(Corresponding to DEV_EVENT_VEHICEL_ALARM_INFO)
#define EVENT_ALARM_VEHICLE_LARGE_ANGLE         0x00000133      // On-board camera large Angle turn events
#define EVENT_IVS_TRAFFIC_PARKINGSPACEOVERLINE  0x00000134      // Parking line pressing events(Corresponding to DEV_EVENT_TRAFFIC_PARKINGSPACEOVERLINE_INFO)
#define EVENT_IVS_MULTISCENESWITCH              0x00000135      // Many scenes switching events(Corresponding to DEV_EVENT_IVS_MULTI_SCENE_SWICH_INFO)
#define EVENT_IVS_TRAFFIC_RESTRICTED_PLATE      0x00000136      // Limited license plate event(Corresponding to DEV_EVENT_TRAFFIC_RESTRICTED_PLATE)
#define EVENT_IVS_TRAFFIC_OVERSTOPLINE          0x00000137      // Cross stop line event(Corresponding to DEV_EVENT_TRAFFIC_OVERSTOPLINE)
#define EVENT_IVS_TRAFFIC_WITHOUT_SAFEBELT      0x00000138      // Traffic unfasten seat belt event(Corresponding to DEV_EVENT_TRAFFIC_WITHOUT_SAFEBELT) 
#define EVENT_IVS_TRAFFIC_DRIVER_SMOKING        0x00000139      // Driver smoking event(Corresponding to DEV_EVENT_TRAFFIC_DRIVER_SMOKING) 
#define EVENT_IVS_TRAFFIC_DRIVER_CALLING        0x0000013A      // Driver call event(Corresponding to DEV_EVENT_TRAFFIC_DRIVER_CALLING) 
#define EVENT_IVS_TRAFFIC_PEDESTRAINRUNREDLIGHT 0x0000013B      // Pedestrain red light(Corresponding to DEV_EVENT_TRAFFIC_PEDESTRAINRUNREDLIGHT_INFO)
#define EVENT_IVS_TRAFFIC_PASSNOTINORDER        0x0000013C      // Pass not in order(corresponding DEV_EVENT_TRAFFIC_PASSNOTINORDER_INFO)
#define EVENT_IVS_OBJECT_DETECTION              0x00000141      // Object feature detection event(Corresponding to DEV_EVENT_TRAFFIC_OBJECT_DETECTION) 
#define EVENT_ALARM_ANALOGALARM                 0x00000150      // Analog alarm channel alarm event(correspondingDEV_EVENT_ALARM_ANALOGALRM_INFO)
#define EVENT_IVS_CROSSLINEDETECTION_EX          0x00000151     // Warning lineexpansion event(Corresponding to DEV_EVENT_CROSSLINE_INFO_EX) 
#define EVENT_ALARM_COMMON                      0x00000152      // Normal Record
#define EVENT_ALARM_VIDEOBLIND                  0x00000153      // Video tampering event(Corresponding to DEV_EVENT_ALARM_VIDEOBLIND)
#define EVENT_ALARM_VIDEOLOSS                   0x00000154      // Video loss event
#define EVENT_IVS_GETOUTBEDDETECTION            0x00000155      // Event of getting out bed detection(Corresponding to DEV_EVENT_GETOUTBED_INFO)
#define EVENT_IVS_PATROLDETECTION               0x00000156      // Event of patrol detection(Corresponding to DEV_EVENT_PATROL_INFO)
#define EVENT_IVS_ONDUTYDETECTION               0x00000157      // Event of on duty detection(Corresponding to DEV_EVENT_ONDUTY_INFO)
#define EVENT_IVS_NOANSWERCALL                  0x00000158      // Event of VTO do not answer calling request
#define EVENT_IVS_STORAGENOTEXIST               0x00000159      // Event of storage do not exist
#define EVENT_IVS_STORAGELOWSPACE               0x0000015A      // Event of storage space low
#define EVENT_IVS_STORAGEFAILURE                0x0000015B      // Event of storage failure
#define EVENT_IVS_PROFILEALARMTRANSMIT          0x0000015C      // Event of profile alarm transmit(corresponding to DEV_EVENT_PROFILE_ALARM_TRANSMIT_INFO)
#define EVENT_IVS_VIDEOSTATIC                   0x0000015D      // Event of static video detect(corresponding DEV_EVENT_ALARM_VIDEOSTATIC_INFO)
#define EVENT_IVS_VIDEOTIMING                   0x0000015E      // Event of video timing detect(corresponding DEV_EVENT_ALARM_VIDEOTIMING_INFO)
#define EVENT_IVS_HEATMAP                       0x0000015F      // Heat map (Corresponding to )
#define EVENT_IVS_CITIZENIDCARD                 0x00000160      // ID info reading event (Corresponding to  DEV_EVENT_ALARM_CITIZENIDCARD_INFO)
#define EVENT_IVS_PICINFO                       0x00000161      // Image info event(Corresponding to DEV_EVENT_ALARM_PIC_INFO)
#define EVENT_IVS_NETPLAYCHECK                  0x00000162      // NetPlayCheck event(corresponding DEV_EVENT_ALARM_NETPLAYCHECK_INFO)
#define EVENT_IVS_TRAFFIC_JAM_FORBID_INTO       0x00000163      // Jam Forbid into  event(corresponding DEV_EVENT_ALARM_JAMFORBIDINTO_INFO)
#define EVENT_IVS_SNAPBYTIME                    0x00000164      // Snap by time event(corresponding DEV_EVENT_SNAPBYTIME)
#define EVENT_IVS_PTZ_PRESET                    0x00000165      // PTZ turn to preset event(corresponding to DEV_EVENT_ALARM_PTZ_PRESET_INFO)
#define EVENT_IVS_RFID_INFO                     0x00000166      // Event of infrared detect info(corresponding to DEV_EVENT_ALARM_RFID_INFO)
#define EVENT_IVS_STANDUPDETECTION              0x00000167      // Event of standing up detection
#define EVENT_IVS_QSYTRAFFICCARWEIGHT           0x00000168      // Event of QSYTrafficCarWeight (corresponding to DEV_EVENT_QSYTRAFFICCARWEIGHT_INFO)
#define EVENT_IVS_TRAFFIC_COMPAREPLATE          0x00000169      // Event of compare plate(corresponding to DEV_EVENT_TRAFFIC_COMPAREPLATE_INFO)
#define EVENT_IVS_SHOOTINGSCORERECOGNITION      0x0000016A      // Event of shooting score recognition(corresponding to CFG_IVS_SHOOTINGSCORERECOGNITION_INFO)
#define EVENT_IVS_TRAFFIC_FCC                   0x0000016B      // Event of refuel gas (corresponding to DEV_EVENT_TRAFFIC_FCC_INFO)
#define EVENT_IVS_TRAFFIC_TRANSFINITE           0x0000016C      // Event of traffic transfinite (corresponding to DEV_EVENT_TRAFFIC_TRANSFINITE_INFO)
#define EVENT_IVS_SCENE_CHANGE                  0x0000016D      // Event of scene change (corresponding to DEV_ALRAM_SCENECHANGE_INFO,CFG_VIDEOABNORMALDETECTION_INFO)
#define EVENT_IVS_LETRACK                       0x0000016E      // Event of simple track(no event data)
#define EVENT_IVS_OBJECT_ACTION                 0x0000016F      // Event of object action detection(no event data)
#define EVENT_IVS_TRAFFIC_ANALYSE_PRESNAP       0x00000170      // Event of presnap analyse(corresponding to DEV_EVENT_TRAFFIC_ANALYSE_PRESNAP_INFO)
#define EVENT_ALARM_EQSTATE                     0x00000171      // Event of electrical power quality state of smart switch (no event data)
#define EVENT_IVS_ALARM_IPC                     0x00000172      // Event of IPC used by DVR/NVR(corresponding to DEV_EVENT_ALARM_IPC_INFO)
#define EVENT_IVS_POS_RECORD                    0x00000173      // Event of POS record
#define EVENT_IVS_NEAR_DISTANCE_DETECTION       0x00000174      // Event of near distance detection(corresponding to DEV_EVENT_NEAR_DISTANCE_DETECTION_INFO)
#define EVENT_IVS_OBJECTSTRUCTLIZE_PERSON       0x00000175      // Event of person feature detect(corresponding to DEV_EVENT_OBJECTSTRUCTLIZE_PERSON_INFO)
#define EVENT_IVS_OBJECTSTRUCTLIZE_NONMOTOR     0x00000176      // Event of nonmotor feature detect(corresponding to DEV_EVENT_OBJECTSTRUCTLIZE_NONMOTOR_INFO)
#define EVENT_IVS_TUMBLE_DETECTION              0x00000177      // Event of tumble detection(corresponding to DEV_EVENT_TUMBLE_DETECTION_INFO)
#define EVENT_IVS_TRAFFIC_ALL                   0x000001FF      // All event start with [TRAFFIC]
                                                                // EVENT_IVS_TRAFFICCONTROL -> EVENT_TRAFFICSNAPSHOT
                                                                // EVENT_IVS_TRAFFIC_RUNREDLIGHT -> EVENT_IVS_TRAFFIC_UNDERSPEED
#define EVENT_IVS_VIDEOANALYSE                  0x00000200      // All IVS events (Corresponding to )
#define EVENT_IVS_LINKSD                        0x00000201      // LinkSD events(Corresponding to )
#define EVENT_IVS_VEHICLEANALYSE                0x00000202      // Vehicle Analyse (Corresponding to DEV_EVENT_VEHICLEANALYSE)
#define EVENT_IVS_FLOWRATE                      0x00000203      // Flow rate events(Corresponding to DEV_EVENT_FLOWRATE_INFO)
#define EVENT_IVS_ACCESS_CTL                    0x00000204      // Acccess control events (Corresponding to DEV_EVENT_ACCESS_CTL_INFO)
#define EVENT_IVS_SNAPMANUAL                    0x00000205      // SnapManual events(Corresponding to DEV_EVENT_SNAPMANUAL)
#define EVENT_IVS_TRAFFIC_ELETAGINFO            0x00000206      // RFID electronic tag  events(Corresponding to DEV_EVENT_TRAFFIC_ELETAGINFO_INFO)
#define EVENT_IVS_TRAFFIC_TIREDPHYSIOLOGICAL    0x00000207      // physiological fatigue driving events(Corresponding to DEV_EVENT_TIREDPHYSIOLOGICAL_INFO)
#define EVENT_IVS_TRAFFIC_BUSSHARPTURN          0x00000208      // bus sharp trun events(Corresponding to DEV_EVENT_BUSSHARPTURN_INFO)
#define EVENT_IVS_CITIZEN_PICTURE_COMPARE       0x00000209      // Event of comparison with ID and citizen picture(corresponding to DEV_EVENT_CITIZEN_PICTURE_COMPARE_INFO)
#define EVENT_IVS_TRAFFIC_TIREDLOWERHEAD        0x0000020A      // Event of driver lower head(Corresponding to DEV_EVENT_TIREDLOWERHEAD_INFO)
#define EVENT_IVS_TRAFFIC_DRIVERLOOKAROUND      0x0000020B      // Event of driver look around(Corresponding to DEV_EVENT_DRIVERLOOKAROUND_INFO)
#define EVENT_IVS_TRAFFIC_DRIVERLEAVEPOST       0x0000020C      // Event of driver leave post(Corresponding to DEV_EVENT_DRIVERLEAVEPOST_INFO)
#define EVENT_IVS_MAN_STAND_DETECTION           0x0000020D      // stereo standing event(Corresponding to DEV_EVENT_MANSTAND_DETECTION_INFO)
#define EVENT_IVS_MAN_NUM_DETECTION             0x0000020E      // Event of regional population statistics (Corresponding to DEV_EVENT_MANNUM_DETECTION_INFO)
#define EVENT_IVS_STEREO_NUMBERSTAT             0x0000020F      // Event of passenger flow statistics(no event data)
#define EVENT_IVS_TRAFFIC_DRIVERYAWN            0x00000210      // Event of  driver yawn(Corresponding to DEV_EVENT_DRIVERYAWN_INFO)
#define EVENT_IVS_NUMBERSTAT_PLAN               0x00000211      // Passenger flow statistics plan(no event data,Speed Dome use,Corresponding to rule config CFG_NUMBERSTAT_INFO)
#define EVENT_IVS_HEATMAP_PLAN                  0x00000212      // Heat map plan(no event data,Speed Dome use,Corresponding to rule config CFG_IVS_HEATMAP_INFO)
#define EVENT_IVS_CALLNOANSWERED                0x00000213      // Event of call no answered
#define EVENT_IVS_IGNOREINVITE                  0x00000214      // Event of ignore invite
#define EVENT_IVS_HUMANTRAIT                    0x00000215      // Event of human trait(Corresponding to DEV_EVENT_HUMANTRAIT_INFO)
#define EVENT_ALARM_LE_HEADDETECTION            0x00000216      // alarm of Head detection
#define EVENT_IVS_FACEANALYSIS                  0x00000217      // Event of face analysis(no event data)
#define EVENT_IVS_TRAFFIC_TURNLEFTAFTERSTRAIGHT 0x00000218      // Event of turn left not give precedence to straight(Corresponding to DEV_EVENT_TURNLEFTAFTERSTRAIGHT_INFO)
#define EVENT_IVS_TRAFFIC_BIGBENDSMALLTURN      0x00000219      // Event of small turn on big bend(Corresponding to DEV_EVENT_BIGBENDSMALLTURN_INFO)
#define EVENT_IVS_ROAD_CONSTRUCTION             0x0000021A      // Event of road construction inspection (Corresponding to DEV_EVENT_ROAD_CONSTRUCTION_INFO)
#define EVENT_IVS_ROAD_BLOCK                    0x0000021B      // Event of road block  detection (Corresponding to DEV_EVENT_ROAD_BLOCK_INFO)
#define EVENT_IVS_TRAFFIC_QUEUEJUMP             0x0000021C      // Event of car jump a queue(Corresponding to DEV_EVENT_TRAFFIC_QUEUEJUMP_INFO)
#define EVENT_IVS_VEHICLE_SUSPICIOUSCAR         0x0000021D      // Event of Suspicious Car(Corresponding to DEV_EVENT_VEHICLE_SUSPICIOUSCAR_INFO)
#define EVENT_IVS_TRAFFIC_TURNRIGHTAFTERSTRAIGHT  0x0000021E    // Turn right to make a straight event(Corresponding to DEV_EVENT_TURNRIGHTAFTERSTRAIGHT_INFO)
#define EVENT_IVS_TRAFFIC_TURNRIGHTAFTERPEOPLE    0x0000021F    // Turn right and go straight to pedestrians(Corresponding to DEV_EVENT_TURNRIGHTAFTERPEOPLE_INFO)
#define EVENT_IVS_INSTALL_CARDREADER            0x00000220      // Install card reader event(Corresponding to DEV_EVENT_INSTALL_CARDREADER_INFO)
#define EVENT_ALARM_YALE_DROPBOX_BADTOKEN       0x00000221      // event of Yale token bad
#define EVENT_IVS_ACC_OFF_SNAP                  0x00000222      // Vehicle equipment's ACC off snap event(Corresponding to DEV_EVENT_ACC_OFF_SNAP_INFO)
#define EVENI_IVS_XRAY_DETECTION				0x00000223		// X ray detection(Corresponding to DEV_EVENT_XRAY_DETECTION_INFO)
#define EVENT_IVS_NOTCLEARCAR					0x00000224		// Not clear car alarm(Corresponding to DEV_EVENT_NOTCLEARCAR_INFO)
#define EVENT_IVS_SOSALEART						0x00000225		// SOS alert(Corresponding to DEV_EVENT_SOSALEART_INFO)
#define EVENT_IVS_OVERLOAD						0x00000226		// Overload snap picture(Corresponding to DEV_EVENT_OVERLOAD_INFO)
#define EVENT_IVS_NONWORKINGTIME				0x00000227		// Non-working time alarm(Corresponding to DEV_EVENT_NONWORKINGTIME_INFO)
#define EVENT_IVS_TRAFFIC_HIGH_BEAM				0x00000228		// Event of traffice high beam(Corresponding to DEV_EVENT_TRAFFIC_HIGH_BEAM_INFO)
#define EVENT_IVS_TRAFFIC_TRUCKFORBID			0x00000229		// truck forbid Enent(Corresponding to DEV_ENENT_TRAFFICTRUCKFORBID_INFO)
#define EVENT_IVS_DRIVINGWITHOUTCARD			0x0000022A		// Event of Driving without card(Corresponding to DEV_EVENT_DRIVINGWITHOUTCARD_INFO)
#define EVENT_IVS_HIGHSPEED						0x0000022B		// Event of high speed(Corresponding to DEV_EVENT_HIGHSPEED_INFO)
#define EVENT_IVS_CROWDDETECTION				0x0000022C		// Event of crowd detection(Corresponding to DEV_EVENT_CROWD_DETECTION_INFO)
#define EVENT_IVS_TRAFFIC_CARDISTANCESHORT		0x0000022D		// Event of car distance short(Corresponding to DEV_EVENT_TRAFFIC_CARDISTANCESHORT_INFO)
#define EVENT_IVS_PEDESTRIAN_JUNCTION			0x00000230		// Pedestrian Junction Event(Corresponding to DEV_EVENT_PEDESTRIAN_JUNCTION_INFO)
#define EVENT_IVS_VEHICLE_RECOGNITION           0x00000231      // Vehicle recognition alarm(Corresponding to DEV_EVENT_VEHICLE_RECOGNITION_INFO)
#define EVENT_IVS_PASS_CHANGE					0x00000232		// Event of Pass change (Corresponding to DEV_EVENT_PASS_CHANGE_INFO)
#define EVENT_IVS_TRAFFIC_PARKING_SPACEDETECTION 0x00000233		// Event of Space detection
#define EVENT_IVS_TRAFFIC_WAITINGAREA           0x00000234		// Event of Traffic Waiting Area(Corresponding to DEV_EVENT_TRAFFIC_WAITINGAREA_INFO)
#define EVENT_IVS_TRAFFIC_BAN					0x00000235		// Event of Traffic ban(Corresponding to DEV_EVENT_TRAFFIC_BAN_INFO)
#define EVENT_IVS_POS_EXCHANGE					0x00000236		// Event of POS ExChange (Corresponding to  DEV_EVENT_POS_EXCHANGE_INFO)
#define EVENT_IVS_STEREO_FIGHTDETECTION         0x00000237      // Stereoscopic behavior analysis of fighting/strenuous motion(only used for configuration rules, alarm event is EVENT_IVS_FIGHTDETECTION)
#define EVENT_IVS_STEREO_DISTANCE_DETECTION		0x00000238		// Stereoscopic behavior analysis of distance anomaly/personnel close(only used for configuration rules, alarm event is EVENT_IVS_DISTANCE_DETECTION)
#define EVENT_IVS_STEREO_STEREOFALLDETECTION    0x00000239      // Stereoscopic behavior analysis of fall detection(only used for configuration rules, alarm event is EVENT_IVS_TUMBLE_DETECTION)
#define EVENT_IVS_STEREO_STAYDETECTION    		0x0000023A      // Stereoscopic behavior analysis of stay detection(only used for configuration rules, alarm event is EVENT_IVS_STAYDETECTION)
#define EVENT_IVS_BANNER_DETECTION				0x0000023B		// Event of Banner detection(Corresponding to DEV_EVENT_BANNER_DETECTION_INFO)
#define EVENT_IVS_NORMAL_FIGHTDETECTION         0x0000023C      // Event of normal fight(only be used to rule of normal fight, the alarm event is same as EVENT_IVS_FIGHTDETECTION)
#define EVENT_IVS_ELEVATOR_ABNORMAL				0x0000023D		// Event of elevator abnormal(Corresponding to DEV_EVENT_ELEVATOR_ABNORMAL_INFO)
#define EVENT_IVS_NONMOTORDETECT                0x0000023E      // Event of Non-Motor detect (Corresponding to DEV_EVENT_NONMOTORDETECT_INFO)
#define EVENT_IVS_VEHICLEDETECT                 0x0000023F      // Event of Vehicle detect (only be used to rule of vehicledetect,the alarm event is same as EVENT_IVS_TRAFFICJUNCTION)
#define EVENT_IVS_TRAFFIC_PARKING_B             0x00000240      // Event of Class B traffic-Parking(Corresponding to DEV_EVENT_TRAFFIC_PARKING_B_INFO)
#define EVENT_IVS_TRAFFIC_PARKING_C             0x00000241      // Event of Class C traffic-Parking(Corresponding to DEV_EVENT_TRAFFIC_PARKING_C_INFO)
#define EVENT_IVS_TRAFFIC_PARKING_D             0x00000242      // Event of Class D traffic-Parking(Corresponding to DEV_EVENT_TRAFFIC_PARKING_D_INFO)
#define EVENT_IVSS_FACEATTRIBUTE                0x00000243      // Event of IVSS face attribute(no event data)
#define EVENT_IVSS_FACECOMPARE                  0x00000244      // Event of IVSS face compare(no event data)
#define EVENT_IVS_FIREWARNING					0x00000245      // Event of FireWarning(Corresponding to DEV_EVENT_FIREWARNING_INFO)
#define EVENT_IVS_SHOPPRESENCE					0x00000246      // Event of ShopPresence(Corresponding to DEV_EVENT_SHOPPRESENCE_INFO)
#define EVENT_IVS_WASTEDUMPED					0x00000247      // Event of WasteDumped(Corresponding to DEV_EVENT_WASTEDUMPED_INFO)
#define EVENT_IVS_SPILLEDMATERIAL_DETECTION		0x00000248      // Event of spilled material detection(Corresponding to DEV_EVENT_SPILLEDMATERIAL_DETECTION_INFO)
#define EVENT_IVS_STEREO_MANNUM_DETECTION		0x00000249		// Stereoscopic behavior analysis of mannum detection(only used for configuration rules, alarm event is EVENT_IVS_MAN_NUM_DETECTION)
#define EVENT_IVS_DISTANCE_DETECTION			0x0000024A		// Event of distance detection(Corresponding to DEV_EVENT_DISTANCE_DETECTION_INFO)
#define EVENT_IVS_TRAFFIC_NONMOTOR_OVERLOAD		0x0000024B		// Event of non-motor overload (Corresponding to DEV_EVENT_TRAFFIC_NONMOTOR_OVERLOAD_INFO)
#define EVENT_IVS_TRAFFIC_NONMOTOR_WITHOUTSAFEHAT	0x0000024C	// Event of non-motor without safehat (Corresponding to DEV_EVENT_TRAFFIC_NONMOTOR_WITHOUTSAFEHAT_INFO)
#define EVENT_IVS_TRAFFIC_JAM_STOP_ON_ZEBRACROSSING 0x0000024D		// Event of TrafficJamStopOnZebraCrossing(Corresponding to DEV_EVENT_TRAFFIC_JAM_STOP_ON_ZEBRACROSSING_INFO)
#define EVENT_IVS_FLOWBUSINESS					0x0000024E		// Event of flowBusiness (Corresponding to DEV_EVENT_FLOWBUSINESS_INFO)
#define EVENT_IVS_CITY_MOTORPARKING				0x0000024F		// Event of CityMotorParking (Corresponding to DEV_EVENT_CITY_MOTORPARKING_INFO)
#define EVENT_IVS_CITY_NONMOTORPARKING			0x00000250		// Event of CityNonMotorParking (Corresponding to EV_EVENT_CITY_NONMOTORPARKING_INFO)
#define EVENT_IVS_LANEDEPARTURE_WARNNING		0X00000251		// Lane Departure warnning(Corresponding to DEV_EVENT_LANEDEPARTURE_WARNNING_INFO)
#define EVENT_IVS_FORWARDCOLLISION_WARNNING		0x00000252		// Forward Collision Warnning(Corresponding to DEV_EVENT_FORWARDCOLLISION_WARNNING_INFO)	
#define EVENT_IVS_MATERIALSSTAY					0x00000253		// Event of MaterialsStay(Corresponding to DEV_EVENT_MATERIALSSTAY_INFO)
#define EVENT_IVS_TRAFFIC_NONMOTOR_HOLDUMBRELLA 0x00000254		// Event of NonMotor hold umbrella (Corresponding to DEV_EVENT_TRAFFIC_NONMOTOR_HOLDUMBRELLA_INFO)
#define EVENT_IVS_JABLOTRON_ALARM				0x00000255		// Event of Jablotron alarm
#define EVENT_IVS_VIDEOUNFOCUS_ALARM			0x00000256		// Event of video unfocus(Corresponding to DEV_EVENT_EVENT_VIDEOUNFOCUS_INFO)
#define EVENT_IVS_FLOATINGOBJECT_DETECTION		0x00000257		// Event of FloatingObject detection (Corresponding to DEV_EVENT_FLOATINGOBJECT_DETECTION_INFO)
#define EVENT_IVS_SHIP_DETECTION				0x00000258		// Event of Ship detection (Corresponding to DEV_EVENT_SHIP_DETECTION_INFO)
#define EVENT_IVS_AIRPLANE_DETECTION			0x00000259		// Event of AirPlaneDetection(Corresponding to DEV_EVENT_AIRPLANE_DETECTION_INFO)
#define EVENT_IVS_PHONECALL_DETECT				0x0000025A		// Event of phone call detect(Corresponding to DEV_EVENT_PHONECALL_DETECT_INFO)
#define EVENT_IVS_SMOKING_DETECT				0x0000025B		// Event of Smoking Detection(Corresponding to DEV_EVENT_SMOKING_DETECT_INFO)
#define EVENT_IVS_RADAR_SPEED_LIMIT_ALARM       0x0000025C      // Event of Radar speed limit alarm(Corresponding to DEV_EVENT_RADAR_SPEED_LIMIT_ALARM_INFO)
#define EVENT_IVS_WATER_LEVEL_DETECTION			0x0000025D		// Event of Water level detection (Corresponding to DEV_EVENT_WATER_LEVEL_DETECTION_INFO)
#define EVENT_IVS_HOLD_UMBRELLA			        0x0000025E		// Event of Hold umbrella detection(Corresponding to DEV_EVENT_HOLD_UMBRELLA_INFO)
#define EVENT_IVS_GARBAGE_EXPOSURE			    0x0000025F		// Event of Garbage Exposure detection (Corresponding to DEV_EVENT_GARBAGE_EXPOSURE_INFO)
#define EVENT_IVS_DUSTBIN_OVER_FLOW			    0x00000260		// Event of Dustbin Overflow detection (Corresponding to DEV_EVENT_DUSTBIN_OVER_FLOW_INFO)
#define EVENT_IVS_DOOR_FRONT_DIRTY			    0x00000261		// Event of Door Front Dirty detection(Corresponding to DEV_EVENT_DOOR_FRONT_DIRTY_INFO)
#define EVENT_IVS_QUEUESTAY_DETECTION			0X00000262		// Event of Queue Stay Detection (Corresponding to DEV_EVENT_QUEUESTAY_DETECTION_INFO)
#define EVENT_IVS_QUEUENUM_DETECTION			0X00000263		// Event of Queue Num DetectionCorresponding to DEV_EVENT_QUEUENUM_DETECTION_INFO
#define EVENT_IVS_GENERATEGRAPH_DETECTION		0X00000264		// Event of Generate Graph DetectionCorresponding to  DEV_EVENT_GENERATEGRAPH_DETECTION_INFO
#define EVENT_IVS_TRAFFIC_PARKING_MANUAL		0x00000265		// Event of manual traffic-Parking(Corresponding to DEV_EVENT_TRAFFIC_PARKING_MANUAL_INFO)
#define EVENT_IVS_HELMET_DETECTION      		0x00000266		// Event of helmet detection (Corresponding to DEV_EVENT_HELMET_DETECTION_INFO)
#define EVENT_IVS_DEPOSIT_DETECTION      		0x00000267		// Event of deposit detection (Corresponding to DEV_EVENT_DEPOSIT_DETECTION_INFO)
#define EVENT_IVS_HOTSPOT_WARNING				0x00000268		// Event of Hot spot warning(Corresponding to DEV_EVENT_HOTSPOT_WARNING_INFO)
#define EVENT_IVS_WEIGHING_PLATFORM_DETECTION	0x00000269		// Event of weighing platform detection(Corresponding to DEV_EVENT_WEIGHING_PLATFORM_DETECTION_INFO)
#define EVENT_IVS_CLASSROOM_BEHAVIOR			0x0000026A		// Event of classroom behavior detection(Corresponding to DEV_EVENT_CLASSROOM_BEHAVIOR_INFO)
#define EVENT_IVS_VEHICLE_DISTANCE_NEAR			0x0000026B		// Event of safe driving vehicle distance near alarm(Corresponding to DEV_EVENT_VEHICLE_DISTANCE_NEAR_INFO)
#define EVENT_IVS_TRAFFIC_DRIVER_ABNORMAL       0x0000026C		// Event of traffic driver abnormal alarm(Corresponding toDEV_EVENT_TRAFFIC_DRIVER_ABNORMAL_INFO)
#define EVENT_IVS_TRAFFIC_DRIVER_CHANGE         0x0000026D		// Event of traffic driver change alarm(Corresponding to DEV_EVENT_TRAFFIC_DRIVER_CHANGE_INFO)
#define EVENT_IVS_WORKCLOTHES_DETECT			0x0000026E		// Event of work clothes(helmet/clothes)detection(Corresponding to DEV_EVENT_WORKCLOTHES_DETECT_INFO)
#define EVENT_IVS_SECURITYGATE_PERSONALARM		0x0000026F		// Event of security gate person alarm(Corresponding to DEV_EVENT_SECURITYGATE_PERSONALARM_INFO)
#define EVENT_IVS_STAY_ALONE_DETECTION          0x00000270		// Event of stay alone detection (Corresponding to DEV_EVENT_STAY_ALONE_DETECTION_INFO)
#define EVENT_IVS_TRAFFIC_ROAD_BLOCK            0x00000271		// Event of traffic road block(Corresponding to DEV_EVENT_TRAFFIC_ROAD_BLOCK_INFO)
#define EVENT_IVS_TRAFFIC_ROAD_CONSTRUCTION     0x00000272		// Event of traffic road construction(Corresponding to DEV_EVENT_TRAFFIC_ROAD_CONSTRUCTION_INFO)
#define EVENT_IVS_XRAY_DETECT_BYOBJECT			0x00000273		// Rule config of X ray detection, event is EVENI_IVS_XRAY_DETECTION
#define EVENT_IVS_WORKSTATDETECTION				0x00000274		// Event of work stat detection(Corresponding to DEV_EVENT_WORKSTATDETECTION_INFO)
#define EVENT_IVS_INFRAREDBLOCK					0x00000275		// Event of infrared block(Corresponding to DEV_EVENT_INFRAREDBLOCK_INFO)
#define EVENT_IVS_FEATURE_ABSTRACT				0x00000276		// Event of feature abstract(Corresponding to DEV_EVENT_FEATURE_ABSTRACT_INFO)
#define EVENT_IVS_INTELLI_SHELF				    0x00000277		// Event of intelligent replenishment(Corresponding to DEV_EVENT_INTELLI_SHELF_INFO)
#define EVENT_IVS_PANORAMA_SHOT					0x00000278		// Event of Panoramic snapshot(Corresponding to DEV_EVENT_PANORAMA_SHOT_INFO)
#define EVENT_ALARM_SMARTMOTION_HUMAN           0x00000279       // Event of smart motion detection(human)it is used for mobile push, no event struct
#define EVENT_ALARM_SMARTMOTION_VEHICLE         0x0000027A       // Event of smart motion detection(vehicle)it is used for mobile push, no event struct
#define EVENT_IVS_CAR_DRIVING_IN_OUT			0x0000027B		// Event of car driving in or out(Corresponding to DEV_EVENT_CAR_DRIVING_IN_OUT_INFO)
#define EVENT_IVS_PARKINGSPACE_STATUS			0x0000027C		// Event of parking spcae status(Corresponding to DEV_EVENT_PARKINGSPACE_STATUS_INFO)
#define EVENT_IVS_VIOLENT_THROW_DETECTION		0x0000027D		// Event violent throw detection (Corresponding to DEV_EVENT_VIOLENT_THROW_DETECTION_INFO)
#define EVENT_IVS_TRAMCARSECTIONS_DETECTION		0x0000027E		// Event of TramCarSectionsDetection (Corresponding to DEV_EVENT_TRAMCARSECTIONS_DETECTION_INFO)
#define EVENT_IVS_ALARM_BOX_ALARM               0x0000027F      // Event of alarm box, only for mobile push
#define EVENT_IVS_FACE_COMPARISION              0x00000280      // Event of face comparision, only for mobile push
#define EVENT_IVS_FACEBODY_DETECT				0x00000281		// Event of face body detect (Corresponding to DEV_EVENT_FACEBODY_DETECT_INFO)
#define EVENT_IVS_FACEBODY_ANALYSE				0x00000282		// Event of face body analyse (Corresponding to DEV_EVENT_FACEBODY_ANALYSE_INFO)
#define EVENT_IVS_GASSTATION_VEHICLE_DETECT     0x00000283      // Event of gas station vehicle detection(Corresponding to DEV_EVENT_GASSTATION_VEHICLE_DETECT_INFO)
#define EVENT_IVS_CONGESTION_DETECTION			0x00000284		// Event of congestion detection(Corresponding to DEV_EVENT_CONGESTION_DETECTION_INFO)
#define EVENT_IVS_VEHICLELIMIT_DETECTION		0x00000285		// Event of vehicle limit detection(Corresponding to DEV_EVENT_VEHICLELIMIT_DETECTION_INFO)
#define EVENT_IVS_ANIMAL_DETECTION              0x00000286      // Event of animal detection(Corresponding to DEV_EVENT_ANIMAL_DETECTION_INFO) 
#define EVENT_IVS_SHOP_WINDOW_POST              0x00000287      // Event of shop window post(Corresponding to DEV_EVENT_SHOP_WINDOW_POST_INFO)
#define EVENT_IVS_SHOP_SIGN_ABNORMAL            0x00000288      // Event of shop sign abnormal (Corresponding to DEV_EVENT_SHOP_SIGN_ABNORMAL_INFO)
#define EVENT_IVS_BREED_DETECTION               0x00000289      // Event of breed detection (Corresponding to DEV_EVENT_BREED_DETECTION_INFO)
#define EVENT_IVS_AIRPORT_VEHICLE_DETECT		0x0000028A		// Event of airport-vehicle detection (Corresponding to DEV_EVENT_AIRPORT_VEHICLE_DETECT)
#define EVENT_IVS_PIG_TEMPERATURE_DETECT        0x0000028B      // Event of pig body temperature detection (it is only uset to analyse rule config)
#define EVENT_IVS_MAN_CAR_COEXISTANCE           0x0000028C      // Event of man and cars exist at the same time (Corresponding to  DEV_EVENT_MAN_CAR_COEXISTANCE_INFO)
#define EVENT_IVS_HIGH_TOSS_DETECT              0x0000028D      // Event of high toss detection(Corresponding to  DEV_EVENT_HIGH_TOSS_DETECT_INFO)
#define EVENT_IVS_ELECTRIC_GLOVE_DETECT         0x0000028E      // Event of electric glove detection(Corresponding to  DEV_EVENT_ELECTRIC_GLOVE_DETECT_INFO)
#define EVENT_IVS_ELECTRIC_LADDER_DETECT        0x0000028F      // Event of electric ladder detection(Corresponding to  DEV_EVENT_ELECTRIC_LADDER_DETECT_INFO)
#define EVENT_IVS_ELECTRIC_CURTAIN_DETECT       0x00000290      // Event of electric curtain detection(Corresponding to  DEV_EVENT_ELECTRIC_CURTAIN_DETECT_INFO)
#define EVENT_IVS_ELECTRIC_FENCE_DETECT         0x00000291      // Event of electric fence detection(Corresponding to  DEV_EVENT_ELECTRIC_FENCE_DETECT_INFO)
#define EVENT_IVS_ELECTRIC_SIGNBOARD_DETECT     0x00000292      // Event of electric signboard detection(Corresponding to  DEV_EVENT_ELECTRIC_SIGNBOARD_DETECT_INFO)
#define EVENT_IVS_ELECTRIC_BELT_DETECT          0x00000293      // Event of electric belt detection(Corresponding to  DEV_EVENT_ELECTRIC_BELT_DETECT_INFO)
#define EVENT_IVS_RADAR_LINE_DETECTION          0x00000294      // Event of Radar cross line detection(Corresponding to  DEV_EVENT_RADAR_LINE_DETECTION_INFO)
#define EVENT_IVS_RADAR_REGION_DETECTION        0x00000295      // Event of Radar cross region detection(Corresponding to  DEV_EVENT_RADAR_REGION_DETECTION_INFO)
#define EVENT_IVS_AUDIO_INTENSITY				0x00000296		// Event of audio intensity (Corresponding to DEV_EVENT_AUDIO_INTENSITY_INFO)
#define EVENT_IVS_PARKING_LOT_STATUS_DETECTION  0x00000297      // Event of parking lot status detection (Corresponding to DEV_EVENT_PARKING_LOT_STATUS_DETECTION_INFO)
#define EVENT_IVS_VEHICLE_COMPARE               0x00000298
#define EVENT_IVS_DREGS_UNCOVERED               0x00000299      // Event of loading test not covered by muck truck(Corresponding to DEV_EVENT_DREGS_UNCOVERED_INFO)
#define EVENT_IVS_WALK_DETECTION                0x0000029A      // Event of walk detection (Corresponding to DEV_EVENT_WALK_DETECTION_INFO)
#define EVENT_IVS_BACK_TO_DETECTION             0x0000029B      // Event of back to dection (corresponding to DEV_EVENT_BACK_TO_DETECTION_INFO)
#define EVENT_IVS_WRITE_ON_THE_BOARD_DETECTION  0x0000029C      // Event of write on the board detection(corresponding to DEV_EVENT_WRITE_ON_THE_BOARD_DETECTION_INFO)
#define EVENT_IVS_SMART_KITCHEN_CLOTHES_DETECTION	0x0000029D	// Event of Smart kitchen wearing detection(alarm for not wearing mask, chef's clothes whose color does not meet the requirements)(Corresponding to DEV_EVENT_SMART_KITCHEN_CLOTHES_DETECTION_INFO)

//Storage Point
#define STOR_POINT_READ_WRITE                   0x00001001      // Read-Write group
#define STOR_POINT_READ_ONLY                    0x00001002      // Read-Only group
#define STOR_POINT_REDUNDANT                    0x00001003      // Redundant group
#define STOR_POINT_BACKUP                       0x00001004      // Backup group
#define STOR_POINT_DRAW_FRAME                   0x00001005      // Drawframe group
#define STOR_POINT_NAS_FTP                      0x00001006      // Remote group(protocol type:FTP)
#define STOR_POINT_NAS_NFS                      0x00001007      // Remote group(protocol type:NFS)
#define STOR_POINT_NAS_SMB                      0x00001008      // Remote group(protocol type:SMB)
#define STOR_POINT_NAS_ISCSI                    0x00001009      // Remote group(protocol type:ISCSI)
#define STOR_POINT_NAS_CLOUD                    0x0000100A      // Remote group(protocol type:Cloud)

//Traffic statistics event using macros
#define FLOWSTAT_ADDR_NAME                      16              //Has long place name

// interface CLIENT_OperateTrafficList, All kinds of string length definition
#define DH_TARFFIC_NAME_LEN                     16                
#define DH_CREATE_TIME_LEN                      32
#define DH_AUTHORITY_NUM                        16

// Error type code. Corresponding to the return value of CLIENT_GetLastError
#define _EC(x)                                    (0x80000000|x)
#define NET_NOERROR                              0          // No error 
#define NET_ERROR                                -1         // Unknown error
#define NET_SYSTEM_ERROR                        _EC(1)      // system error
#define NET_NETWORK_ERROR                       _EC(2)      // Protocol error it may result from network timeout
#define NET_DEV_VER_NOMATCH                     _EC(3)      // Device protocol does not match 
#define NET_INVALID_HANDLE                      _EC(4)      // Handle is invalid
#define NET_OPEN_CHANNEL_ERROR                  _EC(5)      // Failed to open channel 
#define NET_CLOSE_CHANNEL_ERROR                 _EC(6)      // Failed to close channel 
#define NET_ILLEGAL_PARAM                       _EC(7)      // User parameter is illegal 
#define NET_SDK_INIT_ERROR                      _EC(8)      // SDK initialization error 
#define NET_SDK_UNINIT_ERROR                    _EC(9)      // SDK clear error 
#define NET_RENDER_OPEN_ERROR                   _EC(10)     // Error occurs when apply for render resources.
#define NET_DEC_OPEN_ERROR                      _EC(11)     // Error occurs when opening the decoder library 
#define NET_DEC_CLOSE_ERROR                     _EC(12)     // Error occurs when closing the decoder library 
#define NET_MULTIPLAY_NOCHANNEL                 _EC(13)     // The detected channel number is 0 in multiple-channel preview. 
#define NET_TALK_INIT_ERROR                     _EC(14)     // Failed to initialize record library 
#define NET_TALK_NOT_INIT                       _EC(15)     // The record library has not been initialized
#define NET_TALK_SENDDATA_ERROR                 _EC(16)     // Error occurs when sending out audio data 
#define NET_REAL_ALREADY_SAVING                 _EC(17)     // The real-time has been protected.
#define NET_NOT_SAVING                          _EC(18)     // The real-time data has not been save.
#define NET_OPEN_FILE_ERROR                     _EC(19)     // Error occurs when opening the file.
#define NET_PTZ_SET_TIMER_ERROR                 _EC(20)     // Failed to enable PTZ to control timer.
#define NET_RETURN_DATA_ERROR                   _EC(21)     // Error occurs when verify returned data.
#define NET_INSUFFICIENT_BUFFER                 _EC(22)     // There is no sufficient buffer.
#define NET_NOT_SUPPORTED                       _EC(23)     // The current SDK does not support this funcntion.
#define NET_NO_RECORD_FOUND                     _EC(24)     // There is no searched result.
#define NET_NOT_AUTHORIZED                      _EC(25)     // You have no operation right.
#define NET_NOT_NOW                             _EC(26)     // Can not operate right now. 
#define NET_NO_TALK_CHANNEL                     _EC(27)     // There is no audio talk channel.
#define NET_NO_AUDIO                            _EC(28)     // There is no audio.
#define NET_NO_INIT                             _EC(29)     // The network SDK has not been initialized.
#define NET_DOWNLOAD_END                        _EC(30)     // The download completed.
#define NET_EMPTY_LIST                          _EC(31)     // There is no searched result.
#define NET_ERROR_GETCFG_SYSATTR                _EC(32)     // Failed to get system property setup.
#define NET_ERROR_GETCFG_SERIAL                 _EC(33)     // Failed to get SN.
#define NET_ERROR_GETCFG_GENERAL                _EC(34)     // Failed to get general property.
#define NET_ERROR_GETCFG_DSPCAP                 _EC(35)     // Failed to get DSP capacity description.
#define NET_ERROR_GETCFG_NETCFG                 _EC(36)     // Failed to get network channel setup.
#define NET_ERROR_GETCFG_CHANNAME               _EC(37)     // Failed to get channel name.
#define NET_ERROR_GETCFG_VIDEO                  _EC(38)     // Failed to get video property.
#define NET_ERROR_GETCFG_RECORD                 _EC(39)     // Failed to get record setup
#define NET_ERROR_GETCFG_PRONAME                _EC(40)     // Failed to get decoder protocol name 
#define NET_ERROR_GETCFG_FUNCNAME               _EC(41)     // Failed to get 232 COM function name.
#define NET_ERROR_GETCFG_485DECODER             _EC(42)     // Failed to get decoder property
#define NET_ERROR_GETCFG_232COM                 _EC(43)     // Failed to get 232 COM setup
#define NET_ERROR_GETCFG_ALARMIN                _EC(44)     // Failed to get external alarm input setup
#define NET_ERROR_GETCFG_ALARMDET               _EC(45)     // Failed to get motion detection alarm
#define NET_ERROR_GETCFG_SYSTIME                _EC(46)     // Failed to get device time
#define NET_ERROR_GETCFG_PREVIEW                _EC(47)     // Failed to get preview parameter
#define NET_ERROR_GETCFG_AUTOMT                 _EC(48)     // Failed to get audio maintenance setup
#define NET_ERROR_GETCFG_VIDEOMTRX              _EC(49)     // Failed to get video matrix setup
#define NET_ERROR_GETCFG_COVER                  _EC(50)     // Failed to get privacy mask zone setup
#define NET_ERROR_GETCFG_WATERMAKE              _EC(51)     // Failed to get video watermark setup
#define NET_ERROR_GETCFG_MULTICAST              _EC(52)     // Failed to get config, omulticast port by channel
#define NET_ERROR_SETCFG_GENERAL                _EC(55)     // Failed to modify general property
#define NET_ERROR_SETCFG_NETCFG                 _EC(56)     // Failed to modify channel setup
#define NET_ERROR_SETCFG_CHANNAME               _EC(57)     // Failed to modify channel name
#define NET_ERROR_SETCFG_VIDEO                  _EC(58)     // Failed to modify video channel 
#define NET_ERROR_SETCFG_RECORD                 _EC(59)     // Failed to modify record setup 
#define NET_ERROR_SETCFG_485DECODER             _EC(60)     // Failed to modify decoder property 
#define NET_ERROR_SETCFG_232COM                 _EC(61)     // Failed to modify 232 COM setup 
#define NET_ERROR_SETCFG_ALARMIN                _EC(62)     // Failed to modify external input alarm setup
#define NET_ERROR_SETCFG_ALARMDET               _EC(63)     // Failed to modify motion detection alarm setup 
#define NET_ERROR_SETCFG_SYSTIME                _EC(64)     // Failed to modify device time 
#define NET_ERROR_SETCFG_PREVIEW                _EC(65)     // Failed to modify preview parameter
#define NET_ERROR_SETCFG_AUTOMT                 _EC(66)     // Failed to modify auto maintenance setup 
#define NET_ERROR_SETCFG_VIDEOMTRX              _EC(67)     // Failed to modify video matrix setup 
#define NET_ERROR_SETCFG_COVER                  _EC(68)     // Failed to modify privacy mask zone
#define NET_ERROR_SETCFG_WATERMAKE              _EC(69)     // Failed to modify video watermark setup 
#define NET_ERROR_SETCFG_WLAN                   _EC(70)     // Failed to modify wireless network information 
#define NET_ERROR_SETCFG_WLANDEV                _EC(71)     // Failed to select wireless network device
#define NET_ERROR_SETCFG_REGISTER               _EC(72)     // Failed to modify the actively registration parameter setup.
#define NET_ERROR_SETCFG_CAMERA                 _EC(73)     // Failed to modify camera property
#define NET_ERROR_SETCFG_INFRARED               _EC(74)     // Failed to modify IR alarm setup
#define NET_ERROR_SETCFG_SOUNDALARM             _EC(75)     // Failed to modify audio alarm setup
#define NET_ERROR_SETCFG_STORAGE                _EC(76)     // Failed to modify storage position setup
#define NET_AUDIOENCODE_NOTINIT                 _EC(77)     // The audio encode port has not been successfully initialized. 
#define NET_DATA_TOOLONGH                       _EC(78)     // The data are too long.
#define NET_UNSUPPORTED                         _EC(79)     // The device does not support current operation. 
#define NET_DEVICE_BUSY                         _EC(80)     // Device resources is not sufficient.
#define NET_SERVER_STARTED                      _EC(81)     // The server has boot up 
#define NET_SERVER_STOPPED                      _EC(82)     // The server has not fully boot up 
#define NET_LISTER_INCORRECT_SERIAL             _EC(83)     // Input serial number is not correct.
#define NET_QUERY_DISKINFO_FAILED               _EC(84)     // Failed to get HDD information.
#define NET_ERROR_GETCFG_SESSION                _EC(85)     // Failed to get connect session information.
#define NET_USER_FLASEPWD_TRYTIME               _EC(86)     // The password you typed is incorrect. You have exceeded the maximum number of retries.
#define NET_LOGIN_ERROR_PASSWORD                _EC(100)    // Password is not correct
#define NET_LOGIN_ERROR_USER                    _EC(101)    // The account does not exist
#define NET_LOGIN_ERROR_TIMEOUT                 _EC(102)    // Time out for log in returned value.
#define NET_LOGIN_ERROR_RELOGGIN                _EC(103)    // The account has logged in 
#define NET_LOGIN_ERROR_LOCKED                  _EC(104)    // The account has been locked
#define NET_LOGIN_ERROR_BLACKLIST               _EC(105)    // The account has been in the black list
#define NET_LOGIN_ERROR_BUSY                    _EC(106)    // Resources are not sufficient. System is busy now.
#define NET_LOGIN_ERROR_CONNECT                 _EC(107)    // Time out. Please check network and try again.
#define NET_LOGIN_ERROR_NETWORK                 _EC(108)    // Network connection failed.
#define NET_LOGIN_ERROR_SUBCONNECT              _EC(109)    // Successfully logged in the device but can not create video channel. Please check network connection.
#define NET_LOGIN_ERROR_MAXCONNECT              _EC(110)    // exceed the max connect number
#define NET_LOGIN_ERROR_PROTOCOL3_ONLY          _EC(111)    // protocol 3 support
#define NET_LOGIN_ERROR_UKEY_LOST               _EC(112)    // There is no USB or USB info error
#define NET_LOGIN_ERROR_NO_AUTHORIZED           _EC(113)    // Client-end IP address has no right to login
#define NET_LOGIN_ERROR_USER_OR_PASSOWRD        _EC(117)    // user or password error 
#define NET_LOGIN_ERROR_DEVICE_NOT_INIT			_EC(118)	// cannot login because the device has not been init,please init the device and then login
#define NET_LOGIN_ERROR_LIMITED					_EC(119)    // Limited login, it could be IP limited, time limited or expiration limited
#define NET_RENDER_SOUND_ON_ERROR               _EC(120)    // Error occurs when Render library open audio.
#define NET_RENDER_SOUND_OFF_ERROR              _EC(121)    // Error occurs when Render library close audio 
#define NET_RENDER_SET_VOLUME_ERROR             _EC(122)    // Error occurs when Render library control volume
#define NET_RENDER_ADJUST_ERROR                 _EC(123)    // Error occurs when Render library set video parameter
#define NET_RENDER_PAUSE_ERROR                  _EC(124)    // Error occurs when Render library pause play
#define NET_RENDER_SNAP_ERROR                   _EC(125)    // Render library snapshot error
#define NET_RENDER_STEP_ERROR                   _EC(126)    // Render library stepper error
#define NET_RENDER_FRAMERATE_ERROR              _EC(127)    // Error occurs when Render library set frame rate.
#define NET_RENDER_DISPLAYREGION_ERROR          _EC(128)    // Error occurs when Render lib setting show region
#define NET_RENDER_GETOSDTIME_ERROR             _EC(129)    // An error occurred when Render library getting current play time
#define NET_GROUP_EXIST                         _EC(140)    // Group name has been existed.
#define NET_GROUP_NOEXIST                       _EC(141)    // The group name does not exist. 
#define NET_GROUP_RIGHTOVER                     _EC(142)    // The group right exceeds the right list!
#define NET_GROUP_HAVEUSER                      _EC(143)    // The group can not be removed since there is user in it!
#define NET_GROUP_RIGHTUSE                      _EC(144)    // The user has used one of the group right. It can not be removed. 
#define NET_GROUP_SAMENAME                      _EC(145)    // New group name has been existed
#define NET_USER_EXIST                          _EC(146)    // The user name has been existed
#define NET_USER_NOEXIST                        _EC(147)    // The account does not exist.
#define NET_USER_RIGHTOVER                      _EC(148)    // User right exceeds the group right. 
#define NET_USER_PWD                            _EC(149)    // Reserved account. It does not allow to be modified.
#define NET_USER_FLASEPWD                       _EC(150)    // password is not correct
#define NET_USER_NOMATCHING                     _EC(151)    // Password is invalid
#define NET_USER_INUSE                          _EC(152)    // account in use
#define NET_ERROR_GETCFG_ETHERNET               _EC(300)    // Failed to get network card setup.
#define NET_ERROR_GETCFG_WLAN                   _EC(301)    // Failed to get wireless network information.
#define NET_ERROR_GETCFG_WLANDEV                _EC(302)    // Failed to get wireless network device.
#define NET_ERROR_GETCFG_REGISTER               _EC(303)    // Failed to get actively registration parameter.
#define NET_ERROR_GETCFG_CAMERA                 _EC(304)    // Failed to get camera property 
#define NET_ERROR_GETCFG_INFRARED               _EC(305)    // Failed to get IR alarm setup
#define NET_ERROR_GETCFG_SOUNDALARM             _EC(306)    // Failed to get audio alarm setup
#define NET_ERROR_GETCFG_STORAGE                _EC(307)    // Failed to get storage position 
#define NET_ERROR_GETCFG_MAIL                   _EC(308)    // Failed to get mail setup.
#define NET_CONFIG_DEVBUSY                      _EC(309)    // Can not set right now. 
#define NET_CONFIG_DATAILLEGAL                  _EC(310)    // The configuration setup data are illegal.
#define NET_ERROR_GETCFG_DST                    _EC(311)    // Failed to get DST setup
#define NET_ERROR_SETCFG_DST                    _EC(312)    // Failed to set DST 
#define NET_ERROR_GETCFG_VIDEO_OSD              _EC(313)    // Failed to get video OSD setup.
#define NET_ERROR_SETCFG_VIDEO_OSD              _EC(314)    // Failed to set video OSD 
#define NET_ERROR_GETCFG_GPRSCDMA               _EC(315)    // Failed to get CDMA\GPRS configuration
#define NET_ERROR_SETCFG_GPRSCDMA               _EC(316)    // Failed to set CDMA\GPRS configuration
#define NET_ERROR_GETCFG_IPFILTER               _EC(317)    // Failed to get IP Filter configuration
#define NET_ERROR_SETCFG_IPFILTER               _EC(318)    // Failed to set IP Filter configuration
#define NET_ERROR_GETCFG_TALKENCODE             _EC(319)    // Failed to get Talk Encode configuration
#define NET_ERROR_SETCFG_TALKENCODE             _EC(320)    // Failed to set Talk Encode configuration
#define NET_ERROR_GETCFG_RECORDLEN              _EC(321)    // Failed to get The length of the video package configuration
#define NET_ERROR_SETCFG_RECORDLEN              _EC(322)    // Failed to set The length of the video package configuration
#define NET_DONT_SUPPORT_SUBAREA                _EC(323)    // Not support Network hard disk partition
#define NET_ERROR_GET_AUTOREGSERVER             _EC(324)    // Failed to get the register server information
#define NET_ERROR_CONTROL_AUTOREGISTER          _EC(325)    // Failed to control actively registration
#define NET_ERROR_DISCONNECT_AUTOREGISTER       _EC(326)    // Failed to disconnect actively registration
#define NET_ERROR_GETCFG_MMS                    _EC(327)    // Failed to get mms configuration
#define NET_ERROR_SETCFG_MMS                    _EC(328)    // Failed to set mms configuration
#define NET_ERROR_GETCFG_SMSACTIVATION          _EC(329)    // Failed to get SMS configuration
#define NET_ERROR_SETCFG_SMSACTIVATION          _EC(330)    // Failed to set SMS configuration
#define NET_ERROR_GETCFG_DIALINACTIVATION       _EC(331)    // Failed to get activation of a wireless connection
#define NET_ERROR_SETCFG_DIALINACTIVATION       _EC(332)    // Failed to set activation of a wireless connection
#define NET_ERROR_GETCFG_VIDEOOUT               _EC(333)    // Failed to get the parameter of video output
#define NET_ERROR_SETCFG_VIDEOOUT               _EC(334)    // Failed to set the configuration of video output
#define NET_ERROR_GETCFG_OSDENABLE              _EC(335)    // Failed to get osd overlay enabling
#define NET_ERROR_SETCFG_OSDENABLE              _EC(336)    // Failed to set OSD overlay enabling
#define NET_ERROR_SETCFG_ENCODERINFO            _EC(337)    // Failed to set digital input configuration of front encoders
#define NET_ERROR_GETCFG_TVADJUST               _EC(338)    // Failed to get TV adjust configuration
#define NET_ERROR_SETCFG_TVADJUST               _EC(339)    // Failed to set TV adjust configuration
#define NET_ERROR_CONNECT_FAILED                _EC(340)    // Failed to request to establish a connection
#define NET_ERROR_SETCFG_BURNFILE               _EC(341)    // Failed to request to upload burn files
#define NET_ERROR_SNIFFER_GETCFG                _EC(342)    // Failed to get capture configuration information
#define NET_ERROR_SNIFFER_SETCFG                _EC(343)    // Failed to set capture configuration information
#define NET_ERROR_DOWNLOADRATE_GETCFG           _EC(344)    // Failed to get download restrictions information
#define NET_ERROR_DOWNLOADRATE_SETCFG           _EC(345)    // Failed to set download restrictions information
#define NET_ERROR_SEARCH_TRANSCOM               _EC(346)    // Failed to query serial port parameters
#define NET_ERROR_GETCFG_POINT                  _EC(347)    // Failed to get the preset info
#define NET_ERROR_SETCFG_POINT                  _EC(348)    // Failed to set the preset info
#define NET_SDK_LOGOUT_ERROR                    _EC(349)    // SDK log out the device abnormally
#define NET_ERROR_GET_VEHICLE_CFG               _EC(350)    // Failed to get vehicle configuration
#define NET_ERROR_SET_VEHICLE_CFG               _EC(351)    // Failed to set vehicle configuration
#define NET_ERROR_GET_ATM_OVERLAY_CFG           _EC(352)    // Failed to get ATM overlay configuration
#define NET_ERROR_SET_ATM_OVERLAY_CFG           _EC(353)    // Failed to set ATM overlay configuration
#define NET_ERROR_GET_ATM_OVERLAY_ABILITY       _EC(354)    // Failed to get ATM overlay ability
#define NET_ERROR_GET_DECODER_TOUR_CFG          _EC(355)    // Failed to get decoder tour configuration
#define NET_ERROR_SET_DECODER_TOUR_CFG          _EC(356)    // Failed to set decoder tour configuration
#define NET_ERROR_CTRL_DECODER_TOUR             _EC(357)    // Failed to control decoder tour
#define NET_GROUP_OVERSUPPORTNUM                _EC(358)    // Beyond the device supports for the largest number of user groups
#define NET_USER_OVERSUPPORTNUM                 _EC(359)    // Beyond the device supports for the largest number of users 
#define NET_ERROR_GET_SIP_CFG                   _EC(368)    // Failed to get SIP configuration
#define NET_ERROR_SET_SIP_CFG                   _EC(369)    // Failed to set SIP configuration
#define NET_ERROR_GET_SIP_ABILITY               _EC(370)    // Failed to get SIP capability
#define NET_ERROR_GET_WIFI_AP_CFG               _EC(371)    // Failed to get "WIFI ap' configuration 
#define NET_ERROR_SET_WIFI_AP_CFG               _EC(372)    // Failed to set "WIFI ap" configuration  
#define NET_ERROR_GET_DECODE_POLICY             _EC(373)    // Failed to get decode policy 
#define NET_ERROR_SET_DECODE_POLICY             _EC(374)    // Failed to set decode policy 
#define NET_ERROR_TALK_REJECT                   _EC(375)    // refuse talk
#define NET_ERROR_TALK_OPENED                   _EC(376)    // talk has opened by other client
#define NET_ERROR_TALK_RESOURCE_CONFLICIT       _EC(377)    // resource conflict
#define NET_ERROR_TALK_UNSUPPORTED_ENCODE       _EC(378)    // unsupported encode type
#define NET_ERROR_TALK_RIGHTLESS                _EC(379)    // no right
#define NET_ERROR_TALK_FAILED                   _EC(380)    // request failed
#define NET_ERROR_GET_MACHINE_CFG               _EC(381)    // Failed to get device relative config
#define NET_ERROR_SET_MACHINE_CFG               _EC(382)    // Failed to set device relative config
#define NET_ERROR_GET_DATA_FAILED               _EC(383)    // get data failed
#define NET_ERROR_MAC_VALIDATE_FAILED           _EC(384)    // MAC validate failed
#define NET_ERROR_GET_INSTANCE                  _EC(385)    // Failed to get server instance 
#define NET_ERROR_JSON_REQUEST                  _EC(386)    // Generated json string is error
#define NET_ERROR_JSON_RESPONSE                 _EC(387)    // The responding json string is error
#define NET_ERROR_VERSION_HIGHER                _EC(388)    // The protocol version is lower than current version
#define NET_SPARE_NO_CAPACITY                   _EC(389)    // Hotspare disk operation failed. The capacity is low
#define NET_ERROR_SOURCE_IN_USE                 _EC(390)    // Display source is used by other output
#define NET_ERROR_REAVE                         _EC(391)    // advanced users grab low-level user resource
#define NET_ERROR_NETFORBID                     _EC(392)    // net forbid
#define NET_ERROR_GETCFG_MACFILTER              _EC(393)    // get MAC filter configuration error
#define NET_ERROR_SETCFG_MACFILTER              _EC(394)    // set MAC filter configuration error
#define NET_ERROR_GETCFG_IPMACFILTER            _EC(395)    // get IP/MAC filter configuration error
#define NET_ERROR_SETCFG_IPMACFILTER            _EC(396)    // set IP/MAC filter configuration error
#define NET_ERROR_OPERATION_OVERTIME            _EC(397)    // operation over time 
#define NET_ERROR_SENIOR_VALIDATE_FAILED        _EC(398)    // senior validation failure
#define NET_ERROR_DEVICE_ID_NOT_EXIST           _EC(399)    // device ID is not exist
#define NET_ERROR_UNSUPPORTED                   _EC(400)    // unsupport operation
#define NET_ERROR_PROXY_DLLLOAD                 _EC(401)    // proxy dll load error
#define NET_ERROR_PROXY_ILLEGAL_PARAM           _EC(402)    // proxy user parameter is not legal
#define NET_ERROR_PROXY_INVALID_HANDLE          _EC(403)    // handle invalid
#define NET_ERROR_PROXY_LOGIN_DEVICE_ERROR      _EC(404)    // login device error
#define NET_ERROR_PROXY_START_SERVER_ERROR      _EC(405)    // start proxy server error
#define NET_ERROR_SPEAK_FAILED                  _EC(406)    // request speak failed
#define NET_ERROR_NOT_SUPPORT_F6                _EC(407)    // unsupport F6
#define NET_ERROR_CD_UNREADY                    _EC(408)    // CD is not ready
#define NET_ERROR_DIR_NOT_EXIST                 _EC(409)    // Directory does not exist
#define NET_ERROR_UNSUPPORTED_SPLIT_MODE        _EC(410)    // The device does not support the segmentation model
#define NET_ERROR_OPEN_WND_PARAM                _EC(411)    // Open the window parameter is illegal
#define NET_ERROR_LIMITED_WND_COUNT             _EC(412)    // Open the window more than limit
#define NET_ERROR_UNMATCHED_REQUEST             _EC(413)    // Request command with the current pattern don't match
#define NET_RENDER_ENABLELARGEPICADJUSTMENT_ERROR  _EC(414) // Render Library to enable high-definition image internal adjustment strategy error
#define NET_ERROR_UPGRADE_FAILED                _EC(415)    // Upgrade equipment failure
#define NET_ERROR_NO_TARGET_DEVICE              _EC(416)    // Can't find the target device
#define NET_ERROR_NO_VERIFY_DEVICE              _EC(417)    // Can't find the verify device 
#define NET_ERROR_CASCADE_RIGHTLESS             _EC(418)    // No cascade permissions
#define NET_ERROR_LOW_PRIORITY                  _EC(419)    // low priority
#define NET_ERROR_REMOTE_REQUEST_TIMEOUT        _EC(420)    // The remote device request timeout
#define NET_ERROR_LIMITED_INPUT_SOURCE          _EC(421)    // Input source beyond maximum route restrictions
#define NET_ERROR_SET_LOG_PRINT_INFO            _EC(422)    // Failed to set log print
#define NET_ERROR_PARAM_DWSIZE_ERROR            _EC(423)    // "dwSize" is not initialized in input param
#define NET_ERROR_LIMITED_MONITORWALL_COUNT     _EC(424)    // TV wall exceed limit
#define NET_ERROR_PART_PROCESS_FAILED           _EC(425)    // Fail to execute part of the process
#define NET_ERROR_TARGET_NOT_SUPPORT            _EC(426)    // Fail to transmit due to not supported by target
#define NET_ERROR_VISITE_FILE                   _EC(510)    // Access to the file failed
#define NET_ERROR_DEVICE_STATUS_BUSY            _EC(511)    // Device busy
#define NET_USER_PWD_NOT_AUTHORIZED             _EC(512)    // Fail to change the password
#define NET_USER_PWD_NOT_STRONG                 _EC(513)    // Password strength is not enough
#define NET_ERROR_NO_SUCH_CONFIG                _EC(514)    // No corresponding setup
#define NET_ERROR_AUDIO_RECORD_FAILED           _EC(515)    // Failed to record audio
#define NET_ERROR_SEND_DATA_FAILED              _EC(516)    // Failed to send out data 
#define NET_ERROR_OBSOLESCENT_INTERFACE         _EC(517)    // Abandoned port 
#define NET_ERROR_INSUFFICIENT_INTERAL_BUF      _EC(518)    // Internal buffer is not sufficient 
#define NET_ERROR_NEED_ENCRYPTION_PASSWORD      _EC(519)    // verify password when changing device IP
#define NET_ERROR_NOSUPPORT_RECORD              _EC(520)    // device not support the record
#define NET_ERROR_SERIALIZE_ERROR               _EC(1010)   // Failed to serialize data
#define NET_ERROR_DESERIALIZE_ERROR             _EC(1011)   // Failed to deserialize data
#define NET_ERROR_LOWRATEWPAN_ID_EXISTED        _EC(1012)   // the wireless id is already existed
#define NET_ERROR_LOWRATEWPAN_ID_LIMIT          _EC(1013)   // the wireless id limited
#define NET_ERROR_LOWRATEWPAN_ID_ABNORMAL       _EC(1014)   // add the wireless id abnormaly
#define NET_ERROR_ENCRYPT                       _EC(1015)    // encrypt data fail
#define NET_ERROR_PWD_ILLEGAL                   _EC(1016)    // new password illegal
#define NET_ERROR_DEVICE_ALREADY_INIT           _EC(1017)    // device is already init
#define NET_ERROR_SECURITY_CODE                 _EC(1018)    // security code check out fail
#define NET_ERROR_SECURITY_CODE_TIMEOUT         _EC(1019)    // security code out of time
#define NET_ERROR_GET_PWD_SPECI                 _EC(1020)    // get passwd specification fail
#define NET_ERROR_NO_AUTHORITY_OF_OPERATION     _EC(1021)    // no authority of operation 
#define NET_ERROR_DECRYPT                       _EC(1022)    // decrypt data fail
#define NET_ERROR_2D_CODE                       _EC(1023)    // 2D code check out fail
#define NET_ERROR_INVALID_REQUEST               _EC(1024)    // invalid request
#define	NET_ERROR_PWD_RESET_DISABLE			    _EC(1025)	 // pwd reset disabled
#define NET_ERROR_PLAY_PRIVATE_DATA             _EC(1026)    // failed to display private data,such as rule box
#define NET_ERROR_ROBOT_OPERATE_FAILED          _EC(1027)    // robot operate failed
#define NET_ERROR_PHOTOSIZE_EXCEEDSLIMIT        _EC(1028)    // photosize exceeds limit
#define NET_ERROR_USERID_INVALID                _EC(1029)    // userid invalid
#define NET_ERROR_EXTRACTFEATURE_FAILED         _EC(1030)    // photo extract feature failed
#define NET_ERROR_PHOTO_EXIST                   _EC(1031)    // photo exist
#define NET_ERROR_PHOTO_OVERFLOW                _EC(1032)    // photo over flow
#define NET_ERROR_CHANNEL_ALREADY_OPENED		_EC(1033)	 // channel has already been opened
#define NET_ERROR_CREATE_SOCKET					_EC(1034)	 // create socket error
#define NET_ERROR_CHANNEL_NUM					_EC(1035)	 // invalid channel num
#define NET_ERROR_PHOTO_FORMAT					_EC(1036)	 // photo format error



#define NET_ERROR_DIGITAL_CERTIFICATE_INTERNAL_ERROR				_EC(1037)		  // Internal error
#define NET_ERROR_DIGITAL_CERTIFICATE_GET_ID_FAILED					_EC(1038)		  // Get ID failed
#define NET_ERROR_DIGITAL_CERTIFICATE_IMPORT_ILLEGAL				_EC(1039)		  // Import illegal
#define NET_ERROR_DIGITAL_CERTIFICATE_SN_ERROR						_EC(1040)		  // SN error
#define NET_ERROR_DIGITAL_CERTIFICATE_COMMON_NAME_ILLEGAL			_EC(1041)		  // Cert common name illegal
#define NET_ERROR_DIGITAL_CERTIFICATE_NO_ROOT_CERT					_EC(1042)		  // No root cert
#define NET_ERROR_DIGITAL_CERTIFICATE_CERT_REVOKED					_EC(1043)		  // Cert revoked
#define NET_ERROR_DIGITAL_CERTIFICATE_CERT_INVALID					_EC(1044)		  // Cert invalid
#define NET_ERROR_DIGITAL_CERTIFICATE_CERT_ERROR_SIGN				_EC(1045)		  // Cert error sign
#define NET_ERROR_DIGITAL_CERTIFICATE_COUNTS_UPPER_LIMIT			_EC(1046)		  // Counts upper limit
#define NET_ERROR_DIGITAL_CERTIFICATE_CERT_NO_EXIST					_EC(1047)		  // Cert no exist
#define NET_ERROR_DEFULAT_SEARCH_PORT			_EC(1048)	 // default search port can't use5050,37810
#define NET_ERROR_FACE_RECOGNITION_SERVER_MULTI_APPEND_STOUP				_EC(1049)			// face recognition server multi append stop
#define	NET_ERROR_FACE_RECOGNITION_SERVER_MULTI_APPEND_ERROR				_EC(1050)			// face recognition server multi append error
#define	NET_ERROR_FACE_RECOGNITION_SERVER_GROUP_ID_EXCEED					_EC(1051)			// face recognition server group id exceed
#define	NET_ERROR_FACE_RECOGNITION_SERVER_GROUP_ID_NOT_IN_REGISTER_GROUP	_EC(1052)			// face recognition server group id not in register group
#define	NET_ERROR_FACE_RECOGNITION_SERVER_PICTURE_NOT_FOUND					_EC(1053)			// face recognition server picture not found
#define	NET_ERROR_FACE_RECOGNITION_SERVER_GENERATE_GROUP_ID_FAILED			_EC(1054)			// face recognition server generate group id failed
#define	NET_ERROR_FACE_RECOGNITION_SERVER_SET_CONFIG_FAILED					_EC(1055)			// face recognition server set config failed
#define NET_ERROR_FACE_RECOGNITION_SERVER_FILE_OPEN_FAILED					_EC(1056)			// face recognition server file open failed
#define	NET_ERROR_FACE_RECOGNITION_SERVER_FILE_READ_FAILED					_EC(1057)			// face recognition server file read failed
#define NET_ERROR_FACE_RECOGNITION_SERVER_FILE_WRITE_FAILED					_EC(1058)			// face recognition server file write failed
#define	NET_ERROR_FACE_RECOGNITION_SERVER_PICTURE_DPI_ERROR					_EC(1059)			// face recognition server picture dpi error
#define	NET_ERROR_FACE_RECOGNITION_SERVER_PICTURE_PX_ERROR					_EC(1060)			// face recognition server picture px error
#define	NET_ERROR_FACE_RECOGNITION_SERVER_PICTURE_SIZE_ERROR				_EC(1061)			// face recognition server picture size error
#define	NET_ERROR_FACE_RECOGNITION_SERVER_DATA_BASE_ERROR					_EC(1062)			// face recognition server database error
#define	NET_ERROR_FACE_RECOGNITION_SERVER_FACE_MAX_NUM						_EC(1063)			// face recognition server face max num
#define	NET_ERROR_FACE_RECOGNITION_SERVER_BIRTH_DAY_FORMAT_ERROR			_EC(1064)			// face recognition server birthday format error
#define	NET_ERROR_FACE_RECOGNITION_SERVER_UID_ERROR							_EC(1065)			// face recognition server uid error
#define	NET_ERROR_FACE_RECOGNITION_SERVER_TOKEN_ERROR						_EC(1066)			// face recognition server token error
#define	NET_ERROR_FACE_RECOGNITION_SERVER_BEGIN_NUM_OVER_RUN				_EC(1067)			// face recognition server begin num over run
#define	NET_ERROR_FACE_RECOGNITION_SERVER_ABSTRACT_NUM_ZERO					_EC(1068)			// face recognition server abstract num zero
#define	NET_ERROR_FACE_RECOGNITION_SERVER_ABSTRACT_INIT_ERROR				_EC(1069)			// face recognition server abstract init error
#define	NET_ERROR_FACE_RECOGNITION_SERVER_AUTO_ABSTRACT_STATE				_EC(1070)			// face recognition server auto abstract state
#define	NET_ERROR_FACE_RECOGNITION_SERVER_ABSTRACT_STATE					_EC(1071)			// face recognition server abstract state
#define	NET_ERROR_FACE_RECOGNITION_SERVER_IM_EX_STATE						_EC(1072)			// face recognition server im ex state
#define	NET_ERROR_FACE_RECOGNITION_SERVER_PIC_WRITE_FAILED					_EC(1073)			// face recognition server pic write failed
#define	NET_ERROR_FACE_RECOGNITION_SERVER_GROUP_SPACE_EXCEED				_EC(1074)			// face recognition server group space exceed 
#define	NET_ERROR_FACE_RECOGNITION_SERVER_GROUP_PIC_COUNT_EXCEED			_EC(1075)			// face recognition server group pic count exceed
#define	NET_ERROR_FACE_RECOGNITION_SERVER_GROUP_NOT_FOUND					_EC(1076)			// face recognition server group not found
#define	NET_ERROR_FACE_RECOGNITION_SERVER_FIND_RECORDS_ERROR				_EC(1077)			// face recognition server find record error
#define	NET_ERROR_FACE_RECOGNITION_SERVER_DELETE_PERSON_ERROR				_EC(1078)			// face recognition server delete person error
#define NET_ERROR_FACE_RECOGNITION_SERVER_DELETE_GROUP_ERROR                _EC(1079)           // face recognition server delete group error
#define NET_ERROR_FACE_RECOGNITION_SERVER_NAME_FORMAT_ERROR                 _EC(1080)           // face recognition server name format error
#define NET_ERROR_FACE_RECOGNITION_SERVER_FILEPATH_NOT_SET                  _EC(1081)           // face recognition server file path not set

#define NET_ERROR_DEVICE_PARSE_PROTOCOL			_EC(1079)	 // device parses protocol error
#define NET_ERROR_DEVICE_INVALID_REQUEST		_EC(1080)	 // device returns invalid request
#define NET_ERROR_DEVICE_INTERNAL_ERROR			_EC(1081)	 // device internal error
#define NET_ERROR_DEVICE_REQUEST_TIMEOUT		_EC(1082)	 // device internal request timeout
#define NET_ERROR_DEVICE_KEEPALIVE_FAIL			_EC(1083)	 // device keeps alive fail
#define NET_ERROR_DEVICE_NETWORK_ERROR			_EC(1084)	 // device network error
#define NET_ERROR_DEVICE_UNKNOWN_ERROR			_EC(1085)	 // device unknown error
#define NET_ERROR_DEVICE_COM_INTERFACE_NOTFOUND	_EC(1086)	 // device not found com interface
#define NET_ERROR_DEVICE_COM_IMPLEMENT_NOTFOUND	_EC(1087)	 // device not found com implement
#define NET_ERROR_DEVICE_COM_NOTFOUND			_EC(1088)	 // device not found client component 
#define NET_ERROR_DEVICE_COM_INSTANCE_NOTEXIST	_EC(1089)	 // device not found client com instance
#define NET_ERROR_DEVICE_CREATE_COM_FAIL		_EC(1090)	 // device creates com fail
#define NET_ERROR_DEVICE_GET_COM_FAIL			_EC(1091)	 // device gets com instance fail
#define NET_ERROR_DEVICE_BAD_REQUEST			_EC(1092)	 // device can not accept bad request
#define NET_ERROR_DEVICE_REQUEST_IN_PROGRESS	_EC(1093)	 // device does not accept repeat request when in progressing
#define NET_ERROR_DEVICE_LIMITED_RESOURCE		_EC(1094)	 // device limited resource
#define NET_ERROR_DEVICE_BUSINESS_TIMEOUT		_EC(1095)	 // device business timeout
#define NET_ERROR_DEVICE_TOO_MANY_REQUESTS		_EC(1096)	 // device accepts too many requests
#define NET_ERROR_DEVICE_NOT_ALREADY			_EC(1097)	 // device not already and cannot accept request
#define NET_ERROR_DEVICE_SEARCHRECORD_TIMEOUT	_EC(1098)	 // device searchs record timeout
#define NET_ERROR_DEVICE_SEARCHTIME_INVALID		_EC(1099)	 // device checks search record time invalid
#define NET_ERROR_DEVICE_SSID_INVALID			_EC(1100)	 // device checks SSID invalid
#define NET_ERROR_DEVICE_CHANNEL_STREAMTYPE_ERROR		_EC(1101)	// device checks channel or streamtype invalid
#define NET_ERROR_DEVICE_STREAM_PACKINGFORMAT_UNSUPPORT	_EC(1102)	// device does not support stream packing format
#define NET_ERROR_DEVICE_AUDIO_ENCODINGFORMAT_UNSUPPORT	_EC(1103)	// device does not support audio encoding format

#define NET_ERROR_SECURITY_ERROR_SUPPORT_GUI            _EC(1104)    // check request security failed, using local GUI reset password
#define NET_ERROR_SECURITY_ERROR_SUPPORT_MULT           _EC(1105)    // check request security failed, using dahua APP or configtool reset password
#define NET_ERROR_SECURITY_ERROR_SUPPORT_UNIQUE         _EC(1106)	// check request security failed, using Web reset password

#define NET_ERROR_STREAMCONVERTOR_DEFECT				_EC(1107)	// streamconvertor defect



#define NET_ERROR_SECURITY_GENERATE_SAFE_CODE           _EC(1108)	// generate safe code failed
#define NET_ERROR_SECURITY_GET_CONTACT                  _EC(1109)	// get contact failed
#define NET_ERROR_SECURITY_GET_QRCODE                   _EC(1110)	// get QR code information failed of reset passwd
#define NET_ERROR_SECURITY_CANNOT_RESET                 _EC(1111)	// device uninitialized, can't reset
#define NET_ERROR_SECURITY_NOT_SUPPORT_CONTACT_MODE     _EC(1112)	// unsupported contact mode
#define NET_ERROR_SECURITY_RESPONSE_TIMEOUT             _EC(1113)	// server response time out
#define NET_ERROR_SECURITY_AUTHCODE_FORBIDDEN           _EC(1114)	// had check AuthCode too much, forbid check
#define NET_ERROR_TRANCODE_LOGIN_REMOTE_DEV				_EC(1115)	// (virtual transcode)login remote device failed
#define	NET_ERROR_TRANCODE_NOFREE_CHANNEL				_EC(1116)	// (virtual transcode)no free virtual channel
#define NET_ERROR_VK_INFO_DECRYPT_FAILED				_EC(1117)	// VK info decrypt failed
#define NET_ERROR_VK_INFO_DESERIALIZE_FAILED			_EC(1118)	// VK info deserial failed 
#define NET_ERROR_GDPR_ABILITY_NOT_ENABLE				_EC(1119)	// SDK GDPR ability not enable

/*error code of access control import an fast check. start*/
#define NET_ERROR_FAST_CHECK_NO_AUTH					_EC(1120)	// access control fast check:no authority
#define NET_ERROR_FAST_CHECK_NO_FILE					_EC(1121)	// access control fast check:file does not exist
#define NET_ERROR_FAST_CHECK_FILE_FAIL					_EC(1122)	// access control fast check:fail to prepare file
#define NET_ERROR_FAST_CHECK_BUSY						_EC(1123)	// access control fast check:system is busy
#define NET_ERROR_FAST_CHECK_NO_PASSWORD				_EC(1124)	// access control fast check:no password, and import is not allowed
#define NET_ERROR_IMPORT_ACCESS_SEND_FAILD				_EC(1125)	// access control fast import:fail to send access control data
#define NET_ERROR_IMPORT_ACCESS_BUSY					_EC(1126)	// access control fast import:system is busy
#define NET_ERROR_IMPORT_ACCESS_DATAERROR				_EC(1127)	// access control fast import:packet data check failed
#define NET_ERROR_IMPORT_ACCESS_DATAINVALID				_EC(1128)	// access control fast import:illegal packet data
#define NET_ERROR_IMPORT_ACCESS_SYNC_FALID				_EC(1129)	// access control fast import:fail to synchronization
#define NET_ERROR_IMPORT_ACCESS_DBFULL					_EC(1130)	// access control fast import:data base is full
#define NET_ERROR_IMPORT_ACCESS_SDFULL					_EC(1131)	// access control fast import:SD is full
#define NET_ERROR_IMPORT_ACCESS_CIPHER_ERROR			_EC(1132)	// access control fast import:password error
/*error code of access control import an fast check. end*/

#define NET_ERROR_INVALID_PARAM							_EC(1133)	// invalid param
#define NET_ERROR_INVALID_PASSWORD						_EC(1134)	// invalid password
#define NET_ERROR_INVALID_FINGERPRINT					_EC(1135)	// invalid finger print
#define NET_ERROR_INVALID_FACE							_EC(1136)	// invalid face
#define NET_ERROR_INVALID_CARD							_EC(1137)	// invalid card
#define NET_ERROR_INVALID_USER							_EC(1138)	// invalid user
#define NET_ERROR_GET_SUBSERVICE						_EC(1139)	// device get sub service fail
#define NET_ERROR_GET_METHOD							_EC(1140)   // device get method fail
#define NET_ERROR_GET_SUBCAPS							_EC(1141) 	// device get sub caps fail
#define NET_ERROR_UPTO_INSERT_LIMIT						_EC(1142)   // up to insert limit
#define NET_ERROR_UPTO_MAX_INSERT_RATE					_EC(1143)   // up tp max insert rate
#define NET_ERROR_ERASE_FINGERPRINT						_EC(1144)   // erase finger print data fail
#define NET_ERROR_ERASE_FACE							_EC(1145)   // erase face data fail
#define NET_ERROR_ERASE_CARD							_EC(1146)   // erase card data  fail
#define NET_ERROR_NO_RECORD								_EC(1147)   // no record
#define NET_ERROR_NOMORE_RECORDS						_EC(1148)   // no more records
#define NET_ERROR_RECORD_ALREADY_EXISTS					_EC(1149)   // record already exist
#define NET_ERROR_EXCEED_MAX_FINGERPRINT_PERUSER		_EC(1150)   // exceed max finger print per user
#define NET_ERROR_EXCEED_MAX_CARD_PERUSER				_EC(1151)   // exceed max card per user	
#define NET_ERROR_EXCEED_ADMINISTRATOR_LIMIT			_EC(1152)   // exceed administrator limit

#define NET_LOGIN_ERROR_DEVICE_NOT_SUPPORT_HIGHLEVEL_SECURITY_LOGIN		_EC(1153)   // device not support high level security login
#define NET_LOGIN_ERROR_DEVICE_ONLY_SUPPORT_HIGHLEVEL_SECURITY_LOGIN	_EC(1154)   // device only support high level security login
#define NET_ERROR_VIDEO_CHANNEL_OFFLINE                 _EC(1155)   // current video channel is offline, play failed 
#define NET_ERROR_USERID_FORMAT_INCORRECT				_EC(1156)	// The format of  the User ID is incorrect - should be all digital numbers
#define NET_ERROR_CANNOT_FIND_CHANNEL_RELATE_TO_SN		_EC(1157)	// The corresponding channel to this serial number could not be found
#define NET_ERROR_TASK_QUEUE_OF_CHANNEL_IS_FULL			_EC(1158)	// The task queue for this channel is full
#define NET_ERROR_APPLY_USER_INFO_BLOCK_FAIL			_EC(1159)	// Applying for new user information blocks failed
#define NET_ERROR_EXCEED_MAX_PASSWD_PERUSER				_EC(1160)	// The maximum number of user's password exceeded
#define NET_ERROR_PARSE_PROTOCOL						_EC(1161)	// Internal error when parsing protocol packages
#define	NET_ERROR_CARD_NUM_EXIST						_EC(1162)	// card num already exist
#define	NET_ERROR_FINGERPRINT_EXIST						_EC(1163)	// finger print already exist
#define NET_ERROR_OPEN_PLAYGROUP_FAIL					_EC(1164)	// open play group fail
#define NET_ERROR_ALREADY_IN_PLAYGROUP					_EC(1165)	// play handle already in play group
#define NET_ERROR_QUERY_PLAYGROUP_TIME_FAIL				_EC(1166)	// query play group time fail
#define NET_ERROR_SET_PLAYGROUP_BASECHANNEL_FAIL		_EC(1167)	// set play group base channel fail
#define NET_ERROR_SET_PLAYGROUP_DIRECTION_FAIL			_EC(1168)	// set play group direction fail
#define NET_ERROR_SET_PLAYGROUP_SPEED_FAIL				_EC(1169)	// set play group speed fail
#define NET_ERROR_ADD_PLAYGROUP_FAIL					_EC(1170)	// add play handle to play group fail

#define NET_ERROR_EXPORT_AOL_LOGFILE_NO_AUTH			_EC(1171)	// export aol log file:no auth
#define NET_ERROR_EXPORT_AOL_LOGFILE_NO_FILE			_EC(1172)	// export aol log file:no file
#define NET_ERROR_EXPORT_AOL_LOGFILE_FILE_FAIL			_EC(1173)	// export aol log file:prepare file fail
#define NET_ERROR_EXPORT_AOL_LOGFILE_BUSY				_EC(1174)	// export aol log file:device busy


// Error codes related to app installation on equipment
#define NET_ERROR_EMPTY_LICENSE                         _EC(1175)   // Empty license 
#define NET_ERROR_UNSUPPORTED_MODE                      _EC(1176)   // Unsupported mode
#define NET_ERROR_URL_APP_NOT_MATCH                     _EC(1177)   // Url and App are not match
#define NET_ERROR_READ_INFO_FAILED                      _EC(1178)   // Read info failed
#define NET_ERROR_WRITE_FAILED                          _EC(1179)   // Write failed
#define NET_ERROR_NO_SUCH_APP                           _EC(1180)   // No such App
#define NET_ERROR_VERIFIF_FAILED                        _EC(1181)   // Verify failed
#define NET_ERROR_LICENSE_OUT_DATE                      _EC(1182)   // License out of date
#define NET_ERROR_UPGRADE_PROGRAM_TOO_OLD				_EC(1183)	// upgrade program version too old


/************************************************************************
 ** Enumeration Definition
 ***********************************************************************/


//Card information types CLIENT_QueryNetStat interface using
typedef enum tagEM_NET_QUERY_TYPE
{
	NET_APP_DATA_STAT , // Statistics for protocol stack,(input struct NET_IN_NETAPP_NET_DATA_STAT,output struct NET_OUT_NETAPP_NET_DATA_STAT)
	NET_APP_LINK_STAT , // Access to physical link state,(input struct NET_IN_NETAPP_LINK_STATUS,output struct NET_OUT_NETAPP_LINK_STATUS)
}EM_NET_QUERY_TYPE;

// Catch a figure type CLIENT_CapturePictureEx interface using
typedef enum tagNET_CAPTURE_FORMATS
{
    NET_CAPTURE_BMP,        // BMP
    NET_CAPTURE_JPEG,       // 100% quality JPEG
    NET_CAPTURE_JPEG_70,    // 70% quality JPEG
    NET_CAPTURE_JPEG_50,    // 50% quality JPEG
    NET_CAPTURE_JPEG_30,    // 30% quality JPEG
    NET_CAPTURE_JPEG_10     // 10% quality JPEG
}NET_CAPTURE_FORMATS;

// Device type
typedef enum tagNET_DEVICE_TYPE 
{
	NET_PRODUCT_NONE = 0,
	NET_DVR_NONREALTIME_MACE,					// Non real-time MACE
	NET_DVR_NONREALTIME,						// Non real-time
	NET_NVS_MPEG1,								// Network video server
	NET_DVR_MPEG1_2,							// MPEG1 2-ch DVR
	NET_DVR_MPEG1_8,							// MPEG1 8-ch DVR
	NET_DVR_MPEG4_8,							// MPEG4 8-ch DVR
	NET_DVR_MPEG4_16,							// MPEG4 16-ch DVR
	NET_DVR_MPEG4_SX2,							// LB series DVR
	NET_DVR_MEPG4_ST2,							// GB  series DVR
	NET_DVR_MEPG4_SH2,							// HB  series DVR
	NET_DVR_MPEG4_GBE,							// GBE  series DVR
	NET_DVR_MPEG4_NVSII,						// II network video server
	NET_DVR_STD_NEW,							// New standard configuration protocol
	NET_DVR_DDNS,								// DDNS server
	NET_DVR_ATM,								// ATM series 
	NET_NB_SERIAL,								// 2nd non real-time NB series DVR
	NET_LN_SERIAL,								// LN  series 
	NET_BAV_SERIAL,								// BAV series
	NET_SDIP_SERIAL,							// SDIP series
	NET_IPC_SERIAL,								// IPC series
	NET_NVS_B,									// NVS B series
	NET_NVS_C,									// NVS H series 
	NET_NVS_S,									// NVS S series
	NET_NVS_E,									// NVS E series
	NET_DVR_NEW_PROTOCOL,						// Search device type from QueryDevState. it is in string format
	NET_NVD_SERIAL,								// NVD
	NET_DVR_N5,									// N5
	NET_DVR_MIX_DVR,							// HDVR
	NET_SVR_SERIAL,								// SVR series
	NET_SVR_BS,									// SVR-BS
	NET_NVR_SERIAL,								// NVR series
	NET_DVR_N51,                                // N51
	NET_ITSE_SERIAL,							// ITSE Intelligent Analysis Box
	NET_ITC_SERIAL,                             // Intelligent traffic camera equipment
	NET_HWS_SERIAL,                             // radar speedometer HWS
	NET_PVR_SERIAL,                             // portable video record
	NET_IVS_SERIAL,                             // IVS(intelligent video server series)
	NET_IVS_B,                                  // universal intelligent detect video server series 
	NET_IVS_F,                                  // face recognisation server
	NET_IVS_V,                                  // video quality diagnosis server
	NET_MATRIX_SERIAL,							// matrix
	NET_DVR_N52,								// N52
	NET_DVR_N56,								// N56
	NET_ESS_SERIAL,                             // ESS
	NET_IVS_PC,                                 // number statistic server
	NET_PC_NVR,                                 // pc-nvr
	NET_DSCON,									// screen controller
	NET_EVS,									// network video storage server
	NET_EIVS,									// an embedded intelligent video analysis system
	NET_DVR_N6,                                 // DVR-N6
	NET_UDS,                                    // K-Lite Codec Pack
	NET_AF6016,									// Bank alarm host
	NET_AS5008,									// Video network alarm host
	NET_AH2008,									// Network alarm host
	NET_A_SERIAL,								// Alarm host series
	NET_BSC_SERIAL,								// Access control series of products
    NET_NVS_SERIAL,                             // NVS series product
    NET_VTO_SERIAL,                             // VTO series product
    NET_VTNC_SERIAL,                            // VTNC series product
    NET_TPC_SERIAL,               				// TPC series product, it is the thermal device 
    NET_ASM_SERIAL,                             // ASM series product
    NET_VTS_SERIAL,                             // VTS series product
    NET_ARC2016C,                               // Alarm host-ARC2016C    
    NET_ASA,                                    // ASA Attendance machine
	NET_VTT_SERIAL,								// Industry terminal walkie-talkie
	NET_VTA_SERIAL,								// Alarm column
	NET_VTNS_SERIAL,							// SIP Server
	NET_VTH_SERIAL,								// Indoor unit
	NET_IVSS,									// IVSS
    NET_ASG,                                    // ASG
	NET_RADAR,             						// Radar series
	NET_RADAR_PTZ,								// Radar SD
	NET_RADAR_CAM,								// Radar IPC
	NET_ASE,					  				// lift controller
}NET_DEVICE_TYPE ;

// Language type
typedef enum __LANGUAGE_TYPE
{
	DH_LANGUAGE_ENGLISH,						// English 
	DH_LANGUAGE_CHINESE_SIMPLIFIED,				// Simplified Chinese
	DH_LANGUAGE_CHINESE_TRADITIONAL,			// Traditional Chinese
	DH_LANGUAGE_ITALIAN,						// Italian 
	DH_LANGUAGE_SPANISH,						// Spanish
	DH_LANGUAGE_JAPANESE,						// Japanese
	DH_LANGUAGE_RUSSIAN,						// Russian 
	DH_LANGUAGE_FRENCH,							// French
	DH_LANGUAGE_GERMAN, 						// German
	DH_LANGUAGE_PORTUGUESE,						// Portuguese
	DH_LANGUAGE_TURKEY,							// Turkey	
	DH_LANGUAGE_POLISH,							// Polish
	DH_LANGUAGE_ROMANIAN,						// Romanian 
	DH_LANGUAGE_HUNGARIAN,						// Hungarian
	DH_LANGUAGE_FINNISH,						// Finnish
	DH_LANGUAGE_ESTONIAN,						// Estonian	
	DH_LANGUAGE_KOREAN,							// Korean
	DH_LANGUAGE_FARSI,							// Farsi	
	DH_LANGUAGE_DANSK,							// Denmark
	DH_LANGUAGE_CZECHISH,						// Czechish
	DH_LANGUAGE_BULGARIA,						// Bulgaria
	DH_LANGUAGE_SLOVAKIAN,						// Slovakian
	DH_LANGUAGE_SLOVENIA,						// Slovenia
	DH_LANGUAGE_CROATIAN,						// Croatian
	DH_LANGUAGE_DUTCH,							// Dutch
	DH_LANGUAGE_GREEK,							// Greek
	DH_LANGUAGE_UKRAINIAN,						// Ukrainian
	DH_LANGUAGE_SWEDISH,						// Swedish
	DH_LANGUAGE_SERBIAN,						// Serbian
	DH_LANGUAGE_VIETNAMESE,						// Vietnamese
	DH_LANGUAGE_LITHUANIAN,						// Lithuanian
	DH_LANGUAGE_FILIPINO,						// Filipino
	DH_LANGUAGE_ARABIC,							// Arabic
	DH_LANGUAGE_CATALAN,						// Catalan
	DH_LANGUAGE_LATVIAN,						// Latvian
	DH_LANGUAGE_THAI,							// Thai
	DH_LANGUAGE_HEBREW,							// Hebrew
	DH_LANGUAGE_Bosnian,						// Bosnian
} DH_LANGUAGE_TYPE;

// Upgrade type
typedef enum __EM_UPGRADE_TYPE
{
	DH_UPGRADE_BIOS_TYPE = 1,					// BIOS  upgrade
	DH_UPGRADE_WEB_TYPE,						// WEB upgrade
	DH_UPGRADE_BOOT_YPE,						// BOOT upgrade
	DH_UPGRADE_CHARACTER_TYPE,					// Chinese character library
	DH_UPGRADE_LOGO_TYPE,						// LOGO
	DH_UPGRADE_EXE_TYPE,						// EXE such as player
    DH_UPGRADE_DEVCONSTINFO_TYPE,               // upgrade device information
    DH_UPGRADE_PERIPHERAL_TYPE,                 // Peripheral access from (such as car 287 chip)
	DH_UPGRADE_GEOINFO_TYPE,                    // Geographic information positioning chip
	DH_UPGRADE_MENU,                            // Menu (equipment operation interface of the picture)
	DH_UPGRADE_ROUTE,                           // Line files (such as bus lines)
	DH_UPGRADE_ROUTE_STATE_AUTO,                // Stops the audio (with line stops audio)
	DH_UPGRADE_SCREEN,                          // Scheduling screen (e.g., bus operation panel)
} EM_UPGRADE_TYPE;

// Record related (schedule,motion detection,alarm)
typedef enum __REC_TYPE
{
	DH_REC_TYPE_TIM = 0,
	DH_REC_TYPE_MTD,
	DH_REC_TYPE_ALM,
	DH_REC_TYPE_NUM,
} REC_TYPE;

// network type  
typedef enum __GPRSCDMA_NETWORK_TYPE
{
	DH_TYPE_AUTOSEL = 0,						// Automatic selection
	DH_TYPE_TD_SCDMA,							// TD-SCDMA network 
	DH_TYPE_WCDMA,								// WCDMA network
	DH_TYPE_CDMA_1x,							// CDMA 1.x network
	DH_TYPE_EDGE,								// GPRS network
	DH_TYPE_EVDO,								// EVDO network
	DH_TYPE_WIFI,
} EM_GPRSCDMA_NETWORK_TYPE;

// Interface type,responding to the interface CLIENT_SetSubconnCallBack
typedef enum __EM_INTERFACE_TYPE
{
	DH_INTERFACE_OTHER = 0x00000000,			// Unknown interface
	DH_INTERFACE_REALPLAY,						// Realtime monitoring interface
	DH_INTERFACE_PREVIEW,						// Realtime multiple-window preview
	DH_INTERFACE_PLAYBACK,						// Playback interface
	DH_INTERFACE_DOWNLOAD,						// Download interface
	DH_INTERFACE_REALLOADPIC,                   // Download picture interface
} EM_INTERFACE_TYPE;

// realplay disconnect event
typedef enum _EM_REALPLAY_DISCONNECT_EVENT_TYPE
{
	DISCONNECT_EVENT_REAVE,                     // resources is taked by advanced user
	DISCONNECT_EVENT_NETFORBID,                 // forbidden
	DISCONNECT_EVENT_SUBCONNECT,                // sublink disconnect
}EM_REALPLAY_DISCONNECT_EVENT_TYPE;

// event file's tag type
typedef enum __EM_EVENT_FILETAG
{
	DH_ATMBEFOREPASTE = 1,                      // Before ATM Paste
	DH_ATMAFTERPASTE,                           // After ATM Paste
}EM_EVENT_FILETAG;

// IPC type
typedef enum __EM_IPC_TYPE
{
	DH_IPC_PRIVATE,                             // private
	DH_IPC_AEBELL,                              // AEBell
	DH_IPC_PANASONIC,                           // panasonic
	DH_IPC_SONY,                                // sony
	DH_IPC_DYNACOLOR,                           // Dynacolor
	DH_IPC_TCWS = 5 ,                           // TCWS	
	DH_IPC_SAMSUNG,                             // Samsung
	DH_IPC_YOKO,                                // YOKO
	DH_IPC_AXIS,                                // AXIS
	DH_IPC_SANYO,							    // sanyo       
	DH_IPC_BOSH = 10,							// Bosch
	DH_IPC_PECLO,								// PECLO
	DH_IPC_PROVIDEO,							// Provideo
	DH_IPC_ACTI,								// ACTi
	DH_IPC_VIVOTEK,								// Vivotek
	DH_IPC_ARECONT = 15,                        // Arecont
	DH_IPC_PRIVATEEH,			                // PrivateEH	
	DH_IPC_IMATEK,					            // IMatek
	DH_IPC_SHANY,                               // Shany
	DH_IPC_VIDEOTREC,                           // videorec
	DH_IPC_URA = 20,                            // Ura
	DH_IPC_BITICINO,                            // Bticino 
	DH_IPC_ONVIF,                               // Onvif protocol type
	DH_IPC_SHEPHERD,                            // Shepherd
	DH_IPC_YAAN,                                // Yaan
	DH_IPC_AIRPOINT = 25,                       // Airpoint
	DH_IPC_TYCO,                                // TYCO
	DH_IPC_XUNMEI,								// Xunmei
	DH_IPC_HIKVISION,							// HIKVISION
	DH_IPC_LG,                                  // LG
	DH_IPC_AOQIMAN = 30,                        // Aoqiman
	DH_IPC_BAOKANG,                             // baokang  
	DH_IPC_WATCHNET,                            // Watchnet
	DH_IPC_XVISION,                             // Xvision
	DH_IPC_FUSITSU,                             // Fisitu
	DH_IPC_CANON = 35,							// Canon
	DH_IPC_GE,								    // GE
	DH_IPC_Basler,								// Basler
	DH_IPC_Patro,								// Patro
	DH_IPC_CPKNC,								// CPPLUS K series
	DH_IPC_CPRNC = 40,							// CPPLUS R series
	DH_IPC_CPUNC,								// CPPLUS U series
	DH_IPC_CPPLUS,								// cpplus oem 
	DH_IPC_XunmeiS,								// XunmeiS
	DH_IPC_GDDW,								// guangdong power grid
	DH_IPC_PSIA = 45,                           // PSIA
	DH_IPC_GB2818,                              // GB2818	
	DH_IPC_GDYX,                                // GDYX
	DH_IPC_OTHER,                               // custom
	DH_IPC_CPUNR,								// CPPLUS NVR
	DH_IPC_CPUAR = 50,							// CPPLUS DVR
	DH_IPC_AIRLIVE,                             // Airlive	
	DH_IPC_NPE,									// NPE	
	DH_IPC_AXVIEW,								// AXVIEW
    DH_IPC_DFWL,                                // DFWL
	DH_IPC_HYUNDAI = 56,						// HYUNDAI DVR
	DH_IPC_APHD,								// APHD
	DH_IPC_WELLTRANS ,							// WELLTRANS
	DH_IPC_CDJF,								// CDJF
	DH_IPC_JVC = 60,						    // JVC
	DH_IPC_INFINOVA,							// INFINOVA
	DH_IPC_ADT,									// ADT
	DH_IPC_SIVIDI,								// SIVIDI
	DH_IPC_CPUNP,								// CPPLUS PTZ
	DH_IPC_HX = 65,								// HX
	DH_IPC_TJGS,                                // TJGS
    DH_IPC_MULTICAST = 79,                      // Multicast
	DH_IPC_RVI = 84,							// RVi  
	DH_IPC_HONEYWELL = 95,                      // Honeywell
}EM_IPC_TYPE;

// H264 profile rank
typedef enum __EM_H264_PROFILE_RANK
{
    	DH_PROFILE_BASELINE = 1,                 // offer I/P frame, only support progressive and CAVLC
		DH_PROFILE_MAIN,                         // offer I/P/B frame, support progressiv and interlaced,offer CAVLC and CABAC
		DH_PROFILE_EXTENDED,                     // offer I/P/B/SP/SI frame,only support progressive and CAVLC
		DH_PROFILE_HIGH,                         // FRExt,base on Main_Profile:8x8 intra prediction, custom quant, lossless video coding, more yuv
}EM_H264_PROFILE_RANK;

typedef enum __EM_DISK_TYPE
{
    DH_DISK_READ_WRITE,                          // read write disk
		DH_DISK_READ_ONLY,                       // read only disk
		DH_DISK_BACKUP,	                         // back up disk or media disk
		DH_DISK_REDUNDANT,                       // redundancy disk
		DH_DISK_SNAPSHOT,	                     // snapshot disk
}EM_DISK_TYPE;

// stream encrypt algorithm work mode
typedef enum  __EM_ENCRYPT_ALOG_WORKMODE
{
		ENCRYPT_ALOG_WORKMODE_ECB,				// ECB mode
		ENCRYPT_ALOG_WORKMODE_CBC,				// CBC mode
		ENCRYPT_ALOG_WORKMODE_CFB,				// CFB mode
		ENCRYPT_ALOG_WORKMODE_OFB,				// OFB mode
}EM_ENCRYPT_ALOG_WORKMODE;

typedef enum __EM_MOBILE_PPP_STATE
{
	MOBILE_PPP_UP = 0,							// connect has being build
	MOBILE_PPP_DOWN,							// ppp connect has being cut		
	MOBILE_PPP_CONNECTING,						// be connecting		
	MOBILE_PPP_CLOSEING,						// be closing PPP connect
} EM_MOBILE_PPP_STATE;

typedef enum __EM_3GMOBILE_STATE
{
    MOBILE_MODULE_OFF,							// means 3g net card mod is closed   		
	MOBILE_MODULE_STARTING,						// means 3g net card mod is starting
	MOBILE_MODULE_WORKING,						// means 3g net card mod is working
}EM_3GMOBILE_STATE;

typedef enum tagEM_LOGIN_SPAC_CAP_TYPE
{
    EM_LOGIN_SPEC_CAP_TCP               = 0,    // TCP login, default
    EM_LOGIN_SPEC_CAP_ANY               = 1,    // No criteria login
    EM_LOGIN_SPEC_CAP_SERVER_CONN       = 2,    // auto sign up login
    EM_LOGIN_SPEC_CAP_MULTICAST         = 3,    // multicast login, default
    EM_LOGIN_SPEC_CAP_UDP               = 4,    // UDP method login
    EM_LOGIN_SPEC_CAP_MAIN_CONN_ONLY    = 6,    // only main connection login
    EM_LOGIN_SPEC_CAP_SSL               = 7,    // SSL encryption login

    EM_LOGIN_SPEC_CAP_INTELLIGENT_BOX   = 9,    // login IVS box remote device
    EM_LOGIN_SPEC_CAP_NO_CONFIG         = 10,   // login device do not config
    EM_LOGIN_SPEC_CAP_U_LOGIN           = 11,   // USB key device login
    EM_LOGIN_SPEC_CAP_LDAP              = 12,   // LDAP login
    EM_LOGIN_SPEC_CAP_AD                = 13,   // AD, ActiveDirectory,  login
    EM_LOGIN_SPEC_CAP_RADIUS            = 14,   // Radius  login 
    EM_LOGIN_SPEC_CAP_SOCKET_5          = 15,   // Socks5 login
    EM_LOGIN_SPEC_CAP_CLOUD             = 16,   // cloud login
    EM_LOGIN_SPEC_CAP_AUTH_TWICE        = 17,   // dual authentication loin
    EM_LOGIN_SPEC_CAP_TS                = 18,   // TS stream client login
    EM_LOGIN_SPEC_CAP_P2P               = 19,   // web private login
    EM_LOGIN_SPEC_CAP_MOBILE            = 20,   // mobile client login
    EM_LOGIN_SPEC_CAP_INVALID                   // invalid login


}EM_LOGIN_SPAC_CAP_TYPE;

/////////////////////////////////Monitor related/////////////////////////////////

// Preview type.Corresponding to CLIENT_RealPlayEx
typedef enum _RealPlayType
{
	DH_RType_Realplay = 0,						// Real-time preview
	DH_RType_Multiplay,							// Multiple-channel preview 
	DH_RType_Realplay_0,						// Real-time monitor-main stream. It is the same as DH_RType_Realplay
	DH_RType_Realplay_1,						// 1 Real-time monitor -- extra stream 1
	DH_RType_Realplay_2,						// 2 Real-time monitor -- extra stream 2
	DH_RType_Realplay_3,						// 3 Real-time monitor -- extra stream 3
	DH_RType_Multiplay_1,						// Multiple-channel preview--1-window 
	DH_RType_Multiplay_4,						// Multiple-channel preview--4-window
	DH_RType_Multiplay_8,						// Multiple-channel preview--8-window
	DH_RType_Multiplay_9,						// Multiple-channel preview--9-window
	DH_RType_Multiplay_16,						// Multiple-channel preview--16-window
	DH_RType_Multiplay_6,						// Multiple-channel preview--6-window
	DH_RType_Multiplay_12,						// Multiple-channel preview--12-window
    DH_RType_Multiplay_25,                      // Multi-window tour--25-windows
    DH_RType_Multiplay_36,                      // Multi-window preview--36-windows
	DH_RType_Multiplay_64,						// Multi-window preview--64-windows
	DH_RType_Multiplay_255,						// Do not modify the current preview channel number
    DH_RType_Realplay_Test = 255,               // test stream
} DH_RealPlayType;

/////////////////////////////////About PTZ/////////////////////////////////

// General PTZ control command
typedef enum _PTZ_ControlType
{
	DH_PTZ_UP_CONTROL = 0,						// Up
	DH_PTZ_DOWN_CONTROL,						// Down
	DH_PTZ_LEFT_CONTROL,						// Left
	DH_PTZ_RIGHT_CONTROL,						// Right
	DH_PTZ_ZOOM_ADD_CONTROL,					// + Zoom in 
	DH_PTZ_ZOOM_DEC_CONTROL,					// - Zoom out 
	DH_PTZ_FOCUS_ADD_CONTROL,					// - Zoom in 
	DH_PTZ_FOCUS_DEC_CONTROL,					// + Zoom out 
	DH_PTZ_APERTURE_ADD_CONTROL,				// + Aperture 
	DH_PTZ_APERTURE_DEC_CONTROL,				// - Aperture
    DH_PTZ_POINT_MOVE_CONTROL,					// Go to preset 
    DH_PTZ_POINT_SET_CONTROL,					// Set 
    DH_PTZ_POINT_DEL_CONTROL,					// Delete
    DH_PTZ_POINT_LOOP_CONTROL,					// Tour 
    DH_PTZ_LAMP_CONTROL							// Light and wiper 
} DH_PTZ_ControlType;

// PTZ control extensive command 
typedef enum _EXTPTZ_ControlType
{
	DH_EXTPTZ_LEFTTOP = 0x20,					// Upper left
	DH_EXTPTZ_RIGHTTOP,							// Upper right 
	DH_EXTPTZ_LEFTDOWN,							// Down left
	DH_EXTPTZ_RIGHTDOWN,						// Down right 
	DH_EXTPTZ_ADDTOLOOP,						// Add preset to tour		tour	 preset value
	DH_EXTPTZ_DELFROMLOOP,						// Delete preset in tour	tour	 preset value
    DH_EXTPTZ_CLOSELOOP,						// Delete tour				tour		
	DH_EXTPTZ_STARTPANCRUISE,					// Begin pan rotation		
	DH_EXTPTZ_STOPPANCRUISE,					// Stop pan rotation		
	DH_EXTPTZ_SETLEFTBORDER,					// Set left limit		
	DH_EXTPTZ_SETRIGHTBORDER,					// Set right limit	
	DH_EXTPTZ_STARTLINESCAN,					// Begin scanning			
    DH_EXTPTZ_CLOSELINESCAN,					// Stop scanning		
    DH_EXTPTZ_SETMODESTART,						// Start mode	mode line		
    DH_EXTPTZ_SETMODESTOP,						// Stop mode	mode line		
	DH_EXTPTZ_RUNMODE,							// Enable mode	Mode line		
	DH_EXTPTZ_STOPMODE,							// Disable mode	Mode line	
	DH_EXTPTZ_DELETEMODE,						// Delete mode	Mode line
	DH_EXTPTZ_REVERSECOMM,						// Flip
	DH_EXTPTZ_FASTGOTO,							// 3D position	X address(8192)	Y address(8192)	zoom(4)
	DH_EXTPTZ_AUXIOPEN,							// auxiliary open	Auxiliary point	
	DH_EXTPTZ_AUXICLOSE,						// Auxiliary close	Auxiliary point
	DH_EXTPTZ_OPENMENU = 0x36,					// Open dome menu 
	DH_EXTPTZ_CLOSEMENU,						// Close menu 
	DH_EXTPTZ_MENUOK,							// Confirm menu 
	DH_EXTPTZ_MENUCANCEL,						// Cancel menu 
	DH_EXTPTZ_MENUUP,							// menu up 
	DH_EXTPTZ_MENUDOWN,							// menu down
	DH_EXTPTZ_MENULEFT,							// menu left
	DH_EXTPTZ_MENURIGHT,						// Menu right 
	DH_EXTPTZ_ALARMHANDLE = 0x40,				// Alarm activate PTZ param1:Alarm input channel; param2:Alarm activation type  1-preset 2-scan 3-tour; param 3:activation value,such as preset value.
	DH_EXTPTZ_MATRIXSWITCH = 0x41,				// Matrix switch param1:monitor number(video output number);param2:video input number;param3:matrix number 
	DH_EXTPTZ_LIGHTCONTROL,						// Light controller
	DH_EXTPTZ_EXACTGOTO,						// 3D accurately positioning param1:Pan degree(0~3600); param2: tilt coordinates(0~900); param3:zoom(1~128)
	DH_EXTPTZ_RESETZERO,                        // Reset 3D positioning as zero
	DH_EXTPTZ_MOVE_ABSOLUTELY,                  // Absolute motion control commands, param4 corresponding struct PTZ_CONTROL_ABSOLUTELY
	DH_EXTPTZ_MOVE_CONTINUOUSLY,                // Continuous motion control commands, param4 corresponding struct PTZ_CONTROL_CONTINUOUSLY
	DH_EXTPTZ_GOTOPRESET,                       // PTZ control command, at a certain speed to preset locus, param4 corresponding struct PTZ_CONTROL_GOTOPRESET
	DH_EXTPTZ_SET_VIEW_RANGE = 0x49,           	// Set to horizon(param4 corresponding struct PTZ_VIEW_RANGE_INFO)
	DH_EXTPTZ_FOCUS_ABSOLUTELY = 0x4A,         	// Absolute focus(param4 corresponding struct PTZ_FOCUS_ABSOLUTELY)
	DH_EXTPTZ_HORSECTORSCAN = 0x4B,             // Level fan sweep(param4 corresponding PTZ_CONTROL_SECTORSCAN,param1,param2,param3 is invalid)
	DH_EXTPTZ_VERSECTORSCAN = 0x4C,             // Vertical sweep fan(param4correspondingPTZ_CONTROL_SECTORSCAN,param1,param2,param3 is invalid)
	DH_EXTPTZ_SET_ABS_ZOOMFOCUS = 0x4D,         // Set absolute focus, focus on value, param1 for focal length, range: [0-255], param2 as the focus, scope: [0-255], param3, param4 is invalid
    DH_EXTPTZ_SET_FISHEYE_EPTZ = 0x4E,          // Control fish eye PTZ, param4corresponding to structure PTZ_CONTROL_SET_FISHEYE_EPTZ 
    DH_EXTPTZ_SET_TRACK_START = 0x4F,           // Track start control(param4 corresponding to structure  PTZ_CONTROL_SET_TRACK_CONTROL,dwStop set as FALSE, param1, param2, param3 is invalid)
    DH_EXTPTZ_SET_TRACK_STOP = 0x50,            // Track stop control (param4 corresponding to structure PTZ_CONTROL_SET_TRACK_CONTROL,dwStop set as FALSE, param1, param2, param3  is invalid)
    DH_EXTPTZ_RESTART = 0x51,                   // To restart the PTZ(param1,param2,param3,param4 are all invalid ,dwStop set to FALSE )
	DH_EXTPTZ_INTELLI_TRACKMOVE = 0x52,         // Continuous motion control commands,track move,param4 corresponding struct PTZ_CONTROL_INTELLI_TRACKMOVE
    DH_EXTPTZ_SET_FOCUS_REGION = 0x53,          // set the focus region(param4 corresponding to PTZ_CONTROL_SET_FOCUS_REGION,dwStop set to FALSE,param1,param2,param3 are all invalid)
    DH_EXTPTZ_PAUSELINESCAN = 0x54,             // Pause Scan(param1,param2,param3,param4 are all invalid ,dwStop set to FALSE)
	DH_EXTPTZ_INTELLI_SETLENSWISDOMSTATE = 0x55,// Set focus mode when tracking target(param4 corresponding to PTZ_CONTROL_INTELLI_SETLENSWISDOMSTATE, dwStop set to FALSE,param1,param2,param3 are all invalid)
	DH_EXTPTZ_INTELLI_SETFOCUSAREA = 0x56,		// Set focus area when tracking target(param4 corresponding to PTZ_CONTROL_INTELLI_SETFOCUSAREA, dwStop set to FALSE,param1,param2,param3 are all invalid)
												// Note: if target tracking do not need set focus area,user need to set cancel by this interface

	DH_EXTPTZ_UP_TELE = 0x70,					// Up + TELE param1=speed (1-8) 
	DH_EXTPTZ_DOWN_TELE,						// Down + TELE
	DH_EXTPTZ_LEFT_TELE,						// Left + TELE
	DH_EXTPTZ_RIGHT_TELE,						// Right + TELE
	DH_EXTPTZ_LEFTUP_TELE,						// Upper left + TELE
	DH_EXTPTZ_LEFTDOWN_TELE,					// Down left + TELE
	DH_EXTPTZ_TIGHTUP_TELE,						// Upper right + TELE
	DH_EXTPTZ_RIGHTDOWN_TELE,					// Down right + TELE
	DH_EXTPTZ_UP_WIDE,							// Up + WIDE param1=speed (1-8) 
	DH_EXTPTZ_DOWN_WIDE,						// Down + WIDE
	DH_EXTPTZ_LEFT_WIDE,						// Left + WIDE
	DH_EXTPTZ_RIGHT_WIDE,						// Right + WIDE
	DH_EXTPTZ_LEFTUP_WIDE,						// Upper left + WIDE
	DH_EXTPTZ_LEFTDOWN_WIDE,					// Down left+ WIDE
	DH_EXTPTZ_TIGHTUP_WIDE,						// Upper right + WIDE
	DH_EXTPTZ_RIGHTDOWN_WIDE,					// Down right + WIDE
	DH_EXTPTZ_GOTOPRESETSNAP = 0x80,            // goto preset and snap
    DH_EXTPTZ_DIRECTIONCALIBRATION = 0x82,      // calibtate directiontwo direction
    DH_EXTPTZ_SINGLEDIRECTIONCALIBRATION = 0x83,// calibtate directionsingle direction,param4 corresponding to structure NET_IN_CALIBRATE_SINGLEDIRECTION  
    DH_EXTPTZ_MOVE_RELATIVELY = 0x84,			// move Relatively, param4 corresponding to structure NET_IN_MOVERELATIVELY_INFO
    DH_EXTPTZ_SET_DIRECTION = 0x85,				// set PTZ Direction, param4 corresponding to NET_IN_SET_DIRECTION_INFO
	DH_EXTPTZ_TOTAL,							// max command value
} DH_EXTPTZ_ControlType;

// Fish eye electronic PTZ control command 
typedef enum tagNET_FISHEYE_EPTZ_CMD
{
  NET_FISHEYE_EPTZ_CMD_UNKOWN,          // unknown type 
  NET_FISHEYE_EPTZ_CMD_ZOOMIN,          // Zoom in , dwParam1 means step length, range 1-8
  NET_FISHEYE_EPTZ_CMD_ZOOMOUT,         // Zoom out, dwParam1 means step length ,  range 1-8
  NET_FISHEYE_EPTZ_CMD_UP,            	// Move up, dwParam1 means step length ,  range 1-8
  NET_FISHEYE_EPTZ_CMD_DOWN,           	// Move down, dwParam1 means step length ,  range 1-8
  NET_FISHEYE_EPTZ_CMD_LEFT,           	// Move left, dwParam1 means step length ,  range 1-8
  NET_FISHEYE_EPTZ_CMD_RIGHT,           // Move right, dwParam1 means step length ,  range 1-8
  NET_FISHEYE_EPTZ_CMD_ROTATECLOCK,     // Auto clockwise rotation , dwParam1 means step length ,  range 1-8
  NET_FISHEYE_EPTZ_CMD_ROTATEANTICLOCK, // Auto counterclockwise rotation, dwParam1 means step length ,  range 1-8
  NET_FISHEYE_EPTZ_CMD_STOP,           	// End auto rotation
  NET_FISHEYE_EPTZ_CMD_TAPVIEW,         // Display specific location, instant view, dwParam1 means eptz, E-PTZ ,  focus coordinate, as The focus, the rectified image was in the abscissa, take the value does not exceed the rectified output image width
  // dwParam2 means eptz, E-PTZ , The focus of the cordinate, the rectified image was focus on the ordinate, take the value does not exceed the rectified output image 
  NET_FISHEYE_EPTZ_CMD_SHOEREGION,      // Panel Zoom in , wParam1 means selected rectangle center horizontal corrdinate, 
  // dwParam2 means selected rectangle center horizontal coordinate, dwParam3 means selected rectangle width
  // dwParam4 means selected rectangle height
}NET_FISHEYE_EPTZ_CMD;

// Track Control Command
typedef enum tagNET_TRACK_CONTROL_CMD
{
    NET_TRACK_CONTROL_CMD_UP,                       // Move up, dwParam1 means step length range 1-8 
    NET_TRACK_CONTROL_CMD_DOWN,                     // Move down, dwParam1 means step length  range 1-8
    NET_TRACK_CONTROL_CMD_LEFT,                     // Move left, dwParam1 means step length  range 1-8
    NET_TRACK_CONTROL_CMD_RIGHT,                    // Move right, dwParam1 means step length  range 1-8
    NET_TRACK_CONTROL_CMD_SETPRESET,                // Set preset, dwParam1 means preset value
    NET_TRACK_CONTROL_CMD_CLEARPRESET,              // Clear preset, dwParam1 means preset value
    NET_TRACK_CONTROL_CMD_GOTOPRESET,               // Goto preset, dwParam1 means preset value
} NET_TRACK_CONTROL_CMD;

// Fish eye correction mode
typedef enum tagNET_CALIBRATE_MODE
{
  NET_FISHEYE_CALIBRATE_MODE_UNKOWN,           				// unknown mode 
  NET_FISHEYE_CALIBRATE_MODE_ORIGIAL,          				// Original image mode 
  NET_FISHEYE_CALIBRATE_MODE_CONFIG,           				// config mode
  NET_FISHEYE_CALIBRATE_MODE_PANORAMA,         				// global mode 
  NET_FISHEYE_CALIBRATE_MODE_DOUBLEPANORAMA,       			// dual global mode 
  NET_FISHEYE_CALIBRATE_MODE_ORIGIALPLUSTHREEEPTZREGION, 	// 1+3 mode , one original Fish eye plus 3 EPtz images, 
  NET_FISHEYE_CALIBRATE_MODE_SINGLE,           				// Single image EPtz mode , only one EPtz video, 
  NET_FISHEYE_CALIBRATE_MODE_FOUREPTZREGION,       			// 4 image mode , 4 EPtz control image, 
  NET_FISHEYE_CALIBRATE_MODE_NORMAL,           				// normal mode 
}NET_FISHEYE_CALIBRATE_MODE;

typedef enum tagNET_FISHEYE_TYPE
{
  NET_FISHEYE_UNKOWN =0,        	// unknown 
  NET_FISHEYE_CHIP,        			//only support device port Fish eye correction
  NET_FISHEYE_PLUGIN,        		//only support control Fish eye correction
  NET_FISHEYE_CHIP_PLUGIN,        	//support both
}NET_FISHEYE_TYPE;

// Fish eye installation mode 
typedef enum tagNET_FISHEYE_MOUNT_MODE
{
  NET_FISHEYE_MOUNT_MODE_UNKOWN,             // unknown mode          
  NET_FISHEYE_MOUNT_MODE_CEIL,               // ceiling mode 
  NET_FISHEYE_MOUNT_MODE_WALL,               // wall mount mode  
  NET_FISHEYE_MOUNT_MODE_FLOOR,              // ground mode  
}NET_FISHEYE_MOUNT_MODE;

/////////////////////////////////About Log /////////////////////////////////

// Log search type 
typedef enum _DH_LOG_QUERY_TYPE
{
	DHLOG_ALL = 0,								// All logs
	DHLOG_SYSTEM,								// System logs 
	DHLOG_CONFIG,								// Configuration logs 
	DHLOG_STORAGE,								// Storage logs
	DHLOG_ALARM,								// Alarm logs 
	DHLOG_RECORD,								// Record related
	DHLOG_ACCOUNT,								// Account related
	DHLOG_CLEAR,								// Clear log 
	DHLOG_PLAYBACK,								// Playback related 
	DHLOG_MANAGER                               // Concerning the front-end management and running
} DH_LOG_QUERY_TYPE;

// Log Type
typedef enum _DH_LOG_TYPE
{
	DH_LOG_REBOOT = 0x0000,						// Device reboot 
	DH_LOG_SHUT,								// Shut down device 
    DH_LOG_REPORTSTOP,
    DH_LOG_REPORTSTART,
	DH_LOG_UPGRADE = 0x0004,					// Device Upgrade
	DH_LOG_SYSTIME_UPDATE = 0x0005,             // system time update
	DH_LOG_GPS_TIME_UPDATE = 0x0006,			// GPS time update
	DH_LOG_AUDIO_TALKBACK,	  					// Voice intercom, true representative open, false on behalf of the closed
	DH_LOG_COMM_ADAPTER,						// Transparent transmission, true representative open, false on behalf of the closed
    DH_LOG_NET_TIMING,                          // Net sync
	DH_LOG_CONFSAVE = 0x0100,					// Save configuration 
	DH_LOG_CONFLOAD,							// Read configuration 
	DH_LOG_FSERROR = 0x0200,					// File system error
	DH_LOG_HDD_WERR,							// HDD write error 
	DH_LOG_HDD_RERR,							// HDD read error
	DH_LOG_HDD_TYPE,							// Set HDD type 
	DH_LOG_HDD_FORMAT,							// Format HDD
	DH_LOG_HDD_NOSPACE,							// Current working HDD space is not sufficient
	DH_LOG_HDD_TYPE_RW,							// Set HDD type as read-write 
	DH_LOG_HDD_TYPE_RO,							// Set HDD type as read-only
	DH_LOG_HDD_TYPE_RE,							// Set HDD type as redundant 
	DH_LOG_HDD_TYPE_SS,							// Set HDD type as snapshot
	DH_LOG_HDD_NONE,							// No HDD
	DH_LOG_HDD_NOWORKHDD,						// No work HDD
	DH_LOG_HDD_TYPE_BK,							// Set HDD type to backup HDD
	DH_LOG_HDD_TYPE_REVERSE,					// Set HDD type to reserve subarea
	DH_LOG_HDD_START_INFO = 0x20e ,             // note the boot-strap's hard disk info
	DH_LOG_HDD_WORKING_DISK,                    // note the disk number after the disk change
	DH_LOG_HDD_OTHER_ERROR,                     // note other errors of disk
	DH_LOG_HDD_SLIGHT_ERR,						// there has some little errors on disk
	DH_LOG_HDD_SERIOUS_ERR,                     // there has some serious errors on disk
	DH_LOG_HDD_NOSPACE_END,                     // the end of the alarm that current disk has no space left 
	DH_LOG_HDD_TYPE_RAID_CONTROL,               // Raid control
	DH_LOG_HDD_TEMPERATURE_HIGH,				// excess temperature
	DH_LOG_HDD_TEMPERATURE_LOW,					// lower die temperature
	DH_LOG_HDD_ESATA_REMOVE,					// remove eSATA
	DH_LOG_ALM_IN = 0x0300,						// External alarm begin 
	DH_LOG_NETALM_IN,							// Network alarm input 
	DH_LOG_ALM_END = 0x0302,					// External input alarm stop 
	DH_LOG_LOSS_IN,								// Video loss alarm begin 
	DH_LOG_LOSS_END,							// Video loss alarm stop
	DH_LOG_MOTION_IN,							// Motion detection alarm begin 
	DH_LOG_MOTION_END,							// Motion detection alarm stop 
	DH_LOG_ALM_BOSHI,							// Annunciator alarm input 
	DH_LOG_NET_ABORT = 0x0308,					// Network disconnected 
	DH_LOG_NET_ABORT_RESUME,					// Network connection restore 
	DH_LOG_CODER_BREAKDOWN,						// Encoder error
	DH_LOG_CODER_BREAKDOWN_RESUME,				// Encoder error restore 
	DH_LOG_BLIND_IN,							// Camera masking 
	DH_LOG_BLIND_END,							// Restore camera masking 
	DH_LOG_ALM_TEMP_HIGH,						// High temperature 
	DH_LOG_ALM_VOLTAGE_LOW,						// Low voltage
	DH_LOG_ALM_BATTERY_LOW,						// Battery capacity is not sufficient 
	DH_LOG_ALM_ACC_BREAK,						// ACC power off 
    DH_LOG_ALM_ACC_RES,
	DH_LOG_GPS_SIGNAL_LOST,						// GPS signal lost
	DH_LOG_GPS_SIGNAL_RESUME,					// GPS signal resume
	DH_LOG_3G_SIGNAL_LOST,						// 3G signal lost
	DH_LOG_3G_SIGNAL_RESUME,					// 3G signal resume
    DH_LOG_ALM_IPC_IN,							// IPC external alarms
	DH_LOG_ALM_IPC_END,							// IPC external alarms recovery
	DH_LOG_ALM_DIS_IN,							// Broken network alarm
	DH_LOG_ALM_DIS_END,							// Broken network alarm recovery
	DH_LOG_ALM_UPS_IN, 				            // UPS alarm 
    DH_LOG_ALM_UPS_END, 				        // UPS alarm resume 
    DH_LOG_ALM_NAS_IN,				            // NAS server abnormal alarm 
    DH_LOG_ALM_NAS_END,				            // NAS server abnormal alarm resume 
    DH_LOG_ALM_REDUNDANT_POWER_IN,              // Redundant power alarm 
    DH_LOG_ALM_REDUNDANT_POWER_END,             // Redundant alarm resume  
    DH_LOG_ALM_RECORD_FAILED_IN,				// Record failure alarm 
    DH_LOG_ALM_RECORD_FAILED_END,			    // Record failure alarm resume 
    DH_LOG_ALM_VGEXCEPT_IN,				        // Storage pool abnormal alarm 
    DH_LOG_ALM_VGEXCEPT_END,				    // Storage abnormal alarm resume 		
    DH_LOG_ALM_FANSPEED_IN,			            // Fan alarm starts
    DH_LOG_ALM_FANSPEED_END,			        // Fan alarm stops 
    DH_LOG_ALM_DROP_FRAME_IN,			        // Frame loss alarm starts 
    DH_LOG_ALM_DROP_FRAME_END,			        // Frame loss alarm stops
    DH_LOG_ALM_DISK_STATE_CHECK,		        // HDD pre-check tour alarm event log type 
    DH_LOG_ALARM_COAXIAL_SMOKE,		            // HDCVI smoke alarm event
    DH_LOG_ALARM_COAXIAL_TEMP_HIGH,	            // HDCVI temperature alarm event 
    DH_LOG_ALARM_COAXIAL_ALM_IN,		        // HDCVI external alarm event 
	DH_LOG_INFRAREDALM_IN = 0x03a0,				// Wireless alarm begin 
	DH_LOG_INFRAREDALM_END,						// Wireless alarm end 
	DH_LOG_IPCONFLICT,							// IP conflict 
	DH_LOG_IPCONFLICT_RESUME,					// IP restore
	DH_LOG_SDPLUG_IN,							// SD Card insert
	DH_LOG_SDPLUG_OUT,							// SD Card Pull-out
	DH_LOG_NET_PORT_BIND_FAILED,				// Failed to bind port
	DH_LOG_HDD_BEEP_RESET,                      // Hard disk error beep reset 
	DH_LOG_MAC_CONFLICT,                        // MAC conflict
	DH_LOG_MAC_CONFLICT_RESUME,                 // MAC conflict resume
	DH_LOG_ALARM_OUT,							// alarm out
	DH_LOG_ALM_RAID_STAT_EVENT,                 // RAID state event    
	DH_LOG_ABLAZE_ON,				            // Fire alarm, smoker or high temperature
	DH_LOG_ABLAZE_OFF,			                // Fire alarm reset 
	DH_LOG_INTELLI_ALARM_PLUSE,					// Intelligence pulse alarm
	DH_LOG_INTELLI_ALARM_IN,					// Intelligence alarm start
	DH_LOG_INTELLI_ALARM_END,					// Intelligence alarm end
	DH_LOG_3G_SIGNAL_SCAN,						// 3G signal scan
	DH_LOG_GPS_SIGNAL_SCAN,						// GPS signal scan
	DH_LOG_AUTOMATIC_RECORD = 0x0400,			// Auto record 
	DH_LOG_MANUAL_RECORD = 0x0401,				// Manual record 
	DH_LOG_CLOSED_RECORD,						// Stop record 
	DH_LOG_LOGIN = 0x0500,						// Log in 
	DH_LOG_LOGOUT,								// Log off 
	DH_LOG_ADD_USER,							// Add user
	DH_LOG_DELETE_USER,							// Delete user
	DH_LOG_MODIFY_USER,							// Modify user 
	DH_LOG_ADD_GROUP,							// Add user group 
	DH_LOG_DELETE_GROUP,						// Delete user group 
	DH_LOG_MODIFY_GROUP,						// Modify user group 
	DH_LOG_NET_LOGIN = 0x0508,					// Network Login
	DH_LOG_MODIFY_PASSWORD,						// Modify password
	DH_LOG_CLEAR = 0x0600,						// Clear log 
	DH_LOG_SEARCHLOG,							// Search log 
	DH_LOG_SEARCH = 0x0700,						// Search record 
	DH_LOG_DOWNLOAD,							// Record download
	DH_LOG_PLAYBACK,							// Record playback
	DH_LOG_BACKUP,								// Backup recorded file 
	DH_LOG_BACKUPERROR,							// Failed to backup recorded file
	DH_LOG_BACK_UPRT,							// Real-time backup, that is, copy CD
	DH_LOG_BACKUPCLONE,							// CD copy
	DH_LOG_DISK_CHANGED,						// Manual changed
	DH_LOG_IMAGEPLAYBACK,						// Image playback
	DH_LOG_LOCKFILE,							// Lock the video
	DH_LOG_UNLOCKFILE,							// Unlock the video
	DH_LOG_ATMPOS,								// Add log superposition of ATM card number
	DH_PLAY_PAUSE,								// Pause
	DH_PLAY_START,								// Start
	LOG_PLAY_STOP,								// Stop
	LOG_PLAY_BACK,								// Back
	LOG_PLAY_FAST,								// Fast
	LOG_PLAY_SLOW,								// Slow
	LOG_SMART_SEARCH,							// Search
	LOG_RECORD_SNAP,							// Snap
	LOG_ADD_TAG,								// Add tag
	LOG_DEL_TAG,								// Delete tag
	LOG_USB_IN,									// USB connected
	LOG_USB_OUT,								// USB disconnected
	LOG_BACKUP_FILE,							// Backup file
	LOG_BACKUP_LOG,								// Backup log
	LOG_BACKUP_CONFIG,							// Backup config

    DH_LOG_TIME_UPDATE  = 0x0800,               // Time update
    DH_LOG_REMOTE_STATE = 0x0850,               // remote diary 
    DH_LOG_USER_DEFINE = 0x0900,
	DH_LOG_TYPE_NR = 10,
} DH_LOG_TYPE;

// Extensive log type. Correponding to CLIENT_QueryLogEx, Condition (int nType = 1; parameter reserved = &nType)
typedef enum _DH_NEWLOG_TYPE
{
	DH_NEWLOG_REBOOT = 0x0000,					// Device reboot 
	DH_NEWLOG_SHUT,								// Shut down device
    DH_NEWLOG_REPORTSTOP,
    DH_NEWLOG_REPORTSTART,
	DH_NEWLOG_UPGRADE = 0x0004,					// Device upgrade
	DH_NEWLOG_SYSTIME_UPDATE = 0x0005,          // system time update
	DH_NEWLOG_GPS_TIME_UPDATE = 0x0006,			// GPS time update

	DH_NEWLOG_AUDIO_TALKBACK,	  				// Voice intercom, true representative open, false on behalf of the closed
	DH_NEWLOG_COMM_ADAPTER,						// Transparent transmission, true representative open, false on behalf of the closed	
	DH_NEWLOG_NET_TIMING,						// NTP

	DH_NEWLOG_CONFSAVE = 0x0100,				// Save configuration 
	DH_NEWLOG_CONFLOAD,							// Read configuration 
	DH_NEWLOG_FSERROR = 0x0200,					// File system error
	DH_NEWLOG_HDD_WERR,							// HDD write error 
	DH_NEWLOG_HDD_RERR,							// HDD read error
	DH_NEWLOG_HDD_TYPE,							// Set HDD type 
	DH_NEWLOG_HDD_FORMAT,						// Format HDD
	DH_NEWLOG_HDD_NOSPACE,						// Current working HDD space is not sufficient
	DH_NEWLOG_HDD_TYPE_RW,						// Set HDD type as read-write 
	DH_NEWLOG_HDD_TYPE_RO,						// Set HDD type as read-only
	DH_NEWLOG_HDD_TYPE_RE,						// Set HDD type as redundant 
	DH_NEWLOG_HDD_TYPE_SS,						// Set HDD type as snapshot
	DH_NEWLOG_HDD_NONE,							// No HDD
	DH_NEWLOG_HDD_NOWORKHDD,					// No work HDD
	DH_NEWLOG_HDD_TYPE_BK,						// Set HDD type to backup HDD
	DH_NEWLOG_HDD_TYPE_REVERSE,					// Set HDD type to reserve subareas
	DH_NEWLOG_HDD_START_INFO = 0x20e ,          // note the boot-strap's hard disk info
	DH_NEWLOG_HDD_WORKING_DISK,                 // note the disk number after the disk change
	DH_NEWLOG_HDD_OTHER_ERROR,                  // note other errors of disk
	DH_NEWLOG_HDD_SLIGHT_ERR,					// there has some little errors on disk
	DH_NEWLOG_HDD_SERIOUS_ERR,                  // there has some serious errors on disk
	DH_NEWLOG_HDD_NOSPACE_END,                  // the end of the alarm that current disk has no space left 

	DH_NEWLOG_HDD_TYPE_RAID_CONTROL,            // Raid operation
	DH_NEWLOG_HDD_TEMPERATURE_HIGH,				// excess temperature
	DH_NEWLOG_HDD_TEMPERATURE_LOW,				// lower die temperature
	DH_NEWLOG_HDD_ESATA_REMOVE,					// remove eSATA

	DH_NEWLOG_ALM_IN = 0x0300,					// External alarm begin 
	DH_NEWLOG_NETALM_IN,						// Network alarm input 
	DH_NEWLOG_ALM_END = 0x0302,					// External input alarm stop 
	DH_NEWLOG_LOSS_IN,							// Video loss alarm begin 
	DH_NEWLOG_LOSS_END,							// Video loss alarm stop
	DH_NEWLOG_MOTION_IN,						// Motion detection alarm begin 
	DH_NEWLOG_MOTION_END,						// Motion detection alarm stop 
	DH_NEWLOG_ALM_BOSHI,						// Annunciator alarm input 
	DH_NEWLOG_NET_ABORT = 0x0308,				// Network disconnected 
	DH_NEWLOG_NET_ABORT_RESUME,					// Network connection restore 
	DH_NEWLOG_CODER_BREAKDOWN,					// Encoder error
	DH_NEWLOG_CODER_BREAKDOWN_RESUME,			// Encoder error restore 
	DH_NEWLOG_BLIND_IN,							// Camera masking 
	DH_NEWLOG_BLIND_END,						// Restore camera masking 
	DH_NEWLOG_ALM_TEMP_HIGH,					// High temperature 
	DH_NEWLOG_ALM_VOLTAGE_LOW,					// Low voltage
	DH_NEWLOG_ALM_BATTERY_LOW,					// Battery capacity is not sufficient 
	DH_NEWLOG_ALM_ACC_BREAK,					// ACC power off 
    DH_NEWLOG_ALM_ACC_RES,
	DH_NEWLOG_GPS_SIGNAL_LOST,					// GPS signal lost
	DH_NEWLOG_GPS_SIGNAL_RESUME,				// GPS signal resume
	DH_NEWLOG_3G_SIGNAL_LOST,					// 3G signal lost
	DH_NEWLOG_3G_SIGNAL_RESUME,					// 3G signal resume

	DH_NEWLOG_ALM_IPC_IN,						// IPC external alarms
	DH_NEWLOG_ALM_IPC_END,						// IPC external alarms recovery 
	DH_NEWLOG_ALM_DIS_IN,						//Broken network alarm
	DH_NEWLOG_ALM_DIS_END,						// Broken network alarm recovery

	DH_NEWLOG_INFRAREDALM_IN = 0x03a0,			// Wireless alarm begin 
	DH_NEWLOG_INFRAREDALM_END,					// Wireless alarm end 
	DH_NEWLOG_IPCONFLICT,						// IP conflict 
	DH_NEWLOG_IPCONFLICT_RESUME,				// IP restore
	DH_NEWLOG_SDPLUG_IN,						// SD Card insert
	DH_NEWLOG_SDPLUG_OUT,						// SD Card Pull-out
	DH_NEWLOG_NET_PORT_BIND_FAILED,				// Failed to bind port
	DH_NEWLOG_HDD_BEEP_RESET,                   // Hard disk error beep reset
	DH_NEWLOG_MAC_CONFLICT,                     // MAC conflict
	DH_NEWLOG_MAC_CONFLICT_RESUME,              // MAC conflict resume
	DH_NEWLOG_ALARM_OUT,						// alarm of output state
	DH_NEWLOG_ALM_RAID_STAT_EVENT,              // RAID state change
	DH_NEWLOG_ABLAZE_ON,				        // fire alarm, smoke or temperature
	DH_NEWLOG_ABLAZE_OFF,			            // fire alarm resume
	DH_NEWLOG_INTELLI_ALARM_PLUSE,				// alarm of pulse type
	DH_NEWLOG_INTELLI_ALARM_IN,					// begin of alarm
	DH_NEWLOG_INTELLI_ALARM_END,				// end of alarm
	DH_NEWLOG_3G_SIGNAL_SCAN,					// 3G signal scan
	DH_NEWLOG_GPS_SIGNAL_SCAN,					// GPS signal scan
	DH_NEWLOG_AUTOMATIC_RECORD = 0x0400,		// Auto record 
	DH_NEWLOG_MANUAL_RECORD,					// Manual record 
	DH_NEWLOG_CLOSED_RECORD,					// Stop record 
	DH_NEWLOG_LOGIN = 0x0500,					// Log in 
	DH_NEWLOG_LOGOUT,							// Log off 
	DH_NEWLOG_ADD_USER,							// Add user
	DH_NEWLOG_DELETE_USER,						// Delete user
	DH_NEWLOG_MODIFY_USER,						// Modify user 
	DH_NEWLOG_ADD_GROUP,						// Add user group 
	DH_NEWLOG_DELETE_GROUP,						// Delete user group 
	DH_NEWLOG_MODIFY_GROUP,						// Modify user group
	DH_NEWLOG_NET_LOGIN = 0x0508,				// Network user login
	DH_NEWLOG_CLEAR = 0x0600,					// Clear log 
	DH_NEWLOG_SEARCHLOG,						// Search log 
	DH_NEWLOG_SEARCH = 0x0700,					// Search record 
	DH_NEWLOG_DOWNLOAD,							// Record download
	DH_NEWLOG_PLAYBACK,							// Record playback
	DH_NEWLOG_BACKUP,							// Backup recorded file 
	DH_NEWLOG_BACKUPERROR,						// Failed to backup recorded file

	DH_NEWLOG_BACK_UPRT,						// Real-time backup, that is, copy CD
	DH_NEWLOG_BACKUPCLONE,						// CD copy
	DH_NEWLOG_DISK_CHANGED,						// Manual  changed
	DH_NEWLOG_IMAGEPLAYBACK,					// image palyback
	DH_NEWLOG_LOCKFILE,							// Lock the video
	DH_NEWLOG_UNLOCKFILE,						// Unlock the video
	DH_NEWLOG_ATMPOS,							// Add log superposition of ATM card number

	DH_NEWLOG_TIME_UPDATE  = 0x0800,            // Time update
	DH_NEWLOG_REMOTE_STATE = 0x0850,            // remote diary 

    DH_NEWLOG_USER_DEFINE = 0x0900,
    DH_NEWLOG_TYPE_NR = 10,        
} DH_NEWLOG_TYPE;

///////////////////////////////About audio talk ///////////////////////////////

// Audio encode type 
typedef enum __TALK_CODING_TYPE
{
	DH_TALK_DEFAULT = 0,						// No-head PCM
	DH_TALK_PCM = 1,							// With head PCM
	DH_TALK_G711a,								// G711a
	DH_TALK_AMR,								// AMR
	DH_TALK_G711u,								// G711u
	DH_TALK_G726,								// G726
	DH_TALK_G723_53,							// G723_53
	DH_TALK_G723_63,							// G723_63
	DH_TALK_AAC,								// AAC
	DH_TALK_OGG,                                // OGG
    DH_TALK_G729 = 10,                          // G729
    DH_TALK_MPEG2,                              // MPEG2
    DH_TALK_MPEG2_Layer2,                       // MPEG2-Layer2
    DH_TALK_G722_1,                             // G.722.1
	DH_TALK_ADPCM = 21,                         // ADPCM
	DH_TALK_MP3   = 22,							// MP3
} DH_TALK_CODING_TYPE;

// Record file type
typedef enum __NET_RECORD_TYPE
{
	NET_RECORD_TYPE_ALL,                        // All the video
	NET_RECORD_TYPE_NORMAL,                     // common  video
	NET_RECORD_TYPE_ALARM,                      // External alarm video
	NET_RECORD_TYPE_MOTION,                     // DM alarm video
}NET_RECORD_TYPE;

// Audio talk way 
typedef enum __EM_USEDEV_MODE
{
	DH_TALK_CLIENT_MODE,						// Set client-end mode to begin audio talk 
	DH_TALK_SERVER_MODE,						// Set server mode to begin audio talk 
	DH_TALK_ENCODE_TYPE,						// Set encode format for audio talk 
	DH_ALARM_LISTEN_MODE,						// Set alarm subscribe way 
	DH_CONFIG_AUTHORITY_MODE,					// Set user right to realize configuration management
	DH_TALK_TALK_CHANNEL,						// set talking channel(0~MaxChannel-1)
	DH_RECORD_STREAM_TYPE,                      // set the stream type of the record for query(0-both main and extra stream,1-only main stream,2-only extra stream)  
	DH_TALK_SPEAK_PARAM,                        // set speaking parameter,corresponding to NET_SPEAK_PARAM
	DH_RECORD_TYPE,                             // Set by time video playback and download the video file TYPE (see.net RECORD TYPE)
	DH_TALK_MODE3,								// Set voice intercom parameters of three generations of equipment and the corresponding structure NET TALK the EX
    DH_PLAYBACK_REALTIME_MODE ,                 // set real time playback function(0-off, 1-on)
    DH_TALK_TRANSFER_MODE,                      // Judge the voice intercom if it was a forwarding mode, (corresponding to  NET_TALK_TRANSFER_PARAM)
    DH_TALK_VT_PARAM,                           // Set VT Talk param (corresponding to  NET_VT_TALK_PARAM)
    DH_TARGET_DEV_ID,                           // set target device identifier for searching system capacity information, (not zero - locate device forwards the information)
	DH_AUDIO_RECORD_LENGTH = 15,                // set audio record length, corresponding to a int
} EM_USEDEV_MODE;


typedef enum __EM_TALK_DATA_TYPE
{ 
	NET_TALK_DATA_LOCAL_AUDIO = 0,				// Local recording audio data from the library
	NET_TALK_DATA_RECV_AUDIO,					// Receiving device sending audio data
	NET_TALK_DATA_RESPOND,						// Intercom call response data
    NET_TALK_DATA_RECV_VIDEO,                   // Got device sent video data
}EM_TALK_DATA_TYPE;

typedef struct tagNET_TALK_VIDEO_FORMAT
{
	DWORD				dwSize;
	DWORD				dwCompression;			// Video compression format
	int					nFrequency;				// Video sampling frequency
}NET_TALK_VIDEO_FORMAT;
// Three generations of equipment parameters of voice intercom, corresponding to the CLIENT SetDeviceMode DH TALK MODE3 () command
typedef struct tagNET_TALK_EX
{
    DWORD               dwSize;
	int					nChannel;               // channel number 
	int                 nAudioPort;             // Audio transmission listener ports
	int					nWaitTime;              // Ms wait time, unit, use the default value is 0
    HWND				hVideoWnd;				// Visual talk video window
	NET_TALK_VIDEO_FORMAT stuVideoFmt;			// Video encode format
	char				szMulticastAddr[DH_MAX_IPADDR_LEN_EX]; // Multicast address
	WORD				wMulticastLocalPort;	// Multicast local port
	WORD				wMulticastRemotePort;	// Multicast remote port
}NET_TALK_EX;

// AMR Encode Type
typedef enum __EM_ARM_ENCODE_MODE
{
	DH_TALK_AMR_AMR475 = 1,						// AMR475
	DH_TALK_AMR_AMR515,							// AMR515
	DH_TALK_AMR_AMR59,							// AMR59
	DH_TALK_AMR_AMR67,							// AMR67
	DH_TALK_AMR_AMR74,							// AMR74
	DH_TALK_AMR_AMR795,							// AMR795
	DH_TALK_AMR_AMR102,							// AMR102
	DH_TALK_AMR_AMR122,							// AMR122
} EM_ARM_ENCODE_MODE;

// talk parameter
typedef struct __NET_SPEAK_PARAM
{
	DWORD           dwSize;                     // struct size 
	int             nMode;                      // 0:talk back(default), 1: propaganda,from propaganda ro talk back,need afresh to configure
												// 2:unidirectional monitoring, if want to set other mode, need afresh to configure
	int             nSpeakerChannel;            // reproducer channel
    BOOL            bEnableWait;                // Wait for device to responding or not when enable bidirectional talk. Default setup is no.TRUE:wait ;FALSE:no
} NET_SPEAK_PARAM;

//Open the forwarding mode of intercom or not 
typedef struct tagNET_TALK_TRANSFER_PARAM
{
    DWORD           dwSize;
    BOOL            bTransfer;                  // Open the forwarding mode of intercom or not, TRUE: yes, FALSE: no
}NET_TALK_TRANSFER_PARAM;

/////////////////////////////////Control Related/////////////////////////////////

// Control type    Corresponding to CLIENT_ControlDevice
typedef enum _CtrlType
{
	DH_CTRL_REBOOT = 0,							// Reboot device	
	DH_CTRL_SHUTDOWN,							// Shut down device
	DH_CTRL_DISK,								// HDD management
	DH_KEYBOARD_POWER = 3,						// Network keyboard
	DH_KEYBOARD_ENTER,
	DH_KEYBOARD_ESC,
	DH_KEYBOARD_UP,
	DH_KEYBOARD_DOWN,
	DH_KEYBOARD_LEFT,
	DH_KEYBOARD_RIGHT,
	DH_KEYBOARD_BTN0,
	DH_KEYBOARD_BTN1,
	DH_KEYBOARD_BTN2,
	DH_KEYBOARD_BTN3,
	DH_KEYBOARD_BTN4,
	DH_KEYBOARD_BTN5,
	DH_KEYBOARD_BTN6,
	DH_KEYBOARD_BTN7,
	DH_KEYBOARD_BTN8,
	DH_KEYBOARD_BTN9,
	DH_KEYBOARD_BTN10,
	DH_KEYBOARD_BTN11,
	DH_KEYBOARD_BTN12,
	DH_KEYBOARD_BTN13,
	DH_KEYBOARD_BTN14,
	DH_KEYBOARD_BTN15,
	DH_KEYBOARD_BTN16,
	DH_KEYBOARD_SPLIT,
	DH_KEYBOARD_ONE,
	DH_KEYBOARD_NINE,
	DH_KEYBOARD_ADDR,
	DH_KEYBOARD_INFO,
	DH_KEYBOARD_REC,
	DH_KEYBOARD_FN1,
	DH_KEYBOARD_FN2,
	DH_KEYBOARD_PLAY,
	DH_KEYBOARD_STOP,
	DH_KEYBOARD_SLOW,
	DH_KEYBOARD_FAST,
	DH_KEYBOARD_PREW,
	DH_KEYBOARD_NEXT,
	DH_KEYBOARD_JMPDOWN,
	DH_KEYBOARD_JMPUP,
    DH_KEYBOARD_10PLUS,
    DH_KEYBOARD_SHIFT,
    DH_KEYBOARD_BACK,
    DH_KEYBOARD_LOGIN ,                         // new network keyboard function
    DH_KEYBOARD_CHNNEL ,                        // switch video channel
	DH_TRIGGER_ALARM_IN = 100,					// Activate alarm input
	DH_TRIGGER_ALARM_OUT,						// Activate alarm output 
	DH_CTRL_MATRIX,								// Matrix control 
	DH_CTRL_SDCARD,								// SD card control(for IPC series). Please refer to HDD control
	DH_BURNING_START,							// Burner control:begin burning 
	DH_BURNING_STOP,							// Burner control:stop burning 
	DH_BURNING_ADDPWD,							// Burner control:overlay password(The string ended with '\0'. Max length is 8 bits. )
	DH_BURNING_ADDHEAD,							// Burner control:overlay head title(The string ended with '\0'. Max length is 1024 bytes. Use '\n' to Enter.)
	DH_BURNING_ADDSIGN,							// Burner control:overlay dot to the burned information(No parameter) 
	DH_BURNING_ADDCURSTOMINFO,					// Burner control:self-defined overlay (The string ended with '\0'. Max length is 1024 bytes. Use '\n' to Enter)
	DH_CTRL_RESTOREDEFAULT,						// restore device default setup 
	DH_CTRL_CAPTURE_START,						// Activate device snapshot
	DH_CTRL_CLEARLOG,							// Clear log
	DH_TRIGGER_ALARM_WIRELESS = 200,			// Activate wireless alarm (IPC series)
	DH_MARK_IMPORTANT_RECORD,					// Mark important record
	DH_CTRL_DISK_SUBAREA, 						// Network hard disk partition	
	DH_BURNING_ATTACH,							// Annex burning
	DH_BURNING_PAUSE,							// Burn Pause
	DH_BURNING_CONTINUE,						// Burn Resume
	DH_BURNING_POSTPONE,						// Burn Postponed
	DH_CTRL_OEMCTRL,							// OEM control
	DH_BACKUP_START,							// Start to device backup
	DH_BACKUP_STOP,								// Stop to device backup
	DH_VIHICLE_WIFI_ADD,						// Add WIFI configuration manually for car device
	DH_VIHICLE_WIFI_DEC,						// Delete WIFI configuration manually for car device
	DH_BUZZER_START,                            // Start to buzzer control 
	DH_BUZZER_STOP,                             // Stop to buzzer control
	DH_REJECT_USER,                             // Reject User
	DH_SHIELD_USER,                             // Shield User
	DH_RAINBRUSH,                               // Rain Brush 
	DH_MANUAL_SNAP,                             // manual snap (struct MANUAL_SNAP_PARAMETER)
	DH_MANUAL_NTP_TIMEADJUST,                   // manual ntp time adjust
	DH_NAVIGATION_SMS,                          // navigation info and note
	DH_CTRL_ROUTE_CROSSING,                     // route info
	DH_BACKUP_FORMAT,							// backup device format
	DH_DEVICE_LOCALPREVIEW_SLIPT,               // local preview split(struct DEVICE_LOCALPREVIEW_SLIPT_PARAMETER)    
	DH_CTRL_INIT_RAID,							// RAID init
	DH_CTRL_RAID,								// RAID control
	DH_CTRL_SAPREDISK,							// sapredisk control
	DH_WIFI_CONNECT,							// wifi connect(struct WIFI_CONNECT)
	DH_WIFI_DISCONNECT,							// wifi disconnect(struct WIFI_CONNECT)
	DH_CTRL_ARMED,                              // Arm/disarm operation 
	DH_CTRL_IP_MODIFY,                          // IP modify(struct DHCTRL_IPMODIFY_PARAM)                     
	DH_CTRL_WIFI_BY_WPS,                        // wps connect wifi(struct DHCTRL_CONNECT_WIFI_BYWPS)
	DH_CTRL_FORMAT_PATITION,					// format pattion (struct DH_FORMAT_PATITION)
	DH_CTRL_EJECT_STORAGE,						// eject storage device(struct DH_EJECT_STORAGE_DEVICE)
	DH_CTRL_LOAD_STORAGE,						// load storage device(struct DH_LOAD_STORAGE_DEVICE)
	DH_CTRL_CLOSE_BURNER,                       // close burner(struct NET_CTRL_BURNERDOOR) need wait 6s
	DH_CTRL_EJECT_BURNER,                       // eject burner(struct NET_CTRL_BURNERDOOR) need wait 4s
	DH_CTRL_CLEAR_ALARM,						// alarm elimination (corresponding structure NET_CTRL_CLEAR_ALARM)
	DH_CTRL_MONITORWALL_TVINFO,					// TV wall information display (corresponding structure NET_CTRL_MONITORWALL_TVINFO)
	DH_CTRL_START_VIDEO_ANALYSE,                //  start Intelligent VIDEO analysis (corresponding structure NET_CTRL_START_VIDEO_ANALYSE)
	DH_CTRL_STOP_VIDEO_ANALYSE,                 // STOP intelligent VIDEO analysis (corresponding structure NET_CTRL_STOP_VIDEO_ANALYSE)
	DH_CTRL_UPGRADE_DEVICE,                     // Controlled start equipment upgrades, independently complete the upgrade process by the equipment do not need to upgrade file
	DH_CTRL_MULTIPLAYBACK_CHANNALES,            // Multi-channel preview playback channel switching (corresponding structure NET_CTRL MULTIPLAYBACK CHANNALES)
	DH_CTRL_SEQPOWER_OPEN,						// Turn on the switch power supply timing device output (corresponding NET_CTRL SEQPOWER PARAM)
	DH_CTRL_SEQPOWER_CLOSE,						// Close the switch power supply timing device output (corresponding NET_CTRL SEQPOWER PARAM)
	DH_CTRL_SEQPOWER_OPEN_ALL,					// Power timing group open the switch quantity output (corresponding NET_CTRL SEQPOWER PARAM)
	DH_CTRL_SEQPOWER_CLOSE_ALL,					// Power sequence set close the switch quantity output (corresponding NET_CTRL SEQPOWER PARAM)
	DH_CTRL_PROJECTOR_RISE,						// PROJECTOR up (corresponding NET_CTRL_PROJECTOR PARAM)
	DH_CTRL_PROJECTOR_FALL,						// PROJECTOR drop (corresponding to NET_CTRL_PROJECTOR PARAM)
	DH_CTRL_PROJECTOR_STOP,						// PROJECTOR stop (corresponding to the NET_CTRL_PROJECTOR PARAM)
	DH_CTRL_INFRARED_KEY,						// INFRARED buttons (corresponding to the NET_CTRL_INFRARED KEY PARAM)
	DH_CTRL_START_PLAYAUDIO,					// Device START playback of audio file corresponding structure NET_CTRL START PLAYAUDIO)
	DH_CTRL_STOP_PLAYAUDIO,						// Equipment stop playback of audio file
	DH_CTRL_START_ALARMBELL,					// open alarm (Corresponding to NET_CTRL_ALARMBELL)
	DH_CTRL_STOP_ALARMBELL,						// Close the warning signal (corresponding structure NET_CTRL ALARMBELL)
	DH_CTRL_ACCESS_OPEN,						// OPEN ACCESS control (corresponding structure NET_CTRL_ACCESS_OPEN)	
	DH_CTRL_SET_BYPASS,							// By pass (Corresponding to NET_CTRL_SET_BYPASS)
	DH_CTRL_RECORDSET_INSERT,					// Add records to record set number (corresponding to the NET_CTRL_RECORDSET_INSERT_PARAM)
	DH_CTRL_RECORDSET_UPDATE,					// Update a record of the number (corresponding to the NET_CTRL_RECORDSET_PARAM)
	DH_CTRL_RECORDSET_REMOVE,					// According to the record set number to delete a record (corresponding to the NET_CTRL_RECORDSET_PARAM)
	DH_CTRL_RECORDSET_CLEAR,					// Remove all RECORDSET information (corresponding to the NET_CTRL_RECORDSET_PARAM)
	DH_CTRL_ACCESS_CLOSE,						// Entrance guard control - CLOSE corresponding structure NET_CTRL_ACCESS_CLOSE)
	DH_CTRL_ALARM_SUBSYSTEM_ACTIVE_SET,			// Alarm sub system activation setup(corresponding structure NET_CTRL_ALARM_SUBSYSTEM_SETACTIVE)
    DH_CTRL_FORBID_OPEN_STROBE,                 // Disable device open gateway(corresponding to structure  NET_CTRL_FORBID_OPEN_STROBE)
    DH_CTRL_OPEN_STROBE,                        // Enable gateway(corresponding to structure  NET_CTRL_OPEN_STROBE)
    DH_CTRL_TALKING_REFUSE,                     // Talk no response(corresponding to structure  NET_CTRL_TALKING_REFUSE)
    DH_CTRL_ARMED_EX,                           // arm-disarm operation(corresponding to structure CTRL_ARM_DISARM_PARAM_EX), CTRL_ARM_DISARM_PARAM upgrade, recommended
    DH_CTRL_REMOTE_TALK,                        // Remote talk control(corresponding to structure NET_CTRL_REMOTETALK_PARAM)
    DH_CTRL_NET_KEYBOARD = 400,                 // Net keyboard control(corresponding to structure  DHCTRL_NET_KEYBOARD)
    DH_CTRL_AIRCONDITION_OPEN,                  // Open air conditioner(corresponding to structure  NET_CTRL_OPEN_AIRCONDITION)
    DH_CTRL_AIRCONDITION_CLOSE,                 // Close air-conditioner(corresponding to structure  NET_CTRL_CLOSE_AIRCONDITION)
    DH_CTRL_AIRCONDITION_SET_TEMPERATURE,       // Set temperature (corresponding to structure  NET_CTRL_SET_TEMPERATURE)
    DH_CTRL_AIRCONDITION_ADJUST_TEMPERATURE,    // Adjust temperature(corresponding to structure  NET_CTRL_ADJUST_TEMPERATURE)
    DH_CTRL_AIRCONDITION_SETMODE,               // Set air work mode(corresponding to structure  NET_CTRL_ADJUST_TEMPERATURE)
    DH_CTRL_AIRCONDITION_SETWINDMODE,           // Set fan mode(corresponding to structure  NET_CTRL_AIRCONDITION_SETMODE)
    DH_CTRL_RESTOREDEFAULT_EX ,                 // Recover device default and set new protocol(corresponding to structure NET_CTRL_RESTORE_DEFAULT)
                                                // Recover config and use this enumeration first, if port failed,
                                                // and CLIENT_GetLastError return NET_UNSUPPORTED, try again DH_CTRL_RESTOREDEFAULT restore config
    DH_CTRL_NOTIFY_EVENT,                       // send event to device (corresponding to  structure  NET_NOTIFY_EVENT_DATA)
    DH_CTRL_SILENT_ALARM_SET,                   // mute alarm setup
	DH_CTRL_START_PLAYAUDIOEX,                  // device start sound report(corresponding to  structure  NET_CTRL_START_PLAYAUDIOEX)
    DH_CTRL_STOP_PLAYAUDIOEX,                   // device stop sound report
    DH_CTRL_CLOSE_STROBE,                       // close gateway(corresponding to  structure  NET_CTRL_CLOSE_STROBE)
	DH_CTRL_SET_ORDER_STATE,                    // set parking reservation status (corresponding to  structure  NET_CTRL_SET_ORDER_STATE)
	DH_CTRL_RECORDSET_INSERTEX,                 // add fingerprint record get record collection no.(corresponding to NET_CTRL_RECORDSET_INSERT_PARAM)
    DH_CTRL_RECORDSET_UPDATEEX,                 // update finger print record set no record(corresponding to NET_CTRL_RECORDSET_PARAM)
    DH_CTRL_CAPTURE_FINGER_PRINT,               // fingerprint collection (corresponding to structure NET_CTRL_CAPTURE_FINGER_PRINT)
	DH_CTRL_ECK_LED_SET,                           // Parking lot entrance/exit controller LED setup(corresponding structure  NET_CTRL_ECK_LED_SET_PARAM)
    DH_CTRL_ECK_IC_CARD_IMPORT,                    // Intelligent parking system in/out device IC card info import (corresponding structure  NET_CTRL_ECK_IC_CARD_IMPORT_PARAM)
    DH_CTRL_ECK_SYNC_IC_CARD,                      // Intelligent parking system in/out device IC card info sync command, receive this command, device will delete original IC card info(corresponding structure  NET_CTRL_ECK_SYNC_IC_CARD_PARAM)
    DH_CTRL_LOWRATEWPAN_REMOVE,                    // Delete specific wireless device(corresponding structure  NET_CTRL_LOWRATEWPAN_REMOVE)
    DH_CTRL_LOWRATEWPAN_MODIFY,                    // Modify wireless device info(corresponding structure  NET_CTRL_LOWRATEWPAN_MODIFY)	
    DH_CTRL_ECK_SET_PARK_INFO,                     // Set up the vehicle spot information of the machine at the passageway of the intelligent parking system (corresponding to  NET_CTRL_ECK_SET_PARK_INFO_PARAM)
    DH_CTRL_VTP_DISCONNECT,                        // hang up the video phone (corresponding to NET_CTRL_VTP_DISCONNECT)
    DH_CTRL_UPDATE_FILES,                          // the update of the remote multimedia files (corresponding to NET_CTRL_UPDATE_FILES)
    DH_CTRL_MATRIX_SAVE_SWITCH,                    // Save up the relationship between the hyponymy matrixes (corresponding to NET_CTRL_MATRIX_SAVE_SWITCH)
    DH_CTRL_MATRIX_RESTORE_SWITCH,                 // recover the relationship between the hyponymy matrixes (corresponding to NET_CTRL_MATRIX_RESTORE_SWITCH)
    DH_CTRL_VTP_DIVERTACK,                         // video talk phone divert ack(corresponding to NET_CTRL_VTP_DIVERTACK)
    DH_CTRL_RAINBRUSH_MOVEONCE,                    // Rain-brush brush one time, efficient when set as manual mode(corresponding to NET_CTRL_RAINBRUSH_MOVEONCE)
    DH_CTRL_RAINBRUSH_MOVECONTINUOUSLY,            // Rain-brush brush cyclic, efficient when set as manal mode(corresponding to NET_CTRL_RAINBRUSH_MOVECONTINUOUSLY)
    DH_CTRL_RAINBRUSH_STOPMOVE,                    // Rain-brush stop, efficient when set as manal mode(corresponding to NET_CTRL_RAINBRUSH_STOPMOVE)
    DH_CTRL_ALARM_ACK,                             // affirm the alarm event(corresponding to NET_CTRL_ALARM_ACK)                                                   // DH_CTRL_ALARM_ACK DO NOT call this method in callback interface
    DH_CTRL_RECORDSET_IMPORT,                      // Batch import record set info (Corresponding to NET_CTRL_RECORDSET_PARAM)
    DH_CTRL_DELIVERY_FILE,                         // Delivery file to the video output port, building intercom use, run at the same time(Corresponding to NET_CTRL_DELIVERY_FILE)
	DH_CTRL_FORCE_BREAKING,                        // Force breaking rule(Corresponding to NET_CTRL_FORCE_BREAKING)
	DH_CTRL_RESTORE_EXCEPT,						   // Restore the configuration except the prescribed config.
	DH_CTRL_SET_PARK_INFO,						   // Set park info, platform is set to camera,the content is used for the dot matrix display(corresponding to NET_CTRL_SET_PARK_INFO)
	DH_CTRL_CLEAR_SECTION_STAT, 				   // clear the statistics for the period and start again from 0 (Corresponding to NET_CTRL_CLEAR_SECTION_STAT_INFO)
	DH_CTRL_DELIVERY_FILE_BYCAR,				   // Send video and image files to video output, Used by car, The ad time is served separately(Corresponding NET_CTRL_DELIVERY_FILE_BYCAR)
	DH_CTRL_ECK_GUIDINGPANEL_CONTENT,              // set guiding panel content( NET_CTRL_ECK_GUIDINGPANEL_CONTENT )
	DH_CTRL_SET_SAFE_LEVEL,						   // set safe level(pInBuf= NET_IN_SET_SAFE_LEVEL*, pOutBuf= NET_OUT_SET_SAFE_LEVEL * )
    DH_CTRL_VTP_INVITEACK,                           // video talk peer invite ack(corresponding to NET_CTRL_VTP_INVITEACK)
    DH_CTRL_ACCESS_RESET_PASSWORD,                 // access control - reset password (corresponding to structure NET_CTRL_ACCESS_RESET_PASSWORD)
    DH_CTRL_ACCESS_CALL_LIFT,                      // access control - call lift(corresponding to structure NET_CTRL_ACCESS_CALL_LIFT)
                                                   // The following commands are only for  CLIENT_ControlDeviceEx 
    DH_CTRL_THERMO_GRAPHY_ENSHUTTER = 0x10000,     // Enable or disable thermal shutter, pInBuf= NET_IN_THERMO_EN_SHUTTER*, pOutBuf= NET_OUT_THERMO_EN_SHUTTER * 
    DH_CTRL_RADIOMETRY_SETOSDMARK,                 // NET_IN_RADIOMETRY_SETOSDMARK*, pOutBuf= NET_OUT_RADIOMETRY_SETOSDMARK *    
    DH_CTRL_AUDIO_REC_START_NAME,                  // Enable audio record and get audio name, pInBuf = NET_IN_AUDIO_REC_MNG_NAME *, pOutBuf = NET_OUT_AUDIO_REC_MNG_NAME *
    DH_CTRL_AUDIO_REC_STOP_NAME,                   // Close audio file and return file name, pInBuf ,NET_IN_AUDIO_REC_MNG_NAME *, pOutBuf = NET_OUT_AUDIO_REC_MNG_NAME *
    DH_CTRL_SNAP_MNG_SNAP_SHOT,                    // Manual snap, pInBuf = NET_IN_SNAP_MNG_SHOT *, pOutBuf = NET_OUT_SNAP_MNG_SHOT *
    DH_CTRL_LOG_STOP,                              // Forcedly sync buffer data to the database and close the database, pInBuf = NET_IN_LOG_MNG_CTRL *, pOutBuf = NET_OUT_LOG_MNG_CTRL *
    DH_CTRL_LOG_RESUME,                            // Resume database, pInBuf = NET_IN_LOG_MNG_CTRL *, pOutBuf = NET_OUT_LOG_MNG_CTRL *
    DH_CTRL_POS_ADD,                               // Add a POS device, pInBuf = NET_IN_POS_ADD *, pOutBuf = NET_OUT_POS_ADD *
    DH_CTRL_POS_REMOVE,                            // Del a POS device, pInBuf = NET_IN_POS_REMOVE *, pOutBuf = NET_OUT_POS_REMOVE *
    DH_CTRL_POS_REMOVE_MULTI,                      // Del several POS device, pInBuf = NET_IN_POS_REMOVE_MULTI *, pOutBuf = NET_OUT_POS_REMOVE_MULTI *
    DH_CTRL_POS_MODIFY,                            // Modify a POS device, pInBuf = NET_IN_POS_ADD *, pOutBuf = NET_OUT_POS_ADD *
    DH_CTRL_SET_SOUND_ALARM,                       // Trigger alarm with sound, pInBuf = NET_IN_SOUND_ALARM *, pOutBuf = NET_OUT_SOUND_ALARM *
	DH_CTRL_AUDIO_MATRIX_SILENCE,				   // audiomatrix silence,pInBuf = NET_IN_AUDIO_MATRIX_SILENCE*,  pOutBuf =  NET_OUT_AUDIO_MATRIX_SILENCE*
    DH_CTRL_MANUAL_UPLOAD_PICTURE,                 // manual upload picture, pInBuf = NET_IN_MANUAL_UPLOAD_PICTURE *, pOutBUf = NET_OUT_MANUAL_UPLOAD_PICTURE *
    DH_CTRL_REBOOT_NET_DECODING_DEV,               // reboot network decoding device, pInBuf = NET_IN_REBOOT_NET_DECODING_DEV *, pOutBuf = NET_OUT_REBOOT_NET_DECODING_DEV *
	DH_CTRL_SET_IC_SENDER,						   // ParkingControl about setting IC Sender, pInBuf = NET_IN_SET_IC_SENDER *, pOutBuf = NET_OUT_SET_IC_SENDER * 
    DH_CTRL_SET_MEDIAKIND,                         // set the media type ,e.g. audio only,video only , audio & video ,pInBuf = NET_IN_SET_MEDIAKIND *, pOutBuf = NET_OUT_SET_MEDIAKIND *
	DH_CTRL_LOWRATEWPAN_ADD,                       // Add wireless device info(pInBuf = NET_CTRL_LOWRATEWPAN_ADD *, pOutBUf = NULL)
	DH_CTRL_LOWRATEWPAN_REMOVEALL,                 // remove all the wireless device info(pInBuf = NET_CTRL_LOWRATEWPAN_REMOVEALL *, pOutBUf = NULL)
	DH_CTRL_SET_DOOR_WORK_MODE,                    // Set the work mode of door( pInBuf = NET_IN_CTRL_ACCESS_SET_DOOR_WORK_MODE *, pOutBUf = NULL)
    DH_CTRL_TEST_MAIL,                             // Test Mail(pInBuf = NET_IN_TEST_MAIL *, pOutBUf = NET_OUT_TEST_MAIL *)
    DH_CTRL_CONTROL_SMART_SWITCH,                  // Control smart switch pInBuf = NET_IN_CONTROL_SMART_SWITCH *, pOutBUf = NET_OUT_CONTROL_SMART_SWITCH *
	DH_CTRL_LOWRATEWPAN_SETWORKMODE,          	   // Set the work mode of the detector(pInBuf = NET_IN_CTRL_LOWRATEWPAN_SETWORKMODE *, pOutBUf = NULL)
	DH_CTRL_COAXIAL_CONTROL_IO,					   // send coaxial IO control command(pInBuf = NET_IN_CONTROL_COAXIAL_CONTROL_IO*, pOutBUf = NET_OUT_CONTROL_COAXIAL_CONTROL_IO*)
	DH_CTRL_START_REMOTELOWRATEWPAN_ALARMBELL,		// start wireless alarmbell (pInBuf = NET_IN_START_REMOTELOWRATEWPAN_ALARMBELL*, pOutBUf = NET_OUT_START_REMOTELOWRATEWPAN_ALARMBELL*)
	DH_CTRL_STOP_REMOTELOWRATEWPAN_ALARMBELL,		// stop wireless alarmbell (pInBuf = NET_IN_STOP_REMOTELOWRATEWPAN_ALARMBELL*, pOutBUf = NET_OUT_STOP_REMOTELOWRATEWPAN_ALARMBELL*)
	DH_CTRL_THERMO_DO_FFC,							// Thermo FFC calibration(pInBuf = NET_IN_THERMO_DO_FFC *,pOutBuf = NET_OUT_THERMO_DO_FFC *)
	DH_CTRL_THERMO_FIX_FOCUS,						// Thermo stereo fix focus(pInBuf = NET_IN_THERMO_FIX_FOCUS *,pOutBuf = NET_OUT_THERMO_FIX_FOCUS *)
	DH_CTRL_SET_THIRD_CALLSTATUS,					// Set call status(pInBuf = NET_IN_VTP_THIRDCALL_STATUS*, pOutBuf = NET_OUT_VTP_THIRDCALL_STATUS*)



	/**********LowRateWPAN Control(0x10100-0x10150)**********************************************************************************/
	DH_CTRL_LOWRATEWPAN_GETWIRELESSDEVSIGNAL = 0x10100,      // get Wireless Device Signal(pInBuf = NET_IN_CTRL_LOWRATEWPAN_GETWIRELESSDEVSIGNAL *,pOutBuf = NET_OUT_CTRL_LOWRATEWPAN_GETWIRELESSDEVSIGNAL *)
} CtrlType;

#define DH_MAX_WIRELESS_DEV_NUM 80                                    //The max num of Wireless Device

//Get Wireless Device Signal Input Param(according to DH_CTRL_LOWRATEWPAN_GETWIRELESSDEVSIGNAL)
typedef struct tagNET_IN_CTRL_LOWRATEWPAN_GETWIRELESSDEVSIGNAL
{
	DWORD                       dwSize;                               //Structure size
	int                         nStartIndex;                          //Begin index number,starting from 0
	int                         nDevStateNum;                         //Get DevState Number,The value <= the MaxPageSize value of the capacity
}NET_IN_CTRL_LOWRATEWPAN_GETWIRELESSDEVSIGNAL;

//Wireless Device Signal Info
typedef struct tagNET_WIRELESSDEVSIGNAL_INFO
{
	char                        szDevSN[32];                          //Device SN    
	UINT                        unSignal;                             //Wireless Signal Strength percent
	BYTE                        byReserver[512];                      //Reserved byte
}NET_WIRELESSDEVSIGNAL_INFO;

//Get Wireless Device Signal Output Param(according to DH_CTRL_LOWRATEWPAN_GETWIRELESSDEVSIGNAL)
typedef struct tagNET_OUT_CTRL_LOWRATEWPAN_GETWIRELESSDEVSIGNAL
{
	DWORD                       dwSize;                               //Structure size
	int                         nWirelessDevNum;                      //Get Wireless Device Number
	NET_WIRELESSDEVSIGNAL_INFO  stuDevSignal[DH_MAX_WIRELESS_DEV_NUM];//Wireless Signal Strength
}NET_OUT_CTRL_LOWRATEWPAN_GETWIRELESSDEVSIGNAL;

// the parameter of saving the relationship between the hyponymy matrixes(corresponding to DH_CTRL_MATRIX_SAVE_SWITCH)
typedef struct tagNET_CTRL_MATRIX_SAVE_SWITCH 
{
    DWORD           dwSize;
    const char*     pszName;                        //the relationship between the hyponymy matrixes
} NET_CTRL_MATRIX_SAVE_SWITCH;

// recover the relationship between the hyponymy matrixes (corresponding to DH_CTRL_MATRIX_RESTORE_SWITCH)
typedef struct tagNET_CTRL_MATRIX_RESTORE_SWITCH
{
    DWORD           dwSize;
    const char*     pszName;                        // the relationship between the hyponymy matrixes
} NET_CTRL_MATRIX_RESTORE_SWITCH;

// Restore default config new protocol input parameter
typedef struct tagNET_CTRL_RESTORE_DEFAULT
{
    DWORD			dwSize;
    const char*		szCfgNames;		// Config name and'&&' as interval, config see dhconfigsdk.h CLIENT_GetNewDevConfig and CLIENT_SetNewDevConfig port command 
}NET_CTRL_RESTORE_DEFAULT;

// Restore except config new protocol input parameter
typedef struct tagNET_CTRL_RESTORE_EXCEPT
{
	DWORD			 dwSize;
	char			 szCfgName[DH_MAX_STRING_LEN];				// Config name, config see dhconfigsdk.h CLIENT_GetNewDevConfig and CLIENT_SetNewDevConfig port command 
}NET_CTRL_RESTORE_EXCEPT;

// Open air-conditioner parameter(corresponding to DH_CTRL_AIRCONDITION_OPEN)
typedef struct tagNET_CTRL_OPEN_AIRCONDITION
{
    DWORD               dwSize;
    char				szDeviceID[DH_MAX_DEV_ID_LEN];			// Device SN
} NET_CTRL_OPEN_AIRCONDITION;

// Close air-conditioner parameter(corresponding to command DH_CTRL_AIRCONDITION_CLOSE)
typedef struct tagNET_CTRL_CLOSE_AIRCONDITION
{
    DWORD               dwSize;
    char				szDeviceID[DH_MAX_DEV_ID_LEN];			// Device SN
} NET_CTRL_CLOSE_AIRCONDITION;

// Set temperature parameter (corresponding command DH_CTRL_AIRCONDITION_SET_TEMPERATURE)
typedef struct tagNET_CTRL_SET_TEMPERATURE
{
    DWORD               dwSize;
    char				szDeviceID[DH_MAX_DEV_ID_LEN];			// SN 
    int                 nTemperature;                           // Temperature value(unit: degree Celsius)
} NET_CTRL_SET_TEMPERATURE;

// Adjust temperature parameter(corresponding command DH_CTRL_AIRCONDITION_ADJUST_TEMPERATURE)
typedef struct tagNET_CTRL_ADJUST_TEMPERATURE
{
    DWORD               dwSize;
    char				szDeviceID[DH_MAX_DEV_ID_LEN];			// SN 
    int                 nTemperatureScale;                      // Set value
} NET_CTRL_ADJUST_TEMPERATURE;

// Set air condition working mode parameter (corresponding command DH_CTRL_AIRCONDITION_SETMODE)
typedef struct tagNET_CTRL_AIRCONDITION_SETMODE
{
    DWORD                       dwSize;
    char				        szDeviceID[DH_MAX_DEV_ID_LEN];	// SN 
    EM_AIRCONDITION_MODE        emAirconditionMode;             // Air conditioner working mode
    int                         nTemperature;                   // Set value (unit: degree Celsius)
} NET_CTRL_AIRCONDITION_SETMODE;

// Set fan mode parameter(corresponding command DH_CTRL_AIRCONDITION_SETWINDMODE)
typedef struct tagNET_CTRL_AIRCONDITION_SETWINDMODE
{
    DWORD                       dwSize;
    char				        szDeviceID[DH_MAX_DEV_ID_LEN];	// SN 
    EM_AIRCONDITION_WINDMODE    emAirconditionWindMode;         // Aircondition Wind Mode
} NET_CTRL_AIRCONDITION_SETWINDMODE;

// IO control command. Corresponding to CLIENT_QueryIOControlState
typedef enum _IOTYPE
{
	DH_ALARMINPUT = 1,							// Control alarm input 
	DH_ALARMOUTPUT = 2,							// ontrol alarm output 
	DH_DECODER_ALARMOUT = 3,					// Control alarm decoder output 
	DH_WIRELESS_ALARMOUT = 5,					// Control wireless alarm output 
	DH_ALARM_TRIGGER_MODE = 7,					// Alarm activation type(auto/manual/close). Use TRIGGER_MODE_CONTROL structure 
} DH_IOTYPE;

/////////////////////////////////Configuration Related/////////////////////////////////

// Resolution enumeration. For DH_DSP_ENCODECAP to use 
typedef enum _CAPTURE_SIZE
{
	CAPTURE_SIZE_D1,							// 704*576(PAL)  704*480(NTSC),compatible WWxHH,the same below
	CAPTURE_SIZE_HD1,							// 352*576(PAL)  352*480(NTSC)
	CAPTURE_SIZE_BCIF,							// 704*288(PAL)  704*240(NTSC)
	CAPTURE_SIZE_CIF,							// 352*288(PAL)  352*240(NTSC)
	CAPTURE_SIZE_QCIF,							// 176*144(PAL)  176*120(NTSC)
	CAPTURE_SIZE_VGA,							// 640*480
	CAPTURE_SIZE_QVGA,							// 320*240
	CAPTURE_SIZE_SVCD,							// 480*480
	CAPTURE_SIZE_QQVGA,							// 160*128
	CAPTURE_SIZE_SVGA,							// 800*592
	CAPTURE_SIZE_XVGA,							// 1024*768
	CAPTURE_SIZE_WXGA,							// 1280*800
	CAPTURE_SIZE_SXGA,							// 1280*1024  
	CAPTURE_SIZE_WSXGA,							// 1600*1024  
	CAPTURE_SIZE_UXGA,							// 1600*1200
	CAPTURE_SIZE_WUXGA,							// 1920*1200
	CAPTURE_SIZE_LTF,							// 240*192
	CAPTURE_SIZE_720,							// 1280*720
	CAPTURE_SIZE_1080,							// 1920*1080
	CAPTURE_SIZE_1_3M,							// 1280*960
	CAPTURE_SIZE_2M,							// 1872*1408
	CAPTURE_SIZE_5M,							// 3744*1408
	CAPTURE_SIZE_3M,							// 2048*1536
	CAPTURE_SIZE_5_0M,                          // 2432*2050
	CPTRUTE_SIZE_1_2M,							// 1216*1024
	CPTRUTE_SIZE_1408_1024,                     // 1408*1024
	CPTRUTE_SIZE_8M,                            // 3296*2472
	CPTRUTE_SIZE_2560_1920,                     // 2560*1920(5M)
	CAPTURE_SIZE_960H,                          // 960*576(PAL) 960*480(NTSC)
	CAPTURE_SIZE_960_720,                       // 960*720
	CAPTURE_SIZE_NHD,							// 640*360
	CAPTURE_SIZE_QNHD,							// 320*180
	CAPTURE_SIZE_QQNHD,							// 160*90
	CAPTURE_SIZE_960_540,						// 960*540
	CAPTURE_SIZE_640_352,						// 640*352
	CAPTURE_SIZE_640_400,						// 640*400
	CAPTURE_SIZE_320_192,						// 320*192	
	CAPTURE_SIZE_320_176,						// 320*176
	CAPTURE_SIZE_SVGA1,                         // 800*600
	CAPTURE_SIZE_NR=255  
} CAPTURE_SIZE;

// Configuration file type. For CLIENT_ExportConfigFile to use. 
typedef enum __DH_CONFIG_FILE_TYPE
{
	DH_CONFIGFILE_ALL = 0,						// All configuration file 
	DH_CONFIGFILE_LOCAL,						// Local configuration file 
	DH_CONFIGFILE_NETWORK,						// Network configuration file 
	DH_CONFIGFILE_USER,							// User configuration file 
} DH_CONFIG_FILE_TYPE;

// NTP
typedef enum __DH_TIME_ZONE_TYPE
{
	DH_TIME_ZONE_0,								// {0, 0*3600,"GMT+00:00"}
	DH_TIME_ZONE_1,								// {1, 1*3600,"GMT+01:00"}
	DH_TIME_ZONE_2,								// {2, 2*3600,"GMT+02:00"}
	DH_TIME_ZONE_3,								// {3, 3*3600,"GMT+03:00"}
	DH_TIME_ZONE_4,								// {4, 3*3600+1800,"GMT+03:30"}
	DH_TIME_ZONE_5,								// {5, 4*3600,"GMT+04:00"}
	DH_TIME_ZONE_6,								// {6, 4*3600+1800,"GMT+04:30"}
	DH_TIME_ZONE_7,								// {7, 5*3600,"GMT+05:00"}
	DH_TIME_ZONE_8,								// {8, 5*3600+1800,"GMT+05:30"}
	DH_TIME_ZONE_9,								// {9, 5*3600+1800+900,"GMT+05:45"}
	DH_TIME_ZONE_10,							// {10, 6*3600,"GMT+06:00"}
	DH_TIME_ZONE_11,							// {11, 6*3600+1800,"GMT+06:30"}
	DH_TIME_ZONE_12,							// {12, 7*3600,"GMT+07:00"}
	DH_TIME_ZONE_13,							// {13, 8*3600,"GMT+08:00"}
	DH_TIME_ZONE_14,							// {14, 9*3600,"GMT+09:00"}
	DH_TIME_ZONE_15,							// {15, 9*3600+1800,"GMT+09:30"}
	DH_TIME_ZONE_16,							// {16, 10*3600,"GMT+10:00"}
	DH_TIME_ZONE_17,							// {17, 11*3600,"GMT+11:00"}
	DH_TIME_ZONE_18,							// {18, 12*3600,"GMT+12:00"}
	DH_TIME_ZONE_19,							// {19, 13*3600,"GMT+13:00"}
	DH_TIME_ZONE_20,							// {20, -1*3600,"GMT-01:00"}
	DH_TIME_ZONE_21,							// {21, -2*3600,"GMT-02:00"}
	DH_TIME_ZONE_22,							// {22, -3*3600,"GMT-03:00"}
	DH_TIME_ZONE_23,							// {23, -3*3600-1800,"GMT-03:30"}
	DH_TIME_ZONE_24,							// {24, -4*3600,"GMT-04:00"}
	DH_TIME_ZONE_25,							// {25, -5*3600,"GMT-05:00"}
	DH_TIME_ZONE_26,							// {26, -6*3600,"GMT-06:00"}
	DH_TIME_ZONE_27,							// {27, -7*3600,"GMT-07:00"}
	DH_TIME_ZONE_28,							// {28, -8*3600,"GMT-08:00"}
	DH_TIME_ZONE_29,							// {29, -9*3600,"GMT-09:00"}
	DH_TIME_ZONE_30,							// {30, -10*3600,"GMT-10:00"}
	DH_TIME_ZONE_31,							// {31, -11*3600,"GMT-11:00"}
	DH_TIME_ZONE_32,							// {32, -12*3600,"GMT-12:00"}
} DH_TIME_ZONE_TYPE;

typedef enum _SNAP_TYPE
{
	SNAP_TYP_TIMING = 0,
	SNAP_TYP_ALARM,
	SNAP_TYP_NUM,
} SNAP_TYPE;

typedef enum _CONNECT_STATE
{
	CONNECT_STATE_UNCONNECT  = 0,	// no connected 
	CONNECT_STATE_CONNECTING,		// connecting
	CONNECT_STATE_CONNECTED,		// connected
	CONNECT_STATE_EMPTY,			// has connected, but config information is empty
	CONNECT_STATE_CHANGED,			// config information has changed
	CONNECT_STATE_ERROR = 255,		// unknown state
} CONNECT_STATE;

// Snap mode
typedef enum tagDH_TRAFFIC_SNAP_MODE
{	
	DH_TRAFFIC_SNAP_MODE_COIL = 1,				       // Loop snap
	DH_TRAFFIC_SNAP_MODE_COIL_PICANALYSIS,		       // Loop snap   picture analysis
	DH_TRAFFIC_SNAP_MODE_STREAM,				       // Video snap
	DH_TRAFFIC_SNAP_MODE_STREAM_IDENTIFY,		       // Video snap and recognize
} DH_TRAFFIC_SNAP_MODE;

// carport light type
typedef enum 
{
	NET_CARPORTLIGHT_TYPE_RED,                           // red
	NET_CARPORTLIGHT_TYPE_GREEN,                         // green
}NET_CARPORTLIGHT_TYPE;

// carport light mode
typedef enum
{
	NET_CARPORTLIGHT_MODE_OFF,                           // off 
	NET_CARPORTLIGHT_MODE_ON,                            // on
	NET_CARPORTLIGHT_MODE_GLINT,                         // glint
}NET_CARPORTLIGHT_MODE;

/////////////////////////////////Intelligent transportation related/////////////////////////////////
//Black and white list type operation
typedef enum _EM_OPERATE_TYPE
{
	NET_TRAFFIC_LIST_INSERT	    ,								// Increase the record operation(Correspond to NET_INSERT_RECORD_INFO)
	NET_TRAFFIC_LIST_UPDATE		,								// Record update operation(Correspond to NET_UPDATE_RECORD_INFO)
	NET_TRAFFIC_LIST_REMOVE		,								// Delete the record operation(Correspond to NET_REMOVE_RECORD_INFO)
	NET_TRAFFIC_LIST_MAX		,
}EM_RECORD_OPERATE_TYPE ;

//License plate type
typedef enum _EM_NET_PLATE_TYPE
{
	NET_PLATE_TYPE_UNKNOWN					,
	NET_PLATE_TYPE_NORMAL					,		// "Normal" Blue card black card
	NET_PLATE_TYPE_YELLOW					,		// "Yellow" yellow card
	NET_PLATE_TYPE_DOUBLEYELLOW				,		// "DoubleYellow" Double yellow back card
	NET_PLATE_TYPE_POLICE					,		// "Police" Police card
	NET_PLATE_TYPE_ARMED					,		// "Armed" Armed card
	NET_PLATE_TYPE_MILITARY					,		// "Military" Force plate
	NET_PLATE_TYPE_DOUBLEMILITARY			,		// "DoubleMilitary" Forces double
	NET_PLATE_TYPE_SAR						,		// "SAR" Hong Kong and Macao SAR plate	
	NET_PLATE_TYPE_TRAINNING				,		// "Trainning" Drivers Ed plate
	NET_PLATE_TYPE_PERSONAL					,		// "Personal" Personality plate
	NET_PLATE_TYPE_AGRI						,		// "Agri" Agri-using card
	NET_PLATE_TYPE_EMBASSY					,		// "Embassy" The embassy of plate
	NET_PLATE_TYPE_MOTO						,		// "Moto" Motorcycle plate
	NET_PLATE_TYPE_TRACTOR					,		// "Tractor" The tractor plate
	NET_PLATE_TYPE_OFFICIALCAR				,		// "OfficialCar " officer's car
	NET_PLATE_TYPE_PERSONALCAR				,		// "PersonalCar" private car
	NET_PLATE_TYPE_WARCAR					,		// "WarCar"  for military use
	NET_PLATE_TYPE_OTHER					,		// "Other" The other plate
	NET_PLATE_TYPE_CIVILAVIATION			,       // "Civilaviation" Civilaviation
	NET_PLATE_TYPE_BLACK					,       // "Black" 
	NET_PLATE_TYPE_PURENEWENERGYMICROCAR	,       // "PureNewEnergyMicroCar" pure new energy micro car
	NET_PLATE_TYPE_MIXEDNEWENERGYMICROCAR	,       // "MixedNewEnergyMicroCar" mixed new energy micro car
	NET_PLATE_TYPE_PURENEWENERGYLARGECAR	,       // "PureNewEnergyLargeCar" pure new energy large car
	NET_PLATE_TYPE_MIXEDNEWENERGYLARGECAR	,       // "MixedNewEnergyLargeCar" mixed new energy large car

}EM_NET_PLATE_TYPE;


//The license plate color
typedef enum _EM_NET_PLATE_COLOR_TYPE
{
	NET_PLATE_COLOR_OTHER 						,				//	other colors
	NET_PLATE_COLOR_BLUE						,				//	blue		"Blue"
	NET_PLATE_COLOR_YELLOW						,				//	yellow		"Yellow"	
	NET_PLATE_COLOR_WHITE						,				//	white		"White"
	NET_PLATE_COLOR_BLACK						,				//	black		"Black"
	NET_PLATE_COLOR_YELLOW_BOTTOM_BLACK_TEXT	,				//	Yellow Bottom Positive Figure	"YellowbottomBlackText"
	NET_PLATE_COLOR_BLUE_BOTTOM_WHITE_TEXT		,				//	blue-mask LCD" 
	NET_PLATE_COLOR_BLACK_BOTTOM_WHITE_TEXT		,				//	White on Black	"BlackBottomWhiteText"
	NET_PLATE_COLOR_SHADOW_GREEN				,				//  Shadow Green
	NET_PLATE_COLOR_YELLOW_GREEN				,				//  YellowGreen
}EM_NET_PLATE_COLOR_TYPE;

//vehicle type
typedef enum _EM_NET_VEHICLE_TYPE
{
	NET_VEHICLE_TYPE_UNKNOW					  ,				//  unknown type
	NET_VEHICLE_TYPE_MOTOR					  ,				// "Motor" Motor vehicles"		   
	NET_VEHICLE_TYPE_NON_MOTOR				  ,				// "Non-Motor"non-Motor vehicles"		
	NET_VEHICLE_TYPE_BUS					  ,				// "Bus"bus		
	NET_VEHICLE_TYPE_BICYCLE				  ,				// "Bicycle"Bicycle		
    NET_VEHICLE_TYPE_MOTORCYCLE               ,             // "Motorcycle"        
	NET_VEHICLE_TYPE_UNLICENSEDMOTOR		  ,				// "UnlicensedMotor": A motor vehicle without a license
	NET_VEHICLE_TYPE_LARGECAR				  ,				// "LargeCar"  LargeCar
	NET_VEHICLE_TYPE_MICROCAR				  ,				// "MicroCar" MicroCar
	NET_VEHICLE_TYPE_EMBASSYCAR				  ,				// "EmbassyCar" EmbassyCa
	NET_VEHICLE_TYPE_MARGINALCAR			  ,				// "MarginalCar" MarginalCar
	NET_VEHICLE_TYPE_AREAOUTCAR				  ,				// "AreaoutCar" AreaoutCar
	NET_VEHICLE_TYPE_FOREIGNCAR				  ,				// "ForeignCar" ForeignCar
	NET_VEHICLE_TYPE_DUALTRIWHEELMOTORCYCLE	  ,				// "DualTriWheelMotorcycle"Two or three rounds of motorcycle
	NET_VEHICLE_TYPE_LIGHTMOTORCYCLE		  , 			// "LightMotorcycle"  light motorcycle
	NET_VEHICLE_TYPE_EMBASSYMOTORCYCLE		  ,				// "EmbassyMotorcycle "The embassy of the motorcycle
	NET_VEHICLE_TYPE_MARGINALMOTORCYCLE		  ,				// "MarginalMotorcycle "Consulate motorcycle
	NET_VEHICLE_TYPE_AREAOUTMOTORCYCLE		  ,				// "AreaoutMotorcycle "Outside the motorcycle
	NET_VEHICLE_TYPE_FOREIGNMOTORCYCLE		  ,				// "ForeignMotorcycle "Foreign motorcycle
	NET_VEHICLE_TYPE_FARMTRANSMITCAR		  ,				// "FarmTransmitCar" agricultural vehicle
	NET_VEHICLE_TYPE_TRACTOR				  ,				// "Tractor" tractor
	NET_VEHICLE_TYPE_TRAILER				  ,				// "Trailer"  trailer
	NET_VEHICLE_TYPE_COACHCAR				  ,				// "CoachCar "Car coach
	NET_VEHICLE_TYPE_COACHMOTORCYCLE		  ,				// "CoachMotorcycle " coach Motorcycle
	NET_VEHICLE_TYPE_TRIALCAR				  ,				// "TrialCar" trial car 
    NET_VEHICLE_TYPE_TRIALMOTORCYCLE,                   	// "TrialMotorcycle "Test motorcycle
	NET_VEHICLE_TYPE_TEMPORARYENTRYCAR		  ,				// "TemporaryEntryCar"Temporary entry vehicle
	NET_VEHICLE_TYPE_TEMPORARYENTRYMOTORCYCLE ,				// "TemporaryEntryMotorcycle"Temporary entry of motorcycle
	NET_VEHICLE_TYPE_TEMPORARYSTEERCAR		  ,			    // "TemporarySteerCar"Temporary driving car
	NET_VEHICLE_TYPE_PASSENGERCAR			  ,				// "PassengerCar" passenger car
	NET_VEHICLE_TYPE_LARGETRUCK				  ,				// "LargeTruck" LargeTruck
	NET_VEHICLE_TYPE_MIDTRUCK				  ,				// "MidTruck" MidTruck
	NET_VEHICLE_TYPE_SALOONCAR				  ,				// "SaloonCar" SaloonCar
	NET_VEHICLE_TYPE_MICROBUS                 ,				// "Microbus" Microbus
	NET_VEHICLE_TYPE_MICROTRUCK				  ,				// "MicroTruck" MicroTruck
    NET_VEHICLE_TYPE_TRICYCLE				  ,				// "Tricycle" Tricycle
	NET_VEHICLE_TYPE_PASSERBY				  ,				// "Passerby" Passerby
}EM_NET_VEHICLE_TYPE;


//body color
typedef enum _EM_NET_VEHICLE_COLOR_TYPE
{
	NET_VEHICLE_COLOR_OTHER					,				//other color	
	NET_VEHICLE_COLOR_WHITE					,				//white		"White"
	NET_VEHICLE_COLOR_BLACK					,				//black		"Black"
	NET_VEHICLE_COLOR_RED					,				//red		"Red"
	NET_VEHICLE_COLOR_YELLOW				,				//yellow	"Yellow"
	NET_VEHICLE_COLOR_GRAY					,				//gray		"Gray"
	NET_VEHICLE_COLOR_BLUE					,				//blue		"Blue"
	NET_VEHICLE_COLOR_GREEN					,				//green		"Green"
	NET_VEHICLE_COLOR_PINK					,				//pink		"Pink"
	NET_VEHICLE_COLOR_PURPLE				,				//purple	"Purple"
	NET_VEHICLE_COLOR_BROWN					,				//brown		"Brown"
}EM_NET_VEHICLE_COLOR_TYPE;

//Open the coil
typedef enum _EM_NET_TRAFFIC_CAR_CONTROL_TYPE
{
	NET_CAR_CONTROL_OTHER					,
	NET_CAR_CONTROL_OVERDUE_NO_CHECK		,				// Overdue inspection				"OverdueNoCheck"
	NET_CAR_CONTROL_BRIGANDAGE_CAR			,				// Stolen vehicles					"BrigandageCar"
	NET_CAR_CONTROL_BREAKING				,				// Break rules and regulations		"Breaking"
	NET_CAR_CONTROL_CAUSETROUBLE_ESCAPE		,				// Hit and run						"CausetroubleEscape"
}EM_NET_TRAFFIC_CAR_CONTROL_TYPE;

typedef enum _EM_NET_AUTHORITY_TYPE
{
	NET_AUTHORITY_UNKNOW					,
	NET_AUTHORITY_OPEN_GATE					,				// open gate
}EM_NET_AUTHORITY_TYPE;

typedef enum _EM_NET_RECORD_TYPE
{
  NET_RECORD_UNKNOWN,

  NET_RECORD_TRAFFICREDLIST,              // Traffic white list account record
                                          // search criteria corresponding to FIND_RECORD_TRAFFICREDLIST_CONDITION structure 
                                          // record info corresponding to NET_TRAFFIC_LIST_RECORD structure 
  NET_RECORD_TRAFFICBLACKLIST,            // Traffic black list account record
                                          // search criteria corresponding to FIND_RECORD_TRAFFICREDLIST_CONDITION structure 
                                          // record info corresponding to NET_TRAFFIC_LIST_RECORD structure 
  NET_RECORD_BURN_CASE,                   // burning case record
                                          // search criteria corresponding to FIND_RECORD_BURN_CASE_CONDITION structure 
                                          // record info corresponding to NET_BURN_CASE_INFO structure 
  NET_RECORD_ACCESSCTLCARD,               // access control card
                                          // search criteria corresponding to FIND_RECORD_ACCESSCTLCARD_CONDITION structure 
                                          // record info corresponding to NET_RECORDSET_ACCESS_CTL_CARD structure 
  NET_RECORD_ACCESSCTLPWD,                // access control password
                                          // search criteria corresponding to FIND_RECORD_ACCESSCTLPWD_CONDITION structure 
                                          // record info corresponding to NET_RECORDSET_ACCESS_CTL_PWD
  NET_RECORD_ACCESSCTLCARDREC,            // access control in/out record
                                          // search criteria corresponding to FIND_RECORD_ACCESSCTLCARDREC_CONDITION structure 
                                          // record info corresponding to 
  NET_RECORD_ACCESSCTLHOLIDAY,            // holiday record set
                                          // search criteria corresponding to FIND_RECORD_ACCESSCTLHOLIDAY_CONDITION structure 
                                          // record info corresponding to 
  NET_RECORD_TRAFFICFLOW_STATE,           // search Traffic flow record 
                                          // search criteria corresponding to FIND_RECORD_TRAFFICFLOW_CONDITION structure 
                                          // record info corresponding to NET_RECORD_TRAFFIC_FLOW_STATE structure 
  NET_RECORD_VIDEOTALKLOG,                // call record 
                                          // search criteria corresponding to FIND_RECORD_VIDEO_TALK_LOG_CONDITION structure 
                                          // record info corresponding to NET_RECORD_VIDEO_TALK_LOG structure 
  NET_RECORD_REGISTERUSERSTATE,           // status record 
                                          // search criteria corresponding to FIND_RECORD_REGISTER_USER_STATE_CONDITION structure 
                                          // record info corresponding to NET_RECORD_REGISTER_USER_STATE structure 
  NET_RECORD_VIDEOTALKCONTACT,            // contact record 
                                          // search criteria corresponding to FIND_RECORD_VIDEO_TALK_CONTACT_CONDITION structure 
														// record info corresponding to NET_RECORD_VIDEO_TALK_CONTACT structure 
	NET_RECORD_ANNOUNCEMENT,							// Record info corresponding to structure NET_RECORD_ANNOUNCEMENT_INFO 
														// No search criteria 
														
	NET_RECORD_ALARMRECORD,								// Record info corresponding to structure NET_RECORD_ALARMRECORD_INFO 
														// No search criteria 

    NET_RECORD_COMMODITYNOTICE,                         // Issue commodiy record 
                                                        // Record info corresponding to structure NET_RECORD_COMMODITY_NOTICE 
    NET_RECORD_HEALTHCARENOTICE,                        // Medical info  
                                                        // Record info corresponding to structure NET_RECORD_HEALTH_CARE_NOTICE
    NET_RECORD_ACCESSCTLCARDREC_EX,                     // A&C entry-exit record(can select some critera to search. Please replace NET_RECORD_ACCESSCTLCARDREC)
                                                        // Search criteria corresponding to structure FIND_RECORD_ACCESSCTLCARDREC_CONDITION_EX
                                                        // Record info corresponding to structure NET_RECORDSET_ACCESS_CTL_CARDREC

    NET_RECORD_GPS_LOCATION,                            // GPS position information reocrd, support import and clear only.
                                                        // Record info corresponding to structure NET_RECORD_GPS_LOCATION_INFO 

    NET_RECORD_RESIDENT,                                // resident info
    													// Record info corresponding to structure FIND_RECORD_RESIDENT_CONDTION    													
                                                        // Record info corresponding to NET_RECORD_RESIDENT_INFO 

	NET_RECORD_SENSORRECORD,                            // sensor record
														// Search criteria corresponding to structure FIND_RECORD_SENSORRECORD_CONDITION 
														// Record info corresponding to structure NET_RECORD_SENSOR_RECORD
	NET_RECORD_ACCESSQRCODE,							// AccessQRCode record 
														// Record info corresponding to structure NET_RECORD_ACCESSQRCODE_INFO

  	NET_RECORD_ELECTRONICSTAG,						  	// electronic tag info record
														// Search criteria corresponding to structure FIND_RECORD_ELECTRONICSTAG_CONDITION
														// Record info corresponding to NET_RECORD_ELECTRONICSTAG_INFO

    NET_RECORD_ACCESS_BLUETOOTH,					    // Access blue tooth record
                                                        // Search blue tooth access record corresponding to structure FIND_RECORD_ACCESS_BLUETOOTH_INFO_CONDITION
                                                        // Record info corresponding to structure NET_RECORD_ACCESS_BLUETOOTH_INFO
    NET_RECORD_ACCESS_ALARMRECORD,                      // Accesscontrol alarm record
                                                        // Search conditionnull
                                                        // Record info corresponding to NET_RECORD_ACCESS_ALARMRECORD_INFO 
}EM_NET_RECORD_TYPE;

// time type
typedef enum
{
	NET_TIME_TYPE_ABSLUTE,                                  // absolute time  
	NET_TIME_TYPE_RELATIVE,                                 // Relative time, relative to the video file header frame as the time basis points, the first frame corresponding to the UTC (0000-00-00 00:00:00)
}EM_TIME_TYPE;

// color type
typedef enum
{
	NET_COLOR_TYPE_RED,                                     // red
	NET_COLOR_TYPE_YELLOW,                                  // yellow
	NET_COLOR_TYPE_GREEN,                                   // green
	NET_COLOR_TYPE_CYAN,                                    // cyan
	NET_COLOR_TYPE_BLUE,                                    // glue
	NET_COLOR_TYPE_PURPLE,                                  // purple
	NET_COLOR_TYPE_BLACK,                                   // black
	NET_COLOR_TYPE_WHITE,                                   // white
	NET_COLOR_TYPE_MAX,
}EM_COLOR_TYPE;

/////////////////////////////////Face recognition related/////////////////////////////////
// Personnel type
typedef enum 
{
	PERSON_TYPE_UNKNOWN,
	PERSON_TYPE_NORMAL,                                     // common person
	PERSON_TYPE_SUSPICION,                                  // Suspects
	PERSON_TYPE_THIEF,                                      // Thieves
	PERSON_TYPE_VIP,                                        // VIP
	PERSON_TYPE_FATECHECK,                                  // FateCheck
    PERSON_TYPE_STAFF,                                      // Staff
}EM_PERSON_TYPE;

// ID type
typedef enum
{
	CERTIFICATE_TYPE_UNKNOWN,
	CERTIFICATE_TYPE_IC,                                    // ID
	CERTIFICATE_TYPE_PASSPORT,                              // passport 
	CERTIFICATE_TYPE_MILITARY,								// military
}EM_CERTIFICATE_TYPE;

// Face recognition database operations
typedef enum
{
	NET_FACERECONGNITIONDB_UNKOWN, 
	NET_FACERECONGNITIONDB_ADD,							// Add personnel information and face samples, if researchers already exists, image data and the original data
	NET_FACERECONGNITIONDB_DELETE,						// Delete the personnel information and face samples
    NET_FACERECONGNITIONDB_MODIFY,                      // Modify person info and human face sample, must input person UID
    NET_FACERECONGNITIONDB_DELETE_BY_UID,               // Delete person info and human face via UID
}EM_OPERATE_FACERECONGNITIONDB_TYPE;

// Face contrast pattern
typedef enum 
{
	NET_FACE_COMPARE_MODE_UNKOWN,
	NET_FACE_COMPARE_MODE_NORMAL,                  // normal
	NET_FACE_COMPARE_MODE_AREA,                    // Specify the face region combination area
	NET_FACE_COMPARE_MODE_AUTO,                    // Intelligent model, the algorithm according to the situation of facial regions automatically select combination
}EM_FACE_COMPARE_MODE;

// Face region
typedef enum
{
	NET_FACE_AREA_TYPE_UNKOWN,
	NET_FACE_AREA_TYPE_EYEBROW,                    // eyebrow
	NET_FACE_AREA_TYPE_EYE,                        // eye 
	NET_FACE_AREA_TYPE_NOSE,                       // nose
	NET_FACE_AREA_TYPE_MOUTH,                      // mouth
	NET_FACE_AREA_TYPE_CHEEK,                      // face
}EM_FACE_AREA_TYPE;

// face data type
typedef enum
{
	NET_FACE_DB_TYPE_UNKOWN,
	NET_FACE_DB_TYPE_HISTORY,						// History database, storage is to detect the human face information, usually does not contain face corresponding personnel information
	NET_FACE_DB_TYPE_BLACKLIST,						// The blacklist database (it is registe DB now)
	NET_FACE_DB_TYPE_WHITELIST,						// The whitelist database (unuse)
	NET_FACE_DB_TYPE_ALARM  ,						// Alarm library (unuse)
	NET_FACE_DB_TYPE_PASSERBY,						// Passerby DB
}EM_FACE_DB_TYPE;

// Face recognition event type
typedef enum 
{
	NET_FACERECOGNITION_ALARM_TYPE_UNKOWN,
	NET_FACERECOGNITION_ALARM_TYPE_ALL,                // blacklist and whitelist
	NET_FACERECOGNITION_ALARM_TYPE_BLACKLIST,          // The blacklist
	NET_FACERECOGNITION_ALARM_TYPE_WHITELIST,          // The whitelist
}EM_FACERECOGNITION_ALARM_TYPE;

// Face recognition face type
typedef enum
{
	EM_FACERECOGNITION_FACE_TYPE_UNKOWN,
	EM_FACERECOGNITION_FACE_TYPE_ALL,                  // All the faces 
	EM_FACERECOGNITION_FACE_TYPE_REC_SUCCESS,          // recognition success
	EM_FACERECOGNITION_FACE_TYPE_REC_FAIL,             // recognition fail
}EM_FACERECOGNITION_FACE_TYPE;

// Frame type enumeration values  
typedef enum __EM_FRAME_TYPE
{
	EM_FRAME_UNKOWN,                                   // unknown type
	EM_FRAME_TYPE_MOTION,                              // DM frame, corresponding frame information structure NET_MOTION_FRAME_INFO
}EM_FRAME_TYPE;

/////////////////////////////////Cancelled Type/////////////////////////////////

// Configuration type. The interface that uses the enumberaiton has been canceled. Please do not use. 
typedef enum _CFG_INDEX
{
    CFG_GENERAL = 0,							// General 
	CFG_COMM,									// COM
	CFG_NET,									// Network
	CFG_RECORD,									// Record
	CFG_CAPTURE,								// Video setup
	CFG_PTZ,									// PTZ
	CFG_DETECT,									// Motion detection
	CFG_ALARM,									// Alarm 
	CFG_DISPLAY,								// Display 
	CFG_RESERVED,								// Reserved to keet type consecutive
	CFG_TITLE = 10,								// channel title 
	CFG_MAIL = 11,								// Mail function 
	CFG_EXCAPTURE = 12,							// preview video setup
	CFG_PPPOE = 13,								// pppoe setup
	CFG_DDNS = 14,								// DDNS  setup
	CFG_SNIFFER	= 15,							// Network monitor capture setup
	CFG_DSPINFO	= 16,							// Encode capacity information
	CFG_COLOR = 126,							// Color setup information 
	CFG_ALL,									// Reserved 
} CFG_INDEX;


/************************************************************************
 ** Structure Definition 
 ***********************************************************************/


//display area relative to the original display area coordinates
typedef struct
{
    double				dleft;					//left
	double				dright;					//right
	double				dtop;					//top
	double				dbottom;				//bottom
} DH_DISPLAYRREGION;
// Time
typedef struct tagNET_TIME
{
	DWORD				dwYear;					// Year
	DWORD				dwMonth;				// Month
	DWORD				dwDay;					// Date
	DWORD				dwHour;					// Hour
	DWORD				dwMinute;				// Minute
	DWORD				dwSecond;				// Second
} NET_TIME,*LPNET_TIME;

typedef struct tagNET_TIME_EX
{
	DWORD				dwYear;					// Year
	DWORD				dwMonth;				// Month
	DWORD				dwDay;					// Date
	DWORD				dwHour;					// Hour
	DWORD				dwMinute;				// Minute
	DWORD				dwSecond;				// Second
	DWORD               dwMillisecond;          // Millisecond
	DWORD               dwUTC;                  // utc query: zero means invaild, non-zero means vaild;  set:invalid
	DWORD               dwReserved[1];          // reserved data
} NET_TIME_EX,*LPNET_TIME_EX;

typedef struct tagUTCTime
{
	unsigned int		utc;					  // utc
	unsigned int		tolerance;				  // tolerance, allows the setting time to be seconds away from the current time without modification; set:valid
	char				reserved[8];			  // reserved data
}NET_UTCTIME, *LPNET_UTCTIME;

// The time definition in the log information
typedef struct _DHDEVTIME
{
	DWORD				second		:6;			// Second	1-60		
	DWORD				minute		:6;			// Minute	1-60		
	DWORD				hour		:5;			// Hour		1-24		
	DWORD				day			:5;			// Date		1-31		
	DWORD				month		:4;			// Month	1-12		
	DWORD				year		:6;			// Year	2000-2063	
} DHDEVTIME, *LPDHDEVTIME;

typedef struct tagRANGE
{
    float               fMax;                               // Max value
    float               fMin;                               // Min value
    BOOL                abStep;                             // Enable step or not 
    float               fStep;                              // Step 
    BOOL                abDefault;                          // Enable default value or not 
    float               fDefault;                           // Default value 
    char reserved[16];
} RANGE;

//automatic flat field correction period range
typedef struct tagNET_FFCPERIOD_RANGE
{
	int                 nMaxN;                              // Max value(NTSC)
	int                 nMaxP;                              // Max value(PAL)
	int                 nMin;                               // Min value
	int                 nStep;                              // Step
	BYTE reserved[16];
} NET_FFCPERIOD_RANGE;

// callback data(Asynchronous interface)
typedef struct __NET_CALLBACK_DATA 
{
	int					nResultCode;			// Result code;0:Success
	char				*pBuf;					// Receive data,buffer is opened by the user,from the interface parameters,length is nRetLen
	int					nRetLen;				// the length of receive data
	LLONG				lOperateHandle;			// Operating handle
	void*				userdata;				// User parameters
	char				reserved[16];
} NET_CALLBACK_DATA, *LPNET_CALLBACK_DATA;

///////////////////////////////Monitor Related Definition ///////////////////////////////

// Frame parameter structure of Callback video data frame 
typedef struct _tagVideoFrameParam
{
	BYTE				encode;					// Encode type 
	BYTE				frametype;				// I = 0, P = 1, B = 2...
	BYTE				format;					// PAL - 0, NTSC - 1
	BYTE				size;					// CIF - 0, HD1 - 1, 2CIF - 2, D1 - 3, VGA - 4, QCIF - 5, QVGA - 6 ,
												// SVCD - 7,QQVGA - 8, SVGA - 9, XVGA - 10,WXGA - 11,SXGA - 12,WSXGA - 13,UXGA - 14,WUXGA - 15; LFT - 16, 720 - 17, 1080 - 18,
												// 1_3M-19, 2M-20, 5M-21;when size equal to 255, width and height valid
	DWORD				fourcc;					// If it is H264 encode it is always 0,Fill in FOURCC('X','V','I','D') in MPEG 4;
	WORD				width;					// width pixel, valid when struct member "size"  equal to 255
	WORD				height;					// height pixel, valid when struct member "size"  equal to 255
	NET_TIME			struTime;				// Time information 
} tagVideoFrameParam;


// Frame parameter structure of audio data callback 
typedef struct _tagCBPCMDataParam
{
	BYTE				channels;				// Track amount 
	BYTE				samples;				// sample 0 - 8000, 1 - 11025, 2 - 16000, 3 - 22050, 4 - 32000, 5 - 44100, 6 - 48000
	BYTE				depth;					// Sampling depth. Value:8/16 show directly
	BYTE				param1;					// 0 - indication no symbol,1-indication with symbol
	DWORD				reserved;				// Reserved
} tagCBPCMDataParam;


// frame data type of convert stream
typedef enum tagEM_STREAMCONVERT_FRAMEDATA_TYPE
{	
	EM_STREAMCONVERT_FRAMEDATA_UNKNOWN,					// unknown
	EM_STREAMCONVERT_FRAMEDATA_VIDEO,					// video data
	EM_STREAMCONVERT_FRAMEDATA_AUDIO,					// audio data	
} EM_STREAMCONVERT_FRAMEDATA_TYPE;

// data info of convert stream
typedef struct tagNET_STREAMCONVERT_INFO
{
	EM_STREAMCONVERT_FRAMEDATA_TYPE		emDataType;		// frame data type
	void*								pFrameInfo;		// frame info
														// if emDataType is EM_STREAMCONVERT_FRAMEDATA_VIDEO,  pFrameInfo's type is tagVideoFrameParam
														// if emDataType is EM_STREAMCONVERT_FRAMEDATA_AUDIO, pFrameInfo's type is tagCBPCMDataParam
}NET_STREAMCONVERT_INFO;

// Data structure of channel video title overlay 
typedef struct _DH_CHANNEL_OSDSTRING
{
	BOOL				bEnable;				// Enable 
	DWORD				dwPosition[MAX_STRING_LINE_LEN];//Character position in each line. The value ranges from 1 to 9.Corresponding to the small keyboard.
												//		7upper left 	8upper		9upper right 
												//		4left			5middle 	6right 
												//		1down left		2down	    3down right 
	char				szStrings[MAX_STRING_LINE_LEN][MAX_PER_STRING_LEN];	// Max 6 lines. Each line max 20 bytes.
} DH_CHANNEL_OSDSTRING;

// Para struct of YUV callback
typedef struct _tagCBYUVDataParam
{
	long				nWidth;                 // Width of image
	long				nHeight;				// Height of image
    NET_TIME            stNetTime;              // time in YUV stream
    DWORD               reserved[2];            // reserved
} tagCBYUVDataParam;

///////////////////////////////Definition relate with playback///////////////////////////////
// Type of video search
typedef enum tagEmQueryRecordType
{
    EM_RECORD_TYPE_ALL              = 0,            // All the recorded video  
    EM_RECORD_TYPE_ALARM            = 1,            // The video of external alarm
    EM_RECORD_TYPE_MOTION_DETECT    = 2,            // The video of dynamic detection alarm
    EM_RECORD_TYPE_ALARM_ALL        = 3,            // All the alarmed video
    EM_RECORD_TYPE_CARD             = 4,            // query by the card number
    EM_RECORD_TYPE_CONDITION        = 5,            // query by condition
    EM_RECORD_TYPE_JOIN             = 6,            // combination query 
    EM_RECORD_TYPE_CARD_PICTURE     = 8,            // query pictures by the card number, used by HB-U,NVS
    EM_RECORD_TYPE_PICTURE          = 9,            // query pictures, used by HB-U,NVS
    EM_RECORD_TYPE_FIELD            = 10,           // query by field
    EM_RECORD_TYPE_INTELLI_VIDEO    = 11,			// Smart record search 
    EM_RECORD_TYPE_NET_DATA         = 15,           // query network data, used by Jinqiao Internet Bar
    EM_RECORD_TYPE_TRANS_DATA       = 16,           // query the video of serial data
    EM_RECORD_TYPE_IMPORTANT        = 17,           // query the important video
    EM_RECORD_TYPE_TALK_DATA        = 18,           // query the recording file
    EM_RECORD_TYPE_POS				= 19,			// query the pos record

    EM_RECORD_TYPE_INVALID          = 256,          // invalid query type
    
}EM_QUERY_RECORD_TYPE;

// Record file information
typedef struct tagNET_RECORDFILE_INFO
{
    unsigned int		ch;						// Channel number
    char				filename[124];			// File name 
	unsigned int        framenum;               // the total number of file frames
    unsigned int		size;					// File length, unit: Kbyte 
    NET_TIME			starttime;				// Start time 
    NET_TIME			endtime;				// End time 
    unsigned int		driveno;				// HDD number 
    unsigned int		startcluster;			// Initial cluster number 
	BYTE				nRecordFileType;		// Recorded file type  0:general record;1:alarm record ;2:motion detection;3:card number record ;4:image ; 19:Pos record ;255:all
	BYTE                bImportantRecID;		// 0:general record 1:Important record
	BYTE                bHint;					// Document Indexing
	BYTE                bRecType;               // 0-main stream record 1-sub1 stream record 2-sub2 stream record 3-sub3 stream record
} NET_RECORDFILE_INFO, *LPNET_RECORDFILE_INFO;

// info of enrichment record file 
typedef struct tagNET_SynopsisFileInfo
{
	DWORD				dwSize;					// struct size 
    char				szFileName[MAX_PATH];	// file name,like :\a.dav
    NET_TIME			stuStartTime;			// start time
    NET_TIME			stuEndTime;				// end time
	unsigned int		nTaskID;				// server mark,with szFileName[] a choise
	BYTE				bFileType;				// 1-record file, 2- source file
	BYTE				byMode;					// Download mode: 0 - by file downloads, 1 - according to the time to download, 2 - according to download file offset
	BYTE				bReserved[2];
	unsigned int		nFileLength;			// file length (byte)
	unsigned int		nStartFileOffset;		// Starting file offset, unit: KB
	unsigned int		nEndFileOffset;			// The end of the file offset, the unit: KB
    int                 nChannel;               // channel, used for NVR playback(no TaskID), invalid for concentration server
    int                 nCluster;               // Cluster, used for NVR playback(no TaskID), invalid for concentration server
}NET_SYNOPSISFILE_INFO, *LPNET_SYNOPSISFILE_INFO;

// Playback data callback function prototype
// pBuffer: data buffer, memory malloc or free was managed by SDK interior
/**Whether the stream is encrypted,should call CLIENT_GetConfig(NET_EM_CFG_MEDIA_ENCRYPT) to get it;
   If bKeyFrameEncryptEnable is TRUE,it means the stream is encrypted, otherwise it means the stream is unencrypted;
  If you want to tramsmit the original stream,Before call playaback interface,you should call CLIENT_GetConfig(NET_EM_CFG_MEDIA_ENCRYPT) to know whether the stream is encrypted.
  If the stream is encrypted, then should call CLIENT_AttachVK to attach VK info, At last should call CLIENT_GetVK to Get VK info.**/
// If the stream is unencrypted,dwDataType:0-the original unencrypted stream
// If the stream is encrypted,dwDataType: 0-the decrypted stream(the frame data),2-the original encrypted stream
typedef int (CALLBACK *fDataCallBack)(LLONG lRealHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, LDWORD dwUser);

typedef struct __NET_MULTI_PLAYBACK_PARAM 
{
	DWORD                      dwSize; 
	int                        nChannels[DH_MAX_MULTIPLAYBACK_CHANNEL_NUM]; // Preview the channel number
	int                        nChannelNum;                         // Preview the channel number
	int                        nType;                               // Playback file type, 0: ordinary video; 1: alarm video; 2: the mobile detection; 3: video card number; Picture 4:
	NET_TIME                   stStartTime;                         // Playback start time
	NET_TIME                   stEndTime;                           // The playback end time
	int                        nFPS;                                // Frame rate, 1 ~ 25
	int                        nBitRate;                            // Code flow values, 192 ~ 1024
	char                       szResolution[DH_MAX_CAPTURE_SIZE_NUM]; // Resolution, "D1", "HD1", "2 CIF", "CIF", "QCIF"
	int                        nWaitTime;                           // Timeout waiting time
	HWND                       hWnd;                                // Video playback window handle
	fDataCallBack              fDownLoadDataCallBack;               // Video data correction
	LDWORD                     dwDataUser;                          // 
}NET_MULTI_PLAYBACK_PARAM;

// record state of everyday in one month
typedef struct
{
	BYTE 	    flag[32];						// has record this day 0-no, 1-yes
	BYTE		Reserved[64];					// reserved
}NET_RECORD_STATUS, *LPNET_RECORD_STATUS;

// Asynchronous query results callback function prototype
// nError = 0 success
// nError = 1 new memory fail 
// nError = 2 timeout
// nError = 3 data from device validate fail
// nError = 4 send query request failed
// nError = 5 param illegal
// nError = 6 open channel fail
// nError = 7 no permission
typedef void (CALLBACK *fQueryRecordFileCallBack)(LLONG lQueryHandle, LPNET_RECORDFILE_INFO pFileinfos, int nFileNum, int nError, void *pReserved, LDWORD dwUser);

// Whether to combine video
typedef enum tagNET_EM_COMBINATION_MODE
{
	EM_COMBINATION_MODE_DEFAULT = 0,					// Default(yes)
	EM_COMBINATION_MODE_YES,							// yes
	EM_COMBINATION_MODE_NO,								// no
}NET_EM_COMBINATION_MODE;

// CLIENT_StartQueryRecordFile Interface input parameters
typedef struct tagNET_IN_START_QUERY_RECORDFILE
{ 
	DWORD               dwSize;                            // The structure size
	int                 nChannelId;                        // To query the channel number
	int                 nRecordFileType;                   // For video query types
	int                 nStreamType;                       // Query stream type, 0 to advocate complementary code stream, 1 - the main stream, 2 - auxiliary stream
	NET_TIME            stStartTime;                       // Query starting time
	NET_TIME            stEndTime;                         // Query the end time
    char*               pchCardid;                         // card id information,the space application is 512 bytes by the user
														   // if nRecordFileType is 4 or 5 or 10,memory is 256 at most
														   // if nRecordFileType is 8,memory is 20 at most
	int                 nWaitTime;                         // Timeout waiting time, ms
	fQueryRecordFileCallBack cbFunc;                       // The query results callback function 
	LDWORD              dwUser;                            // user info
	BOOL				bByTime;						   // weather query by time
	NET_EM_COMBINATION_MODE	emCombination;				   // Whether to combine video
}NET_IN_START_QUERY_RECORDFILE;

typedef struct tagNET_OUT_START_QUERY_RECORDFILE
{
	DWORD                dwSize;                           //The structure size
	LLONG                lQueryHandle;                     //return handle    
}NET_OUT_START_QUERY_RECORDFILE;

//  function prototype of play back progress 
// dwDownLoadSize == -1 means progress finished
// dwDownLoadSize ==- 2 means no authority of operation
typedef void (CALLBACK *fDownLoadPosCallBack)(LLONG lPlayHandle, DWORD dwTotalSize, int dwDownLoadSize, LDWORD dwUser);

// Object type
typedef enum tagEM_OBJECT_TYPE
{
    EM_OBJECT_TYPE_UNKNOWN    = -1,         				// Unknown
    EM_OBJECT_TYPE_FACE,                    				// Face
    EM_OBJECT_TYPE_HUMAN,                   				// Human
    EM_OBJECT_TYPE_VECHILE,                					// Vechile
    EM_OBJECT_TYPE_NOMOTOR,                 				// Nomotor
    EM_OBJECT_TYPE_ALL,                     				// All
} EM_OBJECT_TYPE;

// Event info
typedef struct tagEVENT_INFO
{
	int                 nEvent;								// Event type, see intelligent analysis event type,like EVENT_IVS_ALL
	EM_OBJECT_TYPE		arrayObejctType[16];				// object type, currently support EM_OBJECT_TYPE_HUMAN, EM_OBJECT_TYPE_VECHILE, EM_OBJECT_TYPE_NOMOTOR, EM_OBJECT_TYPE_ALL
	int					nObjectCount;						// szObejctType's count
	BYTE				byReserved[512];					// reserved
}EVENT_INFO;

// record play back parameter in
typedef struct tagNET_IN_PLAY_BACK_BY_TIME_INFO
{
    NET_TIME            stStartTime;                       // Begin time
    NET_TIME            stStopTime;                        // End time
    HWND                hWnd;                              // Play window
    fDownLoadPosCallBack cbDownLoadPos;                    // Download pos callback
    LDWORD              dwPosUser;                         // Pos user
    fDataCallBack       fDownLoadDataCallBack;             // Download data callback
    LDWORD              dwDataUser;                        // Data user
    int                 nPlayDirection;                    // Playback direction
    int                 nWaittime;                         // Watiting time
	EVENT_INFO*			pstuEventInfo;				   	   // Event info(customized), user allocate memory
	UINT				nEventInfoCount;				   // pstuEventInfo's count, max num is 16
    BYTE                bReserved[1012];                   // reserved
}NET_IN_PLAY_BACK_BY_TIME_INFO;
// record play back parameter out
typedef struct tagNET_OUT_PLAY_BACK_BY_TIME_INFO
{
    BYTE                bReserved[1024];                   // Reserved
}NET_OUT_PLAY_BACK_BY_TIME_INFO;

// record play back speed
typedef enum tagEM_PLAY_BACK_SPEED
{
	EM_PLAY_BACK_SPEED_SLOW_16 = -4,               // 1/16x slow speed
	EM_PLAY_BACK_SPEED_SLOW_8,                     // 1/8x slow speed
	EM_PLAY_BACK_SPEED_SLOW_4,                     // 1/4x slow speed
	EM_PLAY_BACK_SPEED_SLOW_2,                     // 1/2x slow speed
	EM_PLAY_BACK_SPEED_NORMAL = 0,                 // normal speed
	EM_PLAY_BACK_SPEED_FAST_2,                     // 2x fast speed
	EM_PLAY_BACK_SPEED_FAST_4,                     // 4x fast speed
	EM_PLAY_BACK_SPEED_FAST_8,                     // 8x fast speed
	EM_PLAY_BACK_SPEED_FAST_16,                    // 16x fast speed
}EM_PLAY_BACK_SPEED;

typedef struct
{
	unsigned short      left;                   // 0~8192
    unsigned short      right;                  // 0~8192
    unsigned short      top;                    // 0~8192
    unsigned short      bottom;                 // 0~8192
} MotionDetectRect;

// Smart Playback Information
typedef struct 
{
	MotionDetectRect    motion_rect;             // MotionDetect area
    NET_TIME            stime;                   // PlayBack start time
    NET_TIME            etime;                   // PlayBack stop time
	BYTE                bStart;                  // 1,start,2:stop
    BYTE                reserved[116];
} IntelligentSearchPlay, *LPIntelligentSearchPlay;

// The first recording time
typedef struct  
{
	int					nChnCount;				// Channel amount
	NET_TIME			stuFurthestTime[16];	// The first recording time, valid value is 0 to (nChnCount-1).If there is no video, the first recording time is 0.
	DWORD				dwFurthestTimeAllSize;	// when channel >16,use this field.means pStuFurthestTimeAll memory size.
	NET_TIME*			pStuFurthestTimeAll;	// when channel >16,use this field.need user apply, memory size(nChnCount*sizeof(NET_TIME)).
	BYTE				bReserved[376];			// Reserved words
} NET_FURTHEST_RECORD_TIME;

// CLIENT_FindFrameInfo Interface input parameters
typedef struct __NET_IN_FIND_FRAMEINFO_PRAM
{
	DWORD                 dwSize;               // The structure size 
	BOOL                  abFileName;           // Whether the file name as a valid query conditions, if the file name is valid, is don't have to fill the file information (stRecordInfo)
	char                  szFileName[MAX_PATH]; // file name
	NET_RECORDFILE_INFO   stuRecordInfo;        // file information
	DWORD                 dwFramTypeMask;       // Frame type mask, FRAME_TYPE_MOTION motion detect;  FRAME_TYPE_HUMAN motion detect(human); FRAME_TYPE_VEHICLE motion detect(vehicle)
}NET_IN_FIND_FRAMEINFO_PRAM;

// CLIENT_FindFrameInfo Interface input parameters
typedef struct __NET_OUT_FIND_FRAMEINFO_PRAM
{
	DWORD                 dwSize;               // The structure size 
	LLONG                 lFindHandle;          // File search handle
}NET_OUT_FIND_FRAMEINFO_PRAM;

// DM frame information
typedef struct __NET_MOTION_FRAME_INFO
{
	DWORD                 dwSize;               // The structure size 
	NET_TIME              stuTime;              // The current frame, timestamp
	int					  nMotionRow;		    // The number of rows dynamic detection area
	int					  nMotionCol;		    // The number of columns of dynamic detection area
	BYTE				  byRegion[DH_MOTION_ROW][DH_MOTION_COL];// Detection area, up to 32 * 32 area
	int					  nHumanMotionRow;		// The number of rows dynamic detection area about human
    int					  nHumanMotionCol;	    // The number of columns dynamic detection area about human
    BYTE				  byHumanRegion[DH_MOTION_ROW][DH_MOTION_COL]; // Detection area about human, up to 32 * 32 area
    int					  nVehicleMotionRow;	// he number of rows dynamic detection area about vehicle
    int					  nVehicleMotionCol;	// The number of columns dynamic detection area about vehilce
    BYTE				  byVehicleRegion[DH_MOTION_ROW][DH_MOTION_COL]; // Detection area about vehicle, up to 32 * 32 area
}NET_MOTION_FRAME_INFO;

// file frame information
typedef struct __NET_FILE_FRAME_INFO
{
	DWORD                 dwSize;               // The structure size 
	int                   nChannelId;           // channel number 
	NET_TIME              stuStartTime;         // the starting time 
	NET_TIME              stuEndTime;           // the ending time
	WORD                  wRecType;             // 0- main stream video code 1-auxiliary stream video 2- auxiliary stream 3 auxiliary stream video
	WORD                  wFameType;            // Frame TYPE, see EM FRAM TYPE
	void*                 pFramInfo;            // Corresponding to the type of frame information, the space application is sizeof(NET_MOTION_FRAME_INFO)
}NET_FILE_FRAME_INFO;

// CLIENT_FindNextFrameInfo Interface input parameters
typedef struct __NET_IN_FINDNEXT_FRAMEINFO_PRAM
{
	DWORD                 dwSize;               // The structure size
	int                   nFramCount;           // To query the frame number, 0, said all the frame information query conforms to the query conditions
}NET_IN_FINDNEXT_FRAMEINFO_PRAM;

// CLIENT_FindNextFrameInfo Interface output parameters
typedef struct __NET_OUT_FINDNEXT_FRAMEINFO_PRAM
{
	DWORD                 dwSize;               // The structure size 
	NET_FILE_FRAME_INFO*  pFramInfos;           // Frame information, by the user application space, the space size of sizeof(NET_FILE_FRAME_INFO) * nMaxFramCount
	int                   nMaxFramCount;        // The number of the frame of information in the user application
    int                   nRetFramCount;        // The actual returns the number of frame information
}NET_OUT_FINDNEXT_FRAMEINFO_PRAM;

#define	MAX_LABEL_ARRAY		1024

// label array
typedef struct tagNET_FILE_STREAM_TAG_INFO
{
	DWORD				dwSize;									// The structure size 
	NET_TIME			stuTime;								// time
	char				szContext[DH_COMMON_STRING_64];			// context, chinese must be used UTF8 encoding
	char				szUserName[DH_COMMON_STRING_32];		// user name, chinese must be used UTF8 encoding
	char				szChannelName[DH_COMMON_STRING_64];		// channel name, chinese must be used UTF8 encoding
	int 				nDuration;							    // the duration of settag for record, unit:s
} NET_FILE_STREAM_TAG_INFO;

// file type
typedef enum tagNET_FILE_STREAM_TYPE
{
	NET_FILE_STREAM_TYPE_UNKNOWN = 0,				// unknown
	NET_FILE_STREAM_TYPE_NORMAL,					// noamal
	NET_FILE_STREAM_TYPE_ALARM,						// alarm
	NET_FILE_STREAM_TYPE_DETECTION,					// detection
} NET_FILE_STREAM_TYPE;

// file stream tag info
typedef struct tagNET_FILE_STREAM_TAG_INFO_EX
{
	DWORD					dwSize;	
	NET_TIME				stuTime;									// time
	int						nMillisecond;								// millisecond
	int						nSequence;									// Sequence
	char					szContext[DH_COMMON_STRING_64];				// context, chinese must be used UTF8 encoding
	NET_TIME				stuStartTime;								// recode file start time 
	NET_TIME				stuEndTime;									// recode file end time 
	NET_FILE_STREAM_TYPE	emType;										// file type
	char					szUserName[DH_COMMON_STRING_32];			// user name, chinese must be used UTF8 encoding
	char					szChannelName[DH_COMMON_STRING_64];			// channel name, chinese must be used UTF8 encoding
    int						nDuration;								    // the duration time of settag for record,unit:s
} NET_FILE_STREAM_TAG_INFO_EX;


// CLIENT_FileStreamClearTags / CLIENT_FileStreamSetTags Interface input parameters
typedef struct tagNET_IN_FILE_STREAM_TAGS_INFO
{
	DWORD						dwSize;								// The structure size 
	int							nArrayCount;						// count of user malloced, unit: sizeof(NET_FILE_STREAM_TAG_INFO)
	NET_FILE_STREAM_TAG_INFO*	pstuTagInfo;						// label array, user malloc the memory,apply to sizeof(NET_FILE_STREAM_TAG_INFO)*nArrayCount
} NET_IN_FILE_STREAM_TAGS_INFO;

// CLIENT_FileStreamClearTags / CLIENT_FileStreamSetTags Interface output parameters
typedef struct tagNET_OUT_FILE_STREAM_TAGS_INFO
{
	DWORD						dwSize;					// The structure size 
} NET_OUT_FILE_STREAM_TAGS_INFO;


// CLIENT_FileStreamGetTags Interface input parameters
typedef struct tagNET_IN_FILE_STREAM_GET_TAGS_INFO
{
	DWORD						dwSize;					// The structure size 
} NET_IN_FILE_STREAM_GET_TAGS_INFO;

// CLIENT_FileStreamGetTags / CLIENT_FileStreamfilterTags Interface output parameters
typedef struct tagNET_OUT_FILE_STREAM_GET_TAGS_INFO
{
	DWORD							dwSize;								// The structure size 
	int								nMaxNumber;							// max tags Number
	int								nRetTagsNumber;						// returned  tags Number
	NET_FILE_STREAM_TAG_INFO_EX*	pstuTagInfo;						// label array
} NET_OUT_FILE_STREAM_GET_TAGS_INFO;

// CLIENT_FileStreamFilterTags Interface input parameters
typedef struct tagNET_IN_FILE_STREAM_FILTER_TAGS_INFO
{
	DWORD						dwSize;									// The structure size 
	char						szContext[DH_COMMON_STRING_64];			// context, chinese must be used UTF8 encoding
	char						szUserName[DH_COMMON_STRING_32];		// user name, chinese must be used UTF8 encoding
	char						szChannelName[DH_COMMON_STRING_64];		// channel name, chinese must be used UTF8 encoding
} NET_IN_FILE_STREAM_FILTER_TAGS_INFO;

// CLIENT_FileStreamfilterTags Interface output parameters
// typedef struct tagNET_OUT_FILE_STREAM_FILTER_TAGS_INFO
// {
// 	DWORD							dwSize;								// The structure size 
// 	NET_FILE_STREAM_TAG_INFO_EX		stuTagInfo[MAX_LABEL_ARRAY];		// label array
// 	int								nRetTagsCount;						// returned  tags counts
// } NET_OUT_FILE_STREAM_FILTER_TAGS_INFO;

// tag manager's sub tag info
typedef struct tagNET_TAGMANAGER_SUB_TAG_INFO
{
	NET_TIME					stuTime;								// sub tag's time
	char						szSubTagName[DH_COMMON_STRING_64];		// sub tag's name
	BYTE						byReserved[512];						// reserved
}NET_TAGMANAGER_SUB_TAG_INFO;

// tag manager's tag info. this tag info has start\end time of a tag, which is different with NET_FILE_STREAM_TAG_INFO_EX
typedef struct tagNET_TAGMANAGER_TAG_INFO
{
	char						szContext[DH_COMMON_STRING_64];			// tag's context	
	NET_TIME					stuStartTime;							// tag's startTime
	NET_TIME					stuEndTime;								// tag's endTime
	int							nSubTagVaildNum;						// sub tag array(stuSubTag)'s valid number
	NET_TAGMANAGER_SUB_TAG_INFO stuSubTag[MAX_SUB_TAG_NUM];				// sub tag's array
	BYTE						byReserved[1024];						// reserved
}NET_TAGMANAGER_TAG_INFO;

// condition info in find tag
typedef struct tagNET_FINDTAGS_CONDITION_INFO
{
	char						szContext[DH_COMMON_STRING_64];			// tag's context	
	BYTE						byReserved[1024];						// reserved
}NET_FINDTAGS_CONDITION_INFO;

// find tag info, CLIENT_FileStreamFindTags's in param 
typedef struct tagNET_IN_FINDTAGS_INFO
{
	DWORD							dwSize;
	BOOL							bConditionEnable;					// if this field is True, stuCondition is enabled, lToken is disenabled; if this field is False, stuCondition is disenabled, lToken is enabled
	NET_FINDTAGS_CONDITION_INFO		stuCondition;						// condition, used in first query
	UINT							lToken;								// query token, used from second query, get from first query's NET_OUT_FINDTAGS_INFO
	int								nOffset;							// offset
	int								nCount;								// count of a query, can not greater than 60
}NET_IN_FINDTAGS_INFO;

// tag manager's find tag info, CLIENT_FileStreamFindTags's out param
typedef struct tagNET_OUT_FINDTAGS_INFO
{
	DWORD							dwSize;
	UINT							lToken;									// query token, get from first query
	int								nTotal;									// tags' total count, queried in device
	int								nMaxTagsNumber;							// tag array(pstuTagInfo)'s max number, not less than NET_IN_FINDTAGS_INFO's nCount
	int								nRetTagsNumber;							// returned tags Number
	NET_TAGMANAGER_TAG_INFO*		pstuTagInfo;							// pointer to tag ayyay, user malloc the memory, the size is sizeof(NET_TAGMANAGER_TAG_INFO)*nMaxTagsNumber
}NET_OUT_FINDTAGS_INFO;

// tag manager's tag state
typedef struct tagNET_TAGMANAGER_TAGSTATE_INFO
{
	int							nChannel;								// Channel ID
	char						szContext[DH_COMMON_STRING_64];			// tag's context. Parameter obsolete please use szContextEx
	NET_TIME					stuStartTime;							// start time of tag
	int							nSubTagVaildNum;						// sub tag array(stuSubTag)'s valid number
	NET_TAGMANAGER_SUB_TAG_INFO stuSubTag[MAX_SUB_TAG_NUM];				// sub tag's array
    char						szContextEx[DH_COMMON_STRING_256];		// tag's context extend	
	BYTE						byReserved[768];						// reserved
}NET_TAGMANAGER_TAGSTATE_INFO;

// tag manager's get tag state, CLIENT_TagManagerGetTagState's in param
typedef struct tagNET_IN_TAGMANAGER_GETTAGSTATE_INFO
{
	DWORD							dwSize;
}NET_IN_TAGMANAGER_GETTAGSTATE_INFO;

// tag manager's get tag state, CLIENT_TagManagerGetTagState's out param
typedef struct tagNET_OUT_TAGMANAGER_GETTAGSTATE_INFO
{
	DWORD							dwSize;
	int								nState;								// Tag's state, 0 means not in tag, 1 means in tag
	int								nMaxTagStaeNumber;					// tag array(pstuTagStateInfo) 's max number
	int								nRetTagStaeNumber;					// returned tags Number
	NET_TAGMANAGER_TAGSTATE_INFO*	pstuTagStateInfo;					// pointer to tag ayyay, user malloc the memory, the size is sizeof(NET_TAGMANAGER_TAGSTATE_INFO)*nMaxTagStaeNumber
}NET_OUT_TAGMANAGER_GETTAGSTATE_INFO;

// tag manager's start tag, CLIENT_TagManagerStartTag's in param
typedef struct tagNET_IN_TAGMANAGER_STARTTAG_INFO
{
	DWORD						dwSize;
	int							nChannel;								// Channel ID
	char						szContext[DH_COMMON_STRING_64];			// tag's context	
    char						szContextEx[DH_COMMON_STRING_256];		// tag's context extend	
    bool                        bIsUsingContextEx;                      // Whether the tag's context extend	 is valid
}NET_IN_TAGMANAGER_STARTTAG_INFO;

// tag manager's start tag, CLIENT_TagManagerStartTag's out param
typedef struct tagNET_OUT_TAGMANAGER_STARTTAG_INFO
{
	DWORD						dwSize;
}NET_OUT_TAGMANAGER_STARTTAG_INFO;

// tag manager's set sub tag, CLIENT_TagManagerSetSubTag's in param
typedef struct tagNET_IN_TAGMANAGER_SETSUBTAG_INFO
{
	DWORD						dwSize;
	int							nChannel;								// Channel ID
	char						szSubTagName[DH_COMMON_STRING_64];		// sub tag name	
}NET_IN_TAGMANAGER_SETSUBTAG_INFO;

// tag manager's set sub tag, CLIENT_TagManagerSetSubTag's out param
typedef struct tagNET_OUT_TAGMANAGER_SETSUBTAG_INFO
{
	DWORD						dwSize;
}NET_OUT_TAGMANAGER_SETSUBTAG_INFO;

// tag manager's stop tag, CLIENT_TagManagerStopTag's in param
typedef struct tagNET_IN_TAGMANAGER_STOPTAG_INFO
{
	DWORD						dwSize;
	int							nChannel;								// Channel ID
}NET_IN_TAGMANAGER_STOPTAG_INFO;

// tag manager's stop tag, CLIENT_TagManagerStopTag's out param
typedef struct tagNET_OUT_TAGMANAGER_STOPTAG_INFO
{
	DWORD						dwSize;
}NET_OUT_TAGMANAGER_STOPTAG_INFO;


// Get ability to get Tags, CLIENT_TagManagerGetCaps's in param
typedef struct tagNET_IN_TAGMANAGER_GETCAPS_INFO
{
    DWORD						dwSize;                                 // Structure size
}NET_IN_TAGMANAGER_GETCAPS_INFO;

// Get ability to get Tags, CLIENT_TagManagerGetCaps's out param
typedef struct tagNET_OUT_TAGMANAGER_GETCAPS_INFO
{
    DWORD						dwSize;                                 // Structure size
    UINT                        nMaxCount;                              // Max find count
}NET_OUT_TAGMANAGER_GETCAPS_INFO;

// Start to find tag information, CLIENT_TagManagerStartFind's in param
typedef struct tagNET_IN_TAGMANAGER_STARTFIND_INFO
{
    DWORD						dwSize;                                 // Structure size
    int                         nChannel;                               // Channel
    char						szContext[DH_COMMON_STRING_256];		// Tag context
    NET_TIME                    stuStartTime;                           // Start time
    NET_TIME                    stuEndTime;                             // End time
}NET_IN_TAGMANAGER_STARTFIND_INFO;

// Start to find tag information, CLIENT_TagManagerStartFind's out param
typedef struct tagNET_OUT_TAGMANAGER_STARTFIND_INFO
{
    DWORD						dwSize;                                 // Structure size
    int                         nTotalCount;                            // Return count
}NET_OUT_TAGMANAGER_STARTFIND_INFO;

// Get label find result information, CLIENT_TagManagerDoFind's in param
typedef struct tagNET_IN_TAGMANAGER_DOFIND_INFO
{
    DWORD						dwSize;                                 // Structure size
    int                         nBeginNumber;                           // Begin index
    int                         nCount;                                 // Begin number, Please refer to the device query capability(CLIENT_TagManagerGetCaps) returned by the device
}NET_IN_TAGMANAGER_DOFIND_INFO;

// 
typedef struct tagNET_FINDSUBTAG_INFO
{
    NET_TIME                    stuStartTime;                           // Start time
    char                        szSubTagName[DH_COMMON_STRING_64];      // Sub tag context
    BYTE                        byReserved[128];                        // Reserved
}NET_FINDSUBTAG_INFO;

// 
typedef struct tagNET_FINDTAG_INFO
{
    char						szContext[DH_COMMON_STRING_256];		// Tag context
    NET_TIME                    stuStartTime;                           // Start time
    NET_TIME                    stuEndTime;                             // End time
    int                         nSubtagInfoCount;                       // Sub tag count
    NET_FINDSUBTAG_INFO         stuSubTagInfo[20];                      // Sub tag info
    BYTE                        byReserved[1020];                       // Reserved
}NET_FINDTAG_INFO;

// Get label find result information, CLIENT_TagManagerDoFind's out param
typedef struct tagNET_OUT_TAGMANAGER_DOFIND_INFO
{
    DWORD						dwSize;                                 // Structure size 
    UINT                        nMaxTagInfoCount;                       // The maximum number of tags can be accepted in this query, and the number of pstuTagInfo memory pre allocated by the user
    UINT                        nRetTagInfoCount;                       // Actual number of labels returned by the device.Return 0 or less CLIENT_TagManagerDoFind's find result(Count) means find over
    NET_FINDTAG_INFO*           pstuTagInfo;                            // For the label information to be found, the user needs to allocate the memory in advance
}NET_OUT_TAGMANAGER_DOFIND_INFO;


///////////////////////////////Alarm Related Definition ///////////////////////////////

// General alarm informaiton 
typedef struct
{
	int					channelcount;
	int					alarminputcount;
	unsigned char		alarm[16];				// External alarm 
	unsigned char		motiondection[16];		// Motion detection 
	unsigned char		videolost[16];			// Video loss 
} NET_CLIENT_STATE;

// General alarm information
typedef struct
{
	int					channelcount;
	int					alarminputcount;
    unsigned char		alarm[32];				// External alarm 
	unsigned char		motiondection[32];		// Motion detection 
	unsigned char		videolost[32];			// Video loss 
	BYTE                bReserved[32];
} NET_CLIENT_STATE_EX;

// struct of input alarm
typedef struct
{
	DWORD              dwSize;
	int				   alarminputcount;
	DWORD              dwAlarmState[DH_MAX_CHANMASK]; //DWORD value is the state by bit of 32 channels,0-no alarm,1-alarm
}NET_CLIENT_ALARM_STATE;

// struct of video loss alarm
typedef struct
{
	DWORD              dwSize;
	int				   channelcount;
	DWORD              dwAlarmState[DH_MAX_CHANMASK]; //DWORD value is the state by bit of 32 channels,0-no alarm,1-alarm
}NET_CLIENT_VIDEOLOST_STATE;

// struct of motion alarm
typedef struct
{
	DWORD              dwSize;
	int				   channelcount;
	DWORD              dwAlarmState[DH_MAX_CHANMASK]; //DWORD value is the state by bit of 32 channels,0-no alarm,1-alarm
}NET_CLIENT_MOTIONDETECT_STATE;

// struct of blind alarm
typedef struct
{
	DWORD              dwSize;
	int				   channelcount;
	DWORD              dwAlarmState[DH_MAX_CHANMASK]; //DWORD value is the state by bit of 32 channels,0-no alarm,1-alarm
}NET_CLIENT_VIDEOBLIND_STATE;

// struct of querying detailed motion alarm
typedef struct
{
	DWORD              dwSize;
	int                nChannelID;				// channel id
	BOOL               bAlarm;					// alarm or not,value is TRUE/FALSE
	int                nLevel;					// alarm level,in 1/1000 as a unit
}NET_CLIENT_DETAILEDMOTION_STATE;

// Alarm IO control 
typedef struct 
{
	unsigned short		index;					// Port serial number 
	unsigned short		state;					// Port status 
} ALARM_CONTROL;

//Activation type 
typedef struct
{
	unsigned short		index;					// Port serial number 
	unsigned short		mode;					// Activation way(0:close.1:manual.2:auto); The SDK reserves the original setup if you do not set channel here. 
	BYTE				bReserved[28];			
} TRIGGER_MODE_CONTROL;

// Alarm decoder control 
typedef struct 
{
	int					decoderNo;				// Alarm decoder. It begins from 0. 
	unsigned short		alarmChn;				// Alarm output port. It begin from o., 
	unsigned short		alarmState;				// Alarm output status;1:open,0:close.
} DECODER_ALARM_CONTROL;

// Call No-response Alarm Event
typedef struct __ALARM_NO_RESPONSE_INFO
{
	DWORD		dwSize;
	char        szCallID[DH_MAX_CALLID];                             //Call ID
}ALARM_NO_RESPONSE_INFO;

// Alarm information of alarm upload function
typedef struct  
{
	DWORD				dwAlarmType;			// Alarm type,when dwAlarmType = DH_UPLOAD_EVENT,dwAlarmMask and bAlarmDecoderIndex are invalid.
	DWORD				dwAlarmMask;			// Alarm information subnet mask. Bit represents each alarm status
	char				szGlobalIP[DH_MAX_IPADDR_LEN];				// Client-end IP address 
	char				szDomainName[DH_MAX_DOMAIN_NAME_LEN];		// Client-end domain name
	int					nPort;					// The port client-end connected when upload alarm 
	char				szAlarmOccurTime[DH_ALARM_OCCUR_TIME_LEN];	// Alarm occurred time 
	BYTE				bAlarmDecoderIndex;		// It means which alarm decoder. It is valid when dwAlarmType = DH_UPLOAD_DECODER_ALARM.
    BYTE                bChannelIndex;          // Index of channelMask(0,1,2...)only bChannelIndex>0,dwHighAlarmMask is effective
                                                // eg, if bChannelIndex=1, dwHighAlarmMask represent alarm status of channel 33~64
    BYTE                bReserved[2];
    DWORD               dwHighAlarmMask;        // Alarm information subnet mask(channel>32). Bit represents each alarm status
    BYTE                bReservedSpace[8];
} NEW_ALARM_UPLOAD;

// pir device detection alarm about alarm center
typedef struct tagALARM_UPLOAD_PIRDETECTION_INFO
{
	int				nIndex;						// serial number
	NET_TIME_EX		UTC;						// time of occurrence
	char			szName[DH_EVENT_NAME_LEN];	// event name
	int				nAction;					// action of event, 0 means pulse event,1 means continuous event's begin,2means continuous event's end;	
	BYTE			byReserved[1024];       	// reserved 
} ALARM_UPLOAD_PIRDETECTION_INFO;

// pir device prevention and dismantling alarm about alarm center
typedef struct tagALARM_UPLOAD_PIRTAMPER_INFO
{
	int				nIndex;						// serial number
	NET_TIME_EX		UTC;						// time of occurrence
	char			szName[DH_EVENT_NAME_LEN];	// event name
	int				nAction;					// action of event, 0 means pulse event,1 means continuous event's begin,2means continuous event's end;	
	BYTE			byReserved[1024];       	// reserved 
} ALARM_UPLOAD_PIRTAMPER_INFO;

// pir device light occlusion alarm about alarm center
typedef struct tagALARM_UPLOAD_PIRCLOAK_INFO
{
	int				nIndex;						// serial number
	NET_TIME_EX		UTC;						// time of occurrence
	char			szName[DH_EVENT_NAME_LEN];	// event name
	int				nAction;					//action of event, 0 means pulse event,1 means continuous event's begin,2means continuous event's end;
	BYTE			byReserved[1024];       	// reserved 
} ALARM_UPLOAD_PIRCLOAK_INFO;

// pir device shock alarm about alarm center
typedef struct tagALARM_UPLOAD_PIRSHOCK_INFO
{
	int				nIndex;						// serial number
	NET_TIME_EX		UTC;						// time of occurrence
	char			szName[DH_EVENT_NAME_LEN];	// event name
	int				nAction;					// action of event, 0 means pulse event,1 means continuous event's begin,2means continuous event's end;	
	BYTE			byReserved[1024];       	// reserved 
} ALARM_UPLOAD_PIRSHOCK_INFO;

// pir device sensor failure alarm about alarm center
typedef struct tagALARM_UPLOAD_PIRFAILURE_INFO
{
	int				nIndex;						// serial number
	NET_TIME_EX		UTC;						// time of occurrence
	char			szName[DH_EVENT_NAME_LEN];	// event name
	int				nAction;					// action of event, 0 means pulse event,1 means continuous event's begin,2means continuous event's end;
	BYTE			byReserved[1024];       	// reserved 
} ALARM_UPLOAD_PIRFAILURE_INFO;

// pir device low battery power alarm about alarm center
typedef struct tagALARM_UPLOAD_PIRBATTERYLOW_INFO
{
	int				nIndex;						// serial number
	NET_TIME_EX		UTC;						// time of occurrence
	char			szName[DH_EVENT_NAME_LEN];	// event name
	int				nAction;					// action of event, 0 means pulse event,1 means continuous event's begin,2means continuous event's end;
	BYTE			byReserved[1024];       	// reserved 
} ALARM_UPLOAD_PIRBATTERYLOW_INFO;

// pir device missing call alarm about alarm center
typedef struct tagALARM_UPLOAD_PIRMISSINGCALL_INFO
{
	int				nIndex;						// serial number
	NET_TIME_EX		UTC;						// time of occurrence
	char			szName[DH_EVENT_NAME_LEN];	// event name
	int				nAction;					// action of event, 0 means pulse event,1 means continuous event's begin,2means continuous event's end;
	BYTE			byReserved[1024];       	// reserved 
} ALARM_UPLOAD_PIRMISSINGCALL_INFO;

// voide unfocus alarm about alarm center
typedef struct tagALARM_UPLOAD_VIDEO_UNFOCUS_INFO
{
	int				nIndex;						// serial number
	NET_TIME_EX		UTC;						// time of occurrence
	char			szName[DH_EVENT_NAME_LEN];	// event name
	int				nAction;					// action of event, 0 means pulse event,1 means continuous event's begin,2means continuous event's end;
	BYTE			byReserved[1024];       	// reserved 
} ALARM_UPLOAD_VIDEO_UNFOCUS_INFO;

// PIR alarm about alarm center
typedef struct tagALARM_UPLOAD_ALARMPIR_INFO
{
	int				nIndex;						// serial number
	NET_TIME_EX		UTC;						// time of occurrence
	char			szName[DH_EVENT_NAME_LEN];	// event name
	int				nAction;					// action of event, 0 means pulse event,1 means continuous event's begin,2means continuous event's end;	
	BYTE			byReserved[1024];       	// reserved
} ALARM_UPLOAD_ALARMPIR_INFO;

// Heart beat alarm
typedef struct tagALARM_UPLOAD_HEARTBEAT_INFO
{
    char            szGlobalIP[DH_MAX_IPADDR_LEN];               // Global IP
    char            szMAC[DH_MACADDR_LEN];                       // MAC address
    int             nKeepAlive;                                  // keep alive
    NET_TIME_EX     stuTime;                                     // time
    BYTE            byReserved[1024];                            // reserved
}ALARM_UPLOAD_HEARTBEAT_INFO;

// Online alarm
typedef struct tagALARM_UPLOAD_ONLINE_INFO
{
    char            szGlobalIP[DH_MAX_IPADDR_LEN];               // Global IP
    int             nPort;                                       // port
    NET_TIME_EX     stuTime;                                     // time
    BOOL            bOnLine;                                     // online(true), offline(false)
    BYTE            byReserved[1020];                            // reserved
}ALARM_UPLOAD_ONLINE_INFO;

// Smoke alarm events, alarm center
typedef struct __ALARM_UPLOAD_SMOKESENSOR_INFO
{
	DWORD			dwSize;
	char			szGlobalIP[DH_MAX_IPADDR_LEN];				// Remote IP address
	char			szDomainName[DH_MAX_DOMAIN_NAME_LEN];		// The client domain name
	int				nPort;										// When alarm upload client connection port
	char			szAlarmOccurTime[DH_ALARM_OCCUR_TIME_LEN];	// The time of the alarm
	int             nChannel;									// Alarm channel Starting from 0
	BYTE            byHighTemperature;							// 1: high temperature alarm, 0: high temperature alarm
	BYTE            bySmoke;									// 1: smoke alarm, 0: smoke alarm over
}ALARM_UPLOAD_SMOKESENSOR_INFO;

// Waring zone intrusion direction 
typedef enum tagNET_CROSSREGION_DIRECTION_INFO
{
    EM_CROSSREGION_DIRECTION_UNKNOW = 0 , 
    EM_CROSSREGION_DIRECTION_ENTER      ,   //Entry
    EM_CROSSREGION_DIRECTION_LEAVE      ,   //Exit
    EM_CROSSREGION_DIRECTION_APPEAR     ,   //Appear
    EM_CROSSREGION_DIRECTION_DISAPPEAR  ,   //Disappear
}NET_CROSSREGION_DIRECTION_INFO;

// intelligent alarm center
typedef struct __ALARM_UPLOAD_IVS_INFO
{
	DWORD				dwSize;
	NET_TIME			stuTime;                                  // occur time	
	char				szDomainName[DH_MAX_DOMAIN_NAME_LEN];	  // client domain name
	int					nChannelID;                               // channel,from 0
	char				szType[MAX_PATH];                         // alarm type,check rule
	int					nState;                                   // alarm state, 0-reset,1-setting,2-pulse
    char                szRuleName[DH_COMMON_STRING_128];         // Rule Name  
    char                szIPAddress[DH_MAX_IPADDR_LEN_EX];        // Device IP Address  
    int                 nPort;                                    // Device Port No.
    char                szMacAddress[DH_MACADDR_LEN];             // Device-end mac address
    char                szPicFilePath[MAX_PATH];                  // Picture Storage Path
    int                 nPicFileNum;                              // Current alarm folder number
    int                 nUploadPicFileNum;                        // Uploaded FTP picture  number
    DWORD               dwChannelMask;                            // Snapshot video channel mask, 15 means this alarm has 1,2,3,4 channels 
	NET_CROSSREGION_DIRECTION_INFO  emDirection;                  // Warning zone intrusion direction, it is effect only when szType is CrossRegionDetection
} ALARM_UPLOAD_IVS_INFO;

// Alarm center external alarm extension info
typedef struct _ALARM_UPLOAD_ALARMEX_INFO
{
    DWORD           dwSize;
    NET_TIME        stuTime;                                    // Event time    
    char            szDomainName[DH_MAX_DOMAIN_NAME_LEN];       // Client domain name
    DWORD           dwAlarmMask;                                // Alarm info mask, by bit means each alarm channel status, 7 means 1,2,3 alarm input channel
    char            szDevMac[DH_MACADDR_LEN];                   // Device port mac address
    char            szPicFilePath[MAX_PATH];                    // Picture storage file path
    int             nPicFileNum;                                // Current alarm corresponding picture file quantity
    int             nUploadPicFileNum;                          // Uploaded FTP picture file quantity
    char            szAreaName[DH_COMMON_STRING_128];           // Zone name
    DWORD           dwChannelMask;                              // Snapshot video channel mask, 15 means this alarm has 1,2,3,4 channels 
}ALARM_UPLOAD_ALARMEX_INFO;

typedef enum _EM_LOGIN_FAILED_TYPE
{
    LOGIN_FAILED_UNKNOW = 0 ,
    LOGIN_FAILED_PASSWORD   ,           //Password error
    LOGIN_FAILED_USER       ,           //User error
    LOGIN_FAILED_TIMEOUT    ,           //Time out
    LOGIN_FAILED_RELOGGIN   ,           //Relogin
    LOGIN_FAILED_LOCKED     ,           //Account locked
    LOGIN_FAILED_BLACKLIST  ,           //Account in black list
    LOGIN_FAILED_ERROR_BUSY ,           //Resource is busy
    LOGIN_FAILED_VERSION    ,           //Vesion error 
}EM_LOGIN_FAILED_TYPE;

//Login failed alarm upload
typedef struct  __ALARM_UPLOAD_LOGIN_FAILED_INFO
{
    DWORD                   dwSize;
    EM_LOGIN_FAILED_TYPE    emFailedType;                       //Failed type
    char                    szDeviceIP[DH_COMMON_STRING_64];    //Device ip
    DWORD                   nDevicePort;                        //Device port
}ALARM_UPLOAD_LOGIN_FAILED_INFO;

// Recording-changed alarm information
typedef struct
{
	int					nChannel;				// Record channel number
	char				reserved[12];
} ALARM_RECORDING_CHANGED;

// video stream type
typedef enum tagNET_STREAM_TYPE
{
	NET_EM_STREAM_ERR,                  // Others
	NET_EM_STREAM_MAIN,					// "Main"-Main stream
	NET_EM_STREAM_EXTRA_1,				// "Extra1"-Extra stream 1
	NET_EM_STREAM_EXTRA_2,				// "Extra2"-Extra stream 2
	NET_EM_STREAM_EXTRA_3,				// "Extra3"-Extra stream 3
	NET_EM_STREAM_SNAPSHOT,				// "Snapshot"-Snap bit stream
	NET_EM_STREAM_OBJECT,				// "Object"-Object stream
	NET_EM_STREAM_AUTO,                 // "Auto"
	NET_EM_STREAM_PREVIEW,              // "Preview"
	NET_EM_STREAM_NONE,					// No video stream (audio only)
}NET_STREAM_TYPE;


// Recording-changed alarm information(DH_ALARM_RECORD_CHANGED_EX)
typedef struct __ALARM_RECORD_CHANGED_INFO_EX
{
    int                 nAction;                // 0:start 1:stop
	int                 nChannel;               // channel
	char				szStoragePoint[DH_COMMON_STRING_64];	// StoragePoint
	NET_STREAM_TYPE		emStreamType;							// stream type
	char				szUser[DH_COMMON_STRING_128];			// username
	BYTE                byReserved[828];						// reserved 
} ALARM_RECORD_CHANGED_INFO_EX;

// MPT record file transfer progress(DH_ALARM_POLICE_RECORD_PROGRESS)
typedef struct tagALARM_POLICE_RECORD_PROGRESS_INFO
{
    int                 nAction;                // 0:pulse,-1:unknown
    int                 nUsbSlot;               // USB Port number
    UINT                nTotalSize;             // file total size,unit:KB
    UINT                nTransferSize;          // transfered size,unit,KB
    BYTE                byReserved[1024];       // reserved 
}ALARM_POLICE_RECORD_PROGRESS_INFO;

// MPT state type
typedef enum tagEM_MPT_STATE
{
    EM_MPT_STATE_UNKNOWN,                                       // unknown
    EM_MPT_STATE_PLUGIN_OUT,                                    // mpt plugin out
    EM_MPT_STATE_PLUGIN_IN_WORKING_PROPERLY,                    // mpt plugin in and working properly
    EM_MPT_STATE_PLUGIN_IN_STORAGE_ERROR,                       // mpt plugin in but storage error
}EM_MPT_STATE;

// MPT plugin in or out event(DH_ALARM_POLICE_PLUGIN)
typedef struct tagALARM_POLICE_PLUGIN_INFO
{
    int                 nAction;                                // 0:pulse,-1:unknown
    int                 nUsbSlot;                               // usb port number
    EM_MPT_STATE        eState;                                 // mpt state
    char                szSerialNumber[DH_COMMON_STRING_32];    // MPT SN
    BYTE                byReserved[1024];                       // reserved
}ALARM_POLICE_PLUGIN_INFO;

// Gps not aligned alarm(DH_ALARM_GPS_NOT_ALIGNED)
typedef struct tagALARM_GPS_NOT_ALIGNED_INFO
{
    int                                 nAction;                        // -1:unknown, 0:pulse, 1:start, 2:stop 
	NET_TIME_EX                         stuTime;                        // Event occurrence time
	NET_TIME_EX							stuStartTime;					// Start time,it is Reported when nAction is 2
	BYTE                                byReserved[988];                // reserved 
}ALARM_GPS_NOT_ALIGNED_INFO;

// WireLess(include wifi, 3G/4G) not connected alarm(DH_ALARM_WIRELESS_NOT_CONNECTED)
typedef struct tagALARM_WIRELESS_NOT_CONNECTED_INFO
{
    int                                 nAction;                        // -1:unknown, 0:pulse, 1:start, 2:stop 
	NET_TIME_EX                         stuTime;                        // Event occurrence time
	BYTE                                byReserved[1024];               // reserved 
}ALARM_WIRELESS_NOT_CONNECTED_INFO;

// offline log sync state
typedef enum tagEM_OFFLINE_LOGSYNC_STATE
{
    EM_OFFLINE_LOGSYNC_STATE_UNKNOWN,                             // unknown
    EM_OFFLINE_LOGSYNC_STATE_SUCCEEDED,                           // success
    EM_OFFLINE_LOGSYNC_STATE_FAILED,                              // failed
}EM_OFFLINE_LOGSYNC_STATE;

//event of offline log sync
typedef struct tagALARM_OFFLINE_LOGSYNC_INFO
{
    int                                 nAction;                        // -1:unknown, 0:pulse, 1:start, 2:stop   
	NET_TIME_EX                         stuTime;                        // event happen time
	int                                 nDevAddrs;                      // sub controller id
	EM_OFFLINE_LOGSYNC_STATE            emState;                        // synchro state
	BYTE                                byReserved[1024];               //  
}ALARM_OFFLINE_LOGSYNC_INFO;

#define NET_MAX_WINDINGID_NUM    8

// CoilFault alarm event
typedef struct __ALARM_WINGDING_INFO
{
	int                 nDriveWayID;            // road number
	int                 nWindingID;             // coil ID
	NET_TIME            stuTime;                // event happen time 
	int                 nState;                 // Device state,0 indicate fault recover,1 indicate fault happen
	DWORD				dwChannel;				// Channel of alarm
	char                reserve[28];
    int                 nWindingIDNum;          // Coil ID number
    int                 nWindingIDs[NET_MAX_WINDINGID_NUM];// Detailed coil ID 
} ALARM_WINGDING_INFO;

// traffic congestion alarm 
typedef struct __ALARM_TRAF_CONGESTION_INFO
{
	int                 nDriveWayID;            // road number
	int                 nCongestionLevel;       // traffic congestion grade:1,2,3,4,5,6;1 indicate the most one 
	NET_TIME            stuTime;                // event happen time 
	int                 nState;                 // Device state,0 indicate fault recover,1 indicate fault happen
	DWORD				dwChannel;				// Channel of alarm
	char                reserve[28];
} ALARM_TRAF_CONGESTION_INFO;

// traffic exception alarm
typedef struct __ALARM_TRAF_EXCEPTION_INFO
{
	int                 nDriveWayID;            // road number
	NET_TIME            stuTime;                // event happen time
	int                 nState;                 // Device state,0 indicate fault recover,1 indicate fault happen
	DWORD				dwChannel;				// Channel of alarm
	char                reserve[28];
} ALARM_TRAF_EXCEPTION_INFO;

// fill equipment alarm 
typedef struct __ALARM_EQUIPMENT_FILL_INFO
{
	int                 nDriveWayID;            // road number
	NET_TIME            stuTime;                // event happen time
	int                 nState;                 // Device state,0 indicate fault recover,1 indicate fault happen
	DWORD				dwChannel;				// Channel of alarm
	char                reserve[28];
} ALARM_EQUIPMENT_FILL_INFO;

// alarm arm disarm state info
typedef struct __ALARM_ARM_DISARM_STATE_INFO
{
	BYTE                bState;                 // arm-disarm,0 means disarm,1 means arm, 2 means ForceOn
	char                reserve[31];
} ALARM_ARM_DISARM_STATE_INFO;

// 3G flow exceed state info 
typedef struct __DHDEV_3GFLOW_EXCEED_STATE_INFO
{
	BYTE                bState;                 //  3G flow exceed state,0 means not exceed,1 means exceed
	char                reserve[31];
} DHDEV_3GFLOW_EXCEED_STATE_INFO;

// alarm of speed limit (DH_DEVSTATE_SPEED_LIMIT)
typedef struct __ALARM_SPEED_LIMIT
{
	char                szType[DH_SPEEDLIMIT_TYPE_LEN];   // alarm type oLowerSpeed, UpperSpeed
	int                 iSpeedLimit;            // limit speed KM/H 
	int                 iSpeed;                 // speed KM/H
	char                szCrossingID[DH_MAX_CROSSING_ID]; // crossing ID
	DWORD				dwLongitude;			// longitude(millionth degree, 0-360)
    DWORD				dwLatidude;				// latidude(millionth degree,0-180)
	DHDEVTIME           stTime;                 // time
	BYTE                bOffline;               // 0-in real time,1-to fill 
	char				reserve[19];
}ALARM_SPEED_LIMIT;

// alarm of over loading
typedef struct __ALARM_OVER_LOADING
{
    NET_TIME			stuCurTime;             // current time
    DWORD				dwLatidude;				// latidude(millionth degree,0-180)
    DWORD				dwLongitude;			// longitude(millionth degree, 0-360)
    char				szDriverNo[DH_VEHICLE_DRIVERNO_LEN];    // driver id
    DWORD				dwCurSpeed;             // current speed
    BYTE				byReserved[128]; 
}ALARM_OVER_LOADING;

// alarm of hard braking
typedef struct __ALARM_HARD_BRAKING
{
    NET_TIME			stuCurTime;             // current time
    DWORD				dwLatidude;				// latidude(millionth degree,0-180)
    DWORD				dwLongitude;			// longitude(millionth degree, 0-360)
    char				szDriverNo[DH_VEHICLE_DRIVERNO_LEN];    // driver id
    DWORD				dwCurSpeed;             // current speed
    BYTE				byReserved[128]; 
}ALARM_HARD_BRAKING;

// alarm of smoke sensor
typedef struct __ALARM_SMOKE_SENSOR
{
	NET_TIME			stuCurTime;             // current time
	int					nChannel;               // channel
	BYTE				byHighTemperature;      // 1:hight temperature alarm start,0:end
	BYTE				bySmoke;                // 1:smoke alarm start,0:end
	BYTE				byReservrd[126];
}ALARM_SMOKE_SENSOR;

// alarm of traffic light
typedef struct _LIGHT_INFO
{
	BYTE               byDirection;            // direction: 1-left,2-right,3-straight , 4-turn round
	BYTE               byState;                // light state: 1-fault,2-normal
	BYTE               byReserved[62];         // reserved
}LIGHT_INFO;

typedef struct __ALARM_TRAFFIC_LIGHT_FAULT 
{
	NET_TIME           stTime;                 // alarm time
	int                nInfoNumber;            // info number
	LIGHT_INFO         stLightInfo[8];         // info
	BYTE               byReserved[128];        // reserved
}ALARM_TRAFFIC_LIGHT_FAULT;

// Flux alarm channel information
typedef struct __ALARM_TRAFFIC_FLUX_LANE_INFO
{
	NET_TIME            stuCurTime;            // current time
	int                 nLane;                 // lane number
	int                 nState;                // state:1-traffic jam, 2-traffic jam recover, 3-normal 4-break, 5-break recover
	int                 nFlow;                 // flow value,unit:per/second
	BYTE                byReserved[124];       // reserved
}ALARM_TRAFFIC_FLUX_LANE_INFO;

// SIP state alarm
typedef struct __ALARM_SIP_STATE
{
	int					nChannelID;
	BYTE				byStatus;               //0:succeed,1:unregistered ,2:invalid,3:registing,4:talking
	BYTE				bReserved[63];			//reserved
}ALARM_SIP_STATE;

// vehicle info uploading (DH_DEVSTATE_VIHICLE_INFO_UPLOAD)
typedef struct __ALARM_VEHICLE_INFO_UPLOAD
{
    char                szType[DH_VEHICLE_TYPE_LEN];            //type: DriverCheck ,Driver check in or check out
	char                szCheckInfo[DH_VEHICLE_INFO_LEN];       //Check in, Check out
    char                szDirverNO[DH_VEHICLE_DRIVERNO_LEN];    //Driver NO. string
	DHDEVTIME           stTime;                                      // time
	BYTE                bOffline;                                    // 0-real time 1-to fill 
	char                reserved[59];                     
}ALARM_VEHICLE_INFO_UPLOAD;

// card record uploading
typedef struct __ALARM_CARD_RECORD_INFO_UPLOAD
{
	int					nChannel;				// channel id
	BOOL				bEnable;				// is recording
	char				szCardInfo[DH_MAX_CARD_INFO_LEN];	// card info
	NET_TIME			stuTime;				// card start time
	BOOL                bPreviewOverlayEn;      // preview overlay enable
	BYTE                byOverlayPos;           // overlay position,1-left top,2-left bottom,3-right top,4-right bottom
	char				reserved[59];
}ALARM_CARD_RECORD_INFO_UPLOAD;


typedef enum __ATMTradeTypes{
	TRADE_TYPE_INC = 0,							// INSERTCARD
	TRADE_TYPE_WDC,								// WITHDRAWCARD
	TRADE_TYPE_CKT,								// CHECKTIME
	TRADE_TYPE_INQ,								// Query
	TRADE_TYPE_CWD,								// draw 
	TRADE_TYPE_PIN,								// change password
	TRADE_TYPE_TFR,								// debit
	TRADE_TYPE_DEP,								// deposit
	TRADE_TYPE_NCINQ,							// card less query
	TRADE_TYPE_NCDEP,							// card less deposit
	TRADE_TYPE_OTHERS,							// other
	TRADE_TYPE_ALL,								// all
}DH_eATMTradeTypes;

typedef struct __ALARM_ATM_INFO_UPLOAD_CHNL
{
	int					nChannel;				// channel
	char				szATMID[32];			// ATM id
	char				szCardNo[32];			// card number, 6222421541208230456 
	char				szTradetime[32];		// trade time, 20111118112200 means 2011-11-18 11:22:00
	DH_eATMTradeTypes	emTradeType;			// trade type
	int					nAmount;				// trade mount	0-4294967296
	BYTE				byRerved[32];			// reserved
}ALARM_ATM_INFO_UPLOAD_CHNL;

// ATM trade info uploading info
typedef struct __ALARM_ATM_INFO_UPLOAD
{
	int							nCnt;
	ALARM_ATM_INFO_UPLOAD_CHNL	m_stAtmInfo[DH_MAX_CHANNUM];
}ALARM_ATM_INFO_UPLOAD;

// camera move alarm
typedef struct __ALARM_CAMERA_MOVE_INFO
{
	int                         nChannelNum;                        // the number of alarm channel
	unsigned char               alarmChannels[DH_MAX_CHANNUM_EX];   // the channel information of alarm happened
	BYTE                        byReserved[128];
}ALARM_CAMERA_MOVE_INFO;

// detailed motion alarm
typedef struct __ALARM_DETAILEDMOTION_CHNL_INFO
{
	DWORD              dwSize;
	int                nChannelID;    // channel
	BOOL               bAlarm;        // alarm or not,value is TRUE/FALSE
	int                nLevel;        // alarm level,in 1/1000 as a unit
}ALARM_DETAILEDMOTION_CHNL_INFO;

// storage failure alarm info
typedef struct __ALARM_STORAGE_FAILURE
{
	DWORD     dwSize;                                     // struct size
	UINT      ActionType;                                 // 0:stop 1:start
	char      szProtocol[DH_MAX_STRING_LEN];              // protocol type
	char      szServerAddr[DH_MAX_IPADDR_OR_DOMAIN_LEN];  // server device's ip 
	DWORD     dwPort;                                     // port number
	NET_TIME  stuTime;                                    // event happen time	
	int		  nChannel;									  // channel, from 1, 0 means does not distinguish
}ALARM_STORAGE_FAILURE;

// front IPC disconnect alarm info
typedef struct __ALARM_FRONTDISCONNET_INFO
{
	DWORD              dwSize;                           // struct size
	int                nChannelID;                       // channel id
	int                nAction;                          // 0:start 1:stop
	NET_TIME           stuTime;                          // event happen time
	char               szIpAddress[MAX_PATH];            // front IP's address
}ALARM_FRONTDISCONNET_INFO;

// battery low power alarm info
typedef struct __ALARM_BATTERYLOWPOWER_INFO
{
	DWORD             dwSize;                            // struct size
	int               nAction;                           // 0:start 1:stop
	int               nBatteryLeft;                      // battery left, unit:%
	NET_TIME          stTime;                            // event happen time
	int               nChannelID;                        // channel no. Mark sub-device battery. Begins with 0. 
}ALARM_BATTERYLOWPOWER_INFO;

// temperature alarm info
typedef struct __ALARM_TEMPERATURE_INFO
{
	DWORD              dwSize;                           // struct size
	char               szSensorName[DH_MACHINE_NAME_NUM];// sensor name
	int                nChannelID;                       // channel id
	int                nAction;                          // 0:start 1:stop
	float              fTemperature;                     // current temperature, unit:degree centigrade
	NET_TIME           stTime;                           // event happen time
}ALARM_TEMPERATURE_INFO;

// Fatigue Driving Alarm
typedef struct __ALARM_TIREDDRIVE_INFO
{
	DWORD             dwSize;                            // struct size
	int               nAction;                           // 0:start 1:stop
	int               nDriveTime;                        // drive time, unit:minute
	NET_TIME          stTime;                            // event happen time
}ALARM_TIREDDRIVE_INFO;

//Alarm of record loss
typedef struct __ALARM_LOST_RECORD
{
	DWORD     dwSize;                                     // Structure size
	UINT      ActionType;                                 // 0: Stop, 1: start
	UINT      nChannelID;                                 // Channel ID, start from 1
	UINT      nStreamType;                                // Bit Stream type, 0: main stream; 1: extra stream1; 2: extra stream2; 3: extra stream3; 4: snapshot stream
	NET_TIME  stuTime;                                    // Event occurrence time	
}ALARM_LOST_RECORD;

// Alarm of High CPU Occupancy rate, temporarily we set the max limit as 95%
typedef struct __ALARM_HIGH_CPU
{
	DWORD     dwSize;                                     // Structure size
	UINT      ActionType;                                 // 0: Stop, 1: start
	UINT      nUsed;                                      // 1000 times of  CPU Occupancy rate
	NET_TIME  stuTime;                                    // Event occurrence time
}ALARM_HIGH_CPU;


// Alarm of netpackage loss
typedef struct __ALARM_LOST_NETPACKET
{
	DWORD     dwSize;                                     // Structure size
	UINT      ActionType;                                 // 0: Stop, 1: start
	UINT      nChannelID;                                 // Channel ID, start from 1
	UINT      nStreamType;                                // Bit stream type, 0: main stream; 1: extra stream1; 2: extra stream2; 3: extra stream3; 4: snapshot stream
	char      szRemoteIP[DH_MAX_IPADDR_LEN];              // IP address of sending
	DWORD     dwRemotePort;                               // Port address of sending 
	NET_TIME  stuTime;                                    // Event occurrence time
}ALARM_LOST_NETPACKET;

// Alarm of High memory Occupancy rate, temporarily we set the max limit as 95%
typedef struct __ALARM_HIGH_MEMORY
{
	DWORD     dwSize;                                     // Structure size
	UINT      ActionType;                                 // 0: Stop, 1: start
	UINT      nUsed;                                      // 1000 times of  memory Occupancy rate
	NET_TIME  stuTime;                                    // Event occurrence time	
}ALARM_HIGH_MEMORY;

// black list snap info
typedef struct __DH_BLACKLIST_SNAP_INFO
{
	DWORD     dwSize;
	char      szPlateNumber[32];                          // number of plate
	NET_TIME  stuTime;                                    // time
}DH_BLACKLIST_SNAP_INFO;

// disk flux abnormal
typedef struct __ALARM_DISK_FLUX
{
	DWORD				dwSize;	
	DWORD				dwAction;							// 0-start, 1-stop
	DWORD				dwDataFlux;							// data flux,KB			
	NET_TIME			stuTime;							// time
} ALARM_DISK_FLUX;

// net flux abnormal
typedef struct __ALARM_NET_FLUX
{
	DWORD				dwSize;	
	DWORD				dwAction;							// 0-start, 1-stop
	DWORD				dwDataFlux;							// data flux,KB	
	NET_TIME			stuTime;							// time
} ALARM_NET_FLUX;

// fan speed abnormal
typedef struct __ALARM_FAN_SPEED
{
	DWORD				dwSize;	
	DWORD				dwAction;							// 0-start, 1-stop
	DWORD				dwIndex;							// index
	char				szName[DH_MACHINE_NAME_NUM];		// name
	NET_TIME			stuTime;							// time
	DWORD				dwCurrent;							// current speed
} ALARM_FAN_SPEED;

// disk alarm
typedef struct __ALARM_DISK_INFO 
{
	DWORD				dwSize;
	DWORD				nChannel;							// channel number
	DWORD				nHDDNumber;							// number, 0: main trank,1: extern trank1, 2: extern trank2 
	DWORD				nHDDState;							// state, 0: Unknown, 1: Running, 2: Offline, 3: Warning, 4: Failed
} ALARM_DISK_INFO;

// alarm of file system
typedef struct __ALARM_FILE_SYSTEM_INFO 
{
	DWORD				dwSize;
	char				szMountDir[MAX_PATH];				// mount name
	DWORD				nState;								// state, 0: Unkown, 1: Normal, 2: Error
} ALARM_FILE_SYSTEM_INFO;

// alarm of remote 
typedef struct __ALARM_REMOTE_ALARM_INFO
{
	DWORD      dwSize;
	int        nChannelID;                               // channel ID,from 1
	int        nState;                                   // state,0-reset,1-setting
}ALARM_REMOTE_ALARM_INFO;

// alarm of ivs
typedef struct __ALARM_IVS_INFO
{
	DWORD      dwSize;
	NET_TIME   stuTime;                                  // time	
	int        nChannelID;                               // channel ID,from 0
	char	   szType[MAX_PATH];                         // type
	int        nState;                                   // state,0-reset,1-setting,2-pulse
}ALARM_IVS_INFO;

// alarm of good weight
typedef struct __ALARM_GOODS_WEIGHT_INFO
{
	DWORD		dwSize;
	int			nAction;							// 0-start, 1-stop
	int			nAlarmType;							// 0-greater than dwMaxGoodsWeight, 1-less than dwMinGoodsWeight, 2-the change greater than dwAlarmWeight
	DWORD		dwGoodsWeight;						// good weight(kg)
	DWORD		dwSelfWeight;						// self weight(kg)
	DWORD		dwTotalWeight;						// total weight(kg)
	DWORD		dwStandardWeight;					// standard weight(kg)
	DWORD		dwWeightScale;						// weight scale
	DWORD		dwMaxGoodsWeight;					// the max(kg)
	DWORD		dwMinGoodsWeight;					// the min(kg)
	DWORD		dwAlarmWeight;						// alarm of threshold(kg)
	int			nWeightChange;						// whight change when gather(kg)
	int			nCheckTime;							// gather time(s)
} ALARM_GOODS_WEIGHT_INFO;

// goods weight upload
typedef struct __ALARM_GOODS_WEIGHT_UPLOAD_INFO 
{
	DWORD		dwSize;
	DWORD		dwGoodsWeight;						// goods weight(kg)
	DWORD		dwSelfWeight;						// self weight(kg)
	DWORD		dwTotalWeight;						// total weight(kg)
	DWORD		dwStandardWeight;					// standard weight(kg)
	DWORD		dwWeightScale;						// weight scale	
    char        szCardNO[DH_MAX_CARDINFO_LEN];      // card number
} ALARM_GOODS_WEIGHT_UPLOAD_INFO;

// source of date
typedef enum tagEM_DATE_SOURCE
{
    EM_DATE_SOURCE_GPS,                                     // GPS 
    EM_DATE_SOURCE_INERTIALNAVIGATION,                      // inertial navigation date
}EM_DATE_SOURCE;

// GPS status info
typedef struct _NET_GPS_STATUS_INFO
{
    NET_TIME                revTime;                    // time
    char                    DvrSerial[50];              // device number
    BYTE                    byRserved1[6];              // align
    double                  longitude;                  // longitude(1/1000000,range[0-360])
    double                  latidude;                   // latitude(1/1000000,range[0-180])
    double                  height;                     // highness(m)
    double                  angle;                      // angle(north is source point,clockwise is positive)
    double                  speed;                      // speed(sea mile,speed/1000*1.852km/h)
    WORD                    starCount;                  // star count
    BYTE                    byRserved2[2];              // align
    NET_THREE_STATUS_BOOL   antennaState;               // antenna state(true good, false bad) valid when emDateSource is EM_DATE_SOURCE_GPS
    NET_THREE_STATUS_BOOL   orientationState;           // orientation state(true orientation, false not) valid when emDateSource is EM_DATE_SOURCE_GPS
    int                     workStae;                   // working state(true normal, false abnormity)
                                                        // valid when emDateSource is EM_DATE_SOURCE_GPS
    int                     nAlarmCount;                // alarm count
    int                     nAlarmState[128];           // alarm type valid when emDateSource is EM_DATE_SOURCE_GPS
    BYTE                    bOffline;                   // 0- real time 1-fill 
    BYTE                    bSNR;                       // SNR for GPS, range: 0~100, 0 for unusable
    BYTE                    byRserved3[2];              // align
    EM_DATE_SOURCE          emDateSource;               // source of date
    BYTE                    byRserved[124];             // reserved bytes
} NET_GPS_STATUS_INFO,*LPNET_GPS_STATUS_INFO;

// alarm of disk burned full
typedef struct __ALARM_DISKBURNED_FULL_INFO
{
	DWORD		dwSize;
	int         nIndex;                             //index
}ALARM_DISKBURNED_FULL_INFO;

// alarm of storage low space
typedef struct tagALARM_STORAGE_LOW_SPACE_INFO 
{
	DWORD				dwSize;
	int					nAction;						// 0:start 1:stop
	char				szName[DH_EVENT_NAME_LEN];		// name
	char				szDevice[DH_STORAGE_NAME_LEN];	// device name
	char				szGroup[DH_STORAGE_NAME_LEN];	// group name 
	INT64				nTotalSpace;					// total space byte
	INT64				nFreeSpace;						// free space byte
	int					nPercent;						// used percent 
} ALARM_STORAGE_LOW_SPACE_INFO;

// storage error
typedef enum __EM_STORAGE_ERROR
{
	STORAGE_ERROR_NONE,							// no error
    STORAGE_ERROR_PATITION,						// patition error 		
	STORAGE_ERROR_INIT_FS,						// init system file error	
	STORAGE_ERROR_READ_DATA,					// read data error
	STORAGE_ERROR_WRITE_DATA,					// write data error
	STORAGE_ERROR_RAID_FAILED,					// RAID error
	STORAGE_ERROR_RAID_DEGRADED,				// RAID degranded 
    STORAGE_ERROR_ISCSI_FAILED,                 // iSCSI error
} EM_STORAGE_ERROR;

// alarm of storage failure
typedef struct __ALARM_STORAGE_FAILURE_EX
{
	DWORD				dwSize;
	int					nAction;						// 0:start 1:stop
	char				szName[DH_EVENT_NAME_LEN];		// name 
	char				szDevice[DH_STORAGE_NAME_LEN];	// device name
	char				szGroup[DH_STORAGE_NAME_LEN];	// group name
	char				szPath[MAX_PATH];				// path
	EM_STORAGE_ERROR	emError;						// error type
    int                 nPhysicNo;                      // disk No, start from 1 
    NET_TIME_EX			stuTime;						// Event occurrence time 
} ALARM_STORAGE_FAILURE_EX;

// alarm of record failed 
typedef struct __ALARM_RECORD_FAILED_INFO 
{
	DWORD				dwSize;
	int					nAction;						// 0:start 1:stop
	int					nIndex;							// index
} ALARM_RECORD_FAILED_INFO;

// storage break down
typedef struct __ALARM_STORAGE_BREAK_DOWN_INFO 
{
	DWORD				dwSize;
	int					nAction;						// 0:start 1:stop
} ALARM_STORAGE_BREAK_DOWN_INFO;

// hot plug action mode
typedef enum tagEM_STORAGE_HOT_PLUG_ACTION
{
    HOT_PLUG_ACTION_UNKNOW = 0  ,
    HOT_PLUG_ACTION_ADD         ,       //Insert device
    HOT_PLUG_ACTION_REMOVE      ,       //Remove device 
}EM_STORAGE_HOT_PLUG_ACTION;
// storage hot plug action event (corresponding to DH_ALARM_STORAGE_HOT_PLUG)
typedef struct __ALARM_STORAGE_HOT_PLUG_INFO
{
    int                         nAction;                            // 0:Start 1:stop
    EM_STORAGE_HOT_PLUG_ACTION  emHotPLugAction;                    // Hot swap operation type 
    char                        szDevice[DH_STORAGE_NAME_LEN];      // Storage device name 
    char                        szMediaType[DH_COMMON_STRING_32];   // Media type 
    char                        szBusType[DH_COMMON_STRING_32];     // BUS type 
    char                        szMountOn[DH_COMMON_STRING_128];    // Device mount position 
    int                         nPhysicNo;                          // Physical SN. Begins with 1. 
    int                         nLogicNo;                           // Logic SN
    BYTE                        bReserved[256];                     // Reserved byte. To be developed .
}ALARM_STORAGE_HOT_PLUG_INFO;

// flow rate event(corresponding to DH_ALARM_FLOW_RATE)
typedef struct tagALARM_FLOW_RATE_INFO
{
	int				nAction;				// 0:paulse, 1:start, 2:stop
	int				nChannelID;				// channelId
	UINT			nFlowRate;				// the flow rate(unit:MB)
	BYTE			bReserved[512];			// Reserved byte. 
} ALARM_FLOW_RATE_INFO;


typedef enum tagEM_NET_UPS_STATUS
{
	EM_NET_UPS_SYS_SIGN=0	 	,	//System temperature the sign bit. 1: negative temperature; 0:positive temperature
	EM_NET_UPS_SYS_SHUTDOWN 	,	//System shutdown. 1: shutdown activated state
	EM_NET_UPS_SYS_TEST 		,	//System tests. 1: said tests
	EM_NET_UPS_SYS_TYPE 		,	//UPS type. 1: backup machine; 0: said online machine
	EM_NET_UPS_SYS_FAULT 		,	//UPS fault. 1: UPS internal fault; Zero: normal
	EM_NET_UPS_ELE_SUPPLY 		,	//The bypass/inverter state. 1: AC power supply; 0: batteries
	EM_NET_UPS_VOL_LOW 			,	//Low battery voltage. 1: low battery voltage; Zero: it means the battery is normal
	EM_NET_UPS_BYPASS_STATUS	,	//Mains failure. 1: mains failure; Zero: it means the mains is normal
	EM_NET_UPS_MAX = 64			,	//
}EM_NET_UPS_STATUS;

typedef struct tagNET_UPS_INFO
{
	DWORD dwSize;
	float fInputVoltage;						//Specific reference input voltage intelligent transportation special power communication protocol (V1.2), blue shield special definition
	float fInputAbnormalVoltage;				//Abnormal input voltage
	float fOutputVoltage;						//output voltage
	float fOutputCurrent;						//Output current percentage, the unit (%)
	float fInputFrequency;						//incoming frequency
	float fVoltage;								//voltage
	float fTemp;								//temperature
	BYTE  bStatusInfo[EM_NET_UPS_MAX];			//Set UPS STATUS, see.net UPS STATUS enumeration
	char  szVersionInfo[DH_MAX_VERSION_STR];	//version
}NET_UPS_INFO;

typedef struct tagALARM_COMM_PORT_EVENT_INFO
{
	DWORD           dwSize;
	UINT      		nEventAction;	// Event Action, 0=Impulse Event,1=Begin a Continued Event,2=the Event End;
	NET_UPS_INFO	stUPSInfo;		// UPS's COM Information
}ALARM_COMM_PORT_EVENT_INFO;

// ininvalid of video input channel(example:)DH_ALARM_VIDEO_ININVALID
typedef struct __ALARM_VIDEO_ININVALID_INFO 
{
	DWORD               dwSize;                         // struct size
	int                 nChannelID;                     // channel ID,from 0
} ALARM_VIDEO_ININVALID_INFO;


// No Information of Event in Storage Group
typedef struct tagALARM_STORAGE_NOT_EXIST_INFO 
{
    DWORD           dwSize;
    int             nAction;                            // 0:start 1:stop
    char            szGroup[DH_STORAGE_NAME_LEN];       // Storage Droup Name
    NET_TIME        stuTime;                            // the Time of Event triggering)
}ALARM_STORAGE_NOT_EXIST_INFO;

//the Type of Network Fault Event)
typedef enum __EM_NETABORT_EVENT_TYPE
{
	EM_NETABORT_EVENT_TYPE_WIRE = 0,				// Wired Network Fault Event 
	EM_NETABORT_EVENT_TYPE_WIRELESS,				// Wireless Network Fault Event 
	EM_NETABORT_EVENT_TYPE_3G,						// 3G Network Fault Event
}EM_NETABORT_EVENT_TYPE;

// Network Fault Event
typedef struct tagALARM_NETABORT_INFO
{
	DWORD			dwSize;
	int				nAction;						// 0=Start 1=Stop
	EM_NETABORT_EVENT_TYPE	emNetAbortType;			// Event Type
	NET_TIME		stuTime;						// Event Triggering Time

	char			szInterface[DH_MAX_ETH_NAME];	// Conflict network card name
}ALARM_NETABORT_INFO;

// IP Clash Event
typedef struct tagALARM_IP_CONFLICT_INFO
{
	DWORD			dwSize;
	int				nAction;						// 0=Start 1=Stop
	NET_TIME		stuTime;						// Event Triggering Time)
}ALARM_IP_CONFLICT_INFO;


// MAC Clash Evnet)
typedef struct tagALARM_MAC_CONFLICT_INFO
{
	DWORD			dwSize;
	int				nAction;						// 0=Start 1=Stop
	NET_TIME		stuTime;						// Event Triggering Time
}ALARM_MAC_CONFLICT_INFO;


// Power Type
typedef enum __EM_POWER_TYPE
{
	EM_POWER_TYPE_MAIN = 0,							// Main Power
	EM_POWER_TYPE_BACKUP,							// Spare Power
}EM_POWER_TYPE;

// the Type of Power Fault Event
typedef enum __EM_POWERFAULT_EVENT_TYPE
{
	EM_POWERFAULT_EVENT_UNKNOWN = -1,				 // Unknown
	EM_POWERFAULT_EVENT_LOST = 0,                    // Power down, has no battery
	EM_POWERFAULT_EVENT_LOST_ADAPTER,                // Has no adapter
	EM_POWERFAULT_EVENT_LOW_BATTERY,				 // Battery under voltage
	EM_POWERFAULT_EVENT_LOW_ADAPTER,				 // Adapter under voltage
}EM_POWERFAULT_EVENT_TYPE;

// Power Fault Event
typedef struct tagALARM_POWERFAULT_INFO
{
	DWORD					dwSize;			
	EM_POWER_TYPE			emPowerType;			// Power Type
	EM_POWERFAULT_EVENT_TYPE	emPowerFaultEvent;	// Power Fault Event
	NET_TIME				stuTime;				// Alarm Event Begin Time 
	int						nAction;				// 0=Start 1=Stop 
}ALARM_POWERFAULT_INFO;

// Tamper Alarm Event 
typedef struct tagALARM_CHASSISINTRUDED_INFO
{
	DWORD				dwSize;
	int					nAction;				// 0=Start 1=Stop 
	NET_TIME			stuTime;				// Alarm Event Begin Time
	int                 nChannelID;             // Channel ID
	char				szReaderID[DH_COMMON_STRING_32];// Reader ID	
    UINT 			    nEventID;				//event id
    char                szSN[32];               // wireless device serial number
}ALARM_CHASSISINTRUDED_INFO;

// Expand Module Alarm Event
typedef struct tagALARM_ALARMEXTENDED_INFO
{
	DWORD				dwSize;
	int                 nChannelID;             //  Channel ID
	int					nAction;				//  0=Start 1=Stop (1=stop) 
	NET_TIME			stuTime;				//  Alarm Event Begin Time
}ALARM_ALARMEXTENDED_INFO;


// Interphone's Initiator 
typedef enum __EM_TALKING_CALLER
{
	EM_TALKING_CALLER_UNKNOWN = 0,				// Uunbeknown Initiator 
	EM_TALKING_CALLER_PLATFORM,					// Interphone's initiator is Platform
}EM_TALKING_CALLER;

// Invite Evnet remote device protocol
typedef enum tagTALKINGINVITE_REMOTEDEVICE_PROTOCOL
{
    EM_TALKINGINVITE_REMOTEDEVICE_PROTOCOL_UNKNOWN = 0,     // UNKNOWN;
    EM_TALKINGINVITE_REMOTEDEVICE_PROTOCOL_HIKVISION        // HIKVISION
}EM_TALKINGINVITE_REMOTEDEVICE_PROTOCOL;

#define MAX_REMOTEDEVICEINFO_IPADDR_LEN         128       // max remote device IP address length
#define MAX_REMOTEDEVICEINFO_USERNAME_LEN       128       // max remote device username length
#define MAX_REMOTEDEVICEINFO_USERPSW_LENGTH     128       // max remote device password length

// Invite Evnet remote device information
typedef struct tagTALKINGINVITE_REMOTEDEVICEINFO
{
    char		                            szIP[MAX_REMOTEDEVICEINFO_IPADDR_LEN];	        // device's IP
	int	                                    nPort;							                // port
	EM_TALKINGINVITE_REMOTEDEVICE_PROTOCOL  emProtocol;                                     // protocol type
	char		                            szUser[MAX_REMOTEDEVICEINFO_USERNAME_LEN];	    // user name
	char		                            szPassword[MAX_REMOTEDEVICEINFO_USERPSW_LENGTH];// password
	char                                    szReverse[1024];                                // reverse word
}TALKINGINVITE_REMOTEDEVICEINFO;

// Alarm Event TypeDH_ALARM_TALKING_INVITE Device ask Other Side InitiateInterphone Event )Corresponding Data Description Information 
typedef struct tagALARM_TALKING_INVITE_INFO
{
    DWORD                                   dwSize;
    EM_TALKING_CALLER                       emCaller;                       // Interphone's Initiator is Device Desired 
    NET_TIME                                stuTime;                        // Event Triggering Time
    char                                    szCallID[DH_COMMON_STRING_64];	// Unique ID for calling
    int                                     nLevel;						    // The level of current calling device 
    TALKINGINVITE_REMOTEDEVICEINFO          stuRemoteDeviceInfo;            // remote device info
}ALARM_TALKING_INVITE_INFO;

// Alarm Event Type DH_ALARM_TALKING_HANGUP corresponding data description
typedef struct tagALARM_TALKING_IGNORE_INVITE_INFO
{
    DWORD                dwSize;
} ALARM_TALKING_IGNORE_INVITE_INFO;
// data describe info corresponding alarm event mode:DH_ALARM_TALKING_HANGUP
typedef struct tagALARM_TALKING_HANGUP_INFO 
{
    DWORD               dwSize;
    NET_TIME            stuTime;                // Event trigger time
}ALARM_TALKING_HANGUP_INFO;

// Station Update Event Status
typedef enum tagEM_GUARD_EVENT_STATE
{
	EM_GUARD_EVENT_STATE_UNKNOWN = 0,	// unknown status
	EM_GUARD_EVNET_STATE_ONGUARD,		// on guard
	EM_GUARD_EVENT_STATE_OFFGUARD		// off guard
}EM_GUARD_EVENT_STATE;

// station info update event ,DH_ALARM_GUARD_INFO_UNPDATE data description info
typedef struct tagALARM_GUARD_UPDATE_INFO
{
	DWORD				 dwSize;
	EM_GUARD_EVENT_STATE emEventState;							// station update event status
	int					 nIDCount;								// trigger detection event staff ID number
	int					 nIDArray[DH_MAX_GUARD_DETECT_ID_COUNT];// staff ID group
	NET_TIME			 stuTime;								// event trigger time
}ALARM_GUARD_UPDATE_INFO;

// station detection event ,DH_ALARM_GUARD_DETECTcorresponding to data description info
typedef struct tagALARM_GUARD_DETECT_INFO
{
	DWORD				dwSize;
	int					nAction;								// 0: start 1: stop
	int					nIndex;									// station detection config mark	
	int					nIDCount;								// trigger detection event staff ID number
	int					nIDArray[DH_MAX_GUARD_DETECT_ID_COUNT];	// staff ID group number
	NET_TIME			stuTime;								// event trigger time
}ALARM_GUARD_DETECT_INFO;

//Bank card event DH_ALARM_BANKCARDINSERT corresponding data info
typedef struct tagALARM_BANKCARDINSERT_INFO 
{
    DWORD               dwSize;
    int                 nAction;                // -1:unknown 0: start 1:stop
}ALARM_BANKCARDINSERT_INFO;

#define MAX_CARD_RECORD_FIELD_NUM 16            // card no. max domain quantity

// event trigger record,stop storage strategy
typedef enum tagNET_RECORD_SAVEFLAG
{
    NET_RECORD_SAVEFLAG_UNKNOWN = 0,            //unknown type
	NET_RECORD_SAVEFLAG_MARK,                   //save record and lock
	NET_RECORD_SAVEFLAG_SAVE,                   //only save record
}NET_RECORD_SAVEFLAG;

//card no. record event DH_ALARM_CARD_RECORD corresponding to group decryption info
typedef struct tagALARM_CARD_RECORD_INFO 
{
    DWORD               dwSize;
    int                 nAction;                // -1:unknown 0:start 1:stop
    int                 nChannelID;             // channel no., from 0
    unsigned int        nFieldCount;            // domain quantity
    char                szFields[MAX_CARD_RECORD_FIELD_NUM][DH_COMMON_STRING_256]; // domain info
    NET_RECORD_SAVEFLAG emRecordSaveFlag;       // event trigger record, stop storage strategy ,see  NET_RECORD_SAVEFLAG
}ALARM_CARD_RECORD_INFO;

// CLIENT_ControlDevice port DH_CTRL_NOTIFY_EVNENT command parameter(send event to device)
typedef struct tagALARM_NET_INFO
{
    DWORD               dwSize;
    int                 nAction;                // -1:Unknown, 0:Start 1:stop
    int                 nChannelID;             // Channel No. Begins with 0. 
} ALARM_NET_INFO;

//CLIENT_ControlDevice port DH_ALARM_VIDEOMOTION_EVENT command parameter(send event to device) 
typedef struct tagALARM_VIDEOMOTION_EVENT_INFO
{
	DWORD				 dwSize;
	int                  nAction;             // -1:Unknown, 0:Start 1:stop
	int                  nChannelID;          // Channel No. Begins with 0.
}ALARM_VIDEOMOTION_EVENT_INFO;

////CLIENT_ControlDevice port DH_ALARM_WIDE_VIEW_REGION_EVENT command parameter(send event to device)   
typedef struct tagALARM_WIDE_VIEW_REGION_EVENT_INFO
{
    DWORD				 dwSize;
    int                  nAction;             // -1:Unknown 0:Pulse   
}ALARM_WIDE_VIEW_REGION_EVENT_INFO;

// DH_CTRL_NOTIFY_EVNENT command parameter of CLIENT_ControlDevice interface (send event to device)
typedef struct tagNET_NOTIFY_EVENT_DATA
{
    DWORD                       dwSize;
    LONG                        lCommand;       // event type
    void*                       pEventData;     // event content,and lCommandcorresponding to structure indicator
}NET_NOTIFY_EVENT_DATA;

// Sensor's Sense Method Enumeration Type
typedef enum tagNET_SENSE_METHOD
{
	NET_SENSE_UNKNOWN = -1,		//Unknowed type
	NET_SENSE_DOOR=0,			//Door Contact
	NET_SENSE_PASSIVEINFRA,		//Passive Infrared
	NET_SENSE_GAS,				//Gase Induce)
	NET_SENSE_SMOKING,			//Smoking Induce
	NET_SENSE_WATER,			//Wwater Induce)
	NET_SENSE_ACTIVEFRA,		//Initiative Infrared
	NET_SENSE_GLASS,			//Glass Broken
	NET_SENSE_EMERGENCYSWITCH,	//Emergency switch
	NET_SENSE_SHOCK,			//Shock
	NET_SENSE_DOUBLEMETHOD,		//Double Method(Infrare+Microwave)
	NET_SENSE_THREEMETHOD,		//Three Method
	NET_SENSE_TEMP,				//Temperature
	NET_SENSE_HUMIDITY,			//Humidity
	NET_SENSE_WIND,             //Wind
	NET_SENSE_CALLBUTTON,		//Call button
    NET_SENSE_GASPRESSURE,      //Gas Pressure
    NET_SENSE_GASCONCENTRATION, //Gas Concentration
    NET_SENSE_GASFLOW,          //Gas Flow
	NET_SENSE_OTHER,			//Other
    NET_SENSE_OIL,              //oil detection, gasoline, diesel vehicles detection
    NET_SENSE_MILEAGE,          //mileage detection
    NET_SENSE_URGENCYBUTTON,    //Urgency button
    NET_SENSE_STEAL,            //Steal
    NET_SENSE_PERIMETER,        //Permeter
    NET_SENSE_PREVENTREMOVE,    //Prevent remove
    NET_SENSE_DOORBELL,         //Door bell
    NET_SENSE_ALTERVOLT,        //Alter voltage sensor
    NET_SENSE_DIRECTVOLT,       //Direct voltage sensor
    NET_SENSE_ALTERCUR,         //Alter current sensor
    NET_SENSE_DIRECTCUR,        //Direct current sensor
    NET_SENSE_RSUGENERAL,       //RSU general analog sensor, 4~20mA or 0~5V
    NET_SENSE_RSUDOOR,          //RSU door sensor
    NET_SENSE_RSUPOWEROFF,      //RSU power off sensor	
    NET_SENSE_TEMP1500 ,        //1500 temperature sensor	
    NET_SENSE_TEMPDS18B20 ,     //DS18B20 temperature sensor	
    NET_SENSE_HUMIDITY1500,     //1500 humidity sensor
    NET_SENSE_INFRARED,         //Infrared sensor
    NET_SENSE_FIREALARM,        //firealarm sensor
	NET_SENSE_CO2,				//Determination of CO2, typical value:0~5000ppm
	NET_SNESE_SOUND,			//Noise detection,typical value:30~130dB
	NET_SENSE_PM25,				//PM2.5 detection,typical value:0~1000ug/m3
	NET_SENSE_SF6,				 //Determination of SF6,typical value:0~3000ppm
	NET_SENSE_O3,				 //O3 detection,typical value:0~100ppm
	NET_SENSE_AMBIENTLIGHT,		 //ambient light detection,typical value:0~20000Lux
    NET_SENSE_SIGNINBUTTON,      //sign in button
	NET_SENSE_LIQUIDLEVEL,		 //LiquidLevel
	NET_SENSE_DISTANCE,			 //distance
	NET_SENSE_WATERFLOW,		 //water flow



	NET_SENSE_NUM               // enum total
}NET_SENSE_METHOD;

//corresponding Enumeration Type of Sensor's Sense Method's unit 
typedef enum tagEM_SENSE_METHOD_UNIT
{
	EM_SENSE_UNIT_UNKOWN =-1,		 // Unknowed type
	EM_SENSE_TEMP_CENTIGRADE = 0,    // Temperature's unit: Centigrade
	EM_SENSE_TEMP_FAHRENHEIT,        // Temperature's unit: Fahrenheit
	EM_SENSE_WIND_SPEED,             // Wind speed's unit:  m/s
	EM_SENSE_HUMIDITY_PERCENT,       // Humidity unit: Percent 
}EM_SENSE_METHOD_UNIT;	

// Protect/Cancel Protect Mode 
typedef enum tagNET_ALARM_MODE
{	
	NET_ALARM_MODE_UNKNOWN = -1,	// Unknown
	NET_ALARM_MODE_DISARMING,		// Cancel Protect 
	NET_ALARM_MODE_ARMING,			// Install protect
	NET_ALARM_MODE_FORCEON,			// Forceon protect
    NET_ALARM_MODE_PARTARMING,      // Parting protect
}NET_ALARM_MODE;

// Arm/Disarm scene mode
typedef enum tagNET_SCENE_MODE
{
	NET_SCENE_MODE_UNKNOWN,			// Unknown scene
	NET_SCENE_MODE_OUTDOOR,			// Outdoor mode
	NET_SCENE_MODE_INDOOR,			// Inner mode
    NET_SCENE_MODE_WHOLE,           // global mode
    NET_SCENE_MODE_RIGHTNOW,        // immediate mode
    NET_SCENE_MODE_SLEEPING,        // sleeping mode
    NET_SCENE_MODE_CUSTOM,          // custom mode
}NET_SCENE_MODE;

// trigger mode
typedef enum tagNET_EM_TRIGGER_MODE
{
    NET_EM_TRIGGER_MODE_UNKNOWN = 0,
    NET_EM_TRIGGER_MODE_NET,            // Network user(Platform or Web)
    NET_EM_TRIGGER_MODE_KEYBOARD,       // keyboard
    NET_EM_TRIGGER_MODE_REMOTECONTROL,  // remote control
}NET_EM_TRIGGER_MODE;

// Protect Transformate Event's Information
typedef struct tagALARM_ARMMODE_CHANGE_INFO
{
	DWORD				dwSize;
	NET_TIME			stuTime;			// Alarm Event Begin Time
	NET_ALARM_MODE		bArm;				// Statue of Transformated
	NET_SCENE_MODE		emSceneMode;		// ContextualMode
    DWORD               dwID;               // ID number, remote control number or keypad address, emTriggerMode=0 when  belong to NET_EM_TRIGGER_MODE_NET
    NET_EM_TRIGGER_MODE emTriggerMode;      // trigger mode
	char 				szNetClientAddr[64]; //Net user IP or IP address
    UINT            nUserCode;  //User ID, 0:administrator, 1~20:ordinary user, 21:setter, 22:hijacked user  
}ALARM_ARMMODE_CHANGE_INFO;

// defence zone type
typedef enum
{
	NET_DEFENCEAREA_TYPE_UNKNOWN,		// Unknown Type Defence Area
	NET_DEFENCEAREA_TYPE_ALARM,			// Switching Value Defence Area
    NET_DEFENCEAREA_TYPE_ANALOGALARM,   // Analogalarm defence Area
}NET_DEFENCEAREA_TYPE;

// Bypass Statue Type
typedef enum
{
	NET_BYPASS_MODE_UNKNOW,			//UnknownBypass Statue
	NET_BYPASS_MODE_BYPASS,			//Bypass
	NET_BYPASS_MODE_NORMAL,			//Normal
	NET_BYPASS_MODE_ISOLATED,		//Isolated
}NET_BYPASS_MODE;

// The Information of Bypass's Statue Change Event
typedef struct tagALARM_BYPASSMODE_CHANGE_INFO
{
	DWORD                   dwSize;
	int	                    nChannelID;                 // Channel ID
	NET_TIME                stuTime;                    // Alarm Event Begin Time
	NET_DEFENCEAREA_TYPE    emDefenceType;              // Defence Area Type
	int                     nIsExtend;                  // Whether or not It Is Expand, Channel, Defence Area , 1=Expand Channel, 0=Non Expand Channel)
	NET_BYPASS_MODE	        emMode;	                    // Changed Mode 
    DWORD                   dwID;                       // ID number, remote control number or keypad address, emTriggerMode=0 when belong to NET_EM_TRIGGER_MODE_NET
    NET_EM_TRIGGER_MODE     emTriggerMode;              // trigger mode
}ALARM_BYPASSMODE_CHANGE_INFO;


// Emergency Event, Correspond DH_URGENCY_ALARM_EX2,DH_URGENCY_ALARM_EX Update, That is Artificially Triggered Emergency,General Treatment is Linkage External Communications Functions for Help, 
typedef struct tagALARM_URGENCY_ALARM_EX2 
{
	DWORD		dwSize;
	NET_TIME	stuTime;			// Event Begin Time
    DWORD           nID;            // used to mark different emergency event
}ALARM_URGENCY_ALARM_EX2;

// Alarm Input Source Event Details(As Long As There Will Have to Change The Input Event, Regardless of the Current Mode of The Defence Zone Can not be Shielded)
typedef struct tagALARM_INPUT_SOURCE_SIGNAL_INFO
{
	DWORD		dwSize;
	int			nChannelID;             // Channel ID
	int			nAction;				// 0=Start 1=Stop 
	NET_TIME	stuTime;				// Alarm Event Begin Time
}ALARM_INPUT_SOURCE_SIGNAL_INFO;

// Analog Input Channel Alarm Event Information(Corresponding DH_ALARM_ANALOGALARM_EVENT), 
typedef struct tagALARM_ANALOGALARM_EVENT_INFO 
{
	DWORD		dwSize;
	int			nChannelID;             // Alarm Event Begin Time
	int			nAction;				// 0=Start 1=Stop 
	NET_TIME	stuTime;				// Alarm Event Begin Time
	NET_SENSE_METHOD	emSensorType;	// the Sensor's Type
	char		szName[DH_COMMON_STRING_128];	// Channel Name
    int         nIsValid;               // Data is valid or not,-1: unknown,0:invalid,1:valid
    int         nStatus;                // Data status, -1: unknown,0:noemal,1:invalid data(over limit),
                                        // 2:over threshold value1,3: over threshold value 2,4: over threshold value 3,5: over threshold value 4,
                                        // 6:below threshold value 1,7: below threshold value2,8: below threshold value3,9: below threshold value4
    float       fValue;                 // Detector value
    NET_TIME    stuCollectTime;         // Data collection time(UTC)
    NET_GPS_STATUS_INFO stGPSStatus;    // GPS status
}ALARM_ANALOGALARM_EVENT_INFO;


// Access Control Status Type
typedef enum tagNET_ACCESS_CTL_STATUS_TYPE
{
	NET_ACCESS_CTL_STATUS_TYPE_UNKNOWN = 0,
	NET_ACCESS_CTL_STATUS_TYPE_OPEN,		// Open
	NET_ACCESS_CTL_STATUS_TYPE_CLOSE,		// Close
    NET_ACCESS_CTL_STATUS_TYPE_ABNORMAL,    // Abnormal
    NET_ACCESS_CTL_STATUS_TYPE_FAKELOCKED,  // fake locked
	NET_ACCESS_CTL_STATUS_TYPE_CLOSEALWAYS,  // close always
	NET_ACCESS_CTL_STATUS_TYPE_OPENALWAYS,  // open always
}NET_ACCESS_CTL_STATUS_TYPE;

// Access control status event
typedef struct tagALARM_ACCESS_CTL_STATUS_INFO 
{
	DWORD		dwSize;
	int			nDoor;						// Door channel no.
	NET_TIME	stuTime;					// Event time
	NET_ACCESS_CTL_STATUS_TYPE	emStatus;	// Access control status	
    char        szSerialNumber[256];        //wireless device serial number(Intelligent lock)
}ALARM_ACCESS_CTL_STATUS_INFO;

// Access Control Snapshot Type
typedef enum tagNET_ACCESS_SNAP_TYPE
{
    NET_ACCESS_SNAP_TYPE_UNKNOWN = 0,
    NET_ACCESS_SNAP_TYPE_CARD,                          // Swipe
    NET_ACCESS_SNAP_TYPE_PASSWORD,                      // Password
	NET_ACCESS_SNAP_TYPE_REMOTE,						// remote open door
	NET_ACCESS_SNAP_TYPE_BUTTON,						// Button
	NET_ACCESS_SNAP_TYPE_FINGERPRINT,					// Finger print
	NET_ACCESS_SNAP_TYPE_QRCODE,						// QR code
	NET_ACCESS_SNAP_TYPE_BLUETOOTH,						// Blue tooth
	NET_ACCESS_SNAP_TYPE_FACE,							// Face
}NET_ACCESS_SNAP_TYPE;

// Access Control Snapshot Event
typedef struct tagALARM_ACCESS_SNAP_INFO
{
    DWORD           dwSize;
    NET_ACCESS_SNAP_TYPE emType;                        // Type
    char            szCardNO[DH_COMMON_STRING_32];      // Card no., swipe card valie
    char            szPassword[DH_COMMON_STRING_64];    // Password, valid when unlock by password    
    char            szFtpUrl[MAX_PATH];                 // ftp upload address, picturepath
    int             nImageNum;                          // Snapshot picture
    NET_TIME        stuTime;                            // Event time
}ALARM_ACCESS_SNAP_INFO;

// Clear Alarm Event
typedef struct tagALARM_ALARMCLEAR_INFO 
{
    DWORD           dwSize;
    int             nChannelID;                         // Channel No.
    NET_TIME        stuTime;                            // Alarm event time
    int             bEventAction;                       // Event Action,0=Impluse Event,1=Continued Event Start,2=Continued Event End;
}ALARM_ALARMCLEAR_INFO;
// CID Event
typedef struct tagALARM_CIDEVENT_INFO
{
    DWORD           dwSize;
    NET_TIME        stuTime;                            // Alarm event time
    char			szCID[DH_COMMON_STRING_32];         // CID code, standard protocolcode, string length is 16, string value is 0~F
                                                        // 4 bit user code + 2 bit recognition code + 1 bit event limit code + 3 bit event code + 2 bit system code + 3 bit zone code + 1 bit parity code
}ALARM_CIDEVENT_INFO;

// Emergency Help Event Type
typedef enum tagEM_RCEMERGENCY_CALL_TYPE
{
    EM_RCEMERGENCY_CALL_UNKNOWN = 0,
    EM_RCEMERGENCY_CALL_FIRE,                           // Fire
    EM_RCEMERGENCY_CALL_DURESS,                         // Forced
    EM_RCEMERGENCY_CALL_ROBBER,                         // Robber
    EM_RCEMERGENCY_CALL_MEDICAL,                        // Medical
    EM_RCEMERGENCY_CALL_EMERGENCY,                      // Emergency
}EM_RCEMERGENCY_CALL_TYPE;

// alarm method
typedef enum tagEM_RCEMERGENCY_MODE_TYPE
{
    EM_RCEMERGENCY_MODE_UNKNOWN = 0,
    EM_RCEMERGENCY_MODE_KEYBOARD,                       // keyboard
    EM_RCEMERGENCY_MODE_WIRELESS_CONTROL,               // remote control
}EM_RCEMERGENCY_MODE_TYPE;

// Emergency Help Event Details
typedef struct tagALARM_RCEMERGENCY_CALL_INFO 
{
    DWORD                   dwSize;
    int                     nAction;                    // 0:start 1:stop
    EM_RCEMERGENCY_CALL_TYPE  emType;                   // emergency type
    NET_TIME                stuTime;                    // event time
    EM_RCEMERGENCY_MODE_TYPE  emMode;                   // alarm method
    DWORD                   dwID;                       // for different emergency events (only emMode is remote control type, it is valid , means remote control no. , 0 means invalid ID)
}ALARM_RCEMERGENCY_CALL_INFO;

// multi-people unlock event(corresponding to DH_ALARM_OPENDOORGROUP type)
typedef struct tagALARM_OPEN_DOOR_GROUP_INFO
{
    DWORD           dwSize;
    int             nChannelID;                         // door channel(from 0)
    NET_TIME        stuTime;                            // event time
}ALARM_OPEN_DOOR_GROUP_INFO;

// get fingerprint event(corresponding to DH_ALARM_FINGER_PRINT type)
typedef struct tagALARM_CAPTURE_FINGER_PRINT_INFO 
{
    DWORD           dwSize;
    int             nChannelID;                         // door channel no.( from 0)
    NET_TIME        stuTime;                            // event time
    char            szReaderID[DH_COMMON_STRING_32];    // card reader ID
    int             nPacketLen;                         // single fingerprint data length
    int             nPacketNum;                         // fingerprint data number
    char*           szFingerPrintInfo;                  // fingerprint data(data total length as nPacketLen*nPacketNum)
	BOOL			bCollectResult;						// collect result
	char			szCardNo[32];						// card num (customized)
	char			szUserID[32];						// user id (customized)
}ALARM_CAPTURE_FINGER_PRINT_INFO;

// sub system status type
typedef enum __EM_SUBSYSTEM_STATE_TYPE
{
    EM_SUBSYSTEM_STATE_UNKNOWN = 0,                     // unknown
    EM_SUBSYSTEM_STATE_ACTIVE,                          // activated
    EM_SUBSYSTEM_STATE_INACTIVE,                        // not activated
}EM_SUBSYSTEM_STATE_TYPE;

// sub system statua change event
typedef struct tagALARM_SUBSYSTEM_STATE_CHANGE_INFO 
{
    DWORD                   dwSize;
    int                     nChannelID;                 // sub system no.(from 0)
    NET_TIME                stuTime;                    // event time
    EM_SUBSYSTEM_STATE_TYPE emState;                    // changed status
}ALARM_SUBSYSTEM_STATE_CHANGE_INFO;

// battery scheduled notice event
typedef struct tagALARM_BATTERYPOWER_INFO
{
    DWORD       dwSize;
    int         nChannel;                                  // battery no.
    NET_TIME    stuTime;                                   // event time
    int         nPercent;                                  // battery percentage
    float       fVoltage;                                  // Voltage unit:V
    BOOL        bCharging;                                 // Charge status,true:Charging false:not Charge
}ALARM_BATTERYPOWER_INFO;

//bell status event
typedef struct tagALARM_BELLSTATUS_INFO 
{
    DWORD       dwSize;
    int         nChannel;                                   // bell channel no. 
    NET_TIME    stuTime;                                    // event time
    int         nAction;                                    // 0:start 1:stop
}ALARM_BELLSTATUS_INFO;

// zone status change event, corresponding to event type DH_ALARM_DEFENCE_STATE_CHANGE_EVENT
typedef struct tagALARM_DEFENCE_STATUS_CHANGE_INFO 
{
    DWORD                   dwSize;
    int                     nChannelID;                     // zone ID, as alarm input channel no.(from 0)
    NET_TIME                stuTime;                        // event time
    EM_DEFENCE_STATE_TYPE   emStatus;                       // zone changed status
}ALARM_DEFENCE_STATUS_CHANGE_INFO;

// login failed event
typedef struct tagALARM_LOGIN_FAILIUR_INFO
{
    DWORD                   dwSize;
    int                     nAction;                        // 0:start 1:stop
    unsigned int            nSequence;                      // no.
    char                    szName[DH_EVENT_NAME_LEN];      // event name, fill in user name
    char                    szType[DH_COMMON_STRING_128];   // login type
    char                    szAddr[DH_MAX_IPADDR_EX_LEN];   // source IP address
    int                     nError;                         // user login failed error code
}ALARM_LOGIN_FAILIUR_INFO;

// ticket statistics info event corresponding to event type DH_ALARM_TICKET_STATISTIC
typedef struct tagALARM_TICKET_STATISTIC
{
    DWORD                   dwSize;
    NET_GPS_STATUS_INFO     stuGPSStatusInfo;               // GPS info
    NET_TIME                stuTime;                        // event report time
    int                     nNormalCount;                   // general ticket number
    int                     nDiscountCount;                 // discount ticket
    int                     nSubsidyCount;                  // yound and old ticket number
    int                     nDriverCount;                   // driver ticket number
    int                     nNormalPrice;                   // general ticket price
    int                     nDiscountPrice;                 // discount ticket price
    int                     nSubsidyPrice;                  // young and old ticket price
}ALARM_TICKET_STATISTIC;

#define MAX_ALARMEXT_MODULE_NUM     256                     // max expansionmodule quantity

// BUS type
typedef enum tagNET_BUS_TYPE
{
    NET_BUS_TYPE_UNKNOWN = 0,
    NET_BUS_TYPE_MBUS,                                      // M-BUS
    NET_BUS_TYPE_RS485,                                     // RS-485    
    NET_BUS_TYPE_CAN,                                       // CAN
	NET_BUS_TYPE_NET,										// internet device
}NET_BUS_TYPE;

// expansion module offline event  corresponding to event type DH_ALARM_MODULE_LOST
typedef struct tagALARM_MODULE_LOST_INFO 
{
    DWORD                   dwSize;
    NET_TIME                stuTime;                        // event report time
    int                     nSequence;                      // expansion module BUS no.(from 0)
    NET_BUS_TYPE            emBusType;                      // BUS type
    int                     nAddr;                          // offline expansion module quantity
    int                     anAddr[MAX_ALARMEXT_MODULE_NUM];// offline expansionmodule no.(from 0)
	char					szDevType[DH_COMMON_STRING_64];	// device type "SmartLock"when type of"AlarmDefence"Index address is Alarm number
															// "LiftController":lift controller
	BOOL					bOnline;						// Online status. The default setup is false. False=offline, true=online
    char                    szSN[32];                       // wirelessdevice Serial Number
}ALARM_MODULE_LOST_INFO;

// PSTN offline event
typedef struct tagALARM_PSTN_BREAK_LINE_INFO
{
    DWORD                   dwSize;
    int                     nChannelID;                 // tel wire no.(from 0)
    int                     nAction;                    // 0:start  1:stop
    NET_TIME                stuTime;                    // event time
}ALARM_PSTN_BREAK_LINE_INFO;

// analog alarm event(instant event), specific sensot type(as overspeed, mealige, oil)trigger
typedef struct tagALARM_ANALOGPULSE_INFO 
{
    DWORD                   dwSize;
    int                     nChannelID;                     // analog alarm channel no.
    NET_TIME                stuEventTime;                   // alarm event time
    NET_SENSE_METHOD        emSense;                        // sensor type
    char                    szName[DH_COMMON_STRING_128];   // sensor name
    int                     nStatus;                        // data status, -1:unknown,0:normal,1:invalid data(over range),
                                                            // 2:over threshold 1,3:over threshold 2,4: over threshold 3,5 over threshold 4,
                                                            // 6:below threshold 1,7: below threshold 2,8: below threshold 3,9: below threshold 4
    float                   fValue;                         // senspr value
    NET_TIME                stuCollectTime;                 // collection time
    NET_GPS_STATUS_INFO     stuGPSStatusInfo;               // GPS info
}ALARM_ANALOGPULSE_INFO;

//dispatch info confirmation type 
typedef enum tagNET_MISSION_CONFIRM_TYPE
{
    NET_MISSION_CONFIRM_UNKNOWN = 0 ,                        // unknown 
    NET_MISSION_CONFIRM_YES ,                                // agree and execute
	NET_MISSION_CONFIRM_NO ,                                 // refuse
}NET_MISSION_CONFIRM_TYPE;

// task confirmation event(corresponding to command DH_ALARM_MISSION_CONFIRM)
typedef struct tagALARM_MISSION_CONFIRM_INFO 
{
    DWORD                   dwSize;
    char                    szTitle[DH_COMMON_STRING_256];    // task name
    char                    szMissionID[DH_COMMON_STRING_256];// task ID
    char                    szComment[DH_COMMON_STRING_256];  // replay content
    NET_GPS_STATUS_INFO     stuGPSStatusInfo;                 // GPS info
    NET_MISSION_CONFIRM_TYPE emConfirmType;                   // dispatch info confirmation type 
}ALARM_MISSION_CONFIRM_INFO;

// collect Node group  type 
typedef enum tagNET_CLUSTER_GROUP_TYPE
{
  NET_CLUSTER_GROUP_UNKNOWN,            // unknown 
  NET_CLUSTER_GROUP_IDLE,               // stand alone
  NET_CLUSTER_GROUP_MASTER,             // host
  NET_CLUSTER_GROUP_SLAVE,              // spare
}NET_CLUSTER_GROUP_TYPE;

// Node activate event , corresponding to event type DH_ALARM_NODE_ACTIVE
typedef struct tagALARM_NODE_ACTIVE_INFO 
{
  DWORD         dwSize;
  int           nChannelID;         		// collect node no.
  NET_TIME      stuTime;          			// event occurred event 
  NET_CLUSTER_GROUP_TYPE emGroup;          	//  current Node group
}ALARM_NODE_ACTIVE_INFO;

// collect Node status 
typedef struct tagNET_CLUSTER_STATE_INFO 
{
  DWORD          			dwSize;
  NET_CLUSTER_GROUP_TYPE 	emGroup;          //  current Node group
}NET_CLUSTER_STATE_INFO;

// device alarm mode 
typedef enum tagEM_ALARM_VIDEO_STATIC_MODE
{
  EM_ALARM_VIDEO_STATIC_MODE_UNKNOWN,         // unknown 
  EM_ALARM_VIDEO_STATIC_MODE_INDOOR,          // indoor mode "Indoor"
  EM_ALARM_VIDEO_STATIC_MODE_OUTDOOR,         // outdoor mode "Outdoor"
}EM_ALARM_VIDEO_STATIC_MODE;

// video statis detection event , corresponding to event type DH_ALARM_VIDEO_STATIC
typedef struct tagALARM_VIDEO_STATIC_INFO 
{
  DWORD            dwSize;
  DWORD            dwAction;            // event action, 0:Start, 1:Stop
  EM_ALARM_VIDEO_STATIC_MODE emMode;    // device alarm mode 
  int             nChannelID;           // video statis detection alarm channel no.
}ALARM_VIDEO_STATIC_INFO;

// active registration device re-login event , corresponding to event type DH_ALARM_REGISTER_REONLINE
typedef struct tagALARM_REGISTER_REONLINE_INFO
{
  DWORD      dwSize;
}ALARM_REGISTER_REONLINE_INFO;

// connection status 
typedef enum tagEM_ALARM_ISCSI_STATUS
{
  EM_ALARM_ISCSI_STATUS_UNKNOWN,         		// unknown 
  EM_ALARM_ISCSI_STATUS_CONNECTED,        		// connected
  EM_ALARM_ISCSI_STATUS_NOT_CONNECTED,      	// unconnected
  EM_ALARM_ISCSI_STATUS_CONNECT_FAILED,      	// connection failed
  EM_ALARM_ISCSI_STATUS_AUTHENTICATION_FAILED,  // authentication failed
  EM_ALARM_ISCSI_STATUS_CONNECT_TIMEOUT,     	// connection timed out
  EM_ALARM_ISCSI_STATUS_NOT_EXIST,        		// device does not exist
}EM_ALARM_ISCSI_STATUS;

// ISCSI alarm event , corresponding to event type DH_ALARM_ISCSI_STATUS
typedef struct tagALARM_ISCSI_STATUS_INFO
{
  DWORD         dwSize;
  int           nIndex;               				// means ISCSIdevice index no.
  char          szAddress[DH_COMMON_STRING_32];   	// server address
  char          szName[DH_COMMON_STRING_64];    	// Target name 
  char          szUserName[DH_COMMON_STRING_64];  	// username
  EM_ALARM_ISCSI_STATUS  emStatus;              	// connection status 
}ALARM_ISCSI_STATUS_INFO;

//SCADA type
typedef enum tagEM_ALARM_SCADA_DEV_TYPE
{
	EM_ALARM_SCADA_DEV_UNKNOWN,						// Unknown
	EM_ALARM_SCADA_DEV_LEAKAGE,						// Leakage
	EM_ALARM_SCADA_DEV_THCONTROLLER,				// Temperature and humid  controller
	EM_ALARM_SCADA_DEV_UPS,							// UPS
	EM_ALARM_SCADA_DEV_SWITCH,						// Switch
	EM_ALARM_SCADA_DEV_ELECTRICMETER,				// Electric meter
	EM_ALARM_SCADA_DEV_COMMERCIALPOWER,				// Commercial power
	EM_ALARM_SCADA_DEV_BATTERY,						// Battery
	EM_ALARM_SCADA_DEV_AIRCONDITION,				// Air condition
	EM_ALARM_SCADA_DEV_ACCESS,						// Access
	EM_ALARM_SCADA_DEV_SMOKINGSENSOR,				// Smoking sensor
	EM_ALARM_SCADA_DEV_INFRARED,					// Infra red
	EM_ALARM_SCADA_DEV_CHEMICAL,					// Chemical
	EM_ALARM_SCADA_DEV_PERIMETER,					// Preimeter
	EM_ALARM_SCADA_DEV_DOORMAGNETISM,				// Door magnetism
	EM_ALARM_SCADA_DEV_DISTANCE,					// Distance
	EM_ALARM_SCADA_DEV_WINDSENSOR,					// Wind sensor
	EM_ALARM_SCADA_DEV_LOCATION,					// Location
	EM_ALARM_SCADA_DEV_ATMOSPHERE,					// Atmophere
	EM_ALARM_SCADA_DEV_SOLARPOWER,					// Solar power
}EM_ALARM_SCADA_DEV_TYPE;
//Device status
typedef enum tagEM_SCADA_DEVICE_STATUS
{
	EM_SCADA_DEVICE_STATUS_KNOWN = -1,								// Unknown
	EM_SCADA_DEVICE_STATUS_NORMAL,									// Normal
	EM_SCADA_DEVICE_STATUS_ALARM,									// Alarm
	EM_SCADA_DEVICE_STATUS_OFFLINE,									// Offline
}EM_SCADA_DEVICE_STATUS;
// detection collection device alarm event , corresponding to event type DH_ALARM_SCADA_DEV_ALARM
typedef struct tagALARM_SCADA_DEV_INFO 
{
    DWORD       dwSize;
    int         nChannel;                           // channel no.
    NET_TIME    stuTime;                            // event occur time
    char        szDevName[DH_COMMON_STRING_64];     // failure device name 
    char        szDesc[DH_COMMON_STRING_256];       // alarm description
    int         nAction;                            // -1:unknown, 0:pulse, 1:start, 2:stop
    char        szID[DH_COMMON_STRING_32];          // point ID, current len is 16 bytes
    char        szSensorID[DH_COMMON_STRING_32];    // device ID, current len is 16 bytes
    char        szDevID[DH_COMMON_STRING_32];       // Alarm device ID, current len is 16 bytes
    char        szPointName[DH_COMMON_STRING_64];   // point name, matching with spot chart
    int         nAlarmFlag;                         // 0:start, 1:stop
	EM_ALARM_SCADA_DEV_TYPE			emDevType;		// Device type
	EM_SCADA_DEVICE_STATUS		emDevStatus;	// Device status
}ALARM_SCADA_DEV_INFO;

// vehicle ACC alarm event, correspond event: DH_ALARM_VEHICLE_ACC
typedef struct tagALARM_VEHICLE_ACC_INFO 
{
    DWORD                   dwSize;
    int                     nACCStatus;                         // ACC state, 0:invalid, 1:open, 2:close 
    int                     nAction;                            // event action, 0:Start, 1:Stop
    NET_GPS_STATUS_INFO     stuGPSStatusInfo;                   // GPS informmation
    int                     nConstantElectricStatus;            // Constant electric states, 0:unknown, 1:connect, 2:break                            
	NET_TIME_EX				stuTime;							// Event occurrence time 
	unsigned int			nTotalMileage;						// total mileage,Unit:meter,it will report this field When nACCStatus is 2
	NET_TIME_EX				stuStartTime;						// Start time at nACCStatus is 1
	NET_GPS_STATUS_INFO		stuStartGPS;						// GPS information at nACCStatus is 1
}ALARM_VEHICLE_ACC_INFO;

typedef NET_ACCESS_CTL_STATUS_TYPE  NET_ACCESS_LOCK_STATUS_TYPE;

// locked status, correspond to DH_ALARM_ACCESS_LOCK_STATUS
typedef struct tagALARM_ACCESS_LOCK_STATUS_INFO 
{
    DWORD                       dwSize;
    int                         nChannel;                       // door channal (from 0)
    NET_TIME                    stuTime;                        // the time of event occurs
    NET_ACCESS_LOCK_STATUS_TYPE emLockStatus;                   // locked status
}ALARM_ACCESS_LOCK_STATUS_INFO;

// SEVER TYPE
typedef enum tagEM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE
{
    EM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE_UNKNOWN,         // Unknown
    EM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE_ORGANIZATION,    // Organization wealth investment 
    EM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE_SEAL,            // Sealed wealth investment 
    EM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE_EXCLUSIVE,       // Exclusive wealth investment 
    EM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE_GATHER,          // Combination wealth investment 
    EM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE_EVEN,            // Capital protection wealth investment 
}EM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE;

// Finace event, correspond to DH_ALARM_FINACE_SCHEME
typedef struct tagALARM_FINACE_SCHEME_INFO 
{
    DWORD                       dwSize;
    int                         nChannel;                                   // channel ID
    char                        szBusinessSeverID[DH_COMMON_STRING_64];     // business sever ID
    EM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE  emBusinessSeverType;        // business sever type
    NET_TIME                    stuFinaceSchemeTime;                        // finance scheme time
    NET_TIME                    stuSchemeStartTime;                         // scheme start time
    NET_TIME                    stuSchemeEndTime;                           // scheme end time
    char                        szProductName[DH_COMMON_STRING_128];        // product name
    char                        szCardNo[DH_COMMON_STRING_64];              // card ID
    char                        szPersonID[DH_COMMON_STRING_64];            // persion ID
    char                        szPersonName[DH_COMMON_STRING_64];          // persion name
    char                        szOrgNo[DH_COMMON_STRING_64];               // subbranch No
    char                        szStuffID[DH_COMMON_STRING_64];             // stuff ID
    NET_TIME                    stuRecStartTime;                            // record start time
    NET_TIME                    stuRecEndTime;                              // record end time
}ALARM_FINACE_SCHEME_INFO;

//////////////////////////////////////////////////////////////////////////

// New Record Set Operation(Insert)Parameter
typedef struct tagNET_CTRL_RECORDSET_IN
{
	DWORD	dwSize;
	EM_NET_RECORD_TYPE	emType;					// Record Information Type
	void*	pBuf;								// Record Information Cache,The EM_NET_RECORD_TYPE Note is Details,the space application by the user
	int		nBufLen;							// Record Information Cache Size,please refer to the structure of EM_NET_RECORD_TYPE
}NET_CTRL_RECORDSET_INSERT_IN;

// Record New Operation(Insert) Parameter
typedef struct tagNET_CTRL_RECORDSET_OUT 
{
    DWORD           dwSize;
    int             nRecNo;                             // Record Number(The Device Come Back When New Insert )
}NET_CTRL_RECORDSET_INSERT_OUT;

// Record New Operation (Insert)Parameter 
typedef struct tagNET_CTRL_RECORDSET_INSERT_PARAM 
{
    DWORD                           dwSize;
    NET_CTRL_RECORDSET_INSERT_IN    stuCtrlRecordSetInfo;       // Record Information(User Write)
    NET_CTRL_RECORDSET_INSERT_OUT   stuCtrlRecordSetResult;     // Record Information(the Device Come Back)
}NET_CTRL_RECORDSET_INSERT_PARAM;

// Record Operation Parameter
typedef struct tagNET_CTRL_RECORDSET_PARAM 
{
    DWORD               dwSize;
    EM_NET_RECORD_TYPE  emType;                         // Record Information Type
    void*               pBuf;                           // New/Renew/Inquire,It is Record Information Cache, the EM_NET_RECORD_TYPE Note is Details)
                                                        // Delete,It is memory address for storage Record Number(type is int*)
    int                 nBufLen;                     	// Record Information Cache Size,please refer to the structure of EM_NET_RECORD_TYPE
}NET_CTRL_RECORDSET_PARAM;

// video play mode
typedef enum tagEM_VIDEO_PLAY_MODE_TYPE
{
    EM_VIDEO_PLAY_MODE_TYPE_UNKNOWN,                    // unknown
    EM_VIDEO_PLAY_MODE_TYPE_ONCE,                       // once
    EM_VIDEO_PLAY_MODE_TYPE_REPEAT,                     // repeat
}EM_VIDEO_PLAY_MODE_TYPE;

#define MAX_DELIVERY_FILE_NUM 128                       // the max delivery file num
#define DELIVERY_FILE_URL_LEN 128                       // the max len of url of delivery file

// the delivery file type
typedef enum tagEM_DELIVERY_FILE_TYPE
{
    EM_DELIVERY_FILE_TYPE_UNKNOWN,                      // unknown
    EM_DELIVERY_FILE_TYPE_VIDEO,                        // video
    EM_DELIVERY_FILE_TYPE_IMAGE,                        // image
	EM_DELIVERY_FILE_TYPE_AUDIO,						// Audio
}EM_DELIVERY_FILE_TYPE;

// mode of file
typedef enum tagEM_PLAY_WITH_MODE
{
    EM_PLAY_WITH_MODE_UNKNOWN,                          // unknown
    EM_PLAY_WITH_MODE_RECOGNITION,                      // recognition mode
    EM_PLAY_WITH_MODE_INFORMATION_RELEASE,              // information release mode
} EM_PLAY_WITH_MODE;

// the information of delivery file
typedef struct tagNET_DELIVERY_FILE_INFO
{
    EM_DELIVERY_FILE_TYPE   emFileType;                         // file type
    char                    szFileURL[DELIVERY_FILE_URL_LEN];   // url of file
    int                     nImageSustain;                      // the second of sustain for image(it is valid only when emFileType is EM_DELIVERY_FILE_TYPE_IMAGE)
    EM_PLAY_WITH_MODE       emPlayWithMode;                     // mode of file
    BYTE                    byReserved[1020];                   // reserved
}NET_DELIVERY_FILE_INFO;

// Delivery file to the video output port, building intercom use, run at the same time
typedef struct tagNET_CTRL_DELIVERY_FILE 
{
    DWORD                   dwSize;                             // struct size
    int                     nPort;                              // the port index
    EM_VIDEO_PLAY_MODE_TYPE emPlayMode;                         // the play mode
    NET_TIME                stuStartPlayTime;                   // the time of start play
    NET_TIME                stuStopPlayTime;                    // the time of stop play, it is valid only when emPlayMode is EM_VIDEO_PLAY_MODE_TYPE_REPEAT   
    int                     nFileCount;                         // file count
    NET_DELIVERY_FILE_INFO  stuFileInfo[MAX_DELIVERY_FILE_NUM]; // array of file info
}NET_CTRL_DELIVERY_FILE;

// Serving file information
typedef struct tagNET_DELIVERY_FILE_BYCAR_INFO
{
    EM_DELIVERY_FILE_TYPE   emFileType;                         // file type
    char                    szFileURL[DELIVERY_FILE_URL_LEN];   // url of file
    int                     nImageSustain;                      // the second of sustain for image(it is valid only when emFileType is EM_DELIVERY_FILE_TYPE_IMAGE)
    NET_TIME                stuStartPlayTime;                   // the time of start play
    NET_TIME                stuStopPlayTime;                    // the time of stop play, it is valid only when emPlayMode is EM_VIDEO_PLAY_MODE_TYPE_REPEAT
    BYTE                    byReserved[1024];                   // Reserved
}NET_DELIVERY_FILE_BYCAR_INFO;

// Send video and image files to video output, Used by car, The ad time si served separately
typedef struct tagNET_CTRL_DELIVERY_FILE_BYCAR
{
    DWORD                           dwSize;                             // struct size
    int                             nPort;                              // the port index
    EM_VIDEO_PLAY_MODE_TYPE         emPlayMode;                         // the play mode
    int                             nFileCount;                         // file count
    NET_DELIVERY_FILE_BYCAR_INFO    stuFileInfo[MAX_DELIVERY_FILE_NUM]; // array of file info
}NET_CTRL_DELIVERY_FILE_BYCAR;

// 
typedef enum tagNET_ACCESSCTLCARD_STATE
{
    NET_ACCESSCTLCARD_STATE_UNKNOWN = -1,
    NET_ACCESSCTLCARD_STATE_NORMAL = 0,                 // Normal
    NET_ACCESSCTLCARD_STATE_LOSE   = 0x01,              // Lose
    NET_ACCESSCTLCARD_STATE_LOGOFF = 0x02,              // Logoff
    NET_ACCESSCTLCARD_STATE_FREEZE = 0x04,              // Freeze
    NET_ACCESSCTLCARD_STATE_ARREARAGE = 0x08,           // Arrears
    NET_ACCESSCTLCARD_STATE_OVERDUE = 0x10,             // Overdue
    NET_ACCESSCTLCARD_STATE_PREARREARAGE = 0x20,        // Pre-Arrears(still can open the door)
}NET_ACCESSCTLCARD_STATE;

// Card Type 
typedef enum tagNET_ACCESSCTLCARD_TYPE
{
    NET_ACCESSCTLCARD_TYPE_UNKNOWN = -1,
    NET_ACCESSCTLCARD_TYPE_GENERAL,                     // General Card
    NET_ACCESSCTLCARD_TYPE_VIP,                         // VIP Card
    NET_ACCESSCTLCARD_TYPE_GUEST,                       // Guest Card
    NET_ACCESSCTLCARD_TYPE_PATROL,                      // Patrol Card
    NET_ACCESSCTLCARD_TYPE_BLACKLIST,                   // Blacklist Card
    NET_ACCESSCTLCARD_TYPE_CORCE,                       // Corce Card
    NET_ACCESSCTLCARD_TYPE_POLLING,                     // Polling Card
	NET_ACCESSCTLCARD_TYPE_GB_CUSTOM1,                  // Custom card 1
	NET_ACCESSCTLCARD_TYPE_GB_CUSTOM2,                  // Custom card 2
	NET_ACCESSCTLCARD_TYPE_TEMPORARY_PERSON = 0x09,		// temporary person, customized, unallowed to used by other project
	NET_ACCESSCTLCARD_TYPE_INVENTORY_PERSON,			// inventory person, customized, unallowed to used by other project
	NET_ACCESSCTLCARD_TYPE_INVENTORY_DIRECTOR,			// inventory director, customized, unallowed to used by other project
	NET_ACCESSCTLCARD_TYPE_SECURITY_GUARD,				// security guard, customized, unallowed to used by other project
	NET_ACCESSCTLCARD_TYPE_SECURITYGUARD_DIRECTOR,		// security guard director, customized, unallowed to used by other project
	NET_ACCESSCTLCARD_TYPE_STORE_KEEPER,				// store keeper, customized, unallowed to used by other project
	NET_ACCESSCTLCARD_TYPE_STORE_DIRECTOR,				// store director, customized, unallowed to used by other project
	NET_ACCESSCTLCARD_TYPE_ESCORT_PERSON,				// escort person, customized, unallowed to used by other project
	NET_ACCESSCTLCARD_TYPE_REPAIR_PERSON,				// repair person, customized, unallowed to used by other project
	NET_ACCESSCTLCARD_TYPE_INSPECTOR = 0x12,			// inspector, customized, unallowed to used by other project
    NET_ACCESSCTLCARD_TYPE_MOTHERCARD = 0xff,           // Mother Card
}NET_ACCESSCTLCARD_TYPE;

#define DH_MAX_DOOR_NUM               32                // Max Door Number 
#define DH_MAX_TIMESECTION_NUM        32                // Max Time Section Number
#define DH_MAX_CARDNAME_LEN           64                // access control naming max length
#define DH_MAX_CARDNO_LEN             32                // Max Card-Number Len
#define DH_MAX_USERID_LEN             32                // Max User ID Len
#define DH_MAX_IC_LEN                 32                // Max identify card len
#define DH_MAX_QRCODE_LEN             128               // Max QRCode len 

// fingerprint data, for sending only
typedef struct tagNET_ACCESSCTLCARD_FINGERPRINT_PACKET
{
    DWORD   dwSize;
    int     nLength;        // length of a finger print packet, unit: byte
    int     nCount;         // packet number 
    char*   pPacketData;    // all fingerprint packet in a single buffer, allocated and filled by user, nLength*nCount bytes
}NET_ACCESSCTLCARD_FINGERPRINT_PACKET;

// fingerprint data, for sending and receiving
typedef struct tagNET_ACCESSCTLCARD_FINGERPRINT_PACKET_EX
{
    int     nLength;        // length of a finger print packet, unit: byte
    int     nCount;         // packet number 
    char*   pPacketData;    // all fingerprint packet in a single buffer, allocated by user,the space application is over nLength * nCount
    int     nPacketLen;     // pPacketData buffer length, set by user
    int     nRealPacketLen; // The actual fingerprint size returned to the user, equal to nLength*nCount
    int     nDuressIndex;   // duress index of fingerprint group, range: 1~nCount
    BYTE    byReverseed[1020]; //Reserved size 
}NET_ACCESSCTLCARD_FINGERPRINT_PACKET_EX;

#define MAX_REPEATENTERROUTE_NUM   12 //max repeat enter route num 

// hat style
typedef enum tagEM_HAT_STYLE
{
	EM_HAT_UNKNOWN,									// unknown
	EM_HAT_ORDINARY,								// ordinary hat
	EM_HAT_HELMET,									// helmet
	EM_HAT_SAFETYHAT,								// safety hat
	EM_HAT_EAVELESS,								// eaveless hat
	EM_HAT_PEAKEDCAP,								// peakedcap
	EM_HAT_FISHERMANHAT,							// fisher man hat
	EM_HAT_NONE,									// no hat
} EM_HAT_STYLE;


// unified color type
typedef enum tagEM_UNIFIED_COLOR_TYPE
{
	EM_UNIFIED_COLOR_TRANSPARENT = -1,				// transparent
	EM_UNIFIED_COLOR_UNKNOWN,						// unknown
	EM_UNIFIED_COLOR_WHITE,							// white
	EM_UNIFIED_COLOR_ORANGE,						// orange
	EM_UNIFIED_COLOR_PINK,							// pink
	EM_UNIFIED_COLOR_BLACK,							// black
	EM_UNIFIED_COLOR_RED,							// red
	EM_UNIFIED_COLOR_YELLOW,						// yellow
	EM_UNIFIED_COLOR_GRAY,							// gray
	EM_UNIFIED_COLOR_BLUE,							// blue
	EM_UNIFIED_COLOR_GREEN,							// green
	EM_UNIFIED_COLOR_PURPLE,						// purple
	EM_UNIFIED_COLOR_BROWN,							// brown

}EM_UNIFIED_COLOR_TYPE;
// sex
typedef enum tagNET_ACCESSCTLCARD_SEX
{
    NET_ACCESSCTLCARD_SEX_UNKNOWN,
    NET_ACCESSCTLCARD_SEX_MALE,                           // male
    NET_ACCESSCTLCARD_SEX_FEMALE,                         // female    
}NET_ACCESSCTLCARD_SEX;

// user authority 
typedef enum tagNET_ACCESSCTLCARD_AUTHORITY
{
    NET_ACCESSCTLCARD_AUTHORITY_UNKNOWN,                  // unknown
    NET_ACCESSCTLCARD_AUTHORITY_ADMINISTRATORS,           // administrator
    NET_ACCESSCTLCARD_AUTHORITY_CUSTOMER,                 // customer      
}NET_ACCESSCTLCARD_AUTHORITY;

// Entrance Guard Record Information
typedef struct tagNET_RECORDSET_ACCESS_CTL_CARD
{
    DWORD           dwSize;
    int             nRecNo;                                 // Record Number,Read-Only
    NET_TIME        stuCreateTime;                          // Creat Time
    char            szCardNo[DH_MAX_CARDNO_LEN];            // Card number
    char            szUserID[DH_MAX_USERID_LEN];            // User's ID
    NET_ACCESSCTLCARD_STATE       emStatus;                 // Card Stetue
    NET_ACCESSCTLCARD_TYPE        emType;                   // Card Type
    char            szPsw[DH_MAX_CARDPWD_LEN];              // Card Password
    int             nDoorNum;                               // Valid Door Number;
    int             sznDoors[DH_MAX_DOOR_NUM];              // Privileged Door Number,That is CFG_CMD_ACCESS_EVENT Configure Array Subscript
    int             nTimeSectionNum;                        // the Number of Effective Open Time
    int             sznTimeSectionNo[DH_MAX_TIMESECTION_NUM];  // Open Time Segment Index,That is CFG_ACCESS_TIMESCHEDULE_INFO Array subscript
    int             nUserTime;                              // Frequency of Use
    NET_TIME        stuValidStartTime;                      // Valid Start Time 
    NET_TIME        stuValidEndTime;                        // Valid End Time
    BOOL            bIsValid;                               // Wether Valid,True =Valid,False=Invalid
    NET_ACCESSCTLCARD_FINGERPRINT_PACKET stuFingerPrintInfo;// fingerprint data info (send only), DEPRECATED! use stuFingerPrintInfoEx instead
    BOOL            bFirstEnter;                            // has first card or not
    char            szCardName[DH_MAX_CARDNAME_LEN];        // card naming
    char            szVTOPosition[DH_COMMON_STRING_64];     // VTO link position
    BOOL            bHandicap;                              // Card for handicap, TRUE:yes, FALSE:no
    BOOL            bEnableExtended;                        // Enabled member stuFingerPrintInfoEx
    NET_ACCESSCTLCARD_FINGERPRINT_PACKET_EX     stuFingerPrintInfoEx; // fingerprint data info structure   
    int             nFaceDataNum;                           // face detection data number,can not > 20
    char            szFaceData[MAX_FACE_DATA_NUM][MAX_FACE_DATA_LEN];// face detection data
    char            szDynamicCheckCode[MAX_COMMON_STRING_16];       // dynamic check code
    int             nRepeatEnterRouteNum;							// repeat enter route num 
    int             arRepeatEnterRoute[MAX_REPEATENTERROUTE_NUM];	// repeat enter route
    int             nRepeatEnterRouteTimeout;						// repeat enter route timeout
    BOOL            bNewDoor;										// enable to new field, TRUE: user nNewDoorNum,nNewDoors
    int             nNewDoorNum;									// Valid Door Number;
    int             nNewDoors[MAX_ACCESSDOOR_NUM];					// Privileged Door Number, That is CFG_CMD_ACCESS_EVENT Configure Array Subscript
    int             nNewTimeSectionNum;								// the Number of Effective Open Time
    int             nNewTimeSectionNo[MAX_ACCESSDOOR_NUM];			// Open Time Segment Index,That is CFG_ACCESS_TIMESCHEDULE_INFO Array subscript
    char            szCitizenIDNo[MAX_COMMON_STRING_32];			// ID card no
	int				nSpecialDaysScheduleNum;						// SpecialDaysSchedule Number
	int				arSpecialDaysSchedule[MAX_ACCESSDOOR_NUM];		// SpecialDaysSchedule Identification
    UINT            nUserType;                                      // user type, 0:common, 1:blacklist
    int             nFloorNum;                                              // floor number
    char            szFloorNo[MAX_ACCESS_FLOOR_NUM][DH_COMMON_STRING_4];   // floor
	char			szSection[MAX_COMMON_STRING_64];				// Section name
    int             nScore;                                         // credit score
    char            szCompanyName[MAX_COMPANY_NAME_LEN];            // company name
	UINT			nSectionID;										// Section ID
    NET_ACCESSCTLCARD_SEX        emSex;                             // sex
    char            szRole[MAX_COMMON_STRING_32];                   // Role
    char            szProjectNo[MAX_COMMON_STRING_32];              // project No.
    char            szProjectName[MAX_COMMON_STRING_64];            // project name
    char            szBuilderName[MAX_COMMON_STRING_64];            // builder name
    char            szBuilderID[MAX_COMMON_STRING_32];              // builder ID
    char            szBuilderType[MAX_COMMON_STRING_32];            // builder type
    char            szBuilderTypeID[MAX_COMMON_STRING_8];           // builder type ID
    char            szPictureID[MAX_COMMON_STRING_64];              // picture ID
    char            szContractID[MAX_COMMON_STRING_16];             // contract ID in original contract system
    char            szWorkerTypeID[MAX_COMMON_STRING_8];            // worker type ID
    char            szWorkerTypeName[MAX_COMMON_STRING_32];         // worker type name
    BOOL            bPersonStatus;                                  // person status, TRUE:enable, FALSE:forbidden
    NET_ACCESSCTLCARD_AUTHORITY   emAuthority;                      // user authority
    char			szCompanionName[120];							// name of companion
    char			szCompanionCompany[200];						// company of companion
	NET_TIME		stuTmpAuthBeginTime;							// temporary auth begin Time,high priority
	NET_TIME		stuTmpAuthEndTime;								// temporary auth end Time,high priority
	BOOL			bFloorNoExValid;								// is szFloorNoEx valid, TRUE:valid, else invalid
	int             nFloorNumEx;									// floor number extended
	char            szFloorNoEx[512][DH_COMMON_STRING_4];			// floor info
	char			szSubUserID[32];								// sub user id(customized)
}NET_RECORDSET_ACCESS_CTL_CARD;

// Entrance Guard Record  Information
typedef struct tagNET_RECORDSET_ACCESS_CTL_PWD 
{
    DWORD           dwSize;
    int             nRecNo;                                 // Record Number,Read-Only
    NET_TIME        stuCreateTime;                          // Create Time
    char            szUserID[DH_MAX_USERID_LEN];            // User's ID
    char            szDoorOpenPwd[DH_MAX_CARDPWD_LEN];      // Open Password
    char            szAlarmPwd[DH_MAX_CARDPWD_LEN];         // Alarm Password
    int             nDoorNum;                               // Valid Door Number
    int             sznDoors[DH_MAX_DOOR_NUM];              // Privileged Door Number,That is CFG_CMD_ACCESS_EVENT Configure Array Subscript
    char            szVTOPosition[DH_COMMON_STRING_64];     // VTO link position    
    int             nTimeSectionNum;                        // the Number of Effective Open Time
    int             nTimeSectionIndex[DH_MAX_TIMESECTION_NUM]; // Open Timesection Index array,each element corresponds to each element of sznDoors
    BOOL            bNewDoor;                               // enable to new field,TRUE: user nNewDoorNum,nNewDoors
    int             nNewDoorNum;                            // Valid Door Number;
    int             nNewDoors[MAX_ACCESSDOOR_NUM];          // Privileged Door Number,That is CFG_CMD_ACCESS_EVENT Configure Array Subscript
    int             nNewTimeSectionNum;                     // the Number of Effective Open Time
    int             nNewTimeSectionNo[MAX_ACCESSDOOR_NUM];  // Open Time Segment Index,That is CFG_ACCESS_TIMESCHEDULE_INFO Array subscript
    NET_TIME        stuValidStartTime;                      // Valid Start Time 
    NET_TIME        stuValidEndTime;                        // Valid End Time
	int				nValidCounts;							// Valid Counts
	char			szCitizenIDNo[20];						// Citizen Card ID
}NET_RECORDSET_ACCESS_CTL_PWD;


// Door Open Method(Entrance Guard Configure,One Way of Door Work )
typedef enum tagNET_DOOR_OPEN_METHOD
{
    NET_DOOR_OPEN_METHOD_UNKNOWN = 0,
    NET_DOOR_OPEN_METHOD_PWD_ONLY,                          // Password Open is Only
    NET_DOOR_OPEN_METHOD_CARD,                              // Card  open is Only
    NET_DOOR_OPEN_METHOD_PWD_OR_CARD,                       // Password or Card
    NET_DOOR_OPEN_METHOD_CARD_FIRST,                        // First Card then Password
    NET_DOOR_OPEN_METHOD_PWD_FIRST,                         // First Card then Password
    NET_DOOR_OPEN_METHOD_SECTION,                           // Sub-Periods
}NET_DOOR_OPEN_METHOD;

// Door Open Method(Entrance Guard Event,Entrance Guard get In/Out Record, Actual Open Door Method)
typedef enum tagNET_ACCESS_DOOROPEN_METHOD
{
    NET_ACCESS_DOOROPEN_METHOD_UNKNOWN = 0,
    NET_ACCESS_DOOROPEN_METHOD_PWD_ONLY,                    // Password
    NET_ACCESS_DOOROPEN_METHOD_CARD,                        // Card
    NET_ACCESS_DOOROPEN_METHOD_CARD_FIRST,                  // First Card Then Password
    NET_ACCESS_DOOROPEN_METHOD_PWD_FIRST,                   // First Password Then Card 
    NET_ACCESS_DOOROPEN_METHOD_REMOTE,                      // Long-Range Open,Such as Through theIndoor Unit or Unlock the Door Machine Platform
    NET_ACCESS_DOOROPEN_METHOD_BUTTON,                      // Open Door Button
    NET_ACCESS_DOOROPEN_METHOD_FINGERPRINT,                 // fingerprint lock
    NET_ACCESS_DOOROPEN_METHOD_PWD_CARD_FINGERPRINT,        // password+swipe card+fingerprint combination unlock
    NET_ACCESS_DOOROPEN_METHOD_PWD_FINGERPRINT = 10,        // password+fingerprint combination unlock
    NET_ACCESS_DOOROPEN_METHOD_CARD_FINGERPRINT = 11,       // swipe card+fingerprint combination unlock
    NET_ACCESS_DOOROPEN_METHOD_PERSONS = 12,                // multi-people unlock
    NET_ACCESS_DOOROPEN_METHOD_KEY = 13,                    // Key
    NET_ACCESS_DOOROPEN_METHOD_COERCE_PWD = 14,             // Use force password to open the door   
    NET_ACCESS_DOOROPEN_METHOD_QRCODE = 15,                 // Use QR Code  
    NET_ACCESS_DOOROPEN_METHOD_FACE_RECOGNITION = 16,       // face recogniton to open the door
    NET_ACCESS_DOOROPEN_METHOD_FACEIDCARD = 18,             // comparsion of face and ID card
    NET_ACCESS_DOOROPEN_METHOD_FACEIDCARD_AND_IDCARD = 19,	// ID card  and compasion of face and ID card
    NET_ACCESS_DOOROPEN_METHOD_BLUETOOTH = 20,				// Bluetooth
    NET_ACCESS_DOOROPEN_METHOD_CUSTOM_PASSWORD = 21,        // Custom password
    NET_ACCESS_DOOROPEN_METHOD_USERID_AND_PWD = 22,         // UserID and password
    NET_ACCESS_DOOROPEN_METHOD_FACE_AND_PWD = 23,           // Face and password
    NET_ACCESS_DOOROPEN_METHOD_FINGERPRINT_AND_PWD = 24,    // Fingerprint and password
    NET_ACCESS_DOOROPEN_METHOD_FINGERPRINT_AND_FACE = 25,   // FingerPrint and face
    NET_ACCESS_DOOROPEN_METHOD_CARD_AND_FACE = 26,          // Card and face
    NET_ACCESS_DOOROPEN_METHOD_FACE_OR_PWD = 27,            // Face or password
    NET_ACCESS_DOOROPEN_METHOD_FINGERPRINT_OR_PWD = 28,     // Fingerprint or password
    NET_ACCESS_DOOROPEN_METHOD_FINGERPRINT_OR_FACE = 29,    // Fingerprint or face
    NET_ACCESS_DOOROPEN_METHOD_CARD_OR_FACE = 30,           // Card or face
    NET_ACCESS_DOOROPEN_METHOD_CARD_OR_FINGERPRINT = 31,    // Card or fingerprint
    NET_ACCESS_DOOROPEN_METHOD_FINGERPRINT_AND_FACE_AND_PWD   = 32,             // Fingerprint and face and password
    NET_ACCESS_DOOROPEN_METHOD_CARD_AND_FACE_AND_PWD = 33,                      // Card and face and password
    NET_ACCESS_DOOROPEN_METHOD_CARD_AND_FINGERPRINT_AND_PWD = 34,               // Card and fingerprint and password
    NET_ACCESS_DOOROPEN_METHOD_CARD_AND_PWD_AND_FACE = 35,                      // Card and password and face
    NET_ACCESS_DOOROPEN_METHOD_FINGERPRINT_OR_FACE_OR_PWD = 36,                 // Fingerprint or face or password
    NET_ACCESS_DOOROPEN_METHOD_CARD_OR_FACE_OR_PWD = 37,                        // Card or face or password
    NET_ACCESS_DOOROPEN_METHOD_CARD_OR_FINGERPRINT_OR_FACE = 38,                // Card or fingerprint or face
    NET_ACCESS_DOOROPEN_METHOD_CARD_AND_FINGERPRINT_AND_FACE_AND_PWD = 39,      // Card and fingerprint and face and password 
    NET_ACCESS_DOOROPEN_METHOD_CARD_OR_FINGERPRINT_OR_FACE_OR_PWD     = 40,     // Card or fingerprint or face or password
    NET_ACCESS_DOOROPEN_METHOD_FACEIPCARDANDIDCARD_OR_CARD_OR_FACE    = 41,     // ID card  and compasion of face and ID card or card or face
    NET_ACCESS_DOOROPEN_METHOD_FACEIDCARD_OR_CARD_OR_FACE = 42,                 // ID card  and compasion of face or card or face
    NET_ACCESS_DOOROPEN_METHOD_DTMF = 43,					// DTMF unlock(include SIPINFO,RFC2833,INBAND)
	NET_ACCESS_DOOROPEN_METHOD_REMOTE_QRCODE = 44,			// remote QR code to open the door
	NET_ACCESS_DOOROPEN_METHOD_REMOTE_FACE = 45,			// remote face to open the door
	NET_ACCESS_DOOROPEN_METHOD_CITIZEN_FINGERPRINT = 46,		// Citizen picture(fingerprint)
}NET_ACCESS_DOOROPEN_METHOD;

//attendance state
typedef enum tagNET_ATTENDANCESTATE
{
    NET_ATTENDANCESTATE_UNKNOWN,
    NET_ATTENDANCESTATE_SIGNIN,
    NET_ATTENDANCESTATE_GOOUT,
    NET_ATTENDANCESTATE_GOOUT_AND_RETRUN,
    NET_ATTENDANCESTATE_SIGNOUT,
    NET_ATTENDANCESTATE_WORK_OVERTIME_SIGNIN,
    NET_ATTENDANCESTATE_WORK_OVERTIME_SIGNOUT,
}NET_ATTENDANCESTATE;

// Access Control open door Direction
typedef enum tagNET_ENUM_DIRECTION_ACCESS_CTL
{
    NET_ENUM_DIRECTION_UNKNOWN,
    NET_ENUM_DIRECTION_ENTRY,                              // entry             
    NET_ENUM_DIRECTION_EXIT,                               // exit
}NET_ENUM_DIRECTION_ACCESS_CTL;
//Ethnicity
typedef enum tagEM_CITIZENIDCARD_ETHNICITY_TYPE
{
	EM_CITIZENIDCARD_ETHNICITY_Unknown = 0,				// Known
	EM_CITIZENIDCARD_ETHNICITY_Han,						// Han
	EM_CITIZENIDCARD_ETHNICITY_Mongolian,				// Mongolian
	EM_CITIZENIDCARD_ETHNICITY_Hui,						// Hui
	EM_CITIZENIDCARD_ETHNICITY_Tibetan,					// Tibetan
	EM_CITIZENIDCARD_ETHNICITY_Uygur,					// Uygur
	EM_CITIZENIDCARD_ETHNICITY_Miao,					// Miao
	EM_CITIZENIDCARD_ETHNICITY_Yi,						// Yi
	EM_CITIZENIDCARD_ETHNICITY_Zhuang,					// Zhuang
	EM_CITIZENIDCARD_ETHNICITY_Bouyei,					// Bouyei
	EM_CITIZENIDCARD_ETHNICITY_Korean,					// Korean
	EM_CITIZENIDCARD_ETHNICITY_Manchu,					// Manchu
	EM_CITIZENIDCARD_ETHNICITY_Dong,					// Dong
	EM_CITIZENIDCARD_ETHNICITY_Yao,						// Yao
	EM_CITIZENIDCARD_ETHNICITY_Bai,						// Bai
	EM_CITIZENIDCARD_ETHNICITY_Tujia,					// Tujia
	EM_CITIZENIDCARD_ETHNICITY_Hani,					// Hani
	EM_CITIZENIDCARD_ETHNICITY_Kazak,					// Kazak
	EM_CITIZENIDCARD_ETHNICITY_Dai,						// Dai
	EM_CITIZENIDCARD_ETHNICITY_Li,						// Li
	EM_CITIZENIDCARD_ETHNICITY_Lisu,					// Lisu
	EM_CITIZENIDCARD_ETHNICITY_Va,						// Va
	EM_CITIZENIDCARD_ETHNICITY_She,						// She
	EM_CITIZENIDCARD_ETHNICITY_Gaoshan,					// Gaoshan
	EM_CITIZENIDCARD_ETHNICITY_Lahu,					// Lahu
	EM_CITIZENIDCARD_ETHNICITY_Shui,					// Shui
	EM_CITIZENIDCARD_ETHNICITY_Dongxiang,				// Dongxiang
	EM_CITIZENIDCARD_ETHNICITY_Naxi,					// Naxi
	EM_CITIZENIDCARD_ETHNICITY_Jingpo,					// Jingpo
	EM_CITIZENIDCARD_ETHNICITY_Kirgiz,					// Kirgiz
	EM_CITIZENIDCARD_ETHNICITY_Tu,						// Tu
	EM_CITIZENIDCARD_ETHNICITY_Daur,					// Daur
	EM_CITIZENIDCARD_ETHNICITY_Mulam,					// Mulam
	EM_CITIZENIDCARD_ETHNICITY_Qoiang,					// Qoiang
	EM_CITIZENIDCARD_ETHNICITY_Blang,					// Blang
	EM_CITIZENIDCARD_ETHNICITY_Salar,					// Salar
	EM_CITIZENIDCARD_ETHNICITY_Maonan,					// Maonan
	EM_CITIZENIDCARD_ETHNICITY_Gelo,					// Gelo
	EM_CITIZENIDCARD_ETHNICITY_Xibe,					// Xibe
	EM_CITIZENIDCARD_ETHNICITY_Achang,					// Achang
	EM_CITIZENIDCARD_ETHNICITY_Pumi,					// Pumi
	EM_CITIZENIDCARD_ETHNICITY_Tajik,					// Tajik
	EM_CITIZENIDCARD_ETHNICITY_Nu,						// Nu
	EM_CITIZENIDCARD_ETHNICITY_Ozbek,					// Ozbek
	EM_CITIZENIDCARD_ETHNICITY_Russian,					// Russian
	EM_CITIZENIDCARD_ETHNICITY_Ewenkl,					// Ewenkl
	EM_CITIZENIDCARD_ETHNICITY_Deang,					// Deang
	EM_CITIZENIDCARD_ETHNICITY_Bonan,					// Bonan
	EM_CITIZENIDCARD_ETHNICITY_Yugur,					// Yugur
	EM_CITIZENIDCARD_ETHNICITY_Jing,					// Jing
	EM_CITIZENIDCARD_ETHNICITY_Tatar,					// Tatar
	EM_CITIZENIDCARD_ETHNICITY_Drung,					// Drung
	EM_CITIZENIDCARD_ETHNICITY_Oroqen,					// Oroqen
	EM_CITIZENIDCARD_ETHNICITY_Hezhen,					// Hezhen
	EM_CITIZENIDCARD_ETHNICITY_Moinba,					// Moinba
	EM_CITIZENIDCARD_ETHNICITY_Lhoba,					// Lhoba
	EM_CITIZENIDCARD_ETHNICITY_Jino						// Jino	
}EM_CITIZENIDCARD_ETHNICITY_TYPE;

//Citizen sex type
typedef enum tagEM_CITIZENIDCARD_SEX_TYPE
{
	EM_CITIZENIDCARD_SEX_TYPE_UNKNOWN,          // 
	EM_CITIZENIDCARD_SEX_TYPE_MALE,             // 
	EM_CITIZENIDCARD_SEX_TYPE_FEMALE,           // 
	EM_CITIZENIDCARD_SEX_TYPE_UNTOLD,           // 
}EM_CITIZENIDCARD_SEX_TYPE;

// Access Control card Record Information
typedef struct tagNET_RECORDSET_ACCESS_CTL_CARDREC
{
    DWORD           dwSize;
    int             nRecNo;                                 // Record Number,Read-Only
    char            szCardNo[DH_MAX_CARDNO_LEN];            // Card Number
    char            szPwd[DH_MAX_CARDPWD_LEN];              // Password
    NET_TIME        stuTime;                                // Swing Card Time
    BOOL            bStatus;                                // Swing Card Result,True is Success,False is Fail
    NET_ACCESS_DOOROPEN_METHOD    emMethod;                 // Open Door Method
    int             nDoor;                                  // Door Number,That is CFG_CMD_ACCESS_EVENT Configure Array Subscript 
    char            szUserID[DH_MAX_USERID_LEN];            // user ID
    int             nReaderID;                              // card reader ID (abandoned)
    char            szSnapFtpUrl[MAX_PATH];                 // unlock snap upload ftp url
    char            szReaderID[DH_COMMON_STRING_32];        // card reader ID
    NET_ACCESSCTLCARD_TYPE      emCardType;                         // Card Type
    int                         nErrorCode;                         // Reason of unlock failure, only because it is valid when bStatus is FALSE
                                                                    // 0x00 no error
                                                                    // 0x10 unauthorized
                                                                    // 0x11 card lost or cancelled
                                                                    // 0x12 no door right
                                                                    // 0x13 unlock mode error
                                                                    // 0x14 valid period error
                                                                    // 0x15 anti sneak into mode
                                                                    // 0x16 forced alarm not unlocked
                                                                    // 0x17 door NC status
                                                                    // 0x18 AB lock status
                                                                    // 0x19 patrol card
                                                                    // 0x1A device is under intrusion alarm status
                                                                    // 0x20 period error
                                                                    // 0x21 unlock period error in holiday period
                                                                    // 0x30 first card right check required
                                                                    // 0x40 card correct, input password error
                                                                    // 0x41 card correct, input password timed out
                                                                    // 0x42 card correct, input fingerprint error
                                                                    // 0x43 card correct, input fingerprint timed out
                                                                    // 0x44 fingerprint correct, input password error
                                                                    // 0x45 fingerprint correct, input password timed out
                                                                    // 0x50 group unlock sequence error
                                                                    // 0x51 test required for group unlock
                                                                    // 0x60 test passed, control unauthorized
                                                                    // 0x61 card correct, input face error
                                                                    // 0x62 card correct, input face timed out
                                                                    // 0x63 repeat enter
                                                                    // 0x64 unauthorized, requiring back-end platform identification


    char           szRecordURL[MAX_COMMON_STRING_128];              // record url
    int            nNumbers;                                        // snap picture numbers
    NET_ATTENDANCESTATE         emAttendanceState;                  // attendance state 
    NET_ENUM_DIRECTION_ACCESS_CTL   emDirection;                    // open door direction
	char						szClassNumber[MAX_CLASS_NUMBER_LEN];	// Class number(Kenya custom)
	char						szPhoneNumber[MAX_PHONENUMBER_LEN];		// Phone number(Kenya custom)
	char						szCardName[DH_MAX_CARDNAME_LEN];		// Card name
    char                        szSN[DH_COMMON_STRING_32];              // wireless device serial number

	BOOL						bCitizenIDResult;							// Compare result
	char						szCitizenIDName[30];						// Name
	BYTE						byReserved1[2];								// Align
	EM_CITIZENIDCARD_SEX_TYPE			emCitizenIDSex;						// Sex
	EM_CITIZENIDCARD_ETHNICITY_TYPE		emCitizenIDEthnicity;				// Ethnicity
	NET_TIME					stuCitizenIDBirth;						// Birth date
	char						szCitizenIDAddress[108];					// Address
	char						szCitizenIDAuthority[48];					// Authority
	NET_TIME					stuCitizenIDStart;						// Start time
	NET_TIME					stuCitizenIDEnd;							// End time
	BOOL						bIsEndless;									// Is end time unlimited
	char						szSnapFaceURL[DH_COMMON_STRING_128];		// Face picture URL
	char						szCitizenPictureURL[DH_COMMON_STRING_128];	// Citizen picture URL
	char						szCitizenIDNo[20];							// Citizen card number
    NET_ACCESSCTLCARD_SEX       emSex;                                      // sex
    char                        szRole[MAX_COMMON_STRING_32];               // role
    char                        szProjectNo[MAX_COMMON_STRING_32];          // project No.
    char                        szProjectName[MAX_COMMON_STRING_64];        // project name
    char                        szBuilderName[MAX_COMMON_STRING_64];        // builder name
    char                        szBuilderID[MAX_COMMON_STRING_32];          // builder ID
    char                        szBuilderType[MAX_COMMON_STRING_32];        // builder type
    char                        szBuilderTypeID[MAX_COMMON_STRING_8];       // builder type ID
    char                        szPictureID[MAX_COMMON_STRING_64];          // picture ID
    char                        szContractID[MAX_COMMON_STRING_16];         // contract ID in original contract system
    char                        szWorkerTypeID[MAX_COMMON_STRING_8];        // worker type ID
    char                        szWorkerTypeName[MAX_COMMON_STRING_32];     // worker type name
    BOOL                        bPersonStatus;                              // person status, TRUE:enable, FALSE:forbidden
	EM_HAT_STYLE				emHatStyle;									// hat style
	EM_UNIFIED_COLOR_TYPE		emHatColor;									// hat color
}NET_RECORDSET_ACCESS_CTL_CARDREC;

// Holiday Record Iinformation
typedef struct tagNET_RECORDSET_HOLIDAY
{
    DWORD           dwSize;
    int             nRecNo;                                 // Record Number,Read-Only
    int             nDoorNum;                               // Valid Door Number    
    int             sznDoors[DH_MAX_DOOR_NUM];              // Privileged Door Number,That is CFG_CMD_ACCESS_EVENT Configure Array Subscript
    NET_TIME        stuStartTime;                           // Start Time
    NET_TIME        stuEndTime;                             // End Time
    BOOL            bEnable;                                // Holiday Enable
    char            szHolidayNo[DH_COMMON_STRING_32];       // Holiday No
    char            szHolidayName[DH_COMMON_STRING_128];    // Holiday Name
}NET_RECORDSET_HOLIDAY;

// card province
typedef enum tagEM_CARD_PROVINCE
{
    EM_CARD_UNKNOWN            = 10,        // UNKNOWN
    EM_CARD_BEIJING            = 11,        // BeiJing
    EM_CARD_TIANJIN            = 12,        // TianJin
    EM_CARD_HEBEI              = 13,        // HeBei
    EM_CARD_SHANXI_TAIYUAN     = 14,        // ShanXi, the provincial capital is TaiYuan
    EM_CARD_NEIMENGGU          = 15,        // NeiMengGu
    EM_CARD_LIAONING           = 21,        // LiaoNing
    EM_CARD_JILIN              = 22,        // JiKin
    EM_CARD_HEILONGJIANG       = 23,        // HeiLongJiang
    EM_CARD_SHANGHAI           = 31,        // ShangHai
    EM_CARD_JIANGSU            = 32,        // JiangSu
    EM_CARD_ZHEJIANG           = 33,        // ZheJiang
    EM_CARD_ANHUI              = 34,        // AnHui 
    EM_CARD_FUJIAN             = 35,        // FuJian
    EM_CARD_JIANGXI            = 36,        // JiangXi
    EM_CARD_SHANDONG           = 37,        // ShanDong 
    EM_CARD_HENAN              = 41,        // HeNan
    EM_CARD_HUBEI              = 42,        // HuBei
    EM_CARD_HUNAN              = 43,        // HuNan
    EM_CARD_GUANGDONG          = 44,        // GuangDong
    EM_CARD_GUANGXI            = 45,        // GuangXi
    EM_CARD_HAINAN             = 46,        // HaiNan
    EM_CARD_CHONGQING          = 50,        // ChongQing
    EM_CARD_SICHUAN            = 51,        // SiChuan
    EM_CARD_GUIZHOU            = 52,        // GuiZhou
    EM_CARD_YUNNAN             = 53,        // YunNan
    EM_CARD_XIZANG             = 54,        // XiZang
    EM_CARD_SHANXI_XIAN        = 61,        // ShanXi , the provincial capital is XiAn
    EM_CARD_GANSU              = 62,        // GanSu
    EM_CARD_QINGHAI            = 63,        // QingHai
    EM_CARD_NINGXIA            = 64,        // NingXia
    EM_CARD_XINJIANG           = 65,        // XinJiang
    EM_CARD_XIANGGANG          = 71,        // XiangGang
    EM_CARD_AOMEN              = 82,        // AoMen
} EM_CARD_PROVINCE;

// the type of the car
typedef enum tagEM_CAR_TYPE
{
	EM_CAR_0,
	EM_CAR_1,
	EM_CAR_2,
	EM_CAR_3,
	EM_CAR_4,
	EM_CAR_5,
	EM_CAR_6,
	EM_CAR_7,
	EM_CAR_8,
	EM_CAR_9,
	EM_CAR_10,
	EM_CAR_11,
	EM_CAR_12,
	EM_CAR_13,
	EM_CAR_14,
	EM_CAR_15,
	EM_CAR_16,
	EM_CAR_17,
	EM_CAR_18,
	EM_CAR_19,
	EM_CAR_20,
	EM_CAR_21,
	EM_CAR_22,
	EM_CAR_23,
	EM_CAR_24,
	EM_CAR_25,
	EM_CAR_26,
	EM_CAR_27,
	EM_CAR_28,
	EM_CAR_29,
	EM_CAR_30,
	EM_CAR_31,
	EM_CAR_32,
	EM_CAR_33,
	EM_CAR_34,
	EM_CAR_35,
	EM_CAR_36,
	EM_CAR_37,
	EM_CAR_38,
	EM_CAR_39,
	EM_CAR_40,
	EM_CAR_41,
	EM_CAR_42,
	EM_CAR_43,
	EM_CAR_44,
	EM_CAR_45,
	EM_CAR_46,
	EM_CAR_47,
	EM_CAR_48,
	EM_CAR_49,
	EM_CAR_50,
	EM_CAR_51,
	EM_CAR_52,
	EM_CAR_53,
	EM_CAR_54,
	EM_CAR_55,
	EM_CAR_56,
	EM_CAR_57,
	EM_CAR_58,
	EM_CAR_59,
	EM_CAR_60,
	EM_CAR_61,
	EM_CAR_62,
	EM_CAR_63,
	EM_CAR_64,
	EM_CAR_65,
	EM_CAR_66,
	EM_CAR_67,
	EM_CAR_68,
	EM_CAR_69,
	EM_CAR_70,
	EM_CAR_71,
	EM_CAR_72,
	EM_CAR_73,
	EM_CAR_74,
	EM_CAR_75,
	EM_CAR_76,
	EM_CAR_77,
	EM_CAR_78,
	EM_CAR_79,
	EM_CAR_80,
	EM_CAR_81,
	EM_CAR_82,
	EM_CAR_83,
	EM_CAR_84,
	EM_CAR_85,
	EM_CAR_86,
	EM_CAR_87,
	EM_CAR_88,
	EM_CAR_89,
	EM_CAR_90,
	EM_CAR_91,
	EM_CAR_92,
	EM_CAR_93,
	EM_CAR_94,
	EM_CAR_95,
	EM_CAR_96,
	EM_CAR_97,
	EM_CAR_98,
	EM_CAR_99,
	EM_CAR_100,
	EM_CAR_101,
	EM_CAR_102,
	EM_CAR_103,
	EM_CAR_104,
	EM_CAR_105,
	EM_CAR_106,
	EM_CAR_107,
	EM_CAR_108,
	EM_CAR_109,
	EM_CAR_110,
	EM_CAR_111,
	EM_CAR_112,
	EM_CAR_113,
	EM_CAR_114,
	EM_CAR_115,
	EM_CAR_116,
	EM_CAR_117,
	EM_CAR_118,
	EM_CAR_119,
	EM_CAR_120,
	EM_CAR_121,
	EM_CAR_122,
	EM_CAR_123,
	EM_CAR_124,
	EM_CAR_125,
	EM_CAR_126,
	EM_CAR_127,
	EM_CAR_128,
	EM_CAR_129,
	EM_CAR_130,
	EM_CAR_131,
	EM_CAR_132,
	EM_CAR_133,
	EM_CAR_134,
	EM_CAR_135,
	EM_CAR_136,
	EM_CAR_137,
	EM_CAR_138,
	EM_CAR_139,
	EM_CAR_140,
	EM_CAR_141,
	EM_CAR_142,
	EM_CAR_143,
	EM_CAR_144,
	EM_CAR_145,
	EM_CAR_146,
	EM_CAR_147,
	EM_CAR_148,
	EM_CAR_149,
	EM_CAR_150,
	EM_CAR_151,
	EM_CAR_152,
	EM_CAR_153,
	EM_CAR_154,
	EM_CAR_155,
	EM_CAR_156,
	EM_CAR_157,
	EM_CAR_158,
	EM_CAR_159,
	EM_CAR_160,
	EM_CAR_161,
	EM_CAR_162,
	EM_CAR_163,
	EM_CAR_164,
	EM_CAR_165,
	EM_CAR_166,
	EM_CAR_167,
	EM_CAR_168,
	EM_CAR_169,
	EM_CAR_170,
	EM_CAR_171,
	EM_CAR_172,
	EM_CAR_173,
	EM_CAR_174,
	EM_CAR_175,
	EM_CAR_176,
	EM_CAR_177,
	EM_CAR_178,
	EM_CAR_179,
	EM_CAR_180,
	EM_CAR_181,
	EM_CAR_182,
	EM_CAR_183,
	EM_CAR_184,
	EM_CAR_185,
	EM_CAR_186,
	EM_CAR_187,
	EM_CAR_188,
	EM_CAR_189,
	EM_CAR_190,
	EM_CAR_191,
	EM_CAR_192,
	EM_CAR_193,
	EM_CAR_194,
	EM_CAR_195,
	EM_CAR_196,
	EM_CAR_197,
	EM_CAR_198,
	EM_CAR_199,
	EM_CAR_200,
	EM_CAR_201,
	EM_CAR_202,
	EM_CAR_203,
	EM_CAR_204,
	EM_CAR_205,
	EM_CAR_206,
	EM_CAR_207,
	EM_CAR_208,
	EM_CAR_209,
	EM_CAR_210,
	EM_CAR_211,
	EM_CAR_212,
	EM_CAR_213,
	EM_CAR_214,
	EM_CAR_215,
	EM_CAR_216,
	EM_CAR_217,
	EM_CAR_218,
	EM_CAR_219,
	EM_CAR_220,
	EM_CAR_221,
	EM_CAR_222,
	EM_CAR_223,
	EM_CAR_224,
	EM_CAR_225,
	EM_CAR_226,
	EM_CAR_227,
	EM_CAR_228,
	EM_CAR_229,
	EM_CAR_230,
} EM_CAR_TYPE;

// the tpye of the plate
typedef enum tagEM_PLATE_TYPE
{
	EM_PLATE_OTHER,					// Other
	EM_PLATE_BIG_CAR,				// big car
	EM_PLATE_SMALL_CAR,				// small car 
	EM_PLATE_EMBASSY_CAR,			// embassy car
	EM_PLATE_CONSULATE_CAR,			// consulate car
	EM_PLATE_ABROAD_CAR,			// abroad car
	EM_PLATE_FOREIGN_CAR,			// foreign car
	EM_PLATE_LOW_SPEED_CAR,			// Low speed car
	EM_PLATE_COACH_CAR,				// coach car plate
	EM_PLATE_MOTORCYCLE,			// motorcycle plate
	EM_PLATE_NEW_POWER_CAR,			// new power car
	EM_PLATE_POLICE_CAR,			// police car
	EM_PLATE_HONGKONG_MACAO_CAR,	// Hongkong Macao car 
	EM_PLATE_ARMEDPOLICE_CAR,		// Armed police car
	EM_PLATE_MILITARY_CAR,			// Military vehicles
	EM_PLATE_TEMPORARY_LICENSE_FOR_NON_MOTOR_VEHICLES,	  // Temporary license for non motor vehicles
	EM_PLATE_OFFICIAL_LICENSE_PLATE_FOR_NON_MOTOR_VEHICLE, // Official license plate of non motor vehicle
} EM_PLATE_TYPE;

// car color
typedef enum tagEM_CAR_COLOR_TYPE
{
	EM_CAR_COLOR_WHITE,				// white
	EM_CAR_COLOR_BLACK,				// black
	EM_CAR_COLOR_RED,				// red
	EM_CAR_COLOR_YELLOW,			// yellow
	EM_CAR_COLOR_GRAY,				// gray
	EM_CAR_COLOR_BLUE,				// blue
	EM_CAR_COLOR_GREEN,				// green
	EM_CAR_COLOR_PINK,				// pink
	EM_CAR_COLOR_PURPLE,			// purple
	EM_CAR_COLOR_DARK_PURPLE,		// dark purple
	EM_CAR_COLOR_BROWN,				// brown
	EM_CAR_COLOR_MAROON,			// marron
	EM_CAR_COLOR_SILVER_GRAY,		// silver gray
	EM_CAR_COLOR_DARK_GRAY,			// dark gray
	EM_CAR_COLOR_WHITE_SMOKE,		// white smoke
	EM_CAR_COLOR_DEEP_ORANGE,		// deep orange
	EM_CAR_COLOR_LIGHT_ROSE,		// light rose
	EM_CAR_COLOR_TOMATO_RED,		// tomato red
	EM_CAR_COLOR_OLIVE,				// olive
	EM_CAR_COLOR_GOLDEN,			// golden
	EM_CAR_COLOR_DARK_OLIVE,		// dark olive
	EM_CAR_COLOR_YELLOW_GREEN,		// yellow green
	EM_CAR_COLOR_GREEN_YELLOW,		// green yellow
	EM_CAR_COLOR_FOREST_GREEN,		// forest green
	EM_CAR_COLOR_OCEAN_BLUE,		// ocean blue
	EM_CAR_COLOR_DEEP_SKYBLUE,		// deep sky blue
	EM_CAR_COLOR_CYAN,				// cyan
	EM_CAR_COLOR_DEEP_BLUE,			// deep blue
	EM_CAR_COLOR_DEEP_RED,			// deep red
	EM_CAR_COLOR_DEEP_GREEN,		// deep green
	EM_CAR_COLOR_DEEP_YELLOW,		// deep yellow
	EM_CAR_COLOR_DEEP_PINK,			// deep pink
	EM_CAR_COLOR_DEEP_PURPLE,		// deep purple
	EM_CAR_COLOR_DEEP_BROWN,		// deep brown
	EM_CAR_COLOR_DEEP_CYAN,			// deep cyan
	EM_CAR_COLOR_ORANGE,			// orange
	EM_CAR_COLOR_DEEP_GOLDEN,		// deep golden
	EM_CAR_COLOR_OTHER	= 255,		// other
} EM_CAR_COLOR_TYPE;

// use property
typedef enum tagEM_USE_PROPERTY_TYPE
{
	EM_USE_PROPERTY_NONOPERATING,			// not operating
	EM_USE_PROPERTY_HIGWAY,					// higway,tourist
	EM_USE_PROPERTY_BUS,					// bus
	EM_USE_PROPERTY_TAXI,					// taxi
	EM_USE_PROPERTY_FREIGHT,				// freight
	EM_USE_PROPERTY_LEASE,					// lease
	EM_USE_PROPERTY_SECURITY,				// for police,for fire police,for rescue or engineering emergency
	EM_USE_PROPERTY_COACH,					// for coach
	EM_USE_PROPERTY_SCHOOLBUS,				// kindergarten school bus,pupil school bus,other school bus
	EM_USE_PROPERTY_FOR_DANGE_VEHICLE,		// for dangerous goods transportation
	EM_USE_PROPERTY_OTHER,					// Other
	EM_USE_PROPERTY_ONLINE_CAR_HAILING,		// Online car-hailing
	EM_USE_PROPERTY_NON_MOTORIZED_TAKE_OUT_VEHICLE,	// Non motorized take out vehicle
	EM_USE_PROPERTY_NON_MOTORIZED_EXPRESS_CAR,		// Non motorized express car
} EM_USE_PROPERTY_TYPE;

// the info of RFID electronic tag 
typedef struct tagNET_RFIDELETAG_INFO
{
	BYTE					szCardID[MAX_RFIDELETAG_CARDID_LEN];			// card ID
	int						nCardType;										// card type, 0:issued by transport administration offices, 1:new factory preloaded card
	EM_CARD_PROVINCE		emCardPrivince;									// card privince
	char					szPlateNumber[DH_MAX_PLATE_NUMBER_LEN];			// plate number
	char					szProductionDate[MAX_RFIDELETAG_DATE_LEN];		// production data
	EM_CAR_TYPE				emCarType;										// car type
	int						nPower;											// power, unit:kilowatt-hour, range:0~254, 255 means larger than maximum power value can be stored
	int						nDisplacement;									// displacement, unit:100ml, range:0~254, 255 means larger than maximum displacement value can be stored
	int						nAntennaID;										// antenna ID, range:1~4
	EM_PLATE_TYPE			emPlateType;									// plate type
	char					szInspectionValidity[MAX_RFIDELETAG_DATE_LEN];	// validity of inspection, year-month
	int						nInspectionFlag;								// the flag of inspetion, 0:already inspection, 1:not inspection
	int						nMandatoryRetirement;							// the years form effective inspection preiod to compulsory discarding preiod
	EM_CAR_COLOR_TYPE		emCarColor;										// car color
	int						nApprovedCapacity;								// authorized capacity, unit:people, <0:incalid
	int						nApprovedTotalQuality;							// total weight, unit:100kg, range:0~0x3FF,  0x3FF1023:larger than maximum value can be stored, <0:invalid
	NET_TIME_EX				stuThroughTime;									// the time when the car is pass
	EM_USE_PROPERTY_TYPE	emUseProperty;									// use property
	char					szPlateCode[MAX_COMMON_STRING_8];				// Licensing code, UTF-8 encoding
	char					szPlateSN[MAX_COMMON_STRING_16];				// Plate number, serial number, UTF-8 code
	char					szTID[MAX_COMMON_STRING_64];					// Label (Unique identifier), UTF-8 encoding
	BYTE               		bReserved[40];                      			// Reserved bytes
} NET_RFIDELETAG_INFO;

// electronic tag record info
typedef struct tagNET_RECORD_ELECTRONICSTAG_INFO
{
	DWORD					dwSize;							// Structure size 
	int						nRecNo;							// Read set SN. Read-only. 
	BOOL					bMatch;							// whether the picture has been matched
	UINT					unDevID;						// device ID, from 0
	NET_RFIDELETAG_INFO		stuEleTagInfo;					// RFID electronic tag info
} NET_RECORD_ELECTRONICSTAG_INFO;

// GPS position record set info 
typedef struct tagNET_RECORD_GPS_LOCATION_INFO
{
    DWORD           dwSize;                                 // Structure size 
    int             nRecNo;                                 // Read set SN. Read-only. 
    double          dLongitude;                             // GPS longitude. Unit is degree
    double          dLatitude;                              // GPS latitude. Unit is degree. 
    char            szPlaceName[128];                       // GPS coordinates name 
    char            szRadius[16];                           // Radius
} NET_RECORD_GPS_LOCATION_INFO;

// resident record info
typedef struct tagNET_RECORD_RESIDENT_INFO
{
    DWORD           dwSize;                                 // Structure size
    int             nRecNo;                                 // Read set SN. Read-only
    char            szResidentName[DH_MAX_USERID_LEN];      // user name
    char            szCardNo[DH_MAX_CARDNO_LEN];            // card number
    NET_TIME        stuStartTime;                           // start time of available
    NET_TIME        stuEndTime;                             // end time of available    
    char 			szICNum[DH_MAX_IC_LEN];					// Identify Card
}NET_RECORD_RESIDENT_INFO;

//Sensor record information
typedef struct tagNET_RECORD_SENSOR_RECORD
{
	DWORD						dwSize;                     // Structure size
	UINT						uRecNo;                     // Record Number,Read-Only
	NET_TIME					stuTime;					// Acquisition time, field is time
	UINT						uDeviceID;                  // Acquisition device ID, High 8 bits mean instrument type,low 24 bits mean the instrument serial number in the group.For example:0-electricity,1-analog sensor.
	BYTE						byStatus;                   // Data status,0:normal,1:abnormal.
	BYTE						byExceptionCode;            // abnormal data status mask,associated with specific instrument.Valid by Status is 1.
															// When instrument type is electricity, bit0 means under voltage, bit1 means over voltage, bit2 means under current, 
															// bit3 means over current, bit4 means invalid(this state is not set with other state at the same time)
	BYTE						bySwitchOn;					// switch is on or off, 0:off,1:on
	BYTE						byReserved;                 // reserve
	int							nPowerVoltage;              // Power voltage, unit:mV
	int							nPowerCurrent;              // Power current, unit:mA
	int							nPowerValue;				// Power value, unit:mW
	BYTE						byReservedSpace[4];         // reserve
	double						dActualValue;				// analogue use,variable,associated with specific analog instrument.
	char						szName[128];				// instrument name
	NET_SENSE_METHOD			emSenseMethod;				// SenseMethod, refer to the specific enumeration definition.
	EM_SENSE_METHOD_UNIT		emUnit;						// unit, it is associated with emSenseMethod.
}NET_RECORD_SENSOR_RECORD;

//AccessQRCode information
typedef struct tagNET_RECORD_ACCESSQRCODE_INFO
{
	DWORD                       dwSize;                                 // Structure size
	int                         nRecNo;                                 // Record Number,Read-Only
	char                        szQRCode[DH_MAX_QRCODE_LEN];            // QRCode
	UINT						nLeftTimes;                             // left times
	NET_TIME        			stuStartTime;                           // start time of available
    NET_TIME        			stuEndTime;                             // end time of available 
    char                        szRoomNumber[16];                       // room number
}NET_RECORD_ACCESSQRCODE_INFO;

//Access blue tooth information
typedef struct tagNET_RECORD_ACCESS_BLUETOOTH_INFO
{
    DWORD                       dwSize;                                 // Structure size
    int                         nRecNo;                                 // Record Number,Read-Only
    char						szUserName[DH_COMMON_STRING_128];       // User name
    char						szPassword[DH_COMMON_STRING_128];       // Password
    char        			    szMac[DH_COMMON_STRING_32];             // Mac addr
    char        			    szNote[DH_COMMON_STRING_128];           // User note info
}NET_RECORD_ACCESS_BLUETOOTH_INFO;

// the condition of query bluetooth accsess info 
typedef struct tagFIND_RECORD_ACCESS_BLUETOOTH_INFO_CONDITION
{
    DWORD					dwSize;
    char					szUserName[DH_COMMON_STRING_128];           // user name
} FIND_RECORD_ACCESS_BLUETOOTH_INFO_CONDITION;

// alarm type
typedef enum tagEM_RECORD_ACCESS_ALARM_TYPE
{
    EM_RECORD_ACCESS_ALARM_TYPE_UNKNOWN,                                // unknown
    EM_RECORD_ACCESS_ALARM_TYPE_DOOR_NOTCLOSE,                          // door not close
    EM_RECORD_ACCESS_ALARM_TYPE_BREAK_IN,                               // break in
    EM_RECORD_ACCESS_ALARM_TYPE_REPEAT_ENTER,                           // repeat enter
    EM_RECORD_ACCESS_ALARM_TYPE_DURESS,                                 // duress
    EM_RECORD_ACCESS_ALARM_TYPE_ALARMLOCAL,                             // alarmlocal
    EM_RECORD_ACCESS_ALARM_TYPE_CHASSIS_INTRUDED,                       // chassis intreded
}EM_RECORD_ACCESS_ALARM_TYPE;

// access alarm information
typedef struct tagNET_RECORD_ACCESS_ALARMRECORD_INFO
{
    DWORD                       dwSize;                                  // Structure size
    int                         nRecNo;                                  // Rec No,Read only
    char					    szUserID[DH_COMMON_STRING_128];          // user id
    EM_RECORD_ACCESS_ALARM_TYPE emAlarmType;                             // alarm type
    int                         nDevAddress;                             // SubController ID,0:AccessControl, >0:subControl
    int                         nChannel;                                // channel
    NET_TIME                    stuTime;                                 // event time
}NET_RECORD_ACCESS_ALARMRECORD_INFO;

//the condition of query access alarm information
typedef struct tagFIND_NET_RECORD_ACCESS_ALARMRECORD_INFO_CONDITION
{   
    DWORD					    dwSize;
    char					    szUserID[DH_COMMON_STRING_128];          // userID
    NET_TIME                    stStartTime;                             // starttime
    NET_TIME                    stEndTime;                               // endtime
}FIND_NET_RECORD_ACCESS_ALARMRECORD_INFO_CONDITION;

// call type 
typedef enum tagEM_VIDEO_TALK_LOG_CALLTYPE
{
  EM_VIDEO_TALK_LOG_CALLTYPE_UNKNOWN = 0,   // unknown 
  EM_VIDEO_TALK_LOG_CALLTYPE_INCOMING,      // call in
  EM_VIDEO_TALK_LOG_CALLTYPE_OUTGOING,      // call out
  EM_VIDEO_TALK_LOG_CALLTYPE_MAX,         	//
}EM_VIDEO_TALK_LOG_CALLTYPE;

// terminal status 
typedef enum tagEM_VIDEO_TALK_LOG_ENDSTATE
{
  EM_VIDEO_TALK_LOG_ENDSTATE_UNKNOWN = 0,     // unknown 
  EM_VIDEO_TALK_LOG_ENDSTATE_MISSED,       	  // missed
  EM_VIDEO_TALK_LOG_ENDSTATE_RECEIVED,        // answered
  EM_VIDEO_TALK_LOG_ENDSTATE_MAX,         	  //
}EM_VIDEO_TALK_LOG_ENDSTATE;

// opposite type 
typedef enum tagEM_VIDEO_TALK_LOG_PEERTYPE
{
  EM_VIDEO_TALK_LOG_PEERTYPE_UNKNOWN = 0, // unknown 
  EM_VIDEO_TALK_LOG_PEERTYPE_VTO,         // VTO
  EM_VIDEO_TALK_LOG_PEERTYPE_VTH,         // VTH
  EM_VIDEO_TALK_LOG_PEERTYPE_VTS,         // management centre server
}EM_VIDEO_TALK_LOG_PEERTYPE;

// call record record set info 
typedef enum tagNET_RECORD_READFLAG
{
	NET_RECORD_READFLAG_UNREADED = 0, //Unread
	NET_RECORD_READFLAG_READED,	      //Read
	NET_RECORD_READFLAG_UNKNOWN,      //Unknown
}NET_RECORD_READFLAG;

// Call type
typedef enum tagNET_EM_OFFLINE_CALL_TYPE
{
	NET_EM_OFFLINE_CALL_UNKNOWN = -1,			// Unknown
	NET_EM_OFFLINE_CALL_ONLINECALL,				// Online
	NET_EM_OFFLINE_CALL_OFFLINECALL,			// Offline
	NET_EM_OFFLINE_CALL_NONE = 255,			// Other
}NET_EM_OFFLINE_CALL_TYPE;
// video talk record set log
typedef struct tagNET_RECORD_VIDEO_TALK_LOG
{
  DWORD             dwSize;
  int               nRecNo;               				// record set no., read-only
  NET_TIME          stuCreateTime;           			// start time
  EM_VIDEO_TALK_LOG_CALLTYPE   emCallType;             	// call type 
  EM_VIDEO_TALK_LOG_ENDSTATE   emEndState;             	// terminal status 
  char              szPeerNumber[DH_COMMON_STRING_64]; 	// opposite number	may be short no. or middle no., long no.
  EM_VIDEO_TALK_LOG_PEERTYPE   emPeerType;             	// opposite type 
  char              szLocalNumber[DH_COMMON_STRING_64]; // local no.	may be short no. or middle no., long no.
  int               nTalkTime;             				// talk time	unit second
  int               nMessageTime;            			// message time	unit second
  char              szPicturePath[DH_COMMON_STRING_128];// Picture path
  NET_EM_OFFLINE_CALL_TYPE		emOfflineCall;			// Call type
}NET_RECORD_VIDEO_TALK_LOG;


// audio talk status 
typedef enum tagEM_REGISTER_USER_STATE
{
  EM_REGISTER_USER_STATE_UNKNOWN = 0,         // unknown 
  EM_REGISTER_USER_STATE_IDLE,                // initial status 
  EM_REGISTER_USER_STATE_CALLING,             // call status , no response, 
  EM_REGISTER_USER_STATE_RINGING,             // ring status , opposite response, but no response, 
  EM_REGISTER_USER_STATE_PREVIEWING,          // previewing
  EM_REGISTER_USER_STATE_LEAVINGMESSAGE,      // messaging
  EM_REGISTER_USER_STATE_TALKING,             // talking
  EM_REGISTER_USER_STATE_MAX,                 //
}EM_REGISTER_USER_STATE;

// device type
typedef enum tagEM_REGISTER_USER_STATE_DEV_TYPE
{
    EM_REGISTER_USER_STATE_DEV_TYPE_UNKNOWN = 0,            // unknown
    EM_REGISTER_USER_STATE_DEV_TYPE_DIGIT_VTH,              // digital VTH
    EM_REGISTER_USER_STATE_DEV_TYPE_ANALOG_VTH,             // analogue VTH
    EM_REGISTER_USER_STATE_DEV_TYPE_DIGIT_VTO,              // digital VTO
    EM_REGISTER_USER_STATE_DEV_TYPE_ANALOG_VTO,             // analogue VTO
    EM_REGISTER_USER_STATE_DEV_TYPE_MAX,                    //
}EM_REGISTER_USER_STATE_DEV_TYPE;

// support lock or not
typedef enum tagEM_REGISTER_USER_STATE_SUPPORTLOCK_TYPE
{
    EM_REGISTER_USER_STATE_SUPPORTLOCK_TYPE_UNKNOWN = 0,                // Unknown
    EM_REGISTER_USER_STATE_SUPPORTLOCK_TYPE_SUPPORTLOCK,                // Support
    EM_REGISTER_USER_STATE_SUPPORTLOCK_TYPE_NOT_SUPPORTLOCK,            // Do not support
}EM_REGISTER_USER_STATE_SUPPORTLOCK_TYPE;

typedef enum tagNET_MONITORSTATE_TYPE
{
	NET_MONITORSTATE_TYPE_UNMONITORED = 0,		// 0 unmonitor (initial status)
	NET_MONITORSTATE_TYPE_MONITORREQUEST,		// 1 receive monitor query 
	NET_MONITORSTATE_TYPE_MONITORED,			// 2 monitor status 
	NET_MONITORSTATE_TYPE_UNKNOWN,				// Unknown status 
}NET_MONITORSTATE_TYPE;
// state record set info
typedef struct tagNET_RECORD_REGISTER_USER_STATE
{
    DWORD                                   dwSize;
    int                                     nRecNo;	                        // record set no., read-only
    NET_TIME                                stuCreateTime;                  // create time
    char                                    szUserID[DH_MAX_USERID_LEN];    // user ID
    BOOL									bOnline;                        // online or not
    char                                    szAddress[DH_MAX_IPADDR_OR_DOMAIN_LEN];   // network address
    int                                     nPort;                          // port no.  
    EM_REGISTER_USER_STATE                  emVideoTalkState;               // audio talk status 
    NET_TIME                                stuOnlineTime;                  // online time
    NET_TIME                                stuOfflineTime;                 // offline time
    EM_REGISTER_USER_STATE_DEV_TYPE         emDevType;                      // device type
    EM_REGISTER_USER_STATE_SUPPORTLOCK_TYPE	emSupportLock;                  // whether support lock
	NET_MONITORSTATE_TYPE					emMonitorState;					// Monitor State
}NET_RECORD_REGISTER_USER_STATE;

// visual talk analog VTH input mode 
typedef enum tagEM_VIDEO_TALK_CONTACT_VTSLAVEBINDMODE
{
  EM_VIDEO_TALK_CONTACT_VTSLAVEBINDMODE_UNKNOWN,       		// unknown 
  EM_VIDEO_TALK_CONTACT_VTSLAVEBINDMODE_SLAVEADDRESS,     	// via SlaveAddress
  EM_VIDEO_TALK_CONTACT_VTSLAVEBINDMODE_SLAVEID_SLAVEPORT,  // via SlaveID+SlavePort
}EM_VIDEO_TALK_CONTACT_VTSLAVEBINDMODE;

// user type 
typedef enum tagEM_VIDEO_TALK_CONTACT_TYPE
{
  EM_VIDEO_TALK_CONTACT_TYPE_UNKNOWN,       // unknown 
  EM_VIDEO_TALK_CONTACT_TYPE_VTH,         	// "VTH" VTH
  EM_VIDEO_TALK_CONTACT_TYPE_VTO,         	// "VTO" VTO
}EM_VIDEO_TALK_CONTACT_TYPE;

// registration method
typedef enum tagEM_VIDEO_TALK_CONTACT_REGISTER_TYPE
{
  EM_VIDEO_TALK_CONTACT_REGISTER_TYPE_UNKNOWN,        // unknown 
  EM_VIDEO_TALK_CONTACT_REGISTER_TYPE_PUBLIC,         // "public"
  EM_VIDEO_TALK_CONTACT_REGISTER_TYPE_LOCAL,          // "local"
}EM_VIDEO_TALK_CONTACT_REGISTER_TYPE;

// contact record set info 
typedef struct tagNET_RECORD_VIDEO_TALK_CONTACT
{
  DWORD                 dwSize;
  int                   nRecNo;									// record  set no., read-only
  NET_TIME              stuCreateTime;							// create time
  char                  szFirstName[DH_COMMON_STRING_32];		// name
  char                  szFamilyName[DH_COMMON_STRING_32];		// last name
  char                  szVTShortNumber[DH_COMMON_STRING_16];	// visual talk short no.
  char                  szVTMiddleNumber[DH_COMMON_STRING_32];	// visual talk middle no.
  char                  szVTLongNumber[DH_COMMON_STRING_64];	// visual talk long no., or VTH analogue VTH SN
  char                  szVTNetAddress[DH_MAX_IPADDR_LEN_EX];	// visual talk network address
  char                  szVTOPosition[DH_COMMON_STRING_64];		// VTH link to VTO position
  EM_VIDEO_TALK_CONTACT_VTSLAVEBINDMODE  emVTSlaveBindMode;     // visual talk analogue VTH input mode 
  char                  szVTSlaveId[DH_COMMON_STRING_32];		// visual talk analogue  VTH input distributor address
  char                  szVTSlavePort[DH_COMMON_STRING_32];		// visual talk analogue  VTH input distributor port
  char                  szVTSlaveAddress[DH_COMMON_STRING_64];	// visual talk analogue VTH address
  char                  szNickname[DH_COMMON_STRING_64];		// nickname
  char                  szNotes[DH_COMMON_STRING_64];			// note
  EM_VIDEO_TALK_CONTACT_TYPE       emType;						// user type 
  EM_VIDEO_TALK_CONTACT_REGISTER_TYPE   emRegisterType;         // registration method
  char                  szVTHPassword[DH_COMMON_STRING_64];		// registration password
  char                  szVTOBuilding[DH_COMMON_STRING_64];		// building no.
  char                  szVTOUnit[DH_COMMON_STRING_64];			// unit no.
  char                  szGroupNumber[DH_COMMON_STRING_64];		// group
  int                   nVTSlaveId;                             // VTSlave ID
  int                   nVTSlavePort;                           // VTSlave Port
}NET_RECORD_VIDEO_TALK_CONTACT;

//Bulletin status
typedef enum tagNET_ANNOUNCE_STATE
{
	NET_ANNOUNCE_STATE_UNSENDED = 0, //Initial status (to be send)
	NET_ANNOUNCE_STATE_SENDED,		 //Sent
	NET_ANNOUNCE_STATE_EXPIRED,		 //Expired
	NET_ANNOUNCE_STATE_UNKNOWN,		 //Unknown
}NET_ANNOUNCE_STATE;

//The bulletin has been reviewed or not
typedef enum tagNET_ANNOUNCE_READFLAG
{
	NET_ANNOUNCE_READFLAG_UNREADED = 0, //Unread
	NET_ANNOUNCE_READFLAG_READED,	    //Read
	NET_ANNOUNCE_READFLAG_UNKNOWN,      //Unknown
}NET_ANNOUNCE_READFLAG;

// Bulletin record info 
typedef struct tagNET_RECORD_ANNOUNCEMENT_INFO
{
	DWORD									dwSize;									
	int										nRecNo;									// Record set SN. read only 
	NET_TIME                                stuCreateTime;                          // Creation time 
	NET_TIME								stuIssueTime;							// Bulletin released time 
	char									szAnnounceTitle[DH_COMMON_STRING_64];	// Bulletin title
	char									szAnnounceContent[DH_COMMON_STRING_256];// Bulletin contents 
	char									szAnnounceDoor[DH_COMMON_STRING_16];	// The room No. the bulletin to be sent to. 
	NET_TIME								stuExpireTime;							// Bulletin expire time 
	NET_ANNOUNCE_STATE						emAnnounceState;						// Bulletin status
	NET_ANNOUNCE_READFLAG					emAnnounceReadFlag;						// Bulletin has been reviewed or not
}NET_RECORD_ANNOUNCEMENT_INFO;


// Bulletin record info search criteria 
typedef struct tagFIND_RECORD_ANNOUNCEMENT_CONDITION
{
	DWORD                     dwSize;
	BOOL                      bTimeEnable;                      // Enable search period 
	NET_TIME                  stStartTime;                      // Start time
	NET_TIME                  stEndTime;                        // End time
}FIND_RECORD_ANNOUNCEMENT_CONDITION;


//Alarm record info 
typedef struct tagNET_RECORD_ALARMRECORD_INFO
{
	DWORD									dwSize;
	int										nRecNo;									// Record set SN. Read-only 
	NET_TIME                                stuCreateTime;							// Alarm time. UTC second. Read-only 
	int										nChannelID;								// Alarm channel 
	NET_SENSE_METHOD						emSenseMethod;							// Sensor respond type 
	char									szRoomNumber[DH_MAX_DOOR_NUM];			// Alarm room No. 
	NET_ANNOUNCE_READFLAG					emReadFlag;								// 0=unread, 1-=read 
}NET_RECORD_ALARMRECORD_INFO;

//Alarm record search criteria
typedef struct tagFIND_RECORD_ALARMRECORD_CONDITION
{
	DWORD                     dwSize;
	BOOL                      bTimeEnable;                      // Enable search period 
	NET_TIME                  stStartTime;                      // Start time
	NET_TIME                  stEndTime;                        // End time
}FIND_RECORD_ALARMRECORD_CONDITION;


// A&C not close event detailed info
typedef struct tagALARM_ACCESS_CTL_NOT_CLOSE_INFO 
{
    DWORD           dwSize;
    int             nDoor;                                  // Door Channel Number
    char            szDoorName[DH_MAX_DOORNAME_LEN];        // Entrance Guard Name
    NET_TIME        stuTime;                                // Alarm Event Triggered Time
    int             nAction;                                // 0=Start 1=Stop     
    UINT 		    nEventID;				                // event id
}ALARM_ACCESS_CTL_NOT_CLOSE_INFO;

// break in method
typedef enum tagEM_BREAK_IN_METHOD
{
    EM_BREAK_IN_METHOD_UNKNOWN,                             // unknown
    EM_BREAK_IN_METHOD_ILLEGAL,                             // Illegal break in: unauthorized break in
    EM_BREAK_IN_METHOD_REVERSE,                             // Reverse break in: after the authorized door is opened, someone enters the opposite side
} EM_BREAK_IN_METHOD;

// Break Event Detail Information
typedef struct tagALARM_ACCESS_CTL_BREAK_IN_INFO 
{
    DWORD           dwSize;
    int             nDoor;                                  // Door Channel Number
    char            szDoorName[DH_MAX_DOORNAME_LEN];        // Entrance Guard Name
    NET_TIME        stuTime;                                // Alarm Event Triggered Time    
    UINT 		    nEventID;				                // vent id
    EM_BREAK_IN_METHOD   emMethod;                          // break in method
    BYTE            reserved[4];                            // reserved
}ALARM_ACCESS_CTL_BREAK_IN_INFO;


// Repeatedly Entry  Event Detail Information
typedef struct tagALARM_ACCESS_CTL_REPEAT_ENTER_INFO 
{
    DWORD           dwSize;
    int             nDoor;                                  // Door Channel Number
    char            szDoorName[DH_MAX_DOORNAME_LEN];        // Entrance Guard Name
    NET_TIME        stuTime;                                // Alarm Event Triggered Time
	char            szCardNo[DH_MAX_CARDNO_LEN];            // Card number	
    UINT 			nEventID;				                // event id
}ALARM_ACCESS_CTL_REPEAT_ENTER_INFO;


// Forced Card Swing Card  Event Detail Information
typedef struct tagALARM_ACCESS_CTL_DURESS_INFO 
{
    DWORD           dwSize;
    int             nDoor;                                  // Door Channel Number
    char            szDoorName[DH_MAX_DOORNAME_LEN];        // Entrance Guard Name
    char            szCardNo[DH_MAX_CARDNO_LEN];            // Forced Card Number
    NET_TIME        stuTime;                                // Alarm Event Triggered Time    
    UINT 			nEventID;				                // event id
    char            szSN[32];                               // wireless device serial number
	char			szUserID[12];							// user id
}ALARM_ACCESS_CTL_DURESS_INFO;


// Entrance Guard Event Type
typedef enum tagNET_ACCESS_CTL_EVENT_TYPE
{
    NET_ACCESS_CTL_EVENT_UNKNOWN = 0,
    NET_ACCESS_CTL_EVENT_ENTRY,                             // Get In
    NET_ACCESS_CTL_EVENT_EXIT,                              // Get Out
}NET_ACCESS_CTL_EVENT_TYPE;

// Current collect status
typedef enum tagEM_CARD_STATE
{
	EM_CARD_STATE_UNKNOWN = -1,			// Unknown
	EM_CARD_STATE_SWIPE,				// Swipe
	EM_CARD_STATE_COLLECTION,			// Collection
}EM_CARD_STATE;

// lift caller type
typedef enum tagEM_LIFT_CALLER_TYPE
{
	EM_LIFT_CALLER_TYPE_UNKNOWN = 0,	// unknown
	EM_LIFT_CALLER_TYPE_VTO,			// VTO call
	EM_LIFT_CALLER_TYPE_PLATFORM,		// platform call
	EM_LIFT_CALLER_TYPE_LOCAL_AUTH,		// local auth call
}EM_LIFT_CALLER_TYPE;


// access control event
typedef struct tagALARM_ACCESS_CTL_EVENT_INFO 
{
    DWORD                       dwSize;
    int                         nDoor;                              // Door Channel Number
    char                        szDoorName[DH_MAX_DOORNAME_LEN];    // Entrance Guard Name
    NET_TIME                    stuTime;                            // Alarm Event Triggered Time
    NET_ACCESS_CTL_EVENT_TYPE   emEventType;                        // Entrance Guard Event Type
    BOOL                        bStatus;                            // Swing Card Result,True is Success,False is Fail
    NET_ACCESSCTLCARD_TYPE      emCardType;                         // Card Type
    NET_ACCESS_DOOROPEN_METHOD  emOpenMethod;                       // Open The Door Method
    char                        szCardNo[DH_MAX_CARDNO_LEN];        // Card Number
    char                        szPwd[DH_MAX_CARDPWD_LEN];          // Password
    char                        szReaderID[DH_COMMON_STRING_32];    // Reader ID
    char                        szUserID[DH_COMMON_STRING_64];      // unlock user
    char                        szSnapURL[DH_COMMON_STRING_256];    // snapshot picture storage address
    int                         nErrorCode;                         // Reason of unlock failure, only because it is valid when bStatus is FALSE
                                                                    // 0x00 no error
                                                                    // 0x10 unauthorized
                                                                    // 0x11 card lost or cancelled
                                                                    // 0x12 no door right
                                                                    // 0x13 unlock mode error
                                                                    // 0x14 valid period error
                                                                    // 0x15 anti sneak into mode
                                                                    // 0x16 forced alarm not unlocked
                                                                    // 0x17 door NC status
                                                                    // 0x18 AB lock status
                                                                    // 0x19 patrol card
                                                                    // 0x1A device is under intrusion alarm status
                                                                    // 0x20 period error
                                                                    // 0x21 unlock period error in holiday period
                                                                    // 0x30 first card right check required
                                                                    // 0x40 card correct, input password error
                                                                    // 0x41 card correct, input password timed out
                                                                    // 0x42 card correct, input fingerprint error
                                                                    // 0x43 card correct, input fingerprint timed out
                                                                    // 0x44 fingerprint correct, input password error
                                                                    // 0x45 fingerprint correct, input password timed out
                                                                    // 0x50 group unlock sequence error
                                                                    // 0x51 test required for group unlock
                                                                    // 0x60 test passed, control unauthorized
                                                                    // 0x61 card correct, face error
                                                                    // 0x62 card correct,face timeout
                                                                    // 0x63 repeat enter
                                                                    // 0x64 unauthorized, requiring back-end platform identification
    int                         nPunchingRecNo;                     // punching record number 
	int							nNumbers;							// pic Numbers	
    NET_ACCESSCTLCARD_STATE     emStatus;		                    // Card Status
    char                        szSN[32];                           // wireless deivce serial number
    NET_ATTENDANCESTATE         emAttendanceState;                  // attend state
    char                        szQRCode[512];                      // QRcode
    char                        szCallLiftFloor[16];				// Floor of Call Lift
	EM_CARD_STATE				emCardState;                        // Collect as card or not
	char						szCitizenIDNo[20];					// Citizen card ID
	char				        szCompanionCards[MAX_COMPANION_CARD_NUM][DH_MAX_CARDINFO_LEN];    // The companion cards list
	int				            nCompanionCardCount;				// The number of companion cards 
	EM_HAT_STYLE				emHatStyle;							// hat style
	EM_UNIFIED_COLOR_TYPE		emHatColor;							// hat color
	EM_LIFT_CALLER_TYPE			emLiftCallerType;					// lift caller type
}ALARM_ACCESS_CTL_EVENT_INFO;

typedef enum tagEM_NET_RECORD_COMMODITY_NOTICE_SOURCE_TYPE
{
    EM_NET_RECORD_COMMODITY_NOTICE_SOURCE_TYPE_UNKNOWN,				// Unknown 
    EM_NET_RECORD_COMMODITY_NOTICE_SOURCE_TYPE_SUPERMARKET,			// Super market
    EM_NET_RECORD_COMMODITY_NOTICE_SOURCE_TYPE_RESTAURANT,			// Dining hall
    EM_NET_RECORD_COMMODITY_NOTICE_SOURCE_TYPE_FRUITSTORE,     		// Fruit store
}EM_NET_RECORD_COMMODITY_NOTICE_SOURCE_TYPE;

typedef enum tagEM_NET_RECORD_COMMODITY_NOTICE_BARGAIN_TYPE
{
    EM_NET_RECORD_COMMODITY_NOTICE_BARGAIN_TYPE_UNKNOWN,        // Unknown
    EM_NET_RECORD_COMMODITY_NOTICE_BARGAIN_TYPE_YES,            // Bargain
    EM_NET_RECORD_COMMODITY_NOTICE_BARGAIN_TYPE_NO,             // No Bargain
}EM_NET_RECORD_COMMODITY_NOTICE_BARGAIN_TYPE;
// commodity notice record set info
typedef struct tagNET_RECORD_COMMODITY_NOTICE
{
    DWORD                                           dwSize;
    int                                             nRecNo;                                 // record number 
    NET_TIME                                        stuSaleTime;                            // Sale Time
    char                                            szName[DH_COMMON_STRING_128];           // commodity name
    EM_NET_RECORD_COMMODITY_NOTICE_SOURCE_TYPE      emSource;                               // commodity notice source type
    char                                            szURL[DH_COMMON_STRING_256];            // commodity pictrue path
    float                                           fPrice;                                 // commodity price, unit: yuan
    char                                            szID[DH_COMMON_STRING_64];              // ID number
    EM_NET_RECORD_COMMODITY_NOTICE_BARGAIN_TYPE     emBargain;                              // Bargain
}NET_RECORD_COMMODITY_NOTICE;

typedef enum tagEM_NET_RECORD_HEALTH_CARE_NOTICE_OFFICE_TYPE
{
    EM_NET_RECORD_HEALTH_CARE_NOTICE_OFFICE_TYPE_UNKNOWN,           // Unknown
    EM_NET_RECORD_HEALTH_CARE_NOTICE_OFFICE_TYPE_DIGEST,            // Digest 
    EM_NET_RECORD_HEALTH_CARE_NOTICE_OFFICE_TYPE_STOMATOLOGY,       // Stomatology
}EM_NET_RECORD_HEALTH_CARE_NOTICE_OFFICE_TYPE;
// health care notice record set info
typedef struct tagNET_RECORD_HEALTH_CARE_NOTICE
{
    DWORD                                           dwSize;
    int                                             nRecNo;                                 // record number
    NET_TIME                                        stuStartTime;                           // start time
    NET_TIME                                        stuEndTime;                             // end time
    char                                            szHospital[DH_COMMON_STRING_128];       // Hospital
    EM_NET_RECORD_HEALTH_CARE_NOTICE_OFFICE_TYPE    emOffice;                               // Office
    char                                            szOfficeNumber[DH_COMMON_STRING_64];    // OfficeNumber
    char                                            szDoctorName[DH_COMMON_STRING_128];     // Doctor Name
    char                                            szID[DH_COMMON_STRING_64];              // ID 
}NET_RECORD_HEALTH_CARE_NOTICE;
///////////////////////// Alarm of intelligent transportation[CLIENT_StartListenEx] /////////////////////////////////////

//type DH_IVS_TRAFFIC_REALFLOWINFO(traffic real flow info)
typedef struct tagALARM_IVS_TRAFFIC_REALFLOW_INFO
{
	int                 nChannelID;                       // channel ID
	char                szName[128];                      // name
	char                bReserved1[4];                    // reserved
	double              PTS;                              // PTS(ms)
	NET_TIME_EX         UTC;                              // time of occurrence
	int                 nEventID;                         // event ID
	unsigned int        nSequence;                        // sequence
	BYTE                bEventAction;                     // event action,0 pulse,1 durable events begin, 2 durable events end
	BYTE                byReserved[3];
	int                 nLane;                            // lane number
	int                 nCount;                           // cars count
	int					nSpeed;							  // speed,km/h
	int                 nOverPercent;                     // over percent
	int                 nMetersUints;                     // meter unit 0:km,1:mile
	BYTE                bReserved[1024];                  // reserved
}ALARM_IVS_TRAFFIC_REALFLOW_INFO;

//EVNET type DH_YUEQINGLIGHTING_STATE_EVENT(Statistical light switch time) 
typedef struct tagDEV_YUEQINGLIGHTING_STATE_INFO
{
	DWORD               dwAction;                       // event ation, 0:Start, 1:Stop
	int                 nChannelID;                     // Channel ID (start from 0)
	NET_TIME_EX         UTC;							// the event happen time 
	BYTE                bReserved[1024];                // reserved
}DEV_YUEQINGLIGHTING_STATE_INFO;

// Alarm Event Type,DH_ALARM_VEHICLE_TURNOVER's Data Describe Information
typedef struct tagALARM_VEHICEL_TURNOVER_EVENT_INFO
{
    NET_GPS_STATUS_INFO stGPSStatusInfo;                // GPS Information
    BYTE                bEventAction;                   // Event Action,0=Impluse Event,1=Continued Event Start,2=Continued Event End;
    BYTE                byRserved[3];                   // Hold Byte,For Extension.
    NET_TIME_EX         UTC;							// the event happen time 
    BYTE                bReserved[984];                // Hold Byte,For Extension.
}ALARM_VEHICEL_TURNOVER_EVENT_INFO;

// Alarm Event Type,DH_ALARM_VEHICLE_COLLISION'sData Describe Information
typedef struct tagALARM_VEHICEL_COLLISION_EVENT_INFO
{
    NET_GPS_STATUS_INFO stGPSStatusInfo;                // GPS Information
    BYTE                bEventAction;                   // Event Action,0=Impluse Event,1=Continued Event Start,2=Continued Event End;
    BYTE                byRserved[3];                   // Hold Byte,For Extension.
    NET_TIME_EX         UTC;							// the event happen time
    BYTE                bReserved[984];                // Hold Byte,For Extension.
}ALARM_VEHICEL_COLLISION_EVENT_INFO;

// Alarm Event Type,DH_ALARM_VEHICLE_CONFIRM'sData Describe Information
typedef struct tagALARM_VEHICEL_CONFIRM_INFO
{
    DWORD               dwStructSize;                   // StructSize
    NET_GPS_STATUS_INFO stGPSStatusInfo;                // GPS Information
    BYTE                bEventAction;                   // Event Action,0=Impluse Event,1=Continued Event Start,2=Continued Event End;
    BYTE                byRserved[3];                   // Hold Byte,For Extension.
    char                szInfo[128];                    // Upload Alarm Concrete Information
}ALARM_VEHICEL_CONFIRM_INFO;

//Alarm Event Type,DH_EVENT_REGISTER_OFF's Data Describe Information
typedef struct tagEVENT_REGISTER_OFF_INFO
{
    DWORD               dwStructSize;                   // StructSize
    NET_GPS_STATUS_INFO stGPSStatusInfo;                // GPS Information
    BYTE                bEventAction;                   // Event Action,0=Impluse Event,1=Continued Event Start,2=Continued Event End;
    BYTE                byRserved[3];                   // Aline
}EVENT_REGISTER_OFF_INFO;

// Alarm Event Type,DH_ALARM_VIDEO_TIMING's Data Describe Information
typedef struct tagALARM_VIDEO_TIMING
{
    DWORD               dwStructSize;                   // StructSize
    DWORD               dwAction;                       // Event Action,0=Pause,1=Start,2=Stop
    DWORD               dwChannelID;                    // Video Channel ID
}ALARM_VIDEO_TIMING;

// Alarm Event Type,DH_ALARM_VEHICLE_LARGE_ANGLE's Data Describe Information
typedef struct tagALARM_VEHICEL_LARGE_ANGLE
{
    DWORD               dwStructSize;                   // StructSize
    NET_GPS_STATUS_INFO stGPSStatusInfo;                // GPS Information
    BYTE                bEventAction;                   // Event Action,0=Impluse Event,1=Continued Event Start,2=Continued Event End;
    BYTE                byRserved[3];                   // Aline
    unsigned int        nSequence;                      // no.
}ALARM_VEHICEL_LARGE_ANGLE;

// Alarm Event Type,DH_ALARM_AUDIO_ANOMALY's Data Describe Information
typedef struct tagALARM_AUDIO_ANOMALY
{
    DWORD               dwStructSize;                   // StructSize
    DWORD               dwAction;                       // Event Action,0=Pause,1=Start,2=Stop
    DWORD               dwChannelID;                    // Audio Channel ID
    int                 nDecibel;                       // Audio sensitivity
    int                 nFrequency;                     // Audio frequency 
}ALARM_AUDIO_ANOMALY;

// Alarm Event Type,DH_ALARM_AUDIO_MUTATION's Data Describe Information
typedef struct tagALARM_AUDIO_MUTATION
{
    DWORD               dwStructSize;                   // StructSize
    DWORD               dwAction;                       // Event Action,0=Pause,1=Start,2=Stop
    DWORD               dwChannelID;                    // Audio Channel ID
}ALARM_AUDIO_MUTATION;

// Corresponding data description info of alarm event type (alarm event type) DH_ALARM_AUDIO_DETECT (audio detect event)
typedef struct tagALARM_AUDIO_DETECT
{
    DWORD               dwAction;                       // Event operation, 1:Start, 2:Stop
    DWORD               dwChannelID;                    // Audio channel No.
    char                reserved[512];                  // Reserved 
} ALARM_AUDIO_DETECT;

#define MAX_SENSORID_NUMBER 20                          // Sensor max amount 
#define MAX_TYRE_NUM        128                         // Max tyre amount 

// Tyre alarm mark enumeration 
typedef enum tagAlarmTyreFlag
{
    ALARM_TYRE_FLAG_NONE,                               // None Valid Data
    ALARM_TYRE_FLAG_NORMAL,                             // Normal
    ALARM_TYRE_FLAG_HIGHPRESSURE,                       // High Pressure
    ALARM_TYRE_FLAG_LOWERPRESSURE,                      // Low Pressure
    ALARM_TYRE_FLAG_HIGHTEMP,                           // High Temperature
    ALARM_TYRE_FLAG_HIGHTEMP_HIGHPRESSURE,              // High Pressure, High Temperature
    ALARM_TYRE_FLAG_HIGHTEMP_LOWERPRESSURE,             // High Temperature, Low Pressure

    ALARM_TYRE_FLAG_INVALID,                            // Illegal Flag Data
}EM_ALARM_TYER_FALG;

// Tyre Information Struct
typedef struct tagTYRE_INFO_UNIT
{
    DWORD               dwStructSize;                    // StructSize
    DWORD               dwSensorIDNum;                   // Sensor Number
    DWORD               dwSensorID[MAX_SENSORID_NUMBER]; // Sensor ID Information
    DWORD               dwTyreNum;                       // Tyre Number
    DWORD               dwTyrePlace;                     // Tyre at the First Few Shaft

    EM_ALARM_TYER_FALG  emAlarmFlag;                     // Tyre Alarm Flag

    int                 nTemp;                           // Temperature,Unit: degree Celsius
    int                 nTempLimit;                      // Temperature,Unit: degree Celsius

    float               fPressure;                       // Pressure,Unit:Kpa
    float               fUpperLimit;                     // Alarm Threshold Pressure Upper Limit
    float               fLowerLimit;                     // Alarm Threshold Pressure Lower Limit
    float               fVoltage;                        // Sensor Current Voltage,Unit:V
}TYRE_INFO_UNIT;

// Alarm Event Type,DH_EVENT_TYREINFO's Data Describe Information
typedef struct tagEVENT_TYRE_INFO
{
    DWORD               dwStructSize;                   // StructSize
    DWORD               dwAction;                       // Event Action,0=Pause,1=Start,2=Stop
    DWORD               dwTyreNum;                      // Tyre Number
    TYRE_INFO_UNIT      *pstuTyre;                      // Tyre Information
}EVENT_TYRE_INFO;

/////////////////////////////Audio Talk Related Definition/////////////////////////////

// Audio format information 
typedef struct
{
	BYTE				byFormatTag;			// Encode type such as 0:PCM
	WORD				nChannels;				// Track number 
	WORD				wBitsPerSample;			// Sampling depth 	
	DWORD				nSamplesPerSec;			// Sampling rate
} DH_AUDIO_FORMAT, *LPDH_AUDIO_FORMAT;

/////////////////////////////User Management Corresponding Definition /////////////////////////////

// Support the device with max 8 bits user name. Corresponding to the CLIENT_QueryUserInfo and CLIENT_OperateUserInfo.
// Right information 
typedef struct _OPR_RIGHT
{
	DWORD				dwID;
	char				name[DH_RIGHT_NAME_LENGTH];
	char				memo[DH_MEMO_LENGTH];
} OPR_RIGHT;

// User information 
typedef struct _USER_INFO
{
	DWORD				dwID;
	DWORD				dwGroupID;
	char				name[DH_USER_NAME_LENGTH];
	char				passWord[DH_USER_PSW_LENGTH];
	DWORD				dwRightNum;
	DWORD				rights[DH_MAX_RIGHT_NUM];
	char				memo[DH_MEMO_LENGTH];
	DWORD				dwReusable;				// Reuse or not;1:enable reuse;0:disable reuse 
} USER_INFO;

// User group information 
typedef struct _USER_GROUP_INFO
{
	DWORD				dwID;
	char				name[DH_USER_NAME_LENGTH];
	DWORD				dwRightNum;
	DWORD				rights[DH_MAX_RIGHT_NUM];
	char				memo[DH_MEMO_LENGTH];
} USER_GROUP_INFO;

// User information list 
typedef struct _USER_MANAGE_INFO
{
	DWORD				dwRightNum;				// Right information 
	OPR_RIGHT			rightList[DH_MAX_RIGHT_NUM];
	DWORD				dwGroupNum;				// User group information 
	USER_GROUP_INFO		groupList[DH_MAX_GROUP_NUM];
	DWORD				dwUserNum;				// User information 
	USER_INFO			userList[DH_MAX_USER_NUM];
	DWORD				dwSpecial;				// User account reuse; 1:support account to be reused. 0:Does not support account to be reused.
} USER_MANAGE_INFO;

// Support the device of max 8-bit or 16-bit name. Corresponding interface to CLIENT_QueryUserInfoEx and CLIENT_OperateUserInfoEx
#define DH_USER_NAME_LENGTH_EX		16			// User name length 
#define DH_USER_PSW_LENGTH_EX		16			// Password 

// Right information
typedef struct _OPR_RIGHT_EX
{
	DWORD				dwID;
	char				name[DH_RIGHT_NAME_LENGTH];
	char				memo[DH_MEMO_LENGTH];
} OPR_RIGHT_EX;

// User information 
typedef struct _USER_INFO_EX
{
	DWORD				dwID;
	DWORD				dwGroupID;
	char				name[DH_USER_NAME_LENGTH_EX];
	char				passWord[DH_USER_PSW_LENGTH_EX];
	DWORD				dwRightNum;
	DWORD				rights[DH_MAX_RIGHT_NUM];
	char				memo[DH_MEMO_LENGTH];
	DWORD				dwFouctionMask;			// Subnet mask,0x00000001 - support reuse  
	BYTE				byReserve[32];
} USER_INFO_EX;

// User group information 
typedef struct _USER_GROUP_INFO_EX
{
	DWORD				dwID;
	char				name[DH_USER_NAME_LENGTH_EX];
	DWORD				dwRightNum;
	DWORD				rights[DH_MAX_RIGHT_NUM];
	char				memo[DH_MEMO_LENGTH];
} USER_GROUP_INFO_EX;

// User information sheet 
typedef struct _USER_MANAGE_INFO_EX
{
	DWORD				dwRightNum;				// Right information 
	OPR_RIGHT_EX		rightList[DH_MAX_RIGHT_NUM];
	DWORD				dwGroupNum;				// User group information 
	USER_GROUP_INFO_EX  groupList[DH_MAX_GROUP_NUM];
	DWORD				dwUserNum;				// User information 
	USER_INFO_EX		userList[DH_MAX_USER_NUM];
	DWORD				dwFouctionMask;			// Subnet mask;0x00000001 - support reuse, 0x00000002 - Password has been modified , it needs to be verified.
	BYTE				byNameMaxLength;		// The supported user name max length 
	BYTE				byPSWMaxLength;			// The supported password max length
	BYTE				byReserve[254];
} USER_MANAGE_INFO_EX;

// Max support a device of 64-channel. Corresponding extension interface CLIENT_QueryUserInfoNew and CLIENT_OperateUserInfoNew
#define DH_NEW_MAX_RIGHT_NUM        1024
#define DH_NEW_USER_NAME_LENGTH	 128			// User name length
#define DH_NEW_USER_PSW_LENGTH	 128			// password

// Rights info
typedef struct _OPR_RIGHT_NEW
{
	DWORD               dwSize;
	DWORD				dwID;
	char				name[DH_RIGHT_NAME_LENGTH];
	char				memo[DH_MEMO_LENGTH];
} OPR_RIGHT_NEW;

// User info
typedef struct _USER_INFO_NEW
{
	DWORD               dwSize;
	DWORD				dwID;
	DWORD				dwGroupID;
	char				name[DH_NEW_USER_NAME_LENGTH];
	char				passWord[DH_NEW_USER_PSW_LENGTH];
	DWORD				dwRightNum;
	DWORD				rights[DH_NEW_MAX_RIGHT_NUM];
	char				memo[DH_MEMO_LENGTH];
	DWORD				dwFouctionMask;			// Sub mask,0x00000001 - Support account reusable
    NET_TIME            stuTime;                // Last Revise Time
    BYTE                byIsAnonymous;          // Whether Can Be Anonymous Login,0=Can't Be Anonymous Login,1=Can be Anonymous Login
    BYTE                byReserve[7];
} USER_INFO_NEW;

typedef struct tagREMAIN_MODIFY_TIME_AND_LOCK_SECOND
{
	DWORD			dwSize;						// struct size
	int				nRemainModifytimes;			// Remain modify times if input wrong old password
	int				nRemainLockSecond;			// Remain lock seconds if old password input times reach the limit value,Unit:second
}REMAIN_MODIFY_TIME_AND_LOCK_SECOND;

// User group info
typedef struct _USER_GROUP_INFO_NEW
{
	DWORD               dwSize;
	DWORD				dwID;
	char				name[DH_USER_NAME_LENGTH_EX];
	DWORD				dwRightNum;
	DWORD				rights[DH_NEW_MAX_RIGHT_NUM];
	char				memo[DH_MEMO_LENGTH];
} USER_GROUP_INFO_NEW;

// user group information expand,user group lengthen
typedef struct _USER_GROUP_INFO_EX2
{
    DWORD               dwSize;
    DWORD               dwID;
    char                name[DH_NEW_USER_NAME_LENGTH];
    DWORD               dwRightNum;
    DWORD               rights[DH_NEW_MAX_RIGHT_NUM];
    char                memo[DH_MEMO_LENGTH];
} USER_GROUP_INFO_EX2;

// User info list
typedef struct _USER_MANAGE_INFO_NEW
{
	DWORD               dwSize;
	DWORD				dwRightNum;				// Rights info
	OPR_RIGHT_NEW		rightList[DH_NEW_MAX_RIGHT_NUM];
	DWORD				dwGroupNum;				// User group info
	USER_GROUP_INFO_NEW groupList[DH_MAX_GROUP_NUM];
	DWORD				dwUserNum;				// User info
	USER_INFO_NEW		userList[DH_MAX_USER_NUM];
	DWORD				dwFouctionMask;			// Sub mask; 0x00000001 - Support account reusable,0x00000002 - Verification needed when change password
	BYTE				byNameMaxLength;		// Max user name length supported
	BYTE				byPSWMaxLength;			// Max password length supported
	BYTE				byReserve[254];
    USER_GROUP_INFO_EX2 groupListEx[DH_MAX_GROUP_NUM];      // User Group Information Expand
} USER_MANAGE_INFO_NEW;

///////////////////////////////Search Related Definition ///////////////////////////////

// The language types device supported 
typedef struct _DH_LANGUAGE_DEVINFO
{
	DWORD				dwLanguageNum;			// The language amount supported
	BYTE				byLanguageType[252];	// Enumeration value please refer to DH_LANGUAGE_TYPE
} DH_DEV_LANGUAGE_INFO, *LPDH_DEV_LANGUAGE_INFO;

// the IPC types device supported
typedef struct
{
	int                 nTypeCount;              // The IPC type amount supported
	BYTE                bSupportTypes[128];      // Enumeration value please refer to EM_IPC_TYPE
}DH_DEV_IPC_INFO;

//3G net flow info
typedef struct
{
	int					nStrategy;              // strategy,0: charged by flow every month 1:charged by time every month
	int                 nUplimit;               // up limit flow, by flow: MB, by time: h
	int                 nUsed;                  // have used flow, by flow: MB, by time: h
	BYTE                bReserved[64];          // reserved
}DH_DEV_3GFLOW_INFO;

// 3G module info
typedef struct
{
	BYTE			    byEthNum;				// 3G model number
	BYTE				byReserved[255];        // reserved
}DH_DEV_3GMODULE_INFO;

typedef struct
{
	DWORD				dwId;                            // ddns server id
	char				szState[DH_MAX_DDNS_STATE_LEN];	 // ddns status
	BYTE				bReserved[512];                  // reserved
}DH_DEV_DNS_INFO;
typedef struct
{
	DWORD				dwDdnsServerNum;	
	DH_DEV_DNS_INFO     stDdns[DH_MAX_DDNS_NUM];
}DH_DEV_MULTI_DDNS_INFO;

// device URL info
typedef struct
{
	char				szURLInfo[512];         // device URL info, by string
	BYTE				bReserved[512];
}DH_DEV_URL_INFO;
// HDD informaiton 
typedef struct
{
	DWORD				dwVolume;				// HDD capacity 
	DWORD				dwFreeSpace;			// HDD free space 
	BYTE				dwStatus;				// higher 4 byte instruct hdd type, see the enum struct EM_DISK_TYPE; lower four byte instruct HDD status,0-hiberation,1-active,2-malfucntion and etc.;Devide DWORD into four BYTE
	BYTE				bDiskNum;				// HDD number
	BYTE				bSubareaNum;			// Subarea number
	BYTE				bSignal;				// Symbol. 0:local. 1:remote
} NET_DEV_DISKSTATE,*LPNET_DEV_DISKSTATE;

// Device HDD informaiton 
typedef struct _DH_HARDDISK_STATE
{
	DWORD				dwDiskNum;				// Amount 
	NET_DEV_DISKSTATE	stDisks[DH_MAX_DISKNUM];// HDD or subarea information 
} DH_HARDDISK_STATE, *LPDH_HARDDISK_STATE;

typedef DH_HARDDISK_STATE	DH_SDCARD_STATE;	// SD card. Please refer to HDD information for data structure. 

// Audio encode information 
typedef struct  
{
	DH_TALK_CODING_TYPE	encodeType;				// Encode type 
	int					nAudioBit;				// Bit:8/16
	DWORD				dwSampleRate;			// Sampling rate such as 8000 or 16000
    int                 nPacketPeriod;          // Pack Period,Unit ms
    char                reserved[60];
} DHDEV_TALKDECODE_INFO;

// The audio talk type the device supported
typedef struct 
{
	int					nSupportNum;			// Amount
	DHDEV_TALKDECODE_INFO type[64];				// Encode type 
	char				reserved[64];
} DHDEV_TALKFORMAT_LIST;

// PTZ property information
#define  NAME_MAX_LEN 16
typedef struct 
{
	DWORD				dwHighMask;				// Operation mask high bit 
	DWORD				dwLowMask;				// Operation mask low bit 
	char				szName[NAME_MAX_LEN];	// Operation protocol name 
	WORD				wCamAddrMin;			// Channel address min value
	WORD				wCamAddrMax;			// Channel address max value
	WORD				wMonAddrMin;			// Monitor address min value
	WORD				wMonAddrMax;			// Monitor address max value
	BYTE				bPresetMin;				// Preset min value
	BYTE				bPresetMax;				// Preset max value
	BYTE				bTourMin;				// Auto tour min value
	BYTE				bTourMax;				// Auto tour max value
	BYTE				bPatternMin;			// Pattern min value
	BYTE				bPatternMax;			// Pattern max value
	BYTE				bTileSpeedMin;			// Tilt speed min value
	BYTE				bTileSpeedMax;			// Tilt speed max value
	BYTE				bPanSpeedMin;			// Pan speed min value
	BYTE				bPanSpeedMax;			// Pan speed max value
	BYTE				bAuxMin;				// Aux function min value
	BYTE				bAuxMax;				// Aux function max value
	int					nInternal;				// Command interval
	char				cType;					// Protocol type
	BYTE				bReserved_1;			// Reserved
	BYTE				bFuncMask;				// function mask :0x01 - support PTZ-inside function
	BYTE				bReserved_2;
	char				Reserved[4];
} PTZ_OPT_ATTR;

// CD driver tray state
typedef enum tagEM_NET_BURN_DEV_TRAY_TYPE
{
    EM_NET_BURN_DEV_TRAY_TYPE_UNKNOWN,    // unknown
	EM_NET_BURN_DEV_TRAY_TYPE_READY,      // ready
	EM_NET_BURN_DEV_TRAY_TYPE_OPEN,       // open
	EM_NET_BURN_DEV_TRAY_TYPE_NODISK,     // no disk
	EM_NET_BURN_DEV_TRAY_TYPE_NOT_READY,  // not ready
}EM_NET_BURN_DEV_TRAY_TYPE;

// CD driver using state
typedef enum tagEM_NET_BURN_DEV_OPERATE_TYPE
{
    EM_NET_BURN_DEV_OPERATE_TYPE_UNKNOWN, // unknown
	EM_NET_BURN_DEV_OPERATE_TYPE_WRITE,   // write
	EM_NET_BURN_DEV_OPERATE_TYPE_READ,    // read
	EM_NET_BURN_DEV_OPERATE_TYPE_IDLE,    // idle
}EM_NET_BURN_DEV_OPERATE_TYPE;

// Burner informaiton 
typedef struct _NET_DEV_BURNING
{
	DWORD				dwDriverType;			// Burner driver type;0:DHFS,1:DISK,2:CDRW
	DWORD				dwBusType;				// Bus type;0:USB,1:1394,2:IDE
	DWORD				dwTotalSpace;			// Total space(KB)
	DWORD				dwRemainSpace;			// Free space(KB)
	BYTE				dwDriverName[DH_BURNING_DEV_NAMELEN];	 // Burner driver name
	EM_NET_BURN_DEV_TRAY_TYPE    emTrayType;					 // CD driver Tray state
	EM_NET_BURN_DEV_OPERATE_TYPE emOperateType;					 // CD driver using state
} NET_DEV_BURNING, *LPNET_DEV_BURNING;

// Device burner informaiton 
typedef struct _DH_BURNING_DEVINFO
{
	DWORD				dwDevNum;						// Burner device amount
	NET_DEV_BURNING		stDevs[DH_MAX_BURNING_DEV_NUM];	// Each burner device information 
} DH_BURNING_DEVINFO, *LPDH_BURNING_DEVINFO;

// Burner progress 
typedef struct _DH_BURNING_PROGRESS
{
	BYTE				bBurning;				// Burner status;0:ready to burn,1:burner types is not correct. It does not match. 
												// 2:there is no burner available(remainSpace is 0),3:There is burning in process,4:Burner is not free(It is backup or buring or playback.) 
	BYTE				bRomType;				// CD type;0:private file system,1:Portable HDD or flash disk,2:CD
	BYTE				bOperateType;			// Operation type;0:free,1:backup,2:burning,3:playback from the cd 
	BYTE				bType;					// Backup pr burning status:0:stop or end,1:start,2:error,3:full,4:initializing
	NET_TIME			stTimeStart;			// Begin time 
	DWORD				dwTimeElapse;			// Burning time(second)
	DWORD				dwTotalSpace;			// Total space
	DWORD				dwRemainSpace;			// Free space
	DWORD				dwBurned;				// Burned capacity 
	WORD				dwStatus;				// Reserved
	WORD				wChannelMask;			// The burning channel mask 
} DH_BURNING_PROGRESS, *LPDH_BURNING_PROGRESS;

// Log information. Corresponding to CLIENT_QueryLog
typedef struct _DH_LOG_ITEM
{
    DHDEVTIME			time;					// Date 
    unsigned short		type;					// Log Type, corresponding to DH_LOG_TYPE
    unsigned char		reserved;				// Reserved
    unsigned char		data;					// Data 
    unsigned char		context[8];				// Content
} DH_LOG_ITEM, *LPDH_LOG_ITEM;

// Log information. Corresponding to CLIENT_QueryLogEx, parameter reserved(int nType=1;reserved=&nType;)
typedef struct _DH_NEWLOG_ITEM
{
	DHDEVTIME			time;					// Date
	WORD				type;					// New Log Type, corresponding to DH_NEWLOG_TYPE
	WORD				data;					// data
	char				szOperator[8]; 			// User name 
	BYTE				context[16];		    // Content	
} DH_NEWLOG_ITEM, *LPDH_NEWLOG_ITEM;

// Log information. Corresponding to CLIENT_QueryDeviceLog
typedef struct _DH_DEVICE_LOG_ITEM
{
	int					nLogType;				// Log type 
	DHDEVTIME			stuOperateTime;			// Date
	char				szOperator[16]; 		// Operator
	BYTE				bReserved[3];
	BYTE				bUnionType;				// union structure type,0:szLogContext;1:stuOldLog
	union
	{
		char			szLogContext[64];		// Log content
		struct 
		{
			DH_LOG_ITEM		stuLog;				// Old log structure 
			BYTE			bReserved[48];		// Reserved
		}stuOldLog;
	};
	char				reserved[16];
} DH_DEVICE_LOG_ITEM, *LPDH_DEVICE_LOG_ITEM;

// new Log information. Corresponding to CLIENT_QueryDeviceLog
typedef struct _DH_DEVICE_LOG_ITEM_EX
{
	int					nLogType;				// Log type 
	DHDEVTIME			stuOperateTime;			// Date
	char				szOperator[16]; 		// Operator
	BYTE				bReserved[3];
	BYTE				bUnionType;				// union structure type,0:szLogContext;1:stuOldLog
	union
	{
		char			szLogContext[64];		// Log content
		struct 
		{
			DH_LOG_ITEM		stuLog;				// Old log structure 
			BYTE			bReserved[48];		// Reserved
		}stuOldLog;
	};
	char                szOperation[32];        // Detail operation
	char				szDetailContext[4 * 1024];  // DetailContext
} DH_DEVICE_LOG_ITEM_EX, *LPDH_DEVICE_LOG_ITEM_EX;

// Record log informaiton. Corresponding to the context of log structure 
typedef struct _LOG_ITEM_RECORD
{
	DHDEVTIME			time;					// Time 
	BYTE				channel;				// Channel
	BYTE				type;					// Record type
	BYTE				reserved[2];
} LOG_ITEM_RECORD, *LPLOG_ITEM_RECORD;

typedef struct _QUERY_DEVICE_LOG_PARAM
{
	 DH_LOG_QUERY_TYPE	emLogType;				// Searched log type
	 NET_TIME			stuStartTime;			// The searched log start time
	 NET_TIME			stuEndTime;				// The searched log end time. 
	 int				nStartNum;				// The search begins from which log in one period. It shall begin with 0 if it is the first time search.
	 int				nEndNum;				// The ended log serial number in one search,the max returning number is 1024 
	 BYTE                nLogStuType;           // log struct type,0:DH_DEVICE_LOG_ITEM;1:DH_DEVICE_LOG_ITEM_EX
	BYTE                reserved[3];            // Reserved
	unsigned int        nChannelID;             // Channel no. 0:Compatible with previous all channel numbers. The channel No. begins with 1.1: The first channel.
	BYTE				bReserved[40];
} QUERY_DEVICE_LOG_PARAM;

// Subscribe log type
typedef enum tagNET_EM_LOG_QUERY_TYPE
{
	EM_LOG_QUERY_TYPE_UNKNOWN,
	EM_LOG_QUERY_TYPE_TEXT = 1,             // text log type
}NET_EM_LOG_QUERY_TYPE;

// record information in the hard disk
typedef struct __DEV_DISK_RECORD_INFO 
{
	NET_TIME			stuBeginTime;			// The first time video
	NET_TIME			stuEndTime;				// Recently video
	char				reserved[128];
} DEV_DISK_RECORD_INFO;

// disk record time
typedef struct __DEV_DISK_RECORD_TIME
{
	NET_TIME             stuStartTime1;		    // start time 1
	NET_TIME	         stuEndTime1;			// end time 1
	BOOL	             bTwoPart;			    // have two part or not
	NET_TIME	         stuStartTime2;		    // start time 2
	NET_TIME	         stuEndTime2;			// end time 2
	BYTE			  	 bDiskNum;				// disk number 
	BYTE				 bSubareaNum;			// subarea num
	BYTE                 byReserved[62];        // reserved

}DEV_DISK_RECORD_TIME;

///////////////////////////////Control Related Definition///////////////////////////////
//new network keyboard control
typedef struct _NKB_PARAM
{
    BYTE                bAddressCode;           // for DVR and etc. device physical address no.,0xFF as broadcast address
    BYTE                bKeyStatus;             // status code 0/1 0 means press by key 1 means release key
    BYTE                bExtern1;               // expansion field 1
    BYTE                bExtern2;               // expansion field 2
    BYTE                bReserved[60];
}NKB_PARAM;

// HDD operation
typedef struct _DISKCTRL_PARAM
{
	DWORD				dwSize;					// Structure size. For version control.
	int					nIndex;					// Subscript of array stDisks of information structure DH_HARDDISK_STATE. It begins from 0. 
	int					ctrlType;				// Operation type
												// 0 -  clear data, 1 - set as read-write HDD , 2 -  set as read-only HDD
												// 3 - set as redundant , 4 - restore error , 5 -set as snapshot disk  
	NET_DEV_DISKSTATE	stuDisk;				// diskInfo, replace nIndex
} DISKCTRL_PARAM;

typedef struct  
{
	BYTE				bSubareaNum;			// The number of pre-partition
	BYTE				bIndex;					// Subscript of array stDisks of information structure DH_HARDDISK_STATE. It begins from 0. 
	BYTE				bSubareaSize[32];		// partition Size(Percentage)
	BYTE				bReserved[30];			// Reservations
} DISKCTRL_SUBAREA;

// Alarm status
typedef struct _ALARMCTRL_PARAM
{
	DWORD				dwSize;
	int					nAlarmNo;				// Alarm channel. It begins from 0. 
	int					nAction;				// 1:activate alarm,0:stop alarm  
} ALARMCTRL_PARAM;

// Matrix control 
typedef struct _MATRIXCTRL_PARAM
{
	DWORD				dwSize;
	int					nChannelNo;				// Video input number. It begins from  0.
	int					nMatrixNo;				// Matrix output number. It begins from 0
} MATRIXCTRL_PARAM;

// Burner control 
typedef struct _BURNING_PARM
{
	int					channelMask;			// channel subnet mask. Bit means the channel to be burned.
	BYTE				devMask;				// Burner subnet mask.  Use bit to represent according to the searched burner list 
	BYTE                bySpicalChannel;        // PIP channel(Channel No.+32)
	BYTE                byReserved[2];          // Reserved
} BURNNG_PARM;

// Annex burn
typedef struct _BURNING_PARM_ATTACH
{
	BOOL				bAttachBurn;			// Whether,0:Not; 1:Yes
	BYTE				bReserved[12];			// Reservations
} BURNING_PARM_ATTACH;

// Manual snap parameter
typedef struct  _MANUAL_SNAP_PARAMETER{
	int                 nChannel;               // snap channel,start with 0
	BYTE                bySequence[64];	        // snap sequence string
	BYTE                byReserved[60];         // reserved
}MANUAL_SNAP_PARAMETER;

// local preview split parameter
typedef struct _DEVICE_LOCALPREVIEW_SLIPT_PARAMETER
{
	int                 nSliptMode;            // split mode
	int                 nSubSliptNum;          // split num, start with 1
	BYTE                byReserved[64];        // reserved
}DEVICE_LOCALPREVIEW_SLIPT_PARAMETER;

// local preview split capability
typedef struct _DEVICE_LOCALPREVIEW_SLIPT_CAP
{
	int                 nModeNumber;
	int                 nSliptMode[36];        // split array
	BYTE                byReserved[64];        // reserved
}DEVICE_LOCALPREVIEW_SLIPT_CAP;

// Crossing information
typedef struct  _CROSSING_INFO
{
	char              szCrossingID[DH_MAX_CROSSING_ID];  // Crossing ID
	DWORD             dwLatitude;				// Latitude(0-180 Degree, North Latitude 30.183382 degree==120183382)
	DWORD             dwLongitude;				// Longitude(0-360 Degree,East Longitude 100.178274 degree==280178274)
	WORD              wSpeedLimit;				// limit speed(KM/H)
	BYTE 	          byReserved[22];
}CROSSING_INFO;

// Route crossing information
typedef struct  _ROUTE_CROSSING_INFO
{
	BYTE 			   byCrossingNum;             // valid number is 1~DH_MAX_CROSSING_NUM
	BYTE			   byReserved1; 
	WORD               wCrossingRange;            // Crossing range(m)
	CROSSING_INFO 	   stCrossingInfo[DH_MAX_CROSSING_NUM]; // Crossing information struct array
    BYTE			   byReserved2[2044];
}ROUTE_CROSSING_INFO;

// raid control
typedef struct _CTRL_RAID_INFO
{
	char				szAction[16];						// Add,Delete
	char				szName[16];							// Raid name
	int					nType;								// type 1:Jbod     2:Raid0      3:Raid1     4:Raid5
	int					nStatus;							// status 0:unknown ,1:active,2:degraded,3:inactive,4:recovering
	int					nCntMem;							// nMember count
	int					nMember[32];						// 1,2,3,... 
	int					nCapacity;							// capacity(G)
	int					nRemainSpace;						// remain space(M)
	int					nTank;								// tank 0:main,1:tank1,2:tank2.....
	char				reserved[128];
}CTRL_RAID_INFO;

// spake disk info
typedef struct _CTRL_SPARE_DISK_INFO
{
	char				szAction[16];						// Enable
	char				szScope[16];						// Global,Local
	char				szName[16];							// name
	unsigned int        nIndex;								// disk index
    const char*         pszDevName;                         // device name
    char                reserved[124];
}CTRL_SPARE_DISK_INFO;

typedef struct _CTRL_SPARE_DISK_INFO_A
{
	int						nCnt;							// count
	CTRL_SPARE_DISK_INFO	stSpaceDiskInfo[32];			// spare disk info array
}CTRL_SPARE_DISK_INFO_A;

// Alarm arm and disarm control
typedef struct __CTRL_ARM_DISARM_PARAM
{
	BYTE                bState;                             // Arm/disarm state, 0 means disarm, 1 means arm, 2 means forced arm
    char                reserve[3];
    const char*         szDevPwd;                           // User's Password
    NET_SCENE_MODE      emSceneMode;                        // Contextual Mode
    const char*         szDevID;                            // Forwarding the Target Device ID,Null=Non Forward
    char                reserve1[16];
} CTRL_ARM_DISARM_PARAM;

// alarm arm/disarm control expansion input parameter
typedef struct tagCTRL_ARM_DISARM_PARAM_EX_IN
{
    DWORD               dwSize;
    NET_ALARM_MODE      emState;                // arm/disarm status 
    const char*         szDevPwd;               // user password
    NET_SCENE_MODE      emSceneMode;            // scene mode 
    const char*         szDevID;                // transfer target device ID, as NULL means not transfer
} CTRL_ARM_DISARM_PARAM_EX_IN;

#define ARM_DISARM_ZONE_MAX (256)               // zone max number 

// alarm arm/disarm control expansion output parameter
typedef struct tagCTRL_ARM_DISARM_PARAM_EX_OUT
{
    DWORD               dwSize;
    DWORD               dwSourceNum;                    // alarm source input arming failed zone number 
    int                 nSource[ARM_DISARM_ZONE_MAX];   // alarm source input failed zone no.,zone no. start from 0
    DWORD               dwLinkNum;                      // link alarm arming failed zone number 
    int                 nLink[ARM_DISARM_ZONE_MAX];     // link alarm failed zone no., zone no. start from 0
} CTRL_ARM_DISARM_PARAM_EX_OUT;

// alarm arm/diarm control expansion(corresponding to DH_CTRL_ARMED_EX)
typedef struct tagCTRL_ARM_DISARM_PARAM_EX
{
    DWORD               dwSize;
    CTRL_ARM_DISARM_PARAM_EX_IN stuIn;                  // alarm arm/disarm control input
    CTRL_ARM_DISARM_PARAM_EX_OUT stuOut;                // alarm arm/disarm control output
} CTRL_ARM_DISARM_PARAM_EX;

typedef struct tagDHCTRL_CONNECT_WIFI_BYWPS_IN
{
	DWORD				dwSize;
	int                 nType;                         // WPS connect type,0:virtual buttons; 1:(device)pin; 2:(wifi hot point)pin
	char                szSSID[DH_MAX_SSID_LEN];       // when SSID,nType is 1 or 2,availability,biggest support 32-bit
	char                szApPin[DH_MAX_APPIN_LEN];     // APPIN, when nType = 2,availability,PIN is 8 digits,from the wife(hot point)
	char                szWLanPin[DH_MAX_APPIN_LEN];   // device pin,when nType = 1,availability.produced by the device when empty,not empty soecified by the user,need to increase in wifi
}DHCTRL_CONNECT_WIFI_BYWPS_IN;

typedef struct tagDHCTRL_CONNECT_WIFI_BYWPS_OUT
{
	DWORD				dwSize;
	char                szRetWLanPin[DH_MAX_APPIN_LEN];// return pin,when WPS's connect type is device end,this parameter is valid.
}DHCTRL_CONNECT_WIFI_BYWPS_OUT;

// CLIENT_ControlDevice interface DH_CTRL_WIFI_BY_WPS command parameter(WPS rapid configuration WIFI)
typedef struct tagDHCTRL_CONNECT_WIFI_BYWPS
{
	DWORD				dwSize;
	DHCTRL_CONNECT_WIFI_BYWPS_IN     stuWpsInfo;         // connect parameter(user to fill in)
	DHCTRL_CONNECT_WIFI_BYWPS_OUT    stuWpsResult;       // return data(device to return to)
} DHCTRL_CONNECT_WIFI_BYWPS;

// CLIENT_ControlDevice interface DH_CTRL_CLOSE_BURNER 
typedef struct tagNET_CTRL_BURNERDOOR
{
	DWORD		        dwSize;
	const char*         szBurnerName;                  // cd name,like "/dev/sda"
	BOOL                bResult;                       // operate result
    BOOL                bSafeEject;                    // Whether The Security Pop-up Drive, Data Save TRUE- pop Up Before, FALSE- Display)
}NET_CTRL_BURNERDOOR;

// CLIENT_ControlDevice interface DH_CTRL_START_PLAYAUDIO Order Parameter
typedef struct tagNET_CTRL_START_PLAYAUDIO
{
    DWORD               dwSize;
    char                szAudioPath[DH_MAX_AUDIO_PATH];
}NET_CTRL_START_PLAYAUDIO;

// report unit type
typedef enum tagNET_PLAYAUDIO_TYPE
{
    NET_PLAYAUDIO_TYPE_UNKNOWN = 0,
    NET_PLAYAUDIO_TYPE_PHRASE,                          // message type, no analysis, read in order, supported by audio file
    NET_PLAYAUDIO_TYPE_FILE,                            // play specific path audiofile(device complete path)
    NET_PLAYAUDIO_TYPE_PLATERNUM,                       // report plate no, read by plate format
    NET_PLAYAUDIO_TYPE_MONEY,                           // report amount, read byamount format
    NET_PLAYAUDIO_TYPE_DATE,                            // report date, read by date format
    NET_PLAYAUDIO_TYPE_TIME,                            // report time, read by time format
    NET_PLAYAUDIO_TYPE_EMPTY,                           // null type, stop one character time
}NET_PLAYAUDIO_TYPE;


// play priority
typedef enum tagEM_PLAYAUDIO_PRIORITY
{
	EM_PLAYAUDIO_PRIORITY_UNKNOWN,						// unknown		
	EM_PLAYAUDIO_PRIORITY_FRONT,						// insert to the front of the play queue and play the original file after the insert file finished
	EM_PLAYAUDIO_PRIORITY_BACK,							// Insert to the end of the play queue and wait for other files to play before playing the file.
	EM_PLAYAUDIO_PRIORITY_EMERGENCY,					// same as EM_PLAYAUDIO_PRIORITY_FRONT, but cancel the original file
}EM_PLAYAUDIO_PRIORITY;


// audio report content
typedef struct tagNET_CTRL_PLAYAUDIO_INFO
{
    DWORD               		dwSize;
    NET_PLAYAUDIO_TYPE  		emPlayAudioType;                // report unit type,see NET_PLAYAUDIO_TYPE
    char                		szDetail[DH_COMMON_STRING_128]; // detailed content type detail:
		                                                        // Phrase type:"Welcome"
		                                                        // File type: "/home/parking.pcm"
		                                                        // PlateNumbe type: "AA12345"
		                                                        // Money type: "80.12 yuan"
		                                                        // Date type: "2014/4/10"
		                                                        // Time type : "1 day 10 hours 20 min 5 seconds
	int							nRepeatTimes;					// play repeat times
	EM_PLAYAUDIO_PRIORITY		emPriority;						// play priority
}NET_CTRL_PLAYAUDIO_INFO;

#define DH_MAX_PLAYAUDIO_COUNT    16  // max report content items
// CLIENT_ControlDevice port DH_CTRL_START_PLAYAUDIOEX command parameter
typedef struct tagNET_CTRL_START_PLAYAUDIOEX
{
    DWORD                       dwSize;
    unsigned int                nAudioCount;                            // report content quantity               
    NET_CTRL_PLAYAUDIO_INFO     stuAudioInfos[DH_MAX_PLAYAUDIO_COUNT];  // audioplay content
}NET_CTRL_START_PLAYAUDIOEX;

// CLIENT_ControlDevice port DH_CTRL_START_ALARMBELL, DH_CTRL_STOP_ALARMBELL command parameter
typedef struct tagNET_CTRL_ALARMBELL
{
    DWORD               dwSize;
    int                 nChannelID;             // Channel ID (start from 0)            
}NET_CTRL_ALARMBELL;

// Access controller -- Open door type
typedef enum tagEM_OPEN_DOOR_TYPE
{
	EM_OPEN_DOOR_TYPE_UNKNOWN = 0,
	EM_OPEN_DOOR_TYPE_REMOTE,						// Remote
	EM_OPEN_DOOR_TYPE_LOCAL_PASSWORD,				// Local_Password
	EM_OPEN_DOOR_TYPE_LOCAL_CARD,					// Local_Card
	EM_OPEN_DOOR_TYPE_LOCAL_BUTTON,					// Local_Button
}EM_OPEN_DOOR_TYPE;

// open door direction
typedef enum tagEM_OPEN_DOOR_DIRECTION
{
	EM_OPEN_DOOR_DIRECTION_UNKNOWN,						// unknown, device control
	EM_OPEN_DOOR_DIRECTION_FROM_ENTER,					// open from enter direction
	EM_OPEN_DOOR_DIRECTION_FROM_LEAVE,					// open from enter direction
}EM_OPEN_DOOR_DIRECTION;

// CLIENT_ControlDevice's param: DH_CTRL_ACCESS_OPEN
typedef struct tagNET_CTRL_ACCESS_OPEN
{
    DWORD               		dwSize;
    int                 		nChannelID;                     // Channel ID (start from 0) 
    const char*         		szTargetID;                     // Target ID, NULL equals to not transmit    
    char						szUserID[MAX_COMMON_STRING_32];	// remote user id
	EM_OPEN_DOOR_TYPE			emOpenDoorType;                 // open door type
	EM_OPEN_DOOR_DIRECTION		emOpenDoorDirection;			// open door direction
}NET_CTRL_ACCESS_OPEN;

// the enum for work mode of door
typedef enum tagEM_NET_DOOR_WORK_MODE_TYPE
{
    NET_DOOR_WORK_MODE_UNKNOWN,            // Unknown
	NET_DOOR_WORK_MODE_NORMAL,             // Normal
	NET_DOOR_WORK_MODE_SHUTDOWN,           // shutdown
	NET_DOOR_WORK_MODE_UNUSED,             // unused
	NET_DOOR_WORK_MODE_OPEN_DOOR_CONTINUE, // continued opening

}EM_NET_DOOR_WORK_MODE_TYPE;

// the input param for setting the work mode of door
typedef struct tagNET_IN_CTRL_ACCESS_SET_DOOR_WORK_MODE
{
	DWORD                   dwSize;
	EM_NET_DOOR_WORK_MODE_TYPE emWorkMode;    // the work mode
}NET_IN_CTRL_ACCESS_SET_DOOR_WORK_MODE;

// the output param for setting the work mode of door
typedef struct tagNET_OUT_CTRL_ACCESS_SET_DOOR_WORK_MODE
{
    DWORD                   dwSize;
}NET_OUT_CTRL_ACCESS_SET_DOOR_WORK_MODE;

// the input param for synchronizing the cabin led's time
typedef struct tagNET_IN_CTRL_SYNC_CABINLED_TIME
{
    DWORD                   dwSize;
}NET_IN_CTRL_SYNC_CABINLED_TIME;

// the output param for synchronizing the cabin led's time
typedef struct tagNET_OUT_CTRL_SYNC_CABINLED_TIME
{
    DWORD                   dwSize;
}NET_OUT_CTRL_SYNC_CABINLED_TIME;

// the enum for control mode of playing the cabin led
typedef enum tagEM_NET_CABIN_LED_PLAY_CONTROL_MODE
{
    NET_CABIN_LED_PLAY_CONTROL_MODE_UNKNOWN,          // Unknown
    NET_CABIN_LED_PLAY_CONTROL_MODE_NORMAL_TURN_ON,   // Normal mode (turn on the screen)
    NET_CABIN_LED_PLAY_CONTROL_MODE_NEXT_PROGRAM,     // Next program      
    NET_CABIN_LED_PLAY_CONTROL_MODE_PREVIOUS_PROGRAM, // Pre program
    NET_CABIN_LED_PLAY_CONTROL_MODE_PAUSE,            // Pause
    NET_CABIN_LED_PLAY_CONTROL_MODE_PAUSE_TURN_OFF,   // Pause (turn off the screen)
    NET_CABIN_LED_PLAY_CONTROL_MODE_PLAY_GO_ON,       // Go on playing
    NET_CABIN_LED_PLAY_CONTROL_MODE_GO_TO_TEST_ITSELF,// Go to test itself
    NET_CABIN_LED_PLAY_CONTROL_MODE_EXIT_TEST_ITSELF, // Exit testing itself
    NET_CABIN_LED_PLAY_CONTROL_MODE_SYSTEM_RESET,     // Reset the system
}EM_NET_CABIN_LED_PLAY_CONTROL_MODE;

// the input param for play and control the cabin led
typedef struct tagNET_IN_CTRL_CABINLED_PLAYCONTROL
{
    DWORD                                   dwSize;
    EM_NET_CABIN_LED_PLAY_CONTROL_MODE      emAction; // Play mode
}NET_IN_CTRL_CABINLED_PLAYCONTROL;

// the output param for play and control the cabin led
typedef struct tagNET_OUT_CTRL_CABINLED_PLAYCONTROL
{
    DWORD                   dwSize;
}NET_OUT_CTRL_CABINLED_PLAYCONTROL;

// the enum for cmd of modify the cabin led's content
typedef enum tagEM_NET_CABIN_LED_MODIFY_CONTENT_CMD_TYPE
{
    NET_CABIN_LED_MODIFY_CONTENT_CMD_TYPE_UNKNOWN,
    NET_CABIN_LED_MODIFY_CONTENT_CMD_TYPE_ADD       = 0, // Add
    NET_CABIN_LED_MODIFY_CONTENT_CMD_TYPE_MODIFY    = 1, // Modify
    NET_CABIN_LED_MODIFY_CONTENT_CMD_TYPE_DELETE    = 2, // Delete
}EM_NET_CABIN_LED_MODIFY_CONTENT_CMD_TYPE;

// the enum for effect of modify the cabin led's content
typedef enum tagEM_NET_CABIN_LED_MODIFY_CONTENT_EFFECT_TYPE
{
    NET_MODIFY_CONTENT_EFFECT_TYPE_UNKNOWN = -1,
    NET_MODIFY_CONTENT_EFFECT_TYPE_SHOW = 0,                      // Show normal
    NET_MODIFY_CONTENT_EFFECT_TYPE_MOVE_LEFT,                     // Move to left
    NET_MODIFY_CONTENT_EFFECT_TYPE_MOVE_RIGHT,                    // Move to right
    NET_MODIFY_CONTENT_EFFECT_TYPE_MOVE_UP,                       // Move to up
    NET_MODIFY_CONTENT_EFFECT_TYPE_MOVE_DOWN,                     // Move to down
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_LEFT,                  // Fill up the left
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_RIGHT,                 // Fill up the right
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_UP,                    // Fill up the up
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_DOWN,                  // Fill up the down
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_UP_LEFT,               // Fill up the up-left
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_DOWN_LEFT,             // Fill up the down-left
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_UP_RIGHT,              // Fill up the up-right
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_DOWN_RIGHT,            // Fill up the down-right
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_LEFT_RIGHT_TO_CENTER,  // Fill up from left-right to center
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_CENTER_TO_LEFT_RIGHT,  // Fill up from center to left-right
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_UP_DOWN_TO_CENTER,     // Fill up from up-down to center
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_CENTER_TO_UP_DOWN,     // Fill up from center to up-down
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_LEFT_CROSS_RIGHT,      // Fill up with cross left-right
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_UP_CROSS_DOWN,         // Fill up with cross up-down
    NET_MODIFY_CONTENT_EFFECT_TYPE_VERTICAL_BLINDS,               // Vertical_blinds
    NET_MODIFY_CONTENT_EFFECT_TYPE_HORIZONTAL_BLINDS,             // Horizontal_blinds  
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_CENTER_TO_SIDES,       // Fill up from center to sides
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_SIDES_TO_CENTER,       // Fill up from sides to center
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_CENTER_TO_CORNER,      // Fill up from center to corner
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_CORNER_TO_CENTER,      // Fill up from corner to center
    NET_MODIFY_CONTENT_EFFECT_TYPE_ROTATE_360,                    // Rotate 360
    NET_MODIFY_CONTENT_EFFECT_TYPE_ROTATE_180,                    // Rotate_180
}EM_NET_CABIN_LED_MODIFY_CONTENT_EFFECT_TYPE;

// the input param for modify the cabin led's content
typedef struct tagNET_IN_CTRL_CABINLED_MODIFY_CONTENT
{
    DWORD                                    dwSize;
    EM_NET_CABIN_LED_MODIFY_CONTENT_CMD_TYPE emCmd;             // Cmd type
    int                                      nMsgID;            // Msg id,range from 1 to 5
    EM_NET_CABIN_LED_MODIFY_CONTENT_EFFECT_TYPE emEffect;       // Effect type
    int                                      nSpeed;            // Show speed,range of 0 to 15
    int                                      nDuration;         // Duration time,Unit:second   
    char                                     szText[512];       // Text data
}NET_IN_CTRL_CABINLED_MODIFY_CONTENT;

// the output param for modify the cabin led's content
typedef struct tagNET_OUT_CTRL_CABINLED_MODIFY_CONTENT
{
    DWORD                   dwSize;
}NET_OUT_CTRL_CABINLED_MODIFY_CONTENT;

// the input param for get the cabin led's content
typedef struct tagNET_IN_CTRL_CABINLED_GET_CONTENT
{
    DWORD                   dwSize;    
    int                     nMsgID;            // Msg id,range from 1 to 5   
}NET_IN_CTRL_CABINLED_GET_CONTENT;

// the output param for get the cabin led's content
typedef struct tagNET_OUT_CTRL_CABINLED_GET_CONTENT
{
    DWORD                   dwSize;
    int                     nMsgID;            // Msg id,range from 1 to 5
    EM_NET_CABIN_LED_MODIFY_CONTENT_EFFECT_TYPE emEffect;          // Effect type
    int                     nSpeed;            // Show speed,range of 0 to 15
    int                     nDuration;         // Duration time,Unit:second
    char                    szText[512];       // Text data
}NET_OUT_CTRL_CABINLED_GET_CONTENT;

// Time period structure 															    
typedef struct tagDH_TSECT
{
    int				bEnable;	    // Current record period . Bit means the four Enable functions. From the low bit to the high bit:Motion detection record, alarm record and general record, when Motion detection and alarm happened at the same time can record.
									// used in NET_POS_EVENT_LINK, it means enable;
    int				iBeginHour;
    int				iBeginMin;
    int				iBeginSec;
    int				iEndHour;
    int				iEndMin;
    int				iEndSec;
} DH_TSECT, *LPDH_TSECT;

#define NET_CABINLED_SCHEDULE_TIME_SECTION_NUM 8  // the max count for time schedule of cabin led

// the input param for set the cabin led's time schedule
typedef struct tagNET_IN_CTRL_CABINLED_SET_SCHEDULE
{
    DWORD                       dwSize;    
    int                         nIndex;                                                 // the index, zero for Sunday 1-6 mins Monday to Saturday    
    DH_TSECT                    stuTimeSection[NET_CABINLED_SCHEDULE_TIME_SECTION_NUM]; // the array of time schedule
                                                                                        // the bEnable in DH_TSECT: zero for invalid msg id, greater than zero for valid msg id

}NET_IN_CTRL_CABINLED_SET_SCHEDULE;

// the out param for set the cabin led's time schedule
typedef struct tagNET_OUT_CTRL_CABINLED_SET_SCHEDULE
{
    DWORD dwSize;   
}NET_OUT_CTRL_CABINLED_SET_SCHEDULE;

// the input param for get the cabin led's time schedule
typedef struct tagNET_IN_CTRL_CABINLED_GET_SCHEDULE
{
    DWORD                       dwSize;    
    int                         nIndex;                                                 // the index, zero for Sunday 1-6 mins Monday to Saturday 
}NET_IN_CTRL_CABINLED_GET_SCHEDULE;

// the out param for get the cabin led's time schedule
typedef struct tagNET_OUT_CTRL_CABINLED_GET_SCHEDULE
{
    DWORD dwSize;
    DH_TSECT                    stuTimeSection[NET_CABINLED_SCHEDULE_TIME_SECTION_NUM]; // the array of time schedule
                                                                                        // the bEnable in DH_TSECT: zero for invalid msg id, greater than zero for valid msg id
}NET_OUT_CTRL_CABINLED_GET_SCHEDULE;

// the in param for get the cabin led's char encoding
typedef struct tagNET_IN_CTRL_CABINLED_GET_CHAR_ENCODING
{
    DWORD                       dwSize;                     // Size in bytes of the specified structure. This member must be set.    
}NET_IN_CTRL_CABINLED_GET_CHAR_ENCODING;

// the out param for get the cabin led's char encoding
typedef struct tagNET_OUT_CTRL_CABINLED_GET_CHAR_ENCODING
{
    DWORD dwSize;                                           // Size in bytes of the specified structure. This member must be set.
    int nCharacterEncoding;                                 // the char encoding, 0-GB2312 1-Unicode                         
}NET_OUT_CTRL_CABINLED_GET_CHAR_ENCODING;


// the type of control caibin led
typedef enum tagEM_CABIN_LED_CONTROL_TYPE
{
    DH_CABIN_LED_CONTROL_UNKNOWN,                       // Unknown                  
    DH_CABIN_LED_CONTROL_SYNC_TIME,                     // Synchronize the time of cabin led (pInParam corresponding structure NET_IN_CTRL_SYNC_CABINLED_TIME,pOutParam corresponding structure NET_OUT_CTRL_SYNC_CABINLED_TIME)
    DH_CABIN_LED_CONTROL_PLAY_CONTROL,                  // Control the play mode of cabin led (pInParam corresponding structure NET_IN_CTRL_CABINLED_PLAYCONTROL,pOutParam corresponding structure NET_OUT_CTRL_CABINLED_PLAYCONTROL)
    DH_CABIN_LED_CONTROL_MODIFY_CONTENT,                // Modify the content of cabin led (pInParam corresponding structure NET_IN_CTRL_CABINLED_MODIFY_CONTENT,pOutParam corresponding structure NET_OUT_CTRL_CABINLED_MODIFY_CONTENT)
    DH_CABIN_LED_CONTROL_GET_CONTENT,                   // Modify the content of cabin led(pInParam corresponding structureNET_IN_CTRL_CABINLED_GET_CONTENT ,pOutParam corresponding structureNET_OUT_CTRL_CABINLED_GET_CONTENT)
    DH_CABIN_LED_CONTROL_SET_SCHEDULE,                  // Set the time schedule of cabin led(pInParam corresponding structureNET_IN_CTRL_CABINLED_SET_SCHEDULE ,pOutParam corresponding structureNET_OUT_CTRL_CABINLED_SET_SCHEDULE)
    DH_CABIN_LED_CONTROL_GET_SCHEDULE,                  // Get the time schedjle of cabin led(pInParam corresponding structureNET_IN_CTRL_CABINLED_GET_SCHEDULE ,pOutParam corresponding structureNET_OUT_CTRL_CABINLED_GET_SCHEDULE)
    DH_CABIN_LED_CONTROL_GET_CHAR_ENCODING,             // Get the char encoding of cabin led(pInParam corresponding structure NET_IN_CTRL_CABINLED_GET_CHAR_ENCODING ,pOutParam corresponding structureNET_OUT_CTRL_CABINLED_GET_CHAR_ENCODING)

}EM_CABIN_LED_CONTROL_TYPE;


// CLIENT_ControlDevice's param: DH_CTRL_ACCESS_CLOSE
typedef struct tagNET_CTRL_ACCESS_CLOSE
{
    DWORD						dwSize;					// struct size
    int							nChannelID;             // Channel ID (start from 0) 
}NET_CTRL_ACCESS_CLOSE;

typedef enum tagNET_ALARM_TYPE
{
    NET_ALARM_LOCAL = 0,                        // SwitchingValue Defence Area's Alarm Information
    NET_ALARM_ALARMEXTENDED,                    // Expand Module Alarm Event)
    NET_ALARM_TEMP,                             // Temperature Alarm Event)
    NET_ALARM_URGENCY,                          // Emergency Alarm Event)
    NET_ALARM_RCEMERGENCYCALL,                  // Emergency call alarm event (corresponding to DH_ALARM_RCEMERGENCY_CALL event )
    NET_ALARM_ALL,                              // ALL Alarm Event
}NET_ALARM_TYPE;

// CLIENT_ControlDevice's param: DH_CTRL_CLEAR_ALARM
typedef struct tagNET_CTRL_CLEAR_ALARM
{
    DWORD               dwSize;
    int                 nChannelID;             // Defence Area's ID, -1 means all Channel
    NET_ALARM_TYPE      emAlarmType;            // Event Type
    const char*         szDevPwd;               // Landing Equipment Such As Password, Do not Use Encryption Disappear the Police, Direct Assignment of NULL
    BOOL                bEventType;             // Means if enable nEventType field, TRUE:nEventType replaces emAlarmType field, FALSE: use emAlarmType field , ignore nEventType field 
    int                 nEventType;             // Event type, corresponding fMessCallBack called lCommand field , as CLIENT_StartListenEx port got event type
                                                // Such as DH_ALARM_ALARM_EX2 means local alarm event
}NET_CTRL_CLEAR_ALARM;

// TV Wall Display Information Control Parameters
typedef struct tagNET_CTRL_MONITORWALL_TVINFO 
{
    DWORD               dwSize;
    int                 nMonitorWallID;         // TV Wall ID, fill in DH_CTRL_MONITORWALL_TVINFO and DH_DEVSTATE_MONITORWALL_TVINFO
    BOOL                bDecodeChannel;         // Display Decoding Channel Information, fill in DH_CTRL_MONITORWALL_TVINFO
    BOOL                bControlID;             // Display Screen ID, fill in DH_CTRL_MONITORWALL_TVINFO
    BOOL                bCameraID;              // Camera ID, fill in DH_CTRL_MONITORWALL_TVINFO
} NET_CTRL_MONITORWALL_TVINFO;

// CLIENT_ControlDevice's param: DH_CTRL_START_VIDEO_ANALYSE
typedef struct tagNET_CTRL_START_VIDEO_ANALYSE
{
    DWORD               dwSize; 
    int                 nChannelId;             // Channel ID  
}NET_CTRL_START_VIDEO_ANALYSE;

// CLIENT_ControlDevice's param: DH_CTRL_STOP_VIDEO_ANALYSE 
typedef struct tagNET_CTRL_STOP_VIDEO_ANALYSE
{
    DWORD               dwSize; 
    int                 nChannelId;             // Channel ID  
}NET_CTRL_STOP_VIDEO_ANALYSE;

// CLIENT_ControlDevice's param DH_CTRL_MULTIPLAYBACK_CHANNALES 
typedef struct tagNET_CTRL_MULTIPLAYBACK_CHANNALES
{
    DWORD               dwSize;
    LLONG               lPlayBackHandle;        // Playback Handle, CLIENT_MultiPlayBack Returns the Value
    int                 nChannels[DH_MAX_MULTIPLAYBACK_CHANNEL_NUM];// Preview Channel ID
    int                 nChannelNum;            // Preview Channel Number 
}NET_CTRL_MULTIPLAYBACK_CHANNALES;

// CLIENT_ControlDevice's param: DH_CTRL_SET_BYPASS 
typedef struct tagNET_CTRL_SET_BYPASS
{
    DWORD               dwSize;
    const char*         szDevPwd;               // Login Device Password
    NET_BYPASS_MODE     emMode;                 // Channel Statue
    int                 nLocalCount;            // Local Alarm Input Channel Number
    int*                pnLocal;                // Local Alarm Input Channel ID    
    int                 nExtendedCount;         // Expand Module Alarm Input Channel Number
    int*                pnExtended;             // Expand Module Alarm Input Channel ID
}NET_CTRL_SET_BYPASS;

// CLIENT_ControlDevice's param: DH_CTRL_SET_MEDIAKIND 
typedef struct tagNET_CTRL_SET_MEDIAKIND
{
    DWORD                dwSize;                        //  set dwSize to sizeof(NET_CTRL_SET_MEDIAKIND)
    int                  nMediaKind;                    //  media type,0:video and audio,1:video only,2:audio only
    DWORD                dwChannelCount;                //  channel count
    int                  nChannels[256];                //  video channel (start form 0)
} NET_IN_SET_MEDIAKIND;

// CLIENT_ControlDevice's param: DH_CTRL_SET_MEDIAKIND 
typedef struct tagNET_OUT_SET_MEDIAKIND
{
    DWORD                dwSize;                        //  set dwSize to sizeof(NET_OUT_SET_MEDIAKIND)
} NET_OUT_SET_MEDIAKIND;

// CLIENT_QueryDevState's param: DH_DEVSTATE_GET_BYPASS 
typedef struct tagNET_DEVSTATE_GET_BYPASS
{
    DWORD               dwSize;
    int                 nLocalCount;            // Local Alarm Input Channel Number
    int*                pnLocal;                // Local Alarm Input Channel ID    
    int                 nExtendedCount;         // Expand Module Alarm Input Channel Number
    int*                pnExtended;             // Expand Module Alarm Input Channel ID
    NET_BYPASS_MODE*    pemLocal;               // Local Alarm Input Channel Statue
    NET_BYPASS_MODE*    pemExtended;            // Expand Module Alarm Input Channel Statue
}NET_DEVSTATE_GET_BYPASS;

// CLIENT_QueryDevState's param: DH_DEVSTATE_BURNERDOOR 
typedef struct tagNET_DEVSTATE_BURNERDOOR
{
	DWORD		        dwSize;
	const char*         szBurnerName;                  // cd name,like "/dev/sda"
	bool                bEjected;                      // ejected or not
	BYTE				Reserved[3];			       // reserved
}NET_DEVSTATE_BURNERDOOR;

// CLIENT_QueryDevState iterface DH_DEVSTATE_GET_DATA_CHECK
typedef struct tagNET_DEVSTATE_DATA_CHECK
{
    DWORD		        dwSize;                     // struct size
    const char*         szBurnerName;               // cd name,like"/dev/s",if it is multiple track, including one of path is ok
    char                szState[DH_MAX_STRING_LEN]; // "NotStart" "Verifying" "Failed" "Succeed"
    int                 nPercent;                   // check percent:0-100,when state  = Verifying,availability.
}NET_DEVSTATE_DATA_CHECK;

// CLIENT_ListenServer backcall interface, fServiceCallBack support command mode
enum { 
	DH_DVR_DISCONNECT=-1,	                        // Device disconnection callback during the verification period
	DH_DVR_SERIAL_RETURN=1,                         // Device send out SN callback char* szDevSerial
	NET_DEV_AUTOREGISTER_RETURN,                    // when device registering,serial number and token to carry, corresponding NET_CB_AUTOREGISTER
    NET_DEV_NOTIFY_IP_RETURN,                       // Equipment is only reported IP, not used for active registration
};
typedef struct tagNET_CB_AUTOREGISTER
{
	DWORD			dwSize;                          // struct size
	char            szDevSerial[DH_DEV_SERIALNO_LEN];// device serial
	char            szToken[MAX_PATH];               // token
}NET_CB_AUTOREGISTER;

// public agency registration
typedef struct tagCLOUDSERVICE_CONNECT_PARAM
{
	DWORD               dwSize;   
	char                szDstIp[DH_MAX_IPADDR_EX_LEN];    // server IP
	int                 nDstPort;                         // server port 
	DWORD               dwConnectType;                    // connect type,0:main connect, 1:the tunnel connection,2:data connect,3:dynamic registration link(use 0xb4)
	char                szToken[MAX_PATH];                // the only id token
}NET_CLOUDSERVICE_CONNECT_PARAM;

typedef struct tagCLOUDSERVICE_CONNECT_RESULT
{
	DWORD               dwSize;  
	DWORD               dwConnectState;                   // connect state ,1 succeed, 2 failed
	char                szMessage[DH_MAX_CLOUDCONNECT_STATE_LEN]; // connect status info,"Success","Password Error","Network Error","Timeout"
}NET_CLOUDSERVICE_CONNECT_RESULT;
///////////////////////////////definition of configuration///////////////////////////////

//-------------------------------Device Property ---------------------------------
// Device information 
typedef struct
{
	BYTE				sSerialNumber[DH_SERIALNO_LEN];	// SN
	BYTE				byAlarmInPortNum;		// DVR alarm input amount
	BYTE				byAlarmOutPortNum;		// DVR alarm output amount
	BYTE				byDiskNum;				// DVR HDD amount 
	BYTE				byDVRType;				// DVR type.Please refer to NET_DEVICE_TYPE
    union
    {
	BYTE				byChanNum;				// DVR channel amount 
        BYTE            byLeftLogTimes;         // When login failed due to password error, notice user via this parameter, remaining login times, is 0 means this parameter is invalid
    };
} NET_DEVICEINFO, *LPNET_DEVICEINFO;

// Device extension info 
typedef struct tagNET_DEVICEINFO_Ex
{
    BYTE                sSerialNumber[DH_SERIALNO_LEN];	    // serial number
    int	                nAlarmInPortNum;                    // count of DVR alarm input
    int	                nAlarmOutPortNum;                   // count of DVR alarm output
    int	                nDiskNum;                           // number of DVR disk
    int	                nDVRType;                           // DVR type, refer to NET_DEVICE_TYPE
    int                 nChanNum;                           // number of DVR channel
    BYTE                byLimitLoginTime;                   // Online Timeout, Not Limited Access to 0, not 0 Minutes Limit Said
    BYTE                byLeftLogTimes;                     // When login failed due to password error, notice user via this parameter, remaining login times, is 0 means this parameter is invalid
    BYTE                bReserved[2];                       // keep bytes, bytes aligned
    int                 nLockLeftTime;                      // when log in failed, the left time for users to unlock (seconds), -1 indicate the device haven't set the parameter 
    char                Reserved[24];                       // reserved
} NET_DEVICEINFO_Ex, *LPNET_DEVICEINFO_Ex;

//Device software version information. The higher 16-bit means the main version number and low 16-bit means second version number. 
typedef struct 
{
	DWORD				dwSoftwareVersion;
	DWORD				dwSoftwareBuildDate;
	DWORD				dwDspSoftwareVersion;
	DWORD				dwDspSoftwareBuildDate;
	DWORD				dwPanelVersion;
	DWORD				dwPanelSoftwareBuildDate;
	DWORD				dwHardwareVersion;
	DWORD				dwHardwareDate;
	DWORD				dwWebVersion;
	DWORD				dwWebBuildDate;
} DH_VERSION_INFO, *LPDH_VERSION_INFO;

// Device software version information. Corresponding to CLIENT_QueryDevState
typedef struct  
{
	char				szDevSerialNo[DH_DEV_SERIALNO_LEN];	// Serial number 
	char				byDevType;							// Device type, please refer to NET_DEVICE_TYPE
	char				szDevType[DH_DEV_TYPE_LEN];			// Device detailed type. String format. It may be null.
	int					nProtocalVer;						// Protocol version number 
	char				szSoftWareVersion[DH_MAX_URL_LEN];
	DWORD				dwSoftwareBuildDate;
    char                szPeripheralSoftwareVersion[DH_MAX_URL_LEN];// From the Slice Version Information, The String Format, May Be Empty
    DWORD               dwPeripheralSoftwareBuildDate;
    char                szGeographySoftwareVersion[DH_MAX_URL_LEN]; // Geographical Iinformation Positioning Chip Version Information, The String Format, May Be empty
    DWORD               dwGeographySoftwareBuildDate;
	char				szHardwareVersion[DH_MAX_URL_LEN];
	DWORD				dwHardwareDate;
	char				szWebVersion[DH_MAX_URL_LEN];
	DWORD				dwWebBuildDate;
    char                szDetailType[MAX_COMMON_STRING_64];          // Device detailed type. String format. It may be null.
	char				reserved[192];
} DHDEV_VERSION_INFO;

// DSP capacity description. Correspondign to CLIENT_GetDevConfig
typedef struct 
{
	DWORD				dwVideoStandardMask;	// video format mask. Bit stands for the video format device supported.
	DWORD				dwImageSizeMask;		// Resolution mask bit. Bit stands for the resolution setup devices supported.
	DWORD				dwEncodeModeMask;		// Encode mode mask bit. Bit stands for the encode mode devices supported.
	DWORD				dwStreamCap;			// The multiple-media function the devices supported
												// The first bit:main stream
												// The second bit:extra stream 1
												// The third bit:extra stream 2
												// The fifth bit: snapshot in .jpg format
	DWORD				dwImageSizeMask_Assi[8];// When the main stream is the corresponding resolution, the supported extra stream resolution mask.
	DWORD				dwMaxEncodePower;		// The highest encode capacity DSP supported
	WORD				wMaxSupportChannel;		// The max video channel amount each DSP supported.
	WORD				wChannelMaxSetSync;		// Max encode bit setup in each DSP channel  are synchronized or not ;0:does not synchronized,1:synchronized
} DH_DSP_ENCODECAP, *LPDH_DSP_ENCODECAP;

// DSP capacity description. Extensive type. Corresponding to CLIENT_QueryDevState
typedef struct 
{
	DWORD				dwVideoStandardMask;	// video format mask. Bit stands for the video format device supported.
	DWORD				dwImageSizeMask;		// Resolution mask bit. Bit stands for the resolution setup devices supported.
	DWORD				dwEncodeModeMask;		// Encode mode mask bit. Bit stands for the encode mode devices supported.
	DWORD				dwStreamCap;			// The multiple-media function the devices supported
												// The first bit:main stream
												// The second bit:extra stream 1
												// The third bit:extra stream 2
												// The fifth bit: snapshot in .jpg format
	DWORD				dwImageSizeMask_Assi[32];// When the main stream is the corresponding resolution, the supported extra stream resolution mask.
	DWORD				dwMaxEncodePower;		// The highest encode capacity DSP supported
	WORD				wMaxSupportChannel;		// The max video channel amount each DSP supported.
	WORD				wChannelMaxSetSync;		// Max encode bit setup in each DSP channel  are synchronized or not;0:do not synchronized,1:synchronized
	BYTE				bMaxFrameOfImageSize[32];// The max sampling frame rate in different resolution. Bit corresponding to the dwVideoStandardMask.
	BYTE				bEncodeCap;				// Symbol. The configuration shall meet the following requirements, otherwise the configuration is invalid.
												// 0:main stream encode capacity+extra stream encode capacity<= device encode capacity 
												// 1:main stream encode capacity +extra stream encode capacity<= device encode capacity 
												// Extra stream encode capacity <=main stream encode capacity 
												// Extra stream resolution<=main stream resolution 
												// Main stream resolution and extra stream resolution <=front-end video collection frame rate
												// 2:N5 Device
												// Extra stream encode capacity <=main stream encode capacity
												// Query  the supported resolution and the corresponding maximum frame rate
	char				reserved[95];
} DHDEV_DSP_ENCODECAP, *LPDHDEV_DSP_ENCODECAP;

// DSP extend capacity description. Corresponding to CLIENT_QueryDevState
typedef struct 
{
	DWORD				dwVideoStandardMask;	// video format mask. Bit stands for the video format device supported.
	DWORD				dwImageSizeMask;		// Resolution mask bit. Bit stands for the resolution setup devices supported.
	DWORD				dwEncodeModeMask;		// Encode mode mask bit. Bit stands for the encode mode devices supported.
	DWORD				dwStreamCap;			// The multiple-media function the devices supported.
												// The first bit:main stream
												// The second bit:extra stream 1
												// The third bit:extra stream 2
												// The forth bit:extra stream 3
												// The fifth bit: snapshot in .jpg format
	DWORD				dwImageSizeMask_Assi[3][64];// When the main stream is the corresponding resolution, the supported extra stream resolution mask, the 0,1,2 member in the group correspond extra stream1,2,3
	DWORD				dwMaxEncodePower;		// The highest encode capacity DSP supported
	WORD				wMaxSupportChannel;		// The max video channel amount each DSP supported.
	WORD				wChannelMaxSetSync;		// Max encode bit setup in each DSP channel  are synchronized or not;0:do not synchronized,1:synchronized
	BYTE				bMaxFrameOfImageSize[32];// The max sampling frame rate in different resolution. Bit corresponding to the dwVideoStandardMask.
	BYTE				bEncodeCap;				// Symbol. The configuration shall meet the following requirements, otherwise the configuration is invalid.
												// 0:main stream encode capacity+extra stream encode capacity<= device encode capacity 
												// 1:main stream encode capacity +extra stream encode capacity<= device encode capacity 
												// Extra stream encode capacity <=main stream encode capacity 
												// Extra stream resolution<=main stream resolution 
												// Main stream resolution and extra stream resolution <=front-end video collection frame rate
												// 2:N5 Device
												// Extra stream encode capacity <=main stream encode capacity
												// Query  the supported resolution and the corresponding maximum frame rate
	BYTE				btReserve1[3];			// reserved
	DWORD				dwExtraStream;			// bit0-main stream, bit1-extra stream1, bit2-extra stream2
	DWORD				dwCompression[3];		// extra stream compression

	char				reserved[108];
} DHDEV_DSP_ENCODECAP_EX, *LPDHDEV_DSP_ENCODECAP_EX;

// System information
typedef struct 
{
	DWORD				dwSize;
	/* The following are read only for device. */
	DH_VERSION_INFO		stVersion;
	DH_DSP_ENCODECAP	stDspEncodeCap;			// DSP  capacity description 
	BYTE				szDevSerialNo[DH_DEV_SERIALNO_LEN];	// SN
	BYTE				byDevType;				// device type. Please refer to enumeration NET_DEVICE_TYPE
	BYTE				szDevType[DH_DEV_TYPE_LEN];	// Device detailed type. String format. It may be empty.
	BYTE				byVideoCaptureNum;		// Video port amount
	BYTE				byAudioCaptureNum;		// Audio port amount 
	BYTE				byTalkInChanNum;		// NSP
	BYTE				byTalkOutChanNum;		// NSP
	BYTE				byDecodeChanNum;		// NSP
	BYTE				byAlarmInNum;			// Alarm input port amount
	BYTE				byAlarmOutNum;			// Alarm output amount port
	BYTE				byNetIONum;				// network port amount 
	BYTE				byUsbIONum;				// USB USB port amount
	BYTE				byIdeIONum;				// IDE amount 
	BYTE				byComIONum;				// COM amount 
	BYTE				byLPTIONum;				// LPT amount
	BYTE				byVgaIONum;				// NSP
	BYTE				byIdeControlNum;		// NSP
	BYTE				byIdeControlType;		// NSP
	BYTE				byCapability;			// NSP, expansible description 
	BYTE				byMatrixOutNum;			// video matrix output amount 
	/* The following are read-write part for device */
	BYTE				byOverWrite;			// Operate when HDD is full(overwrite/stop)
	BYTE				byRecordLen;			// Video file Package length
	BYTE				byDSTEnable;			// Enable  DTS or not  1--enable. 0--disable
	WORD				wDevNo;					// Device serial number. Remote control can use this SN to control.
	BYTE				byVideoStandard;		// Video format
	BYTE				byDateFormat;			// Date format
	BYTE				byDateSprtr;			// Date separator(0:".",1:"-",2:"/")
	BYTE				byTimeFmt;				// Time separator  (0-24H,1-12H)
	BYTE				byLanguage;				// Please refer to DH_LANGUAGE_TYPE for enumeration value
} DHDEV_SYSTEM_ATTR_CFG, *LPDHDEV_SYSTEM_ATTR_CFG;

// The returned information after modify device 
typedef struct
{
	DWORD				dwType;					// Type (type of GetDevConfig and SetDevConfig)
	WORD				wResultCode;			// Returned bit;0:succeeded,1:failed,2:illegal data,3:can not set right now,4:have no right 
	WORD   				wRebootSign;			// Reboot symbol;0:do not need to reboot,1:need to reboot to get activated 
	DWORD				dwReserved[2];			// Reserved 
} DEV_SET_RESULT;

// play result
typedef struct
{
	DWORD              	dwResultCode;           // result code,
                                                // 1:no authority,2:device not support,3:insufficient resources,4:get data error, 
                                                // 11:resouces are taked by advance users, 12:forbidden, 13:limited from reading disk data
                                                // 14:multi window preview already open, out of resource, compressed playback failed, 15: compressed playback already open
                                                // 16:current video channel is offline, play failed
                                                // 21:Unknown compression failure reason, 22: Compression failed because decoding capacity exceeded,
	                                            // 23:Compression failed because compression capacity exceeded, 24: Compression failed due to no original stream
                                                // 25:Compression failed because the slave on which the compression channel is located dropped
	LLONG               lPlayHandle;            // play handle
	BYTE               	byReserved[32];         // reserved   
	                    
}DEV_PLAY_RESULT;

// request audio tal error return info
typedef struct
{
    DWORD               dwResultCode;               // error return code CLIENT_GetLastError port return value
                                                    // NET_ERROR_TALK_REJECT _EC(375) // refuse talk
                                                    // NET_ERROR_TALK_RESOURCE_CONFLICIT _EC(377) // resource conflict
                                                    // NET_ERROR_TALK_UNSUPPORTED_ENCODE _EC(378) // not support talk encode format
                                                    // NET_ERROR_TALK_RIGHTLESS _EC(379) // no right
    LLONG               lTalkHandle;                // correspoinding handle
    BYTE                byReserved[32];             // reserved text                         
}DEV_TALK_RESULT;

//DST(Daylight Save Time) setup
typedef struct  
{
	int					nYear;					// Year[200 - 2037]
	int					nMonth;					// Month[1 - 12]
	int					nHour;					// Hour[0 - 23]
	int					nMinute;				// Minute [0 - 59]
	int					nWeekOrDay;				// [-1 - 4]0:It means it adopts the date calculation method. 
												// 1:in week: the first week ,2:the second week,3:the third week,4: The fourth week ,-1: the last week  
	union
	{
		int				iWeekDay;				// week[0 - 6](nWeekOrDay:calculated in week )0: Sunday, 1:Monday , 2:Tuesday ,3: Wednesday,4:Thirsday ,5: Friday,6:Saturday 
		int				iDay;					// date[1 - 31] (nWeekOrDay: in date)
	};
	
	DWORD				dwReserved[8];			// Reserved 
}DH_DST_POINT;

typedef struct  
{
	DWORD				dwSize;
	int					nDSTType;				// DST position way. 0: position in date  , 1:position in week  
	DH_DST_POINT        stDSTStart;             // Enable DTS
	DH_DST_POINT        stDSTEnd;				// End DTS
	DWORD				dwReserved[16];			// Reserved
}DHDEV_DST_CFG;


// Auto maintenance setup
typedef struct
{
	DWORD				dwSize;
	BYTE				byAutoRebootDay;		// Auto reboot;0:never, 1:each day,2:each Sunday,3:Each Monday ,......
	BYTE				byAutoRebootTime;		// 0:0:00,1:1:00,......23:23:00
	BYTE				byAutoDeleteFilesTime;	// Auto delete file;0:never,1:24H,2:48H,3:72H,4:96H,5:ONE WEEK,6:ONE MONTH
	BYTE				reserved[13];			// Reserved bit
} DHDEV_AUTOMT_CFG;

// car's disk info
typedef struct  
{
	DWORD				dwSize;										// struct size,must initialize
	DWORD				dwVolume;									// disk volume
	DWORD				dwFreeSpace;								// free space MB
	BYTE				byModle[DH_MAX_HARDDISK_TYPE_LEN];			// disk mode
	BYTE				bySerialNumber[DH_MAX_HARDDISK_SERIAL_LEN];	// serial number
}DHDEV_VEHICLE_DISK;

// car's 3G mode info,the largest support DH_MAX_SIM_NUM
typedef struct
{
	DWORD				dwSize;						// struct size,must initialize
	BYTE				szIMSI[DH_MAX_SIM_LEN];		// SIM's value = 460012002778636,top three for the country code MCC,4-6for the network code MNC,the last is MSIN,a total of not more than 15 characters
	BYTE				szMDN[DH_MAX_MDN_LEN];		// MDN
}DHDEV_VEHICLE_3GMODULE;

// car basic info
typedef struct 
{
	DWORD					dwSize;								// struct size,must initialize
	DWORD					dwSoftwareBuildDate;				// soft ware build date
	char					szVersion[DH_MAX_VERSION_LEN];		// version
	char					szDevSerialNo[DH_DEV_SERIALNO_LEN];	// device serial no.
	char					szDevType[DH_DEV_TYPE_LEN];			// device type,string format,can empty
	DWORD					dwDiskNum;							// disk number
	DHDEV_VEHICLE_DISK		stuHarddiskInfo[DH_MAX_DISKNUM];	// disk info
	DWORD					dw3GModuleNum;						// count of 3G module
	DHDEV_VEHICLE_3GMODULE	stu3GModuleInfo[DH_MAX_SIM_NUM];	// 3G module info
}DHDEV_VEHICLE_INFO;

// net interface,the largest support DH_MAX_NETINTERFACE_NUM
typedef struct tagDHDEV_NETINTERFACE_INFO
{
	int             dwSize;
	BOOL			bValid;								// valid or not
	BOOL			bVirtual;							// support virtual or not
	int             nSpeed;								// theory of speed (Mbps)
	int             nDHCPState;							// 0-disable, 1-getting, 2-get succeed
	char			szName[DH_NETINTERFACE_NAME_LEN];	// net port mane
	char			szType[DH_NETINTERFACE_TYPE_LEN];	// net type
	char			szMAC[DH_MACADDR_LEN];			    // MAC addr
	char			szSSID[DH_MAX_SSID_LEN];			// SSID, if only szType == "Wireless",availability
	char            szConnStatus[DH_MAX_CONNECT_STATUS_LEN]; // Wifi,3G connect status,"Inexistence" : not exist, "Down": close "Disconn": disconnect "Connecting" "Connected"
	int             nSupportedModeNum;                  // support mode number
	char            szSupportedModes[DH_MAX_MODE_NUM][DH_MAX_MODE_LEN];// support 3G net mode	"TD-SCDMA", "WCDMA", "CDMA1x", "EDGE", "EVDO"
    
	BOOL            bSupportLongPoE;                                // IsSupport Long PoE
	char			szNetCardName[8];								// NetCard name
} DHDEV_NETINTERFACE_INFO;
//-----------------------------Video Channel Property -------------------------------

// Zone;Each margin is total lenght :8192
typedef struct 
{
    long					left;
    long					top;
    long					right;
    long					bottom;
} DH_RECT, *LPDH_RECT;

typedef struct tagNET_RECT
{
    int             nLeft;
    int             nTop;
    int             nRight;
    int             nBottom;
} NET_RECT;

// 2 dimension point
typedef struct 
{
	short					nx;
	short					ny;
} DH_POINT, *LPDH_POINT, NET_POINT, *LPNET_POINT;

// 
typedef struct
{
	int        nPointNum;                           // point number
	DH_POINT   stuPoints[DH_MAX_DETECT_REGION_NUM]; // point info
}DH_POLY_POINTS;

// struct of OSD attribute
typedef struct  tagENCODE_WIDGET
{
	DWORD				rgbaFrontground;		// Object front view. Use bit to represent:red, green, blue and transparency.
	DWORD				rgbaBackground;			// Object back ground. Use bit to represent:red, green, blue and transparency.
	DH_RECT				rcRect;					// Position
	BYTE				bShow;					// Enable display
	BYTE                bExtFuncMask;           // Extended function,mask 
                                                // bit0 indicate week showing,0-not show 1-show 
	BYTE				byReserved[2];
} DH_ENCODE_WIDGET, *LPDH_ENCODE_WIDGET;

// Channel audio property 
typedef struct 
{
	// Video property 
	BYTE				byVideoEnable;			// Enable video;1:open,0:close 
	BYTE				byBitRateControl;		// Bit stream control;Please refer to constant Bit Stream Control definition 
	BYTE				byFramesPerSec;			// Frame rate
	BYTE				byEncodeMode;			// Encode mode:please refer to constant Encode Mode definition
	BYTE				byImageSize;			// Resolution:please refer to constant Resolution definition.
	BYTE				byImageQlty:7;			// Level 1-6
	BYTE                byImageQltyType:1;       
	WORD				wLimitStream;			// Limit stream parameter
	// Audio property 
	BYTE				byAudioEnable;			// Enable audio;1:open,0:close
	BYTE				wFormatTag;				// Audio encode mode:0:G711A,1:PCM,2:G711U,3:AMR,4:AAC 
	WORD				nChannels;				// Track amount 
	WORD				wBitsPerSample;			// Sampling depth 	
	BYTE				bAudioOverlay;			// Enabling audio
	BYTE				bH264ProfileRank;       // H.264 Profile rank(when byEncodeMode is h264, this value works ), see enmu struct EM_H264_PROFILE_RANK,when this value is 0, it means nothing
	DWORD				nSamplesPerSec;			// Sampling rate 
	BYTE				bIFrameInterval;		// 0-149. I frame interval amount. Describe the P frame amount between two I frames.
	BYTE				bScanMode;				// NSP
	BYTE				bReserved_3;
	BYTE				bReserved_4;
} DH_VIDEOENC_OPT, *LPDH_VIDEOENC_OPT;

// Image color property  
typedef struct 
{
	DH_TSECT			stSect;
	BYTE				byBrightness;			// Brightness:0-100
	BYTE				byContrast;				// Contrast:0-100
	BYTE				bySaturation;			// Saturation:0-100
	BYTE				byHue;					// Hue:0-100
	BYTE				byGainEn;				// Enable gain
	BYTE				byGain;					// Gain:0-100
	BYTE				byGamma;                // gamma 0-100
	BYTE				byReserved[1];
} DH_COLOR_CFG, *LPDH_COLOR_CFG;

// Image channel property structure 
typedef struct 
{
	WORD				dwSize;
	BYTE				bNoise;
	BYTE				bMode;   // (vehicle's special need)model 1 (quality first): 4-way video resolution D1, frame rate 2fps, bit rate 128kbps(225MB per hour) 
	                             // Mode 2 (fluency preferred): 4-way video resolution CIF, frame rate of 12fps, bit rate 256kbps (550MB per hour) 
                                 // Mode 3 (Custom) video resolution can be defined by the user, limited the maximum capacity of 4CIF/25fps
	char				szChannelName[DH_CHAN_NAME_LEN];
	DH_VIDEOENC_OPT		stMainVideoEncOpt[DH_REC_TYPE_NUM];
	DH_VIDEOENC_OPT		stAssiVideoEncOpt[DH_N_ENCODE_AUX];		
	DH_COLOR_CFG		stColorCfg[DH_N_COL_TSECT];
	DH_ENCODE_WIDGET	stTimeOSD;
	DH_ENCODE_WIDGET	stChannelOSD;
	DH_ENCODE_WIDGET	stBlindCover[DH_N_COVERS];	// Single privacy mask zone
	BYTE				byBlindEnable;				// Privacy mask zone enable button;0x00:disable privacy mask ,0x01:privacy mask local preview ,0x10:privacy mask record and network preview,0x11: Privacy mask all
	BYTE				byBlindMask;				// Privacy mask zone subnet mask. The first bit; device local preview ;The second bit :record (and network preview ) */
	BYTE				bVolume;					// volume(0~100)
	BYTE				bVolumeEnable;				// volume enable
} DHDEV_CHANNEL_CFG, *LPDHDEV_CHANNEL_CFG;

// Preview image property 
typedef struct 
{
	DWORD				dwSize;
	DH_VIDEOENC_OPT		stPreView;
	DH_COLOR_CFG		stColorCfg[DH_N_COL_TSECT];
}DHDEV_PREVIEW_CFG;

// snap control configuration
typedef struct _config_snap_control
{
	BYTE               bySnapState[32];           // every channel's snap on-off: 0 Autumn(other configuration and event will control whether snap picture ); 1: turn on snap; 2: turn off snap
    BYTE               byReserved[480];
}DHDEV_SNAP_CONTROL_CFG;

enum _gps_mode
{
	GPS_OR_GLONASS_MODE,	// GPS,GLONASS
	GLONASS_MODE,			// GLONASS
	GPS_MODE,				// GPS
};
// DH_DEV_GPS_MODE_CFG configuration
typedef struct tagDHDEV_GPS_MODE_CFG
{
	BYTE				byGPSMode; // GPS mode
	BYTE				byRev[255];
}DHDEV_GPS_MODE_CFG;

// snap upload DH_DEV_SNAP_UPLOAD_CFG configuration
typedef struct tagDHDEV_SNAP_UPLOAD_CFG
{
	int					nUploadInterval;		// the interval time of upload picture(s)
	BYTE				byReserved[252];	
}DHDEV_SNAP_UPLOAD_CFG;

// DH_DEV_SPEED_LIMIT_CFG configuration
typedef struct tagDHDEV_SPEED_LIMIT_CFG
{
	BYTE       byEnable;						// Enable speed limit;1:enable,0:disable
	BYTE       byReserved1;      
	WORD       wMaxSpeed;						// upper speed(KM/H) 0: none limit speed, >0:limit speed
	WORD       wMinSpeed;						// low speed(KM/H) 0: none limit speed, >0:limit speed
	BYTE       byReserved2[122];  
}DHDEV_SPEED_LIMIT_CFG;

// wireless routing config
typedef struct
{
	BOOL		bEnable;						// enable
	char		szSSID[36];						// SSID
	BOOL		bHideSSID;						// hide SSID
	char		szIP[DH_MAX_IPADDR_LEN];		// IP
	char		szSubMark[DH_MAX_IPADDR_LEN];	// sub mark
	char		szGateWay[DH_MAX_IPADDR_LEN];	// gateway
	char		szCountry[32];					// country
	int			nSafeType;						// safe type: 1-no encryption; 2-WEP; 2-WPA-PSK; 3-WPA2-PSK
	int			nEncryption;					// encryption: WEP(1-auto 2-open 3-shareable); WPA-PSK/WPA2-PSK(4-TKIP 5-AES)
	char		szKey[32];						// key
	int			nChannel;						// channel
	BOOL		bAutoChannelSelect;				// auto channel select
}DHDEV_WIRELESS_ROUTING_CFG;

//-------------------------------COM property ---------------------------------

// COM basic property 
typedef struct
{
	BYTE				byDataBit;				// Data bit;0:5,1:6,2:7,3:8
	BYTE				byStopBit;				// Stop bit;0:1 bit,1:1.5 bit,2:2 bits
	BYTE				byParity;				// Parity;0: None,1: Odd;2: even;3:sign;4:empty
	BYTE				byBaudRate;				// Baud rate;0:300,1:600,2:1200,3:2400,4:4800,
												// 5:9600,6:19200,7:38400,8:57600,9:115200
} DH_COMM_PROP;

// 485 decoder setup 
typedef struct
{ 
	DH_COMM_PROP		struComm;
	BYTE				wProtocol;				// Protocol type. Corresponding to the subscript of Protocol Name List
	BYTE				bPTZType;				// 0-Compatible,local ptz 1-remote network ptz, the capability refer to DEV_ENCODER_CFG.
	BYTE				wDecoderAddress;		// Decoder address;0 - 255
	BYTE 				byMartixID;				// Matrix number 
} DH_485_CFG;

// 232 COM setup 
typedef struct
{
	DH_COMM_PROP		struComm;
	BYTE				byFunction;				// COM function,Corresponding to the subscript of Function Name list. 
	BYTE				byReserved[3];
} DH_RS232_CFG;

// COM configuration structure 
typedef struct
{
	DWORD				dwSize;

	DWORD				dwDecProListNum;										// Decoder protocol amount
	char				DecProName[DH_MAX_DECPRO_LIST_SIZE][DH_MAX_NAME_LEN];	// Protocol name list
	DH_485_CFG			stDecoder[DH_MAX_DECODER_NUM];							// Each decoder current property

	DWORD				dw232FuncNameNum;										// 232 function amount 
	char				s232FuncName[DH_MAX_232FUNCS][DH_MAX_NAME_LEN];			// Function name list 
	DH_RS232_CFG		st232[DH_MAX_232_NUM];									// Current 232 COM property 
} DHDEV_COMM_CFG;

// Extended COM configuration structure 
typedef struct
{
	DWORD				dwSize;
	
	DWORD				dwDecProListNum;			                           // Decoder protocol amount
	char				DecProName[DH_MAX_DECPRO_LIST_SIZE][DH_MAX_NAME_LEN];  // Protocol name list
	DH_485_CFG			stDecoder[DH_MAX_DECODER_NUM];						   // Each decoder current property
	
	DWORD				dw232FuncNameNum;									   // 232 function amount
	char				s232FuncName[DH_MAX_232FUNCS][DH_MAX_NAME_LEN];	       // Function name list
	DWORD               dw232ComNum;										   // 232 com amount  
	DH_RS232_CFG		st232[DH_MAX_232_NUM_EX];	                           // Current 232 COM property
} DHDEV_COMM_CFG_EX;

// Serial port status
typedef struct
{
	unsigned int		uBeOpened;
	unsigned int		uBaudRate;
	unsigned int		uDataBites;
	unsigned int		uStopBits;
	unsigned int		uParity;
	BYTE				bReserved[32];
} DH_COMM_STATE;

//-------------------------------Record configuration---------------------------------

// Scheduled record 
typedef struct 
{
	DWORD				dwSize;
	DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT];
	BYTE				byPreRecordLen;			// Pre-record button. Unit is second. 0 means disable pre-record 
	BYTE				byRedundancyEn;			// Record redundant enable button 
	BYTE                byRecordType;           // Video bit-stream type:0:Main Stream 1:Assist Stream1 2:Assist Stream2 3:Assist Stream3
	BYTE				byReserved;
} DHDEV_RECORD_CFG, *LPDH_RECORD_CFG;

// NTP setup 
typedef struct  
{
	BOOL				bEnable;				// Enable or not
	int					nHostPort;				// NTP  server default port is 123
	char				szHostIp[32];			// Host IP
	char				szDomainName[128];		// Domain name 
	int					nType;					// Read only ,0:IP,1:domain name ,2:IP and domain name 
	int					nUpdateInterval;		// Update time(minute)
	int					nTimeZone;				// Please refer to DH_TIME_ZONE_TYPE
	char				reserved[128];
} DHDEV_NTP_CFG;

// FTP upload setup 
typedef struct
{
	struct
	{
		DH_TSECT		struSect;				// Enable function is disabled during the period. Can ignore
		BOOL			bMdEn;					// Upload motion detection record
		BOOL			bAlarmEn;				// Upload external alarm record 
		BOOL			bTimerEn;				// Upload scheduled record 
		DWORD			dwRev[4];
	} struPeriod[DH_TIME_SECTION];
} DH_FTP_UPLOAD_CFG;

typedef struct
{
	DWORD				dwSize;
	BOOL				bEnable;							// Enable or not
	char				szHostIp[DH_MAX_IPADDR_LEN];		// Host IP
	WORD				wHostPort;							// Host port 
	char				szDirName[DH_FTP_MAX_PATH];			// FTP path
	char				szUserName[DH_FTP_USERNAME_LEN];	// User name
	char				szPassword[DH_FTP_PASSWORD_LEN];	// Password 
	int					iFileLen;							// File length
	int					iInterval;							// Time interval between two near files.
	DH_FTP_UPLOAD_CFG	struUploadCfg[DH_MAX_CHANNUM][DH_N_WEEKS];
	char 				protocol;							// 0-FTP 1-SMB 2-NFS,3-ISCSI
	char				NASVer;								// Network storage server version 0=Old FTP(There is time period in the user interface),1=NAS storage(There is no time period in the user interface. )
	DWORD				dwFunctionMask;						// Function capacity mask. Use bit to represent. Lower 16-bit:FTP,SMB,NFS, ISCSI and higher 16-bit:(Local storage)DISK,U
	BYTE                bDataType;                          // data type, 0-all, 1-video, 2-image
	BYTE 				reserved[123];
} DHDEV_FTP_PROTO_CFG;

// extend FTP upload setup (support setting the FTP's path, maximal picture number)
typedef struct 
{
    int            nMaxPictures;                             // the maximal number of the FTP can save,can set limit of the picture number in the every chennel's direct;
	                                                         // if the saved picture number extended the limit the old picture will be covered by new one; the value 0 indecate that it will save picture untill the disck was full.
    char           szPreChannelName[DH_FTP_MAX_SUB_PATH];    // the picture named mod
    char           szFTPChannelPath[DH_FTP_MAX_SUB_PATH];    // the FTP's sub direction
    char           szRev[128];                               // reserved
}DHDEV_FTP_CHANNEL_CFG; 


typedef struct 
{ 
	DHDEV_FTP_PROTO_CFG       stuFtpNormalSet;                	// the normal function of the FTP
	DHDEV_FTP_CHANNEL_CFG     stuFtpChannelSet[DH_MAX_CHANNUM]; // the extended function of the FTP
	char                      szRev[128];                    	// reserved
}DHDEV_FTP_PROTO_CFG_EX;

//-------------------------------Network Configuration---------------------------------

// Ethernet Configuration
typedef struct 
{
	char				sDevIPAddr[DH_MAX_IPADDR_LEN];	// DVR IP  address
	char				sDevIPMask[DH_MAX_IPADDR_LEN];	// DVR IP subnet mask    
	char				sGatewayIP[DH_MAX_IPADDR_LEN];	// Gateway address

	/*
	 * 1:10Mbps full-duplex
	 * 2:10Mbps auto-duplex
	 * 3:10Mbps half-duplex
	 * 4:100Mbps full-duplex
	 * 5:100Mbps auto-duplex
	 * 6:100Mbps half-duplex
	 * 7:auto
	 */
	// Divide DWORD into four to future development
	BYTE				dwNetInterface;			// NSP
	BYTE				bTranMedia;				// 0:cable,1:wireless
	BYTE				bValid;					// Use bit to represent, The first bit:1:valid 0:invalid;The second bit:0:Disable DHCP 1:Enable DHCP;The third bit:0:Do not support DHCP 1:Support DHCP
	BYTE				bDefaultEth;			// To be the default network card or not.  1: default 0:non-default 
	char				byMACAddr[DH_MACADDR_LEN];	// MAC address , read-only., 
} DH_ETHERNET; 

// Remote host setup 
typedef struct 
{
	BYTE				byEnable;				// Enable connection 
	BYTE				byAssistant;            // Only for PPPoE server,0:on the cabled network; 1:on the wireless network
	WORD				wHostPort;				// Remote host Port 
	char				sHostIPAddr[DH_MAX_IPADDR_LEN];		// Remote host IP address  				
	char				sHostUser[DH_MAX_HOST_NAMELEN];		// Remote host User name   
	char				sHostPassword[DH_MAX_HOST_PSWLEN];	// Remote host Password   
} DH_REMOTE_HOST;

// Mail setup 
typedef struct 
{
	char				sMailIPAddr[DH_MAX_IPADDR_LEN];		// Email server IP
	WORD				wMailPort;							// Email server port 
	WORD				wReserved;							// Reserved
	char				sSenderAddr[DH_MAX_MAIL_ADDR_LEN];	// Send out address 
	char				sUserName[DH_MAX_NAME_LEN];			// User name 
	char				sUserPsw[DH_MAX_NAME_LEN];			// User password 
	char				sDestAddr[DH_MAX_MAIL_ADDR_LEN];	// Destination address 
	char				sCcAddr[DH_MAX_MAIL_ADDR_LEN];		// CC address 
	char				sBccAddr[DH_MAX_MAIL_ADDR_LEN];		// BCC address 
	char				sSubject[DH_MAX_MAIL_SUBJECT_LEN];	// Subject 
} DH_MAIL_CFG;

// Network configuration structure 
typedef struct
{ 
	DWORD				dwSize; 
	char				sDevName[DH_MAX_NAME_LEN];	// Device host name
	WORD				wTcpMaxConnectNum;		// TCP max connection amount
	WORD				wTcpPort;				// TCP listening port 
	WORD				wUdpPort;				// UDP listening port 
	WORD				wHttpPort;				// HTTP port number 
	WORD				wHttpsPort;				// HTTPS port number 
	WORD				wSslPort;				// SSL port number 
	DH_ETHERNET			stEtherNet[DH_MAX_ETHERNET_NUM];	// Ethernet port 

	DH_REMOTE_HOST		struAlarmHost;			// Alarm server 
	DH_REMOTE_HOST		struLogHost;			// Log server 
	DH_REMOTE_HOST		struSmtpHost;			// SMTP server 
	DH_REMOTE_HOST		struMultiCast;			// Multiple-cast group 
	DH_REMOTE_HOST		struNfs;				// NFS server
	DH_REMOTE_HOST		struPppoe;				// PPPoE server 
	char				sPppoeIP[DH_MAX_IPADDR_LEN]; // returned IP after PPPoE registration 
	DH_REMOTE_HOST		struDdns;				// DDNS server
	char				sDdnsHostName[DH_MAX_HOST_NAMELEN];	// DDNS host name
	DH_REMOTE_HOST		struDns;				// DNS server 
	DH_MAIL_CFG			struMail;				// Email setup 
} DHDEV_NET_CFG;

// Ethernet extended Configuration
typedef struct 
{
	char				sDevIPAddr[DH_MAX_IPADDR_LEN];	// DVR IP  address
	char				sDevIPMask[DH_MAX_IPADDR_LEN];	// DVR IP subnet mask
	char				sGatewayIP[DH_MAX_IPADDR_LEN];	// Gateway address

	/*
	 * 1:10Mbps full-duplex
	 * 2:10Mbps auto-duplex
	 * 3:10Mbps half-duplex
	 * 4:100Mbps full-duplex
	 * 5:100Mbps auto-duplex
	 * 6:100Mbps half-duplex
	 * 7:auto
	 */
	// Divide DWORD into four to future development
	BYTE				dwNetInterface;			// NSP
	BYTE				bTranMedia;				// 0:cable,1:wireless
	BYTE				bValid;					// Use bit to represent, The first bit:1:valid 0:invalid;The second bit:0:Disable DHCP 1:Enable DHCP;The third bit:0:Do not support DHCP 1:Support DHCP
	BYTE				bDefaultEth;			//To be the default network card or not.  1: default 0:non-default 
	char				byMACAddr[DH_MACADDR_LEN];	// MAC address , read-only.
	BYTE                bMode;                  // mode, 1:balance, 2:multi, 3:fault-toerant
	BYTE                bReserved1[3];          // reserved   
    char                szEthernetName[DH_MAX_NAME_LEN];    // Card name, read only
    BYTE                bReserved[12];                      // reserved    
} DH_ETHERNET_EX; 

// Network extended configuration structure
typedef struct
{ 
	DWORD				dwSize; 
	char				sDevName[DH_MAX_NAME_LEN];	// Device host name
	WORD				wTcpMaxConnectNum;		// TCP max connection amount
	WORD				wTcpPort;				// TCP listening port
	WORD				wUdpPort;				// UDP listening port 
	WORD				wHttpPort;				// HTTP port number
	WORD				wHttpsPort;				// HTTPS port number
	WORD				wSslPort;				// SSL port number
	int                 nEtherNetNum;           // Ethernet port number
	DH_ETHERNET_EX		stEtherNet[DH_MAX_ETHERNET_NUM_EX];	// Ethernet info
	
	DH_REMOTE_HOST		struAlarmHost;			// Alarm server
	DH_REMOTE_HOST		struLogHost;			// Log server
	DH_REMOTE_HOST		struSmtpHost;			// SMTP server
	DH_REMOTE_HOST		struMultiCast;			// Multiple-cast group
	DH_REMOTE_HOST		struNfs;				// NFS server
	DH_REMOTE_HOST		struPppoe;				// PPPoE server
	char				sPppoeIP[DH_MAX_IPADDR_LEN]; // returned IP after PPPoE registration
	DH_REMOTE_HOST		struDdns;				// DDNS server
	char				sDdnsHostName[DH_MAX_HOST_NAMELEN];	// DDNS host name
	DH_REMOTE_HOST		struDns;				// DNS server
	DH_MAIL_CFG			struMail;				// Email setup
	BYTE                bReserved[128];         // reserved
} DHDEV_NET_CFG_EX;

// IPV4 config
typedef struct tagDEV_IPV4_CFG
{
	DWORD				dwSize;								// struct size
	char                szDevName[DH_MAX_NAME_LEN];         // device name
	WORD                wTcpMaxConnectNum;                  // TCP max connect num
	WORD                wTcpPort;                           // TCP port
	WORD                wUdpPort;                           // UDP port
	WORD                wHttpPort;                          // HTTP port
	WORD                wHttpsPort;                         // HTTPS port
	WORD                wSslPort;                           // SSL port	
	DH_ETHERNET_EX      stuEtherNet[DH_MAX_ETHERNET_NUM_EX];// ethernet info
	int					nEtherNetNum;						// stuEtherNet num
}DEV_IPV4_CFG;

// ddns configuraiton structure 
typedef struct
{
	DWORD				dwId;					// ddns server id
	BOOL				bEnable;				// Enable. There is only one valid ddns server at one time.
	char				szServerType[DH_MAX_SERVER_TYPE_LEN];	// Server type. www.3322.org.
	char				szServerIp[DH_MAX_DOMAIN_NAME_LEN];		// Server IP or domain name 
	DWORD				dwServerPort;			// Server port 
	char				szDomainName[DH_MAX_DOMAIN_NAME_LEN];	// DVR domain name such as jeckean.3322.org
	char				szUserName[DH_MAX_HOST_NAMELEN];		// User name
	char				szUserPsw[DH_MAX_HOST_PSWLEN];			// Password
	char				szAlias[DH_MAX_DDNS_ALIAS_LEN];			// Server alias 
	DWORD				dwAlivePeriod;							// DDNS alive period
	BYTE				ByMode;									// domain mode:0-manual,szDomainName enable; 1-default szDefaultDomainName enable
	char				szDefaultDomainName[DH_MAX_DEFAULT_DOMAIN_LEN];// default domain, real only
    BYTE                bReserved[3];                           // Text align
    char                szEmailUserName[DH_MAX_MAIL_NAME_LEN];	// Mail username
    char                reserved[128];
} DH_DDNS_SERVER_CFG;

typedef struct
{
	DWORD				dwSize;
	DWORD				dwDdnsServerNum;	
	DH_DDNS_SERVER_CFG	struDdnsServer[DH_MAX_DDNS_NUM];	
} DHDEV_MULTI_DDNS_CFG;

// Mail configuration structure 
typedef struct 
{
	char				sMailIPAddr[DH_MAX_DOMAIN_NAME_LEN];	// Mail server address(IP and domain name )
	char				sSubMailIPAddr[DH_MAX_DOMAIN_NAME_LEN];
	WORD				wMailPort;								// Mail server port 
	WORD				wSubMailPort;
	WORD				wReserved;								// Reserved 
	char				sSenderAddr[DH_MAX_MAIL_ADDR_LEN];		// From
	char				sUserName[DH_MAX_MAIL_NAME_LEN];		// User name
	char				sUserPsw[DH_MAX_MAIL_NAME_LEN];			// password
	char				sDestAddr[DH_MAX_MAIL_ADDR_LEN];		// To
	char				sCcAddr[DH_MAX_MAIL_ADDR_LEN];			// CC
	char				sBccAddr[DH_MAX_MAIL_ADDR_LEN];			// BCC
	char				sSubject[DH_MAX_MAIL_SUBJECT_LEN];		// Subject
	BYTE				bEnable;								// Enable 0:false,	1:true
	BYTE				bSSLEnable;								// SSL enable
	WORD				wSendInterval;							// Send interval,[0,3600]s
	BYTE				bAnonymous;								// Anonymous Options[0,1], 0:FALSE,1:TRUE.
	BYTE				bAttachEnable;							// Attach enable[0,1], 0:FALSE,1:TRUE.
	char				reserved[154];
} DHDEV_MAIL_CFG;

// DNS server setup 
typedef struct  
{
	char				szPrimaryIp[DH_MAX_IPADDR_LEN];
	char				szSecondaryIp[DH_MAX_IPADDR_LEN];
	char				reserved[256];
} DHDEV_DNS_CFG;

// Record download strategy setup 
typedef struct
{
	DWORD				dwSize;
	BOOL				bEnable;				// TRUE: high-speed download,FALSE:general download  
}DHDEV_DOWNLOAD_STRATEGY_CFG;

// Network transmission strategy setup 
typedef struct
{
	DWORD				dwSize;
	BOOL				bEnable;
	int					iStrategy;				// 0: video quality,1:fluency ,2: auto
}DHDEV_TRANSFER_STRATEGY_CFG;

// The corresponding parameter when setting log in
typedef struct tagNET_PARAM
{
	int					nWaittime;				// Waiting time(unit is ms), 0:default 5000ms.
	int					nConnectTime;			// Connection timeout value(Unit is ms), 0:default 1500ms.
	int					nConnectTryNum;			// Connection trial times, 0:default 1.
	int					nSubConnectSpaceTime;	// Sub-connection waiting time(Unit is ms), 0:default 10ms.
	int					nGetDevInfoTime;		// Access to device information timeout, 0:default 1000ms.
	int					nConnectBufSize;		// Each connected to receive data buffer size(Bytes), 0:default 250*1024
	int					nGetConnInfoTime;		// Access to sub-connect information timeout(Unit is ms), 0:default 1000ms.
	int                 nSearchRecordTime;      // Timeout value of search video (unit ms), default 3000ms
	int                 nsubDisconnetTime;      // dislink disconnect time,0:default 60000ms
	BYTE				byNetType;				// net type, 0-LAN, 1-WAN
	BYTE                byPlaybackBufSize;      // playback data from the receive buffer size(m),when value = 0,default 4M
    BYTE                bDetectDisconnTime;     // Pulse detect offline time(second) .When it is 0, the default setup is 60s, and the min time is 2s 
    BYTE                bKeepLifeInterval;      // Pulse send out interval(second). When it is 0, the default setup is 10s, the min internal is 2s. 
	int                 nPicBufSize;            // actual pictures of the receive buffer size(byte)when value = 0,default 2*1024*1024
	BYTE				bReserved[4];			// reserved
} NET_PARAM;

// udp and multicast option
typedef struct tagNET_UDP_OPTION
{
   unsigned int nPacketArriveTimeout;           // timeout waiting for out-of-order packets to arrive, unit: ms, default time 50ms, max time is 200ms, zero means don't chanage current value
   unsigned int nRetransmitPacketArriveTimeout; // timeout waiting for retransmitted packets arrive, unit: ms, default time is 100ms, max time is 400ms, zero means don't chanage current value
   unsigned int nMaxLostNumOfMulitcastSeqNo;    // maximnum acceptable number of multicast packets lost, default num is 1000, max num is 2000, zero means don't chanage current value
   unsigned int nMaxWaitNumOfUdpSeqNo;          // maximum waiting udp seq number, default num is 30, max num is 1000, zero means don't chanage current value
   unsigned int nMultiSocketSendBufferSize;     // multicast socket send buffer size, unitByte, default: 64K, min: 8K, max: 1M, zero means don't chanage current value
   unsigned int nMultiSocketRecvBufferSize;     // multicast socket send buffer size, unit: Byte, default: 1M, min: 8K, max: 1M, zero means don't chanage current value
   unsigned int nUdpSocketSendBufferSize;       // UDP socket send buffer size, unit: Byte, default: 64K, min: 8K, max: 1M, zero means don't chanage current value
   unsigned int nUdpSocketRecvBufferSize;       // UDP socket send buffer size, unit: Byte, default: 1M, min: 8K, max: 1M, zero means don't chanage current value
   BYTE bReserved[128];                         // reserved
}NET_UDP_OPTION;

// Corresponding to CLIENT_SearchDevices
typedef struct 
{
	char				szIP[DH_MAX_IPADDR_LEN];			// IP
	int					nPort;								// Port
	char				szSubmask[DH_MAX_IPADDR_LEN];		// Subnet mask
	char				szGateway[DH_MAX_IPADDR_LEN];		// Gateway
	char				szMac[DH_MACADDR_LEN];				// MAC address
	char				szDeviceType[DH_DEV_TYPE_LEN];		// Device type
	BYTE        		byManuFactory;				    	// manufactory
	BYTE        		byIPVersion;                    	// 4: IPv4, szXXX is in format with dot; 6:IPv6, szXXX is 128-bit *16 bytes) numerical format
	BYTE				byInitStatus;						// init status
															// bit0~10-old device, can not be init; 1-not init; 2-already init
															// bit2~30-old device,reserved; 1-connect to public network disable; 2-connect to public network enable
															// bit4~50-old device,reserved; 1-connect to cellphone disable; 2-connect to cellphone enable
	BYTE				byPwdResetWay;						// the way supported for reset password:make sense when the device is init														
															// bit0-support reset password by cellphone; bit1-support reset password by mail; bit2-support reset password by XML file
	BYTE				bySpecialAbility;					// special ability of device ,bit0-2D Code:0 support  1 no support, bit1-PN:0 support  1 no support
    BYTE                bReserved[27];                      // reserved
} DEVICE_NET_INFO;

#define DH_DEV_CUSTOM_DEVICEID_LEN               24			// Custom deviceid length

// Corresponding to CLIENT_StartSearchDevices
typedef struct tagDEVICE_NET_INFO_EX
{
    int                 iIPVersion;                      // 4 for IPV4, 6 for IPV6
    char                szIP[64];                        // IP IPV4 like"192.168.0.1" IPV6 like "2008::1/64"
    int                 nPort;                           // port
    char                szSubmask[64];	                 // Subnet mask(IPV6 do not have subnet mask)
    char                szGateway[64];	                 // Gateway
    char                szMac[DH_MACADDR_LEN];           // MAC address
    char                szDeviceType[DH_DEV_TYPE_LEN];   // Device type
    BYTE                byManuFactory;                   // device manufactory, see EM_IPC_TYPE
    BYTE                byDefinition;                    // 1-Standard definition 2-High definition
    bool                bDhcpEn;                         // Dhcp, true-open, false-close
    BYTE                byReserved1;                     // reserved
    char                verifyData[88];                  // ECC data 
    char                szSerialNo[DH_DEV_SERIALNO_LEN]; // serial no
    char                szDevSoftVersion[DH_MAX_URL_LEN];// soft version    
    char                szDetailType[DH_DEV_TYPE_LEN];   // device detail type
    char                szVendor[DH_MAX_STRING_LEN];     // OEM type
    char                szDevName[DH_MACHINE_NAME_NUM];  // device name
    char                szUserName[DH_USER_NAME_LENGTH_EX];  // user name for log in device(it need be filled when modify device ip)
    char                szPassWord[DH_USER_NAME_LENGTH_EX];  // pass word for log in device(it need be filled when modify device ip)
    unsigned short      nHttpPort;                           // HTTP server port
    WORD                wVideoInputCh;                       // count of video input channel
    WORD                wRemoteVideoInputCh;                 // count of remote video input
    WORD                wVideoOutputCh;                      // count of video output channel 
    WORD                wAlarmInputCh;                       // count of alarm input
    WORD                wAlarmOutputCh;                      // count of alarm output
    BOOL                bNewWordLen;                         // TRUE:szNewPassWord Enable
    char                szNewPassWord[DH_COMMON_STRING_64];  // pass word for log in device(it need be filled when modify device ip)
    BYTE                byInitStatus;                        // init status
                                                            // bit0~10-old device, can not be init; 1-not init; 2-already init
                                                            // bit2~30-old device,reserved; 1-connect to public network disable; 2-connect to public network enable
                                                            // bit4~50-old device,reserved; 1-connect to cellphone disable; 2-connect to cellphone enable
                                                            // bit6~7: 0- unknown 1-unsupported reset password 2-support password
    BYTE                byPwdResetWay;                      // the way supported for reset password:make sense when the device is init														
                                                            // bit0-support reset password by cellphone; bit1-support reset password by mail; bit2-support reset password by XML file;
                                                            // bit3-support reset password by security question; bit4-support reset password by change cellphone															
    BYTE                bySpecialAbility;                   // special ability of device ,high eight bit, bit0-2D Code:0 support  1 no support, bit1-PN:0 support  1 no support
    char                szNewDetailType[DH_COMMON_STRING_64];// device detail type 
    BOOL                bNewUserName;                       // TRUE:szNewUserName enable
    char                szNewUserName[DH_COMMON_STRING_64]; // new user name for login device(it need be filled when modify device ip)
    BYTE                byPwdFindVersion;                   // password find version, effective when device supports reset password
                                                            // 0-device of old scheme reset password version;1-support reset password by reserved contact;
                                                            // 2-support reset password by change contact;
    char                szDeviceID[DH_DEV_CUSTOM_DEVICEID_LEN]; // Custom item, do not use for general client;
    DWORD               dwUnLoginFuncMask;                      // function mask before login, Bit0 means wifi config
    char                cReserved[12];                          // reserved
}DEVICE_NET_INFO_EX;

// Corresponding to CLIENT_StartSearchDevicesEx
typedef struct tagDEVICE_NET_INFO_EX2 
{
    DEVICE_NET_INFO_EX  stuDevInfo;                         // device net info	
    char                szLocalIP[MAX_LOCAL_IP_LEN];        // local ip
    char                cReserved[2048];                    // reserved
}DEVICE_NET_INFO_EX2;
// Corresponding to CLIENT_SearchDevicesByIPs
typedef struct tagDEVICE_IP_SEARCH_INFO
{
	DWORD               dwSize;                          // struct size 
	int                 nIpNum;                          // the IPs number for search
	char                szIP[DH_MAX_SAERCH_IP_NUM][64];  // the IPs for search
}DEVICE_IP_SEARCH_INFO;

// Device search config
typedef struct tagNET_DEVICE_SEARCH_PARAM
{
    DWORD       dwSize;						// struct size 
	BOOL        bUseDefault;				// whether use default configuration,default TRUE
	WORD        wBroadcastLocalPort;		// broadcast local port, defalut 5050, 0 means use last setted configuration.
	WORD        wBroadcastRemotePort;		// broadcast remote port, defalut 5050, 0 means use last setted configuration.
	WORD        wMulticastRemotePort;		// multicast remote port, defalut 37810, 0 means use last setted configuration.
	BOOL        bMulticastModifyRespond;	// whether multicast reply is only supported when modify device, defalut FALSE means unicast or multicast reply.
	WORD        wMulticastLocalPort;		// multicast local port, defalut 37810, 0 means use last setted configuration.
	int			iAutoUpdatePortTimes;		// auto update port times while port not available: default 50, range [0-65534]
	WORD        wAOLMulticastRemotePort;	// AOL multicast remote port, defalut 8087, 0 means use last setted configuration.
	WORD        wAOLMulticastLocalPort;		// AOL multicast local port, defalut 37811, 0 means use last setted configuration.
}NET_DEVICE_SEARCH_PARAM;

// struct SNMP config struct
typedef struct
{
	BOOL                bEnable;                                // SNMP enable
	int                 iSNMPPort;                              // SNMP port
	char                szReadCommon[DH_MAX_SNMP_COMMON_LEN];   // read common
	char                szWriteCommon[DH_MAX_SNMP_COMMON_LEN];  // write common
	char                szTrapServer[64];                       // trap address
	int                 iTrapPort;                              // trap port
	BYTE				bSNMPV1;								// SNMP V1 enable
	BYTE				bSNMPV2;								// SNMP V2 enable
	BYTE				bSNMPV3;								// SNMP V3 enable
	char                szReserve[125];
}DHDEV_NET_SNMP_CFG;

// ISCSI server
typedef struct
{
	char				szServerName[32];				// name
	union
	{ 
		BYTE	c[4];
		WORD	s[2];
		DWORD	l;
	}					stuIP;							// IP
	int					nPort;							// port
	char				szUserName[32];					// username
	char				szPassword[32];					// password
	BOOL				bAnonymous;						// anonymous
}DHDEV_ISCSI_SERVER;

// ISCSI config
typedef struct
{
	BOOL				bEnable;						// enable
	DHDEV_ISCSI_SERVER	stuServer;						// server
	char				szRemotePath[240];				// remote path
	BYTE				reserved[256];
}DHDEV_ISCSI_CFG;

//-------------------------------Alarm Property ---------------------------------

// PTZ Activation
typedef struct 
{
	int					iType;                          // 0-None,1-Preset,2-Tour,3-Pattern
	int					iValue;
} DH_PTZ_LINK, *LPDH_PTZ_LINK;

//Alarm activation structure 
typedef struct 
{
	/* Message process way. There can be several process ways.
	 * 0x00000001 -  Alarm upload
	 * 0x00000002 -  Activation alarm 
	 * 0x00000004 -  PTZ activation
	 * 0x00000008 -  Send out mail
	 * 0x00000010 -  Local tour
	 * 0x00000020 -  Local prompt
	 * 0x00000040 -  Alarm output
	 * 0x00000080 - Ftp upload
	 * 0x00000100 -  Buzzer 
	 * 0x00000200 -  Video prompt
	 * 0x00000400 -  Snapshot
	*/

	/* The process way current alarm supported. Use bit mask to represent */
	DWORD				dwActionMask;

	/* Use bit mask to represent. The parameters of detailed operation are in its correspond configuration */
	DWORD				dwActionFlag;
	
	/* The output channel the alarm activated. The output alarm activated. 1 means activate current output. */ 
	BYTE				byRelAlarmOut[DH_MAX_ALARMOUT_NUM];
	DWORD				dwDuration;				/*  Alarm duration time*/

	/* Activation record */
	BYTE				byRecordChannel[DH_MAX_VIDEO_IN_NUM]; /*  The record channel alarm activated. 1 means activate current channel. */
	DWORD				dwRecLatch;				/*  Record duration time */

	/* Snapshot channel  */
	BYTE				bySnap[DH_MAX_VIDEO_IN_NUM];
	/* Tour channel */
	BYTE				byTour[DH_MAX_VIDEO_IN_NUM];

	/* PTZ activation  */
	DH_PTZ_LINK			struPtzLink[DH_MAX_VIDEO_IN_NUM];
	DWORD				dwEventLatch;			/* The latch time after activation begins. Unit is second. The value ranges from 0 to 15. Default value is 0. */
	/* The wireless output channel alarm activated.The output alarm activated. 1 means activate current output.*/ 
	BYTE				byRelWIAlarmOut[DH_MAX_ALARMOUT_NUM];
	BYTE				bMessageToNet;
	BYTE                bMMSEn;					/* SMS Alarm enabled */
	BYTE                bySnapshotTimes;		/* the number of sheets of drawings */
	BYTE				bMatrixEn;				/* enable matrix */
	DWORD				dwMatrix;				/* matrix mask */			
	BYTE				bLog;					/* enable log */
	BYTE				bSnapshotPeriod;		/* <Snapshot frame interval. System can snapshot regularly at the interval you specify here. The snapshot amount in a period of time also has relationship with the snapshot frame rate. 0 means there is no interval, system just snapshot continuously. */
	BYTE                byEmailType;            /* <0,picture,1,record> */
	BYTE                byEmailMaxLength;       /* <max record length,unit:MB> */
	BYTE                byEmailMaxTime;         /* <max time length, unit:second> */
	BYTE				byReserved[99];     
} DH_MSG_HANDLE;

// External alarm 
typedef struct
{
	BYTE				byAlarmType;			// Annunciator type,0: normal close,1:normal open 
	BYTE				byAlarmEn;				// Enable alarm 
	BYTE				byReserved[2];						
	DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT]; // NSP
	DH_MSG_HANDLE		struHandle;				// Process way 
} DH_ALARMIN_CFG, *LPDHDEV_ALARMIN_CFG; 

//Motion detection alarm 
typedef struct 
{
	BYTE				byMotionEn;				// Enable motion detection alarm 
	BYTE				byReserved;
	WORD				wSenseLevel;			// Sensitivity 
	WORD				wMotionRow;				// Row amount in motion detection zones
	WORD				wMotionCol;				// Column amount in motion detection zones 
	BYTE				byDetected[DH_MOTION_ROW][DH_MOTION_COL]; // Detection zones .Max 32*32 zones.
	DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT];	// NSP
	DH_MSG_HANDLE		struHandle;				// Process way 
} DH_MOTION_DETECT_CFG;

// Video loss alarm 
typedef struct
{
	BYTE				byAlarmEn;				// Enable video loss alarm 
	BYTE				byReserved[3];
	DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT];	// NSP
	DH_MSG_HANDLE		struHandle;				// Process way
} DH_VIDEO_LOST_CFG;

// Camera masking alarm 
typedef struct
{
	BYTE				byBlindEnable;						// Enable
	BYTE				byBlindLevel;						// Sensitivity 1-6
	BYTE				byReserved[2];
	DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT];	// NSP
	DH_MSG_HANDLE		struHandle;							// Process way 
} DH_BLIND_CFG;

// HDD information(External alarm )
typedef struct 
{
	BYTE				byNoDiskEn;								// Alarm when there is no HDD
	BYTE				byReserved_1[3];
	DH_TSECT			stNDSect[DH_N_WEEKS][DH_N_REC_TSECT];	// NSP
	DH_MSG_HANDLE		struNDHandle;							// Process way 

	BYTE				byLowCapEn;								// Alarm when HDD capacity is low 
	BYTE				byLowerLimit;							// Capacity threshold 0-99
	BYTE				byReserved_2[2];
	DH_TSECT			stLCSect[DH_N_WEEKS][DH_N_REC_TSECT];	// NSP
	DH_MSG_HANDLE		struLCHandle;							// Process way 

	BYTE				byDiskErrEn;							// HDD malfunction alarm 
	BYTE				bDiskNum;
	BYTE				byReserved_3[2];
	DH_TSECT			stEDSect[DH_N_WEEKS][DH_N_REC_TSECT];	// NSP
	DH_MSG_HANDLE		struEDHandle;							// Process way 
} DH_DISK_ALARM_CFG;

typedef struct
{
	BYTE				byEnable;
	BYTE				byReserved[3];
	DH_MSG_HANDLE		struHandle;
} DH_NETBROKEN_ALARM_CFG;

// Alarm deployment 
typedef struct
{
	DWORD dwSize;
	DH_ALARMIN_CFG 		struLocalAlmIn[DH_MAX_ALARM_IN_NUM];
	DH_ALARMIN_CFG		struNetAlmIn[DH_MAX_ALARM_IN_NUM];
	DH_MOTION_DETECT_CFG struMotion[DH_MAX_VIDEO_IN_NUM];
	DH_VIDEO_LOST_CFG	struVideoLost[DH_MAX_VIDEO_IN_NUM];
	DH_BLIND_CFG		struBlind[DH_MAX_VIDEO_IN_NUM];
	DH_DISK_ALARM_CFG	struDiskAlarm;
	DH_NETBROKEN_ALARM_CFG	struNetBrokenAlarm;
} DHDEV_ALARM_SCHEDULE;

#define DECODER_OUT_SLOTS_MAX_NUM 		16
#define DECODER_IN_SLOTS_MAX_NUM 		16

// Alarm decoder configuration
typedef struct  
{
	DWORD				dwAddr;									// Alarm decoder address
	BOOL				bEnable;								// Alarm decoder enable
	DWORD				dwOutSlots[DECODER_OUT_SLOTS_MAX_NUM];	// Now only support 8
	int					nOutSlotNum;							// Effective number of array elements.
	DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT];
	DH_MSG_HANDLE		struHandle[DECODER_IN_SLOTS_MAX_NUM];	// Now only support 8
	int					nMsgHandleNum;							// Effective number of array elements.
	BYTE				bReserved[120];
} DH_ALARMDEC_CFG;

// The setup of alarm upload
typedef struct  
{
	BYTE				byEnable;						// Enable upload
	BYTE				bReserverd;						// Reserved
	WORD				wHostPort;						// Alarm center listening port 
	char				sHostIPAddr[DH_MAX_IPADDR_LEN];	// Alarm center IP
	int					nByTimeEn;						// Enable scheduled upload.Use it to upload IP or domain name to the centre.
	int					nUploadDay;						/*  Set upload date 
														"Never = 0", "Everyday = 1", "Sunday = 2", 
														"Monday = 3", Tuesday = 4", "Wednesday = 5",
														"Thursday = 6", "Friday = 7", "Saturday = 8"*/	
	int					nUploadHour;					// Set upload time ,[0~23]o'clock
	DWORD				dwReserved[300]; 				// Reserved for future development 
} ALARMCENTER_UP_CFG;

// Panorama switch alarm configuration
typedef struct __DH_PANORAMA_SWITCH_CFG 
{
	BOOL				bEnable;				// Enabled
	int					nReserved[5];			// Reserved
	DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT];
	DH_MSG_HANDLE		struHandle;				// Process way
} DH_PANORAMA_SWITCH_CFG;

typedef struct __ALARM_PANORAMA_SWITCH_CFG 
{
	int					nAlarmChnNum;			// Number of alarm channels
	DH_PANORAMA_SWITCH_CFG stuPanoramaSwitch[DH_MAX_VIDEO_IN_NUM];
} ALARM_PANORAMA_SWITCH_CFG;

// Lose focus alarm configuration
typedef struct __DH_LOST_FOCUS_CFG
{
	BOOL				bEnable;				// Enabled
	int					nReserved[5];			// Reserved
	DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT];
	DH_MSG_HANDLE		struHandle;				// Process way
} DH_LOST_FOCUS_CFG;

typedef struct __ALARM_LOST_FOCUS_CFG 
{
	int					nAlarmChnNum;			// Number of alarm channels
	DH_LOST_FOCUS_CFG stuLostFocus[DH_MAX_VIDEO_IN_NUM];
} ALARM_LOST_FOCUS_CFG;

// IP collision detection alarm configuration
typedef struct __ALARM_IP_COLLISION_CFG
{
	BOOL				bEnable;				// Enable
	DH_MSG_HANDLE		struHandle;				// Alarm activation
	int                 nReserved[300];			// Reserved
} ALARM_IP_COLLISION_CFG;

// MACcollision detection configuration
typedef struct __ALARM_MAC_COLLISION_CFG
{
	BOOL				bEnable;				// Enable
	DH_MSG_HANDLE		struHandle;				// Alarm activation
	int                 nReserved[300];			// Reserved
} ALARM_MAC_COLLISION_CFG;

// 232/485 com card signal info configuration
typedef struct __COM_CARD_SIGNAL_INFO
{
	WORD                wCardStartPose;          // card number start location
	WORD                wCardLenth;              // card number length
	char                cStartCharacter[32];     // start string
	char                cEndCharacter[32];       // end string
	BYTE                byReserved[28];          // reserved
}COM_CARD_SIGNAL_INFO;

// 232/485 com card  linked configuration(when the info from the com fit the configuration, it will trigger the device snap picture)
typedef struct __COM_CARD_SIGNAL_LINK_CFG
{
	COM_CARD_SIGNAL_INFO  struCardInfo;          // card info
	DH_MSG_HANDLE         struHandle;            // event link
	BYTE                  byReserved[24];        // reserved
	
}COM_CARD_SIGNAL_LINK_CFG;

//------------------------------Multiple privacy mask zones--------------------------------

// Privacy mask information
typedef struct __VIDEO_COVER_ATTR
{
	DH_RECT				rcBlock;				// Privacy mask zone coordinates
	int					nColor;					// Privacy mask color
	BYTE				bBlockType;				// Mask type;0:Black block,1: mosaic
	BYTE				bEncode;				// Encode level cover mask;1:valid,0:invalid
	BYTE				bPriview;				// Preview mask; 1:valid,0:invalid
	char				reserved[29];			// Reserved 
} VIDEO_COVER_ATTR;

// Multiple privacy mask zones 
typedef struct __DHDEV_VIDEOCOVER_CFG 
{
	DWORD				dwSize;
	char				szChannelName[DH_CHAN_NAME_LEN]; // Read-only
	BYTE				bTotalBlocks;			// The mask zones supported
	BYTE				bCoverCount;			// The mask zones have been set 
	VIDEO_COVER_ATTR	CoverBlock[DH_MAX_VIDEO_COVER_NUM]; // The mask zones 
	char				reserved[30];			// Reserved 
}DHDEV_VIDEOCOVER_CFG;

// decode policy configuration
typedef struct __DHDEV_DECODEPOLICY_CFG 
{
	int					nMinTime;				// (read only):minimal delay time(ms)
	int					nMaxTime;				// (read only):maximal delay time(ms)
	int					nDeocdeBufTime;			// device decode delay time(ms)
	
	char				reserved[128];			// reserved
}DHDEV_DECODEPOLICY_CFG;

// Device relative configuration
typedef struct __DHDEV_MACHINE_CFG 
{
	char				szMachineName[DH_MACHINE_NAME_NUM];		// Device name or SN 
	char				szMachineAddress[DH_MACHINE_NAME_NUM];	// Device location
	char				reserved[128];							// reserved
}DHDEV_MACHINE_CFG;


////////////////////////////////IPC series ////////////////////////////////

// Set wireless network information 
typedef struct 
{
	int					nEnable;				// Enable wireless
	char				szSSID[36];				// SSID
	int					nLinkMode;				// connection mode;0:auto,1:adhoc,2:Infrastructure
	int					nEncryption;			// encrypt;0:off,2:WEP64bit,3:WEP128bit, 4:WPA-PSK-TKIP, 5: WPA-PSK-CCMP
	int					nKeyType;				// 0:Hex,1:ASCII
    int					nKeyID;					// Serial number
	union
	{
		char			szKeys[4][32];			// Four group passwords
		char			szWPAKeys[128];			// when nEncryption is 4 or 5, use szWPAKeys
	};
	int					nKeyFlag;
	BYTE                byConnectedFlag;        // 0: not connect, 1: connect 
	char				reserved[11];
} DHDEV_WLAN_INFO;

// Select to use one wireless device 
typedef struct  
{
	char				szSSID[36];
	int					nLinkMode;				// Connection mode;0:adhoc,1:Infrastructure
	int 				nEncryption;			// Encrypt;0:off,2:WEP64bit,3:WEP128bit
	char				reserved[48];
} DHDEV_WLAN_DEVICE;

// The searched wireless device list 
typedef struct  
{
	DWORD				dwSize;
	BYTE				bWlanDevCount;			// The wireless devices searched 
	DHDEV_WLAN_DEVICE	lstWlanDev[DH_MAX_WLANDEVICE_NUM];
	char				reserved[255];
} DHDEV_WLAN_DEVICE_LIST;

// wireless device expended configuration
typedef struct
{
	char                szSSID[36];                         // server id
	char                szMacAddr[18];                      // mac address 
	BYTE                byApConnected;                      // connect state 0: not connect,1: connected
	BYTE                byLinkMode;                         // connect mod 0:adhoc 1:Infrastructure;
	int                 nRSSIQuality;                       // rssi quality(dbm)
	unsigned int        unApMaxBitRate;                     // max transmit speed
	BYTE                byAuthMode;                         // attestation mod:0:OPEN;1:SHARED;2:WPA;3:WPA-PSK;4:WPA2;5:WPA2-PSK;
															// 6:WPA-NONE(only use in Adhoc mode),
															// 7-11 are mix mode,choose one of them can to be connected 
															// 7:WPA-PSK | WPA2-PSK; 8:WPA | WPA2; 9:WPA | WPA-PSK;
															// 10:WPA2 | WPA2-PSK; 11:WPA | WPA-PSK |WPA2 |WPA2-PSK //12: UnKnown
	BYTE                byEncrAlgr;                         // encrypt mod 0:off; 2:WEP64bit; 3:WEP128bit; 4:WEP; 5:TKIP; 6:AES(CCMP)
															// 7: TKIP+AES( mix Mode) 8: UnKnown
	BYTE                byLinkQuality;                      // link quality 0~100(%)
    BYTE                byReserved[129];                    // Reserved 
}DHDEV_WLAN_DEVICE_EX;

// The searched wireless device expended configuration list 
typedef struct  
{
	DWORD				dwSize;
	BYTE				bWlanDevCount;			// The wireless device number searched
	DHDEV_WLAN_DEVICE_EX  lstWlanDev[DH_MAX_WLANDEVICE_NUM_EX];
	char				reserved[255];
} DHDEV_WLAN_DEVICE_LIST_EX;


// The searched wireless device expended configuration list
typedef struct  
{
	DWORD					dwSize;
	BYTE					bWlanDevCount;            // The wireless device number searched
	DHDEV_WLAN_DEVICE_EX	lstWlanDev[MAX_WLAN_DEVICE_NUM];
} DHDEV_WLAN_DEVICE_LIST_EX2;

// Function Test
typedef struct
{
	int                 nResult;                  // 0:success,1:failure
	BYTE                reserved[32];
} DHDEV_FUNC_TEST;

// FTP server info
typedef struct
{
	char                szServerName[32];          // server name
	char                szIp[16];                  // IP address
	int                 nPort;                     // port number
	char                szUserName[32];            // user name
	char                szPassword[32];	           // pass word
	BOOL                bAnonymity;                // whether anonymity log in 
	BYTE                byReserved[256];           // reserved
}FTP_SERVER_CFG;

// ftp server connect test
typedef struct
{
	FTP_SERVER_CFG     stuFtpServerInfo;           // ftp server info(filled by user)
	DHDEV_FUNC_TEST    stuTestResult;              // ftp server connect state
	BYTE               byReserved[64];
}DHDEV_FTP_SERVER_TEST;

// DDNS domain info
typedef struct
{

	char				szServerType[DH_MAX_SERVER_TYPE_LEN];	// server type
	char				szServerIp[DH_MAX_DOMAIN_NAME_LEN];		// server ip or domain
	DWORD				dwServerPort;							// server port
	char				szDomainName[DH_MAX_DOMAIN_NAME_LEN];	// dvr domain,such as jeckean.3322.org
	char				szUserName[DH_MAX_HOST_NAMELEN];		// username
	char				szUserPsw[DH_MAX_HOST_PSWLEN];			// password
	BYTE                byReserved[256];           				// reserved
}DDNS_DOMAIN_INFO;


// DDNS domain test
typedef struct
{
	DDNS_DOMAIN_INFO   stuDomainInfo;				// DDNS domain
	DHDEV_FUNC_TEST    stuTestResult;				// test result
	char			   szMemo[128];					// test result memo
	BYTE               byReserved[64];
}DHDEV_DDNS_DOMAIN_TEST;


// hard disk's basic information
typedef struct 
{
	BYTE                byModle[32];				// model
	BYTE                bySerialNumber[32];			// serial number
	BYTE                byFirmWare[32];				// firmware no
	int                 nAtaVersion;				// ATA protocol version no
	int                 nSmartNum ;					// smart information no
	INT64				Sectors;	
	int                 nStatus;					// disk state 0-normal 1-abnormal
	int                 nReserved[33]; 
} DHDEV_DEVICE_INFO;

//smart information of harddisk, there may be many items up to more than 30
typedef struct
{
	BYTE				byId;						// ID
	BYTE				byCurrent;					// attribute values 
	BYTE				byWorst;					// maximum error value 
	BYTE				byThreshold;				// threshold value 
	char				szName[64];					// property name
	char				szRaw[8];					// actual value
	int					nPredict;					// state
	char				reserved[128];
} DHDEV_SMART_VALUE;

//search hard disk smart information
typedef struct
{
	BYTE               nDiskNum;       // disk number
	BYTE               byRaidNO;       // Raid sub disk, 0:single disk
	BYTE               byReserved[2];  
	DHDEV_DEVICE_INFO  deviceInfo;    
	DHDEV_SMART_VALUE  smartValue[MAX_SMART_VALUE_NUM];
} DHDEV_SMART_HARDDISK;

// submodule information
typedef struct
{
	char               szModuleName[64];			//  submodule name
	char               szHardWareVersion[32];		//  submodule HardWareVersion
	char               szSoftwareVersion[32];		//  submodule SoftWareVersion
	BYTE               reserved[128]; 
} DHDEV_SUBMODELE_VALUE;

// search submodule information
typedef struct
{
	int                    nSubModuleNum;							// nSubModuleNum
	DHDEV_SUBMODELE_VALUE  stuSubmoduleValue[MAX_SUBMODULE_NUM];	// Submodule information
	BYTE				   bReserved[256];
} DHDEV_SUBMODULE_INFO;

// Query harddisk damage ability
typedef struct
{
	BYTE                bDiskDamageLevel[DH_MAX_DISK_NUM];  // every disk's damage level
	BYTE                bReserved[128];
} DHDEV_DISKDAMAGE_INFO;

// SYSLOG remote server ability
typedef struct 
{
	char				szServerIp[DH_MAX_IPADDR_OR_DOMAIN_LEN];	//Server IP address
	int					nServerPort;								//Server port
	BYTE				bEnable;									//Server Enable
	BYTE				bReserved[255];								//Reserved bytes
}DHDEV_SYSLOG_REMOTE_SERVER;

// Video backup config parameter
typedef struct
{
	BYTE				backupVideoFormat;							//file type to backup, 0:dav, 1:asf
	BYTE				password[6];								//password
	BYTE				reversed[505];								//reserved
}DHDEV_BACKUP_VIDEO_FORMAT;


// Auto register config parameter
typedef struct  
{
	char				szServerIp[32];			// Registration server IP ; no use it,use szServerIpEx
	int					nServerPort;			// Port number 
	BYTE                byReserved[3];          // 
	BYTE                bServerIpExEn;          // Extend Registration server IP enable, 0-not enable, 1-enable
	char				szServerIpEx[60];       // Extend Registration server IP
} DHDEV_SERVER_INFO;

typedef struct  
{
	DWORD				dwSize;
	BYTE				bServerNum;				// The max IP amount supported
	DHDEV_SERVER_INFO	lstServer[DH_MAX_REGISTER_SERVER_NUM];
	BYTE				bEnable;				// Enable
	char				szDeviceID[32];			// Device ID
	char				reserved[94];
} DHDEV_REGISTER_SERVER;

// Camera property 
typedef struct __DHDEV_CAMERA_INFO
{
	BYTE				bBrightnessEn;			// Brightness adjustable;1:adjustable,0:can not be adjusted
	BYTE				bContrastEn;			// Contrast adjustable
	BYTE				bColorEn;				// Hue adjustable
	BYTE				bGainEn;				// Gain adjustable
	BYTE				bSaturationEn;			// Saturation adjustable
	BYTE				bBacklightEn;			// Backlight compensation adjustable
	BYTE				bExposureEn;			// Exposure option adjustable
	BYTE				bColorConvEn;			// Day/night switch 
	BYTE				bAttrEn;				// Property option; 1:Enable, 0:Disable
	BYTE				bMirrorEn;				// Mirror;1:support,0:do not support 
    BYTE				bFlipEn;				// Flip;1:support,0:do not support 
	BYTE				iWhiteBalance;			// White Balance 1 Support,0 :Do not support
	BYTE				iSignalFormatMask;		// Signal format mask,Bitwise:0-Inside(Internal input) 1- BT656 2-720p 3-1080i  4-1080p  5-1080sF
	BYTE				bRotate90;				// 90-degree rotation 1:support,0:do not support 
    BYTE				bLimitedAutoExposure;   // Support the time limit with automatic exposure 1:support,0:do not support 
    BYTE				bCustomManualExposure;  // support user-defined manual exposure time 1:support,0:do not support
	BYTE				bFlashAdjustEn;			// Support the flash lamp adjust
	BYTE				bNightOptions;			// Support day and night change
	BYTE                iReferenceLevel;    	// Support electric reference setting
	BYTE                bExternalSyncInput;     // Support external sync Input
	unsigned short      usMaxExposureTime;      // Max exposure time, unit:ms         
	unsigned short      usMinExposureTime;      // Min exposure time, unit:ms
	BYTE                bWideDynamicRange;      // Wide dynamic range,0-present not support,2~n max supported range value
	BYTE                bDoubleShutter;         // Double Shutter
	BYTE				byExposureCompensation; // 1 support, 0 not support
	BYTE				bRev[109];				// reserved 
} DHDEV_CAMERA_INFO;

// Special configuration for night,will automatically switch to night configuration when low light
typedef struct __DHDEV_NIGHTOPTIONS 
{
	BYTE  bEnable;								// 0-Do not switch,1-Switch 
												// Roughly sunrise and sunset time, before sunrise or after sunset, will use a special configuration for night.
												// 00:00:00 ~23:59:59
	BYTE  bSunriseHour;
	BYTE  bSunriseMinute;
	BYTE  bSunriseSecond;
	BYTE  bSunsetHour;
	BYTE  bSunsetMinute;
	BYTE  bSunsetSecond;  
	BYTE  bWhiteBalance ;						// White balance  0:Disabled,1:Auto 2:sunny 3:cloudy 4:home 5:office 6:night 7: Custom
	BYTE  bGainRed;								// Red gain adjustment, white balance to "Custom" mode will effect 0~100
	BYTE  bGainBlue;							// Green gain adjustment, white balance to "Custom" mode will effect 0~100
	BYTE  bGainGreen;							// Blue gain adjustment, white balance to "Custom" mode will effect 0~100
	BYTE  bGain;								// 0~100
	BYTE  bGainAuto;							// 0-Without auto gain 1-Auto gain
	BYTE  bBrightnessThreshold ;				// Brightness value 0~100
	BYTE  ReferenceLevel;                       // electric value 0~100   
	BYTE  bExposureSpeed;						// Range depends on the device capability: 0-Auto Exposure  1~n-1-manual exposure level;  n-Auto Exposure with time limit;  n+1-manual exposure customized time (n means exposure level)
	float ExposureValue1;						// Lower limit of automatic exposure time or customized manual exposure time, in milliseconds, value 0.1ms ~ 80ms
	float ExposureValue2;						// Automatic exposure time limit, in milliseconds, value 0.1ms ~ 80ms
	BYTE  bAutoApertureEnable;                  // Auto Aperture Enable,1:open,0:close
	BYTE  bWideDynamicRange;                    // wide dynamic value, it depends on max support value
	WORD  wNightSyncValue;						// night sync 0~360
	WORD  wNightSyncValueMillValue;             // night sync mill value 0~999
	BYTE res[10];								// Reserve
} DHDEV_NIGHTOPTIONS;

// camera attribute configration
typedef struct __DHDEV_CAMERA_CFG 
{ 
	DWORD				dwSize;
	BYTE				bExposure;				// Exposure mode;1-9:Manual exposure level  ,0: Auto exposure 
	BYTE				bBacklight;				// Backlight compensation:3:High,2:Medium,1:Low,0:close
	BYTE				bAutoColor2BW;			// Day/night mode;2:Open,1:Auto,0:Close
	BYTE				bMirror;				// Mirror;1:Open,0:Close
	BYTE				bFlip;					// Flip;1:Open,0:Close  support;0 :do not support 
	BYTE				bLensEn;				// the capacity of Auto Iris function 1:support;0 :do not support
	BYTE				bLensFunction;			// Auto aperture function: 1:Enable aperture  ;0: Disable aperture  
	BYTE				bWhiteBalance;			// White Balance 0:Disabled,1:Auto 2:sunny 3:cloudy 4:home 5:office 6:night
	BYTE				bSignalFormat;			// Signal format 0-Inside(Internal input) 1- BT656 2-720p 3-1080i  4-1080p  5-1080sF
	BYTE				bRotate90;				// 0-Not rotating,1-90 degrees clockwise,2-90 degrees counterclockwise
	BYTE                bReferenceLevel;        // electric value 0~100  
	BYTE                byReserve;              // Reserved
	float				ExposureValue1;			// Auto exposure or manual exposure limit custom time,Milliseconds(0.1ms~80ms)
	float				ExposureValue2;			// Auto exposure limit,Milliseconds(0.1ms~80ms)
	DHDEV_NIGHTOPTIONS	stuNightOptions;		// Configuration parameter options for night 
	BYTE				bGainRed;				// Red gain adjustment, effective when white balance to "Custom" mode,  0 ~ 100
	BYTE				bGainBlue;				// Green gain adjustment, effective when white balance to "Custom" mode,  0 ~ 100
	BYTE				bGainGreen;				// Blue gain adjustment, effective when white balance to "Custom" mode,  0 ~ 100
	BYTE				bFlashMode;				// Flash mode,0-close,1-always,2-auto 
	BYTE				bFlashValue;			// Flash work values,  0-0us, 1-64us, 2-128us,...15-960us
	BYTE				bFlashPole;				// Flash trigger mode 0 - low level 1 - high level
	BYTE                bExternalSyncPhase;     // External single input
	BYTE                bFlashInitValue;        // Flash brightness prevlue, 0~100
	WORD                wExternalSyncValue ;    // External value 0~360
	WORD                wExternalSyncValueMillValue; //  External SyncValue Mill Value0~999
	BYTE                bWideDynamicRange;           // wide dynamic range, it depends on max support value
	BYTE				byExposureCompensation;		// default compensation value,default is 7,range[0~14]
	char				bRev[54];				// Reserved
} DHDEV_CAMERA_CFG;

#define ALARM_MAX_NAME 64
// (wireless)IR alarm setup
typedef struct
{
	BOOL				bEnable;				// Enable alarm input
	char				szAlarmName[DH_MAX_ALARM_NAME];	// Alarm input name
	int					nAlarmInPattern;		// Annunciator input wave
	int					nAlarmOutPattern;		// Annunciator output wave
	char				szAlarmInAddress[DH_MAX_ALARM_NAME];// Alarm input address
	int					nSensorType;			// External device sensor type normal open or normal close 
	int					nDefendEfectTime;		// Deploy and cancel latch time. The alarm input becomes activated after the specified time.
	int					nDefendAreaType;		// Defend area 
	int					nAlarmSmoothTime;		// Alarm smooth time:system ignores the second alarm if one alarm inputs in two times. 
	char				reserved[128];
	DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT];
	DH_MSG_HANDLE		struHandle;				// Process way 
} DH_INFRARED_INFO;

// Wireless remote control setup 
typedef struct 
{
	BYTE				address[ALARM_MAX_NAME];// Remote control address
	BYTE				name[ALARM_MAX_NAME];	// Remote control name
	BYTE				reserved[32];			// Reserved string 
} DH_WI_CONFIG_ROBOT;

// Wireless alarm output setup 
typedef struct 
{
	BYTE				address[ALARM_MAX_NAME];// Alarm output address
	BYTE				name[ALARM_MAX_NAME];	// Alarm output name
	BYTE				reserved[32];			// Reserved string 
} DH_WI_CONFIG_ALARM_OUT;

typedef struct  
{
	DWORD				dwSize;
	BYTE				bAlarmInNum;			// Wireless alarm input amount 
	BYTE				bAlarmOutNum;			// Wireless alarm output amount 
	DH_WI_CONFIG_ALARM_OUT AlarmOutAddr[16];	// Alarm output address
	BYTE				bRobotNum;				// Remote control amount
	DH_WI_CONFIG_ROBOT  RobotAddr[16];			// Remote control address 
	DH_INFRARED_INFO	InfraredAlarm[16];
	char				reserved[256];
} DH_INFRARED_CFG;

// New audio detection alarm information 
typedef struct
{
	int					channel;				// Alarm channel number
	int					alarmType;				// Alarm type;0:Volume value is too low ,1:Volume value is too high. 
	unsigned int		volume;					// Volume
	BYTE                byState;                // volume alarm state, 0: alarm appear, 1: alarm disappear
	char				reserved[255];
} NET_NEW_SOUND_ALARM_STATE;

typedef struct  
{
	int					channelcount;			// Alarm channel amount 
	NET_NEW_SOUND_ALARM_STATE SoundAlarmInfo[DH_MAX_ALARM_IN_NUM];
} DH_NEW_SOUND_ALARM_STATE;

// Snapshot function property structure 
typedef struct 
{
	int					nChannelNum;			// Channel amount 
	DWORD				dwVideoStandardMask;	// Resolution(Bit). Please refer to enumeration CAPTURE_SIZE						
	int					nFramesCount;			// Valid length of Frequency[128] array
	char				Frames[128];			// Frame rate(value) 
												// -25:1f/25s;-24:1f/24s;-23:1f/23s;-22:1f/23s
												// ......
												// 0: invalid;1:1f/s;2:2f/s;3:13f/s
												// 4:4f/s;5:5f/s;17:17f/s;18:18f/s
												// 19:19f/s;20:20f/s
												// ......
												// 25: 25f/s
	int					nSnapModeCount;			// valid length of SnapMode[16] array
	char				SnapMode[16];			// (value)0:activate scheduled snapshot,1:Manually activate snapshot
	int					nPicFormatCount;		// Valid length of Format[16] array 
	char 				PictureFormat[16];		// (Value)0:BMP format,1:JPG format
	int					nPicQualityCount;		// valid length of Quality[32] array
	char 				PictureQuality[32];		// value
												// 100:Image quality 100%;80:Image quality 80%;60:Image quality60%
												// 50:Image quality50%;30:Image quality30%;10:Image quality10%
	char 				nReserved[128];			// Reserved
} DH_QUERY_SNAP_INFO;

typedef struct 
{
	int					nChannelCount;			// Channel amount 
	DH_QUERY_SNAP_INFO  stuSnap[DH_MAX_CHANNUM];
} DH_SNAP_ATTR_EN;


/* IP Filtering configuration */
#define DH_IPIFILTER_NUM			200			// IP
#define DH_IPIFILTER_NUM_EX			512			// IP

// IP Information
typedef struct 
{
	DWORD				dwIPNum;				// IP count
	char				SZIP[DH_IPIFILTER_NUM][DH_MAX_IPADDR_LEN]; // IP
	char				byReserve[32];			// Reserved
} IPIFILTER_INFO;

// IP Filtering configuration
typedef struct
{
	DWORD				dwSize;
	DWORD				dwEnable;				// Enable
	DWORD				dwType;					// The current list type;0:White List 1:Blacklist(The device can enable only one type of list)
	IPIFILTER_INFO		BannedIP;				// Black list
	IPIFILTER_INFO		TrustIP;				// Trusted sites
	char				byReserve[256];			// Reserved
} DHDEV_IPIFILTER_CFG;

// IP Information extended
typedef struct 
{
	DWORD				dwIPNum;				// IP count
	char				SZIP[DH_IPIFILTER_NUM_EX][DH_MAX_IPADDR_LEN]; // IP
	char				byReserve[32];			// Reserved
} IPIFILTER_INFO_EX;

// IP Filtering extended configuration
typedef struct
{
	DWORD				dwSize;
	DWORD				dwEnable;				// Enable
	DWORD				dwType;					// The current list type;0:White List 1:Blacklist(The device can enable only one type of list) can only user one kind of device
	IPIFILTER_INFO_EX	BannedIP;				// Black list
	IPIFILTER_INFO_EX	TrustIP;				// Trusted sites
	char				byReserve[256];			// Reserved
} DHDEV_IPIFILTER_CFG_EX;

/* MAC filter configuration */
#define DH_MACFILTER_NUM			512			// MAC

// MAC info
typedef struct 
{
	DWORD				dwSize;					// struct size
	DWORD				dwMacNum;				// MAC count
	char				szMac[DH_MACFILTER_NUM][DH_MACADDR_LEN]; // MAC
} MACFILTER_INFO;
// MAC filter configuration
typedef struct
{
	DWORD					dwSize;				// struct size
	DWORD					dwEnable;			// enable
	DWORD					dwType;				// current list type,0:white list, 1:blacklist (The device can enable only one type of list) can only user one kind of device
	MACFILTER_INFO			stuBannedMac;		// black list Mac
	MACFILTER_INFO			stuTrustMac;		// white list Mac
} DHDEV_MACFILTER_CFG;

/* MAC,IP filter configuration */
#define DH_MACIPFILTER_NUM			512			// MAC,IP
// MAC, IP filter configuration info
typedef struct
{
	DWORD	dwSize;					// struct size
	char	szMac[DH_MACADDR_LEN];	// mac
	char	szIp[DH_MAX_IPADDR_LEN];// ip
}MACIP_INFO;

// MAC,IP filter configuration
typedef struct
{
	DWORD					dwSize;								// struct size
	DWORD					dwEnable;							// enable
	DWORD					dwType;								// The current list type;0:White List 1:Blacklist(The device can enable only one type of list) can only user one kind of device
	DWORD					dwBannedMacIpNum;					// black list MAC,IP count (MAC,IP one to one)
	MACIP_INFO				stuBannedMacIp[DH_MACIPFILTER_NUM];	// black list Mac,IP
	DWORD					dwTrustMacIpNum;					// white list MAC,IP count(MAC,IP one to one)
	MACIP_INFO				stuTrustMacIp[DH_MACIPFILTER_NUM];	// white list Mac,IP
} DHDEV_MACIPFILTER_CFG;
typedef struct
{
	int                nCardNum;                // card number
	char 	           cardInfo [DH_MAX_CARD_NUM][DH_MAX_CARDINFO_LEN]; // card info string 
	BYTE               byReserve[32];           // reserved
}DHDEV_NETCARD_CFG;

// RTSP configuration
typedef struct
{
	WORD               wPort;                  // port number(can't be the same as tcp or udp's port number)
	BYTE               byReserved[62];         // reserved
}DHDEV_RTSP_CFG;

// stream encrypt configuration
// encrypt key info
typedef struct _ENCRYPT_KEY_INFO
{
	BYTE        byEncryptEnable;       //  encrypt enable, 0: not encrypt, 1:encrypt
	BYTE        byReserved[3]; 
	union
	{
		BYTE    byDesKey[8];           // des key
		BYTE    by3DesKey[3][8];       // 3des key
		BYTE    byAesKey[32];          // aes key
		
	};
}ENCRYPT_KEY_INFO;

// encrypt algorithm
typedef struct _ALGO_PARAM_INFO
{
	WORD       wEncryptLenth;       // encrypt length, for example: wEncryptLenth = 128,the effictive encprypt key value only include byAesKey[0]~[15] in the  ENCRYPT_KEY_INFO struct
									// when the encrypt algorithm is AES,it only support 3 kind length such as 128,192,256
									// when the encrypt algorithm is DES,it has a fixed value 64
									// when the encrypt algorithm is DES,it means the encrypt key's number(2 or 3 encrypt key)
	BYTE       byAlgoWorkMode ;     // work mode, see EM_ENCRYPT_ALOG_WORKMODE 
	BYTE       reserved[13];        // reserved
}ALGO_PARAM_INFO;

// stream encrypt configuration
typedef struct _DHEDV_STREAM_ENCRYPT
{
    BYTE                    byEncrptAlgoType;        // encrypt algorithm type:00: AES,01:DES,02: 3DES
    BYTE                    byReserved1[3];
    ALGO_PARAM_INFO         stuEncrptAlgoparam;      // encrypt algorithm param
    ENCRYPT_KEY_INFO        stuEncryptKeys[32];      // each channel's encrypt key's info
	BYTE					byEncrptPlanEnable;		 // encrpt plan enable
	BYTE					byReserved3[3];
	NET_TIME				stuPreTime;				 // encrpt plan beginning time
	BYTE					reserved2[1360];
}DHEDV_STREAM_ENCRYPT;

// limit stream configuration
typedef struct _DHDEV_BIT_RATE
{
	DWORD                   nExpectCodeRate;          // limit stream (kps)
	BYTE                    byReserved[64];           // reserved
}DHDEV_LIMIT_BIT_RATE;
// custom configuration
typedef struct _DHDEV_CUSTOM_CFG
{
	char                   szData[1024];            // custom configuration information
	char                   reserved[3072];          // reserved
}DHDEV_CUSTOM_CFG;

/*audio talk configuration*/
typedef struct
{
	DWORD				dwSize;
	int					nCompression;			// Compression type,value,refer to DH_TALK_CODING_TYPE,please set the compression type according to the mode the device supports
	int					nMode;					// Encode mode, value, 0 means not support the compression type
												// Set the responding type according to compression type
												// like AMR, please refer to EM_ARM_ENCODE_MODE
	char				byReserve[256];			// Reserved
} DHDEV_TALK_ENCODE_CFG;

// According to the mobile function
// (Event triggers message)MMS Configuration Structure
typedef struct
{
	DWORD				dwSize;
	DWORD				dwEnable;				// Enable
	DWORD				dwReceiverNum;			// Receiver amount
	char				SZReceiver[DH_MMS_RECEIVER_NUM][32];	// Receiver,normally cellphone
    BYTE                byType;					// Message type 0:MMS;1:SMS
	char                SZTitle[32];			// Message title
	char				byReserve[223];			// Reserved
} DHDEV_MMS_CFG;

// (Message triggers wireless connection configuration)
typedef struct  
{
	DWORD				dwSize;
	DWORD				dwEnable;				// Enable
	DWORD				dwSenderNum;			// Sender amount
	char				SZSender[DH_MMS_SMSACTIVATION_NUM][32];	// Sender, normally the cellphone number
 	char				byReserve[256];			// Reserved
}DHDEV_SMSACTIVATION_CFG;

// (Dailing triggers the wireless connection)
typedef struct  
{
	DWORD				dwSize;
	DWORD				dwEnable;				// Enable
	DWORD				dwCallerNum;			// Sender amount
	char				SZCaller[DH_MMS_DIALINACTIVATION_NUM][32];	// Sender, normally the cellphone
 	char				byReserve[256];			// Reserved
}DHDEV_DIALINACTIVATION_CFG;
// Above is with the mobile phone functions


// Wireless network signal strength structure
typedef struct
{
	DWORD				dwSize;
	DWORD				dwTDSCDMA;				// TD-SCDMA strength,range:0-100
	DWORD				dwWCDMA;				// WCDMA strength,range:0-100
	DWORD				dwCDMA1x;				// CDMA1x strength,range:0-100
	DWORD				dwEDGE;					// EDGE strength,range:0-100
	DWORD				dwEVDO;					// EVDO strength,range:0-100
	int					nCurrentType;			// Current type
												// 0	The device can't support this
												// 1    TD_SCDMA
												// 2	WCDMA
												// 3	CDMA_1x
												// 4	EDGE
												// 5	EVDO
                                                // 6 	TD-LTE
												// 7 	FDD-LTE
    DWORD               dwTDLTE;                // TD-LTE Strength, Range:0:100
    DWORD               dwFDDLTE;               // FDD-LTE Strength, Range0-100
    char                byReserve[244];         // reserved
} DHDEV_WIRELESS_RSS_INFO;

typedef struct _DHDEV_SIP_CFG
{
	BOOL				bUnregOnBoot;			//Unregister on Reboot
	char				szAccoutName[64];		//Account Name
	char				szSIPServer[128];		//SIP Server
	char				szOutBoundProxy[128];	//Outbound Proxy
	DWORD				dwSIPUsrID;				//SIP User ID
	DWORD				dwAuthID;				//Authenticate ID
	char				szAuthPsw[64];			//Authenticate Password
	char				szSTUNServer[128];		//STUN Server
	DWORD				dwRegExp;				//Registration Expiration
	DWORD				dwLocalSIPPort;			//Local SIP Port
	DWORD				dwLocalRTPPort;			//Local RTP Port
	BOOL				bEnable;				//Enable
	char				szNotifyID[128];        //Notify ID
	NET_TIME			stuRegTime;             //register time, read only 
	BYTE				bReserved[868];		    //reserved
} DHDEV_SIP_CFG;

typedef struct _DHDEV_SIP_STATE
{
	int					nStatusNum;				//SIP state number 
	BYTE				byStatus[64];           //0:on line,1:off line,2:invalid sip,3:registering,4:talking
	BYTE				bReserved[64];		    //reserved
}DHDEV_SIP_STATE;

typedef struct _DHDEV_HARDKEY_STATE
{
	BOOL				bState;                 // 0:Hard Key disconnect, 1:Hard Key connect
	BYTE				bReserved[64];          // reserved
}DHDEV_HARDKEY_STATE;

typedef struct _DHDEV_ISCSI_PATHLIST
{
	int					nCount;
	char				szPaths[DH_MAX_ISCSI_PATH_NUM][MAX_PATH_STOR];	// remote path
} DHDEV_ISCSI_PATHLIST;

// wifi capability country
typedef struct _DHDEV_WIFI_ROUTE_CAP_COUNTRY
{
	char				szCountry[32];			// country
	int					nValidChnNum;			// valid channel number
	int					nValideChannels[32];	// valid channel array
	char				reserved[64];			// reserved
} DHDEV_WIFI_ROUTE_CAP_COUNTRY;

typedef struct _DHDEV_WIFI_ROUTE_CAP
{
	int					nCountryNum;				// country number
	DHDEV_WIFI_ROUTE_CAP_COUNTRY stuCountry[256];	// country config
	char				reserved[256];				// reserved
} DHDEV_WIFI_ROUTE_CAP;

//  monitor info
typedef struct _MONITOR_INFO
{
	int					nPresetObjectNum;        // preset object number
	int					nActualObjectNum;        // actual object number
	char				reserved[64]; 
}MONITOR_INFO;

typedef struct _DHDEV_MONITOR_INFO
{
	int					nChannelNumber;
	MONITOR_INFO		stMonitorInfo[64];			//  monitor info
	char				reserved[128];
}DHDEV_MONITOR_INFO;

//Multi Channel Preview Playback Segmentation Ability
typedef struct tagNET_MULTIPLAYBACK_SPLIT_CAP
{
    DWORD            dwSize;
    int              nSliptMode[DH_MAX_MULTIPLAYBACK_SPLIT_NUM]; // Support segmentation Mode  
    int              nModeNumber;       
}NET_MULTIPLAYBACK_SPLIT_CAP;

/***************************** PTZ preset configuration ***********************************/
typedef struct _POINTEANBLE
{
	BYTE				bPoint;					// Preset range[1,80], invalid setting is 0.
	BYTE				bEnable;				// Valid or not,0 invalid,1 valid
	BYTE				bReserved[2];
} POINTEANBLE;

typedef struct _POINTCFG
{
	char				szIP[DH_MAX_IPADDR_LEN];// ip
	int					nPort;					// Port	
	POINTEANBLE			stuPointEnable[80];		// Preset enable
	BYTE				bReserved[256];
}POINTCFG;

typedef struct _DHDEV_POINT_CFG
{
	int					nSupportNum;			// Read-only parameter, shall return to sdk when set, it means supported pre-set number
	POINTCFG			stuPointCfg[16];		// 2D config means point info.
	BYTE				bReserved[256];			// Reserved
}DHDEV_POINT_CFG;
////////////////////////////////Mobile DVR supported////////////////////////////////

// GPS information(Mobile device)
typedef struct _GPS_Info
{
    NET_TIME			revTime;				// position time 
	char				DvrSerial[50];			// Device serial number
    double				longitude;				// Longitude
    double				latidude;				// Latitude 
    double				height;					// Height(meter)
    double				angle;					// Angle(The north pole is the original point and clockwise is +)
    double				speed;					// Speed(Kilometer/hour)
    WORD				starCount;				// Starcount
    BOOL				antennaState;			// Antenna status(true=good,false =bad)
    BOOL				orientationState;		// Orientation status (true=position,false = no position )
} GPS_Info,*LPGPS_Info;

// alarm state info
typedef struct 
{
	int                nAlarmCount;             // alarm count
	int                nAlarmState[128];        // alarm state
	BYTE               byRserved[128];          // reserved
}ALARM_STATE_INFO;

// Gps location info
typedef struct tagNET_GPS_LOCATION_INFO
{
	GPS_Info	        stuGpsInfo;               // GPS info
	ALARM_STATE_INFO    stuAlarmStateInfo;        // Alarm state info
	int				    nTemperature;		              // Temperature(Unit:0.1 centigrade)
	int					nHumidity;				  // Humidity(Unit:0.1%)
	unsigned int		nIdleTime;				  // Idle time(Unit:second)
	unsigned int        nMileage;				  // Mileage(Unit:0.1km)
	int					nVoltage;				  // Set Voltage value(Unit:0.1V)
    BYTE                bOffline;                 // 0-real time 1-fill
	BYTE			    byReserved[1023];  
}NET_GPS_LOCATION_INFO, *LPNET_GPS_LOCATION_INFO;

// Snapshot parameter structure 
typedef struct _snap_param
{
	unsigned int		Channel;				// Snapshot channel
	unsigned int		Quality;				// Image quality:level 1 to level 6
	unsigned int		ImageSize;				// Video size;0:QCIF,1:CIF,2:D1
	unsigned int		mode;					// Snapshot mode;0:request one frame,1:send out requestion regularly,2: Request consecutively
	unsigned int		InterSnap;				// Time unit is second.If mode=1, it means send out requestion regularly. The time is valid.
	unsigned int		CmdSerial;				// Request serial number
	unsigned int		Reserved[4];
} SNAP_PARAMS, *LPSNAP_PARAMS;

// Snapshot function setup 
typedef struct 
{
	DWORD				dwSize;
	BYTE				bTimingEnable;				// Schedule snapshot button(The alarm snapshot button is in alarm activation configuration)
	BYTE                bPicIntervalHour;           // timing snapshot interval hour
	short	            PicTimeInterval;			// The time intervals of timing capture (s). At present, the capture device supports the largest time interval is 30 minutes 
	DH_VIDEOENC_OPT		struSnapEnc[SNAP_TYP_NUM];  // Snapshot encode setup. The resolution, video quality, frame rate setup and fram rate are all negative. It means the snapshot times in each second. 
} DHDEV_SNAP_CFG;

// snap function extern configuration
typedef struct 
{
	DWORD				dwSize;
	BYTE				bTimingEnable;				// timing diagram switch(in tach of the alarm configuration)
	BYTE                bPicIntervalHour;           // the number of hours interval
	short	            PicTimeInterval;			// time interval(s),the biggest capture device support interval 30min now                        
	DH_VIDEOENC_OPT		struSnapEnc[SNAP_TYP_NUM];  // snap encode configuration,support resolution ,image quality and frame rate setting,frame rate is negative,say for a second to grasp figure number
	DWORD               dwTrigPicIntervalSecond;    // 
	BYTE                byRserved[256];             // reserved
} DHDEV_SNAP_CFG_EX;
//wifi state of car device
typedef struct  
{
	char	szSSID[128];							//SSID
	BOOL	bEnable;								//If enable wifi function, 0:Disable 1:Enable
	int		nSafeType;								//Verify type
													//0:OPEN 
													//1:RESTRICTE
													//2:WEP
													//3:WPA
													//4:WPA2
													//5:WPA-PSK
													//6:WPA2-PSK
	int		nEncryprion;							//Encryption method
													//0:OPEN
													//1:TKIP
													//2:WEP
													//3:AES
													//4:NONE(without verify)
													//5:AUTO
	                                                //6:SHARED
	int		nStrength;								//AP site signal
	char	szHostIP[128];							//host address
	char	szHostNetmask[128];						//host mask
	char	szHostGateway[128];						//host gate  way
	int		nPriority;								//Priority,(1-32)
	int     nEnDHCP;                                //0:disable 1:enable(default value is 1)
	BYTE	bReserved[1016];
} DHDEV_VEHICLE_WIFI_STATE;

typedef struct
{
	char	szSSID[128];							//SSID
	int		nPriority;								//Priority,(1-32)
	int		nSafeType;								//Verify type
													//0:OPEN 
													//1:RESTRICTE
													//2:WEP
													//3:WPA
													//4:WPA2
													//5:WPA-PSK
													//6:WPA2-PSK
	int		nEncryprion;							//Encryption method
													//0:OPEN
													//1:TKIP
													//2:WEP
													//3:AES
													//4:NONE(No verify)
													//5:AUTO
	                                                //6:SHARED
	char	szKey[128];								//Connection key
	char	szHostIP[128];							//Host address
	char	szHostNetmask[128];						//Host mask
	char	szHostGateway[128];						//Host gateway
	int     nEnDHCP;                                //0:disable 1:enable(default value is 1)
	BYTE    byKeyIndex;                             //Verify index of WEP,0:no support,1-4 is index
	BYTE	bReserved[1019];
} DHDEV_VEHICLE_WIFI_CONFIG;
typedef struct
{
	char    szSSID[128];                            // SSID   
	BYTE    bReserved[256];                         // reserved
}WIFI_CONNECT;
// IP modify configuration
typedef struct __DHCTRL_IPMODIFY_PARAM
{
	int                 nStructSize;
	char				szRemoteIP[DH_MAX_IPADDR_OR_DOMAIN_LEN];		// device IP
	char				szSubmask[DH_MAX_IPADDR_LEN];	                // submask
	char				szGateway[DH_MAX_IPADDR_OR_DOMAIN_LEN];	        // gatway
	char				szMac[DH_MACADDR_LEN];			                // MAC addr
	char				szDeviceType[DH_DEV_TYPE_LEN];	                // device type
}DHCTRL_IPMODIFY_PARAM;

typedef struct 
{
	BOOL	bIsScan;								//0:Not scan wifi (Manually added), 1: scanned wifi
	char	szSSID[128];							//SSID
	int		nSafeType;								//Verify type
													//0:OPEN 
													//1:RESTRICTE
													//2:WEP
													//3:WPA
													//4:WPA2
													//5:WPA-PSK
													//6:WPA2-PSK
	int		nEncryprion;							//Encryption method
													//0:OPEN
													//1:TKIP
													//2:WEP
													//3:AES
													//4:NONE(No verify)	
													//5:AUTO
	                                                //6:SHARED
	char	szKey[128];								//Connection key
	int		nStrength;								//AP site signal
	int		nMaxBitRate;							//AP site maximum transmission rate, with units, read-only
	int		nIsCnnted;								//If success connect read-only
	int		nIsSaved;								//If save read-only
	int		nPriority;								//Priority,(1-32)
	char	szHostIP[128];							//Host address
	char	szHostNetmask[128];						//Host network mask
	char	szHostGateway[128];						//Host gateway
	int		nWifiFreq;								//Radio frequency, using channel logo
	int     nEnDHCP;                                //0:disable 1:enable(default value is 1)
	BYTE    byKeyIndex;                             //Verify index of WEP,0:no support,1-4 is index
	BYTE	bReserved[1019];
}DHDEV_VEHICLE_SINGLE_WIFI_AP_CFG;

typedef struct 
{
	BOOL	bEnable;								//if enable wifi, 0:disable, 1:enable
	int		nWifiApNum;								//Effective number of structure:DHDEV_VEHICLE_WIFI_AP_CFG 
	DHDEV_VEHICLE_SINGLE_WIFI_AP_CFG struWifiAp[64];//Single WIFI AP configration
	int	nReserved[512];								//reserved
}DHDEV_VEHICLE_WIFI_AP_CFG;

typedef struct  
{	
	BOOL   bEnable;									//to enable wift, 0:disable 1:enable
	int    nRetWifiApNum;							//get number of DHDEV_VEHICLE_WIFI_AP_CFG
	int    nMaxWifiApNum;							//apply number of DHDEV_VEHICLE_SINGLE_WIFI_AP_CFG
	DHDEV_VEHICLE_SINGLE_WIFI_AP_CFG* pWifiAp;		//a WIFI AP configuration
	int nReserved[512];								//reserved
}DHDEV_VEHICLE_WIFI_AP_CFG_EX;
// GPS log structure
typedef struct _DH_DEVICE_GPS_LOG_ITEM
{
	DHDEVTIME       stuDevTime;             // device time  
	DWORD		    dwLatidude;				// Longitude(0-180 degree)north Longitude 30.183382 = (30.183382 + 90) * 100000 = 120183382
	DWORD		    dwLongitude;			// Latitude(0-360 degree)east Latitude 120.178274 =(120.178274 + 180) * 100000 = 300178274
	DWORD           dwSpeed;                // speed,dwSpeed/1000*1.852km/h
	DWORD           dwHight;                // hight,m
	DWORD           dwAngle;                // direction,0~360,the north is it's origin, clockwise
	DHDEVTIME       stuGpsTime;             // GPS time 
	BYTE            bAntStatus; 		    // GPS antenna state,0 means good;!=0 meams there has some exception 
	BYTE            bOriStatus; 			// orientation state, != 0 means orientation sucess;
	BYTE            bSatCount; 				// satellite count
	BYTE            bGPSStatus; 			// GPS state,0:not orientation, 1:non differential position information 2:differential position information
	DWORD           dwTemp;                 // temperature(centigrade),if real value is 30.0 centigrade,this param will be valued as 30000
	DWORD           dwHumidity;             // humidity(%),if real value is 30.0%,this param will be valued as 30000
	BYTE            bReserved[24];          // reserved
    
}DH_DEVICE_GPS_LOG_ITEM;

// query GPS param
typedef struct _QUERY_GPS_LOG_PARAM
{
	NET_TIME			stuStartTime;			// start time
	NET_TIME			stuEndTime;				// end time
	int					nStartNum;				// start index,the first time to query an be valued with 0
	BYTE				bReserved[20];
} QUERY_GPS_LOG_PARAM;

typedef struct _GPS_TEMP_HUMIDITY_INFO
{
	double              dTemperature;          // temperature(centigrade),if real value is 30.0 centigrade,this param will be valued as 30000
	double              dHumidity;             // humidity(%),if real value is 30.0%,this param will be valued as 30000
	BYTE                bReserved[128];        // reserved
}GPS_TEMP_HUMIDITY_INFO;

// enclosure type
typedef enum
{
    ENCLOSURE_UNKNOWN = 0x00,                   // unknown
	ENCLOSURE_LIMITSPEED = 0x01,				// speed limit
	ENCLOSURE_DRIVEALLOW = 0x02,				// drive allow
	ENCLOSURE_FORBIDDRIVE = 0x04,				// forbid drive
	ENCLOSURE_LOADGOODS = 0x08,					// load goods
	ENCLOSURE_UPLOADGOODS = 0x10,				// upload goods
    ENCLOSURE_FLYALLOW = 0x20,                  // fly allow
    ENCLOSURE_MANUALFORBIDFLY = 0x40,           // manual forbid fly
    ENCLOSURE_FIXEDFORBIDFLY = 0x80,            // fixed forbid fly (airdrome ) - no configuration
    ENCLOSURE_FiXEDLIMITFLY = 0x81,             // fixed limit fly - no configuration
}ENCLOSURE_TYPE;

typedef enum
{
	 ENCLOSURE_ALARM_DRIVEIN ,	                 // drive in
	 ENCLOSURE_ALARM_DRIVEOUT,	                 // drive out
	 ENCLOSURE_ALARM_OVERSPEED,				     // over speed
	 ENCLOSURE_ALARM_SPEEDCLEAR,				 // speed clear
     ENCLOSURE_ALARM_FLYNEAR,                    // fly near
}ENCLOSURE_ALARM_TYPE;

typedef struct 
{
	DWORD				dwLongitude;			// longitude
    DWORD				dwLatidude;				// latidude
}GPS_POINT;

// enclosure config
typedef struct _DHDEV_ENCLOSURE_CFG
{
	UINT				unType;                 // mask
	BYTE				bRegion[8];             // front 4 bit means country, province, city, town
	UINT				unId;                   // rect id
	UINT				unSpeedLimit;           // speed limit(km/h)
	UINT				unPointNum;             // rect point number
	GPS_POINT			stPoints[128];			// rect point info
	char          		szStationName[DH_STATION_NAME_LEN];  //station name
    BYTE                bDisenable;             // disable. 0 - enable ; 1 - diable
    BYTE                bShape;                 // shape.  0 - polygon; 1 - circular;
    BYTE                bLimitType;             // limit type. 0-no limit; 1 - altitude limit; 2 - radius limist; 3 - both altitude and radius limit 
    BYTE                bAction;                // action . 0 - no; 1 - only report; 2 - hover; 3 - home return;
    int                 nLimitAltitude;         // limit altitude. unit: cm. 0 - invalid
    int                 nAlarmAltitude;         // alarm altitude. unit: cm. 0 - invalid
    UINT                unLimitRadius;          // limit radius. unit: cm. 0 - invalid
    UINT                unAlarmRadius;          // alarm radius. unit: cm. 0 - invalid
    BYTE                reserved[12];           // reserved
}DHDEV_ENCLOSURE_CFG;

// enclosure version config
typedef struct _DHDEV_ENCLOSURE_VERSION_CFG
{
	UINT				unType;                 // type mask,such as LIMITSPEED | DRIVEALLOW
    UINT				unVersion[32];          // version
    int					nReserved;              // reserved 
}DHDEV_ENCLOSURE_VERSION_CFG;

// enclosure alarm info
typedef struct __ALARM_ENCLOSURE_INFO
{
	int					nTypeNumber;                    // type number
	BYTE				bType[16];						// type
	int					nAlarmTypeNumber;               // alarm type number
	BYTE				bAlarmType[16];                 // alarm type
	char				szDriverId[DH_VEHICLE_DRIVERNO_LEN];  // drive id
	UINT				unEnclosureId;      	        // enclosure id
	UINT				unLimitSpeed;	                // speed limit(km/h)
	UINT				unCurrentSpeed;                 // current speed
	NET_TIME			stAlarmTime;                    // alarm time
	DWORD				dwLongitude;					// longitude
	DWORD				dwLatidude;						// latidude
	BYTE          		bOffline;                       // 0-real time 1-tofill  
    UINT                unTriggerCount;                 // trigger count
	BYTE				byReserved[115];                // reserved
}ALARM_ENCLOSURE_INFO;

// RAID state
#define DH_MAX_RAID_NUM  16
#define DH_MAX_RAID_DEVICE_NAME 16
typedef struct __RAID_STATE_INFO
{
	char				szName[16];					// Raid name
	BYTE				byType;						// type 1:Jbod     2:Raid0      3:Raid1     4:Raid5
	BYTE				byStatus;					// status 0:unknown ,1:active,2:degraded,3:inactive,4:recovering
	BYTE                byReserved[2];
	int					nCntMem;					// nMember number
	int					nMember[32];				// 1,2,3,.
	int					nCapacity;					// capacity(G)
	int					nRemainSpace;				// remain space(M)
	int					nTank;						// Tank 0:main,1:tank1,2:tank2 ...
	char				reserved[32];
}RAID_STATE_INFO;

typedef struct __ALARM_RAID_INFO
{
	int              nRaidNumber;                   // RAID number
	RAID_STATE_INFO  stuRaidInfo[DH_MAX_RAID_NUM];  // RAID info
	char             reserved[128];
}ALARM_RAID_INFO;

// RAID error type
typedef enum tagEM_RAID_ERROR
{
	EM_RAID_ERROR_UNKNOW,                                       // unknow
	EM_RAID_ERROR_FAILED,								        // RAID failed
	EM_RAID_ERROR_DEGRADED,                                     // RAID degraded
} EM_RAID_ERROR;

// subdisk state
typedef enum tagEM_RAID_ERR_SUBDISK
{
    EM_RAID_ERR_SUBDISK_UNKNOWN,                                // unknown
        EM_RAID_ERR_SUBDISK_OFFLINE,                            // offline
        EM_RAID_ERR_SUBDISK_FAULTY,                             // faulty
        EM_RAID_ERR_SUBDISK_WRITEERR,                           // write error
} EM_RAID_ERR_SUBDISK;

// subdisk detail info
typedef struct tagNET_RAID_ERR_DETAIL_INFO
{
    DWORD                 dwSlotNum;                            // subdisk slotNumber
    EM_RAID_ERR_SUBDISK   emErrSubDisk;                         // subdisk state
    BYTE                  byReserved[24];                       // rerserved
}NET_RAID_ERR_DETAIL_INFO;

// NEW RAID alram,used in DH_ALARM_RAID_STATE_EX Alarm
typedef struct tagALARM_RAID_INFO_EX
{
	DWORD                nAction;                               // 0-start, 1-stop
	char                 szDevice[DH_MAX_RAID_DEVICE_NAME];     // device name
	EM_RAID_ERROR        emErrorType;                           // error type
    int                  nDetailNum;                            // valid count of subdisk detail info
    NET_RAID_ERR_DETAIL_INFO stuErrDetail[16];                  // subdisk detail info
	BYTE                 byReserved[508];                       // rerserved
}ALARM_RAID_INFO_EX;

// Structure of IPC storage failure alarm(IPC SD Card Abnormal Alarm) Corresponding to DH_ALARM_STORAGE_IPC_FAILURE alarm
typedef struct tagALARM_STORAGE_IPC_FAILURE_INFO
{
    int                  nAction;                               // 0-start, 1-stop
    int                  nChannelID;                            // channel ID
    BYTE                 byReserved[1024];                      // rerserved
}ALARM_STORAGE_IPC_FAILURE_INFO;

//Still amarm, if the device coordinates are not changed in the specified time, the static alarm information is triggered. Corresponding to DH_ALARM_DEVICE_STAY
typedef struct tagALARM_DEVICE_STAY_INFO
{
	int					nAction;								// 0-start, 1-stop
	int					nChannelID;								// channel ID
	BYTE				byReserved[1024];						// rerserved
}ALARM_DEVICE_STAY_INFO;
// sub way door state type
typedef enum tagEM_SUB_WAY_DOOR_STATE_TYPE
{
    EM_SUB_WAY_DOOR_STATE_TYPE_UNKNOWN,     // Unkown
    EM_SUB_WAY_DOOR_STATE_TYPE_LOST,        // Lost
    EM_SUB_WAY_DOOR_STATE_TYPE_ISOLATION,   // Isolation
    EM_SUB_WAY_DOOR_STATE_TYPE_UNLOCK,      // Unlock
    EM_SUB_WAY_DOOR_STATE_TYPE_NORMAL,      // normal
}EM_SUB_WAY_DOOR_STATE_TYPE;


// sub way carriage number type
typedef enum tagEM_SUB_WAY_CARRIAGE_NUMBER_TYPE
{
    EM_SUB_WAY_CARRIAGE_NUMBER_TYPE_UNKNOWN, // Unknown
    EM_SUB_WAY_CARRIAGE_NUMBER_TYPE_TC1,     // TC1
    EM_SUB_WAY_CARRIAGE_NUMBER_TYPE_M1,      // M1
    EM_SUB_WAY_CARRIAGE_NUMBER_TYPE_M2,      // M2
    EM_SUB_WAY_CARRIAGE_NUMBER_TYPE_TC2,     // TC2
}EM_SUB_WAY_CARRIAGE_NUMBER_TYPE;

// the door state of subway Corresponding to DH_ALARM_SUB_WAY_DOOR_STATE alarm
typedef struct tagALARM_SUB_WAY_DOOR_STATE_INFO
{
    int                                 nAction;             // -1:unknown, 0:pulse, 1:start, 2:stop
    int					                nEventID;			 // Event ID
    double				                dbPTS;				 // Time stamp (Unit is ms)
    NET_TIME_EX			                stuTime;			 // Event occurrence time    
    int                                 nDoorNumber;         // door number
    EM_SUB_WAY_DOOR_STATE_TYPE          emDoorState;         // door state
    EM_SUB_WAY_CARRIAGE_NUMBER_TYPE     emCarriageNumber;    // carriage number
    BYTE                                byReserved[1024];    // reserved
}ALARM_SUB_WAY_DOOR_STATE_INFO;

// the PECE switch state of subway Corresponding to DH_ALARM_SUB_WAY_PECE_SWITCH alarm
typedef struct tagALARM_SUB_WAY_PECE_SWITCH_INFO
{
    int                                 nAction;             // -1:unknown, 0:pulse, 1:start, 2:stop
    int					                nEventID;			 // Event ID
    double				                dbPTS;				 // Time stamp (Unit is ms)
    NET_TIME_EX			                stuTime;			 // Event occurrence time
    int                                 nDoorNumber;         // door number
    int                                 nState;              // state,1:open,0:close,other:unknown
    EM_SUB_WAY_CARRIAGE_NUMBER_TYPE     emCarriageNumber;    // carriage number
    BYTE                                byReserved[1024];    // reserved
}ALARM_SUB_WAY_PECE_SWITCH_INFO;

// the fire alarm of subway Corresponding to DH_ALARM_SUB_WAY_FIRE_ALARM alarm
typedef struct tagALARM_SUB_WAY_FIRE_ALARM_INFO
{
    int                                 nAction;             // -1:unknown, 0:pulse, 1:start, 2:stop
    int					                nEventID;			 // Event ID
    double				                dbPTS;				 // Time stamp (Unit is ms)
    NET_TIME_EX			                stuTime;			 // Event occurrence time
    int                                 nSourceNumber;       // source number
    BOOL                                bState;              // state,TRUE:alarm,FALSE:no alarm    
    BYTE                                byReserved[1024];    // reserved
}ALARM_SUB_WAY_FIRE_ALARM_INFO;

// the emer handle state Corresponding to DH_ALARM_SUB_WAY_EMER_HANDLE alarm
typedef struct tagALARM_SUB_WAY_EMER_HANDLE_INFO
{
    int                                 nAction;             // -1:unknown, 0:pulse, 1:start, 2:stop
    int					                nEventID;			 // Event ID
    double				                dbPTS;				 // Time stamp (Unit is ms)
    NET_TIME_EX			                stuTime;			 // Event occurrence time
    BOOL                                bState;              // state,TRUE:handling,FALSE:no handling
    EM_SUB_WAY_CARRIAGE_NUMBER_TYPE     emCarriageNumber;    // carriage number
    BYTE                                byReserved[1024];    // reserved
}ALARM_SUB_WAY_EMER_HANDLE_INFO;

// the cab cover state Corresponding to DH_ALARM_SUB_WAY_CAB_COVER alarm
typedef struct tagALARM_SUB_WAY_CAB_COVER_INFO
{
    int                                 nAction;             // -1:unknown, 0:pulse, 1:start, 2:stop
    int					                nEventID;			 // Event ID
    double				                dbPTS;				 // Time stamp (Unit is ms)
    NET_TIME_EX			                stuTime;			 // Event occurrence time
    int                                 nState;              // state,1:open,0:close,other:unknown
    EM_SUB_WAY_CARRIAGE_NUMBER_TYPE     emCarriageNumber;    // carriage number
    BYTE                                byReserved[1024];    // reserved
}ALARM_SUB_WAY_CAB_COVER_INFO;

// the dera or obst of subway Corresponding to DH_ALARM_SUB_WAY_DERA_OBST alarm
typedef struct tagALARM_SUB_WAY_DERA_OBST_INFO
{
    int                                 nAction;             // -1:unknown, 0:pulse, 1:start, 2:stop
    int					                nEventID;			 // Event ID
    double				                dbPTS;				 // Time stamp (Unit is ms)
    NET_TIME_EX			                stuTime;			 // Event occurrence time
    BOOL                                bState;              // state, TRUE:state checked,FALSE:no state checked
    EM_SUB_WAY_CARRIAGE_NUMBER_TYPE     emCarriageNumber;    // carriage number
    BYTE                                byReserved[1024];    // reserved
}ALARM_SUB_WAY_DERA_OBST_INFO;

// the PECU call state Corresponding to DH_ALARM_SUB_WAY_PECU_CALL alarm
typedef struct tagALARM_SUB_WAY_PECU_CALL_INFO
{
    int                                 nAction;             // -1:unknown, 0:pulse, 1:start, 2:stop
    int					                nEventID;			 // Event ID
    double				                dbPTS;				 // Time stamp (Unit is ms)
    NET_TIME_EX			                stuTime;			 // Event occurrence time
    int                                 nCallNumber;         // call number
    BOOL                                bState;              // state,TRUE:alarming,FALSE:no alarming
    EM_SUB_WAY_CARRIAGE_NUMBER_TYPE     emCarriageNumber;    // carriage number
    BYTE                                byReserved[1024];    // reserved
}ALARM_SUB_WAY_PECU_CALL_INFO;

// door closed manually  Corresponding to DH_ALARM_DOOR_CLOSEDMANUALLY  alarm
typedef struct tagALARM_DOOR_CLOSEDMANUALLY_INFO
{
    int                                 nAction;             // -1:unknown 1:start 2:stop
    int					                nEventID;			 // Event ID
    double				                dbPTS;			     // Time stamp (Unit is ms)
    NET_TIME_EX			                stuTime;			 // Event occurrence time
    int                                 nDoor;               // door channel id
    char                                szDoorName[DH_MAX_DOORNAME_LEN]; //door name
    BYTE                                byReserved[1024];    // reserved
}ALARM_DOOR_CLOSEDMANUALLY_INFO;

// door not closed long time Corresponding to DH_ALARM_DOOR_NOTCLOSED_LONGTIME alarm
typedef struct tagALARM_DOOR_NOTCLOSED_LONGTIME_INFO
{
    int                                 nAction;             // -1:unknown 1:start 2:stop
    int					                nEventID;			 // Event ID
    double				                dbPTS;			     // Time stamp (Unit is ms)
    NET_TIME_EX			                stuTime;			 // Event occurrence time
    int                                 nDoor;               // door channel id
    char                                szDoorName[DH_MAX_DOORNAME_LEN]; // door name
    BYTE                                byReserved[1024];    // reserved
}ALARM_DOOR_NOTCLOSED_LONGTIME_INFO;

// the cut line alarm info, Corresponding to DH_ALARM_CUT_LINE alarm
typedef struct tagALARM_CUT_LINE_INFO
{
	int									nChannel;			 // Channel ID
	int                                 nAction;             // -1:unknown, 0:pulse, 1:start, 2:stop
    NET_TIME_EX			                stuTime;			 // Event occurrence time
    BYTE                                byReserved[1024];    // reserved
} ALARM_CUT_LINE_INFO;

// the fibre optic abort info,Corresponding to DH_ALARM_FIBRE_OPTIC_ABORT alarm
typedef struct tagALARM_FIBRE_OPTIC_ABORT
{
	int									nAlarmIn;			 // Alarm input NO.;
	int                                 nAction;             // 1:start, 2:stop 
	NET_TIME_EX							UTC;				 // Event occurrence time
	BYTE                                byReserved[1024];    // reserved
}ALARM_FIBRE_OPTIC_ABORT;

//tail detetcion info,Corresponding to DH_ALARM_TAIL_DETECTION alarm
typedef struct tagALARM_TAIL_DETECTION_INFO       
{     
	int									nAction;                   		// Event operation. 1: Start, 2: Stop
	int									nChannelID;						// Channel No.
    double								dbPTS;							// Time stamp (Unit is ms)
    NET_TIME_EX							stuTime;						// Event occurrence time 
    int									nEventID;						// Event ID
	BYTE                				byReserved[1024];   			// reserve text  
}ALARM_TAIL_DETECTION_INFO; 

// near distance detection alarm infoCorresponding to DH_ALARM_NEAR_DISTANCE_DETECTION alarm
typedef struct tagALARM_NEAR_DISTANCE_INFO
{
	int									nChannel;			 // channel ID
	int                 				nAction;             // event action, 0: Pulse, 1: Start, 2: Stop
	int					                nEventID;			 // event ID
    double				                dbPTS;			     // PTS(ms)
    NET_TIME_EX			                stuTime;			 // time of occurrence
    BYTE                                byReserved[1024];    //  reserved
} ALARM_NEAR_DISTANCE_INFO;

// list of petsons within the region(man stand)
typedef struct tagMAN_STAND_LIST_INFO
{
	DH_POINT			stuCenter;			// standing personnel coordinate, 8192 coordinate system
	char                szReversed[128];    // reserved
} MAN_STAND_LIST_INFO;

// stereo standing alarm info, Corresponding to DH_ALARM_MAN_STAND_DETECTION alarm
typedef struct tagALARM_MAN_STAND_INFO
{
	int							nChannel;			 		// channel ID
	int                 		nAction;             		// event action, 0: Pulse, 1: Start, 2: Stop
	int					        nEventID;			 		// event ID
    double				        dbPTS;			     		// PTS(ms)
    NET_TIME_EX			        stuTime;			 		// time of occurrence

	int							nManListCount;				// number of regional personnet list
	MAN_STAND_LIST_INFO			stuManList[MAX_MAN_LIST_COUNT];	// list of petsons within the region
    BYTE                        byReserved[1024];    		// reserved
} ALARM_MAN_STAND_INFO;

// list of petsons within the region(man num)
typedef struct tagMAN_NUM_LIST_INFO
{
	DH_RECT				stuBoudingBox;			// personnel bounding box, 8192 coordinate system
	int					nStature;				// persoonel  height, unit cm
	char                szReversed[128];    	// reserved
} MAN_NUM_LIST_INFO;

// the statistics of people in stereo vision alarm info, Corresponding to DH_ALARM_MAN_NUM_DETECTION alarm
typedef struct tagALARM_MAN_NUM_INFO
{
	int							nChannel;			 		// channel ID
	int                 		nAction;             		// event action, 0: Pulse, 1: Start, 2: Stop
	int					        nEventID;			 		// event ID
    double				        dbPTS;			     		// PTS(ms)
    NET_TIME_EX			        stuTime;			 		// time of occurrence
    int							nManListCount;				// number of regional personnet list
	MAN_NUM_LIST_INFO			stuManList[MAX_MAN_LIST_COUNT];	// list of petsons within the region
    BYTE                        byReserved[1024];    		// reserved
} ALARM_MAN_NUM_INFO;

//alarm when camera bitrate is over channel decoding specification, corresponding to DH_ALARM_BITRATES_OVERLIMIT alarm 
typedef struct tagALARM_BITRATES_OVERLIMIT_INFO        
{      
	int                                 nChannel;                       // video channel NO.          
	int                                 nAction;                        // event action,1:alarm start,2:alarm stop;   
	int                                 nLimitBps;                      // limit Bps,UNIT:Kbps 
	int                                 nCurrentBps;                    // Current Bps,UNIT:Kbps 
	BYTE                                byReserved[1024];               // reserved  
}ALARM_BITRATES_OVERLIMIT_INFO; 

//High decibel alarm info, corresponding to DH_ALARM_HIGH_DECIBEL alarm
typedef struct tagALARM_HIGH_DECIBEL_INFO
{
	int                                 nAudioChannel;                  // Audio channel NO. 
	int                                 nAction;                        // -1:unknown, 0:pulse, 1:start, 2:stop
	NET_TIME_EX                         stuTime;                        // Event occurrence time
    BYTE                                byReserved[1024];               // reserved
}ALARM_HIGH_DECIBEL_INFO; 

//Shake detection alarm info, corresponding to DH_ALARM_SHAKE_DETECTION alarm
typedef struct tagALARM_SHAKE_DETECTION_INFO
{          
	int                                 nAction;                        // -1:unknown, 0:pulse, 1:start, 2:stop   
    NET_TIME_EX                         stuTime;                        // Event occurrence time
	BYTE                                byReserved[1024];               // reserved    
}ALARM_SHAKE_DETECTION_INFO;

// access method
typedef enum tagNET_ACCESS_METHOD
{
    NET_ACCESS_METHOD_UNKNOWN,                                          // unknown
    NET_ACCESS_METHOD_CARD,                                             // card
    NET_ACCESS_METHOD_PASSWORD,                                         // password
    NET_ACCESS_METHOD_FINGERPRINT,                                      // fingerprint
}NET_ACCESS_METHOD;

//open door with malice,  corresponding to DH_ALARM_ACCESS_CTL_MALICIOUS
typedef struct tagALARM_ACCESS_CTL_MALICIOUS
{
    int                                 nAction;                        // -1:unknown, 0:pulse, 1:start, 2:stop   
    NET_TIME_EX                         stuTime;                        // event occurrence time
    NET_ACCESS_METHOD                   emMethod;                       // open door method
    char                                szSerialNum[MAX_COMMON_STRING_32];     // sn
	int									nChannel;						// channel
    BYTE                                byReserved[1020];               // reserved	
}ALARM_ACCESS_CTL_MALICIOUS;

// user register alarm, corresponding to DH_ALARM_ACCESS_CTL_USERID_REGISTER
typedef struct tagALARM_ACCESS_CTL_USERID_REGISTER
{
    int                                 nAction;                        // -1:unknown, 0:pulse, 1:start, 2:stop   
    NET_TIME_EX                         stuTime;                        // event occurrence time
    char                                UserID[DH_USER_NAME_LEN_EX];    // user id
    NET_ACCESS_METHOD                   emMethod;                       // register method
    char                                szSerialNum[MAX_COMMON_STRING_32];     // intelligence lock serial number
    BYTE                                byReserved[1024];               // reserved 
}ALARM_ACCESS_CTL_USERID_REGISTER;

// lock type
typedef enum tagNET_ACCESS_CTL_LOCKTYPE
{
    NET_ACCESS_CTL_LOCKTYPE_UNKNOWN,                                    // unknown
    NET_ACCESS_CTL_LOCKTYPE_DEADBOLT,                                   // dead bolt
    NET_ACCESS_CTL_LOCKTYPE_STAYBOLT,                                   // stay bolt
}NET_ACCESS_CTL_LOCKTYPE;

// reverer lock alarm, corresponding to DH_ALARM_ACCESS_CTL_REVERSELOCK
typedef struct tagALARM_ACCESS_CTL_REVERSELOCK
{
    int                                 nAction;                        // -1:unknown, 0:pulse, 1:start, 2:stop     
    NET_TIME_EX                         stuTime;                        // event occurrence time
    BOOL                                bStatus;                        // lock status
    NET_ACCESS_CTL_LOCKTYPE             emMethod;                       // lock type
    char                                szSerialNum[MAX_COMMON_STRING_32];     // intelligence lock serial number
    BYTE                                byReserved[1024];               // reserved 
}ALARM_ACCESS_CTL_REVERSELOCK;

// delate user alarm , corresponding to DH_ALARM_ACCESS_CTL_USERID_DELETE
typedef struct tagALARM_ACCESS_CTL_USERID_DELETE
{
    int                                 nAction;                        // -1:unknown, 0:pulse, 1:start, 2:stop  
    NET_TIME_EX                         stuTime;                        // event occurrence time
    NET_ACCESS_METHOD                   emMethod;                       // register method
    char                                szSerialNum[MAX_COMMON_STRING_32];     // intelligence lock serial number
    BYTE                                byReserved[1024];               // reserved 
}ALARM_ACCESS_CTL_USERID_DELETE;

//event type DH_ALARM_ACCESS_DOOR_BELL (Door bell event ) corresponding data description info
typedef struct tagALARM_ACCESS_DOOR_BELL_INFO
{
	int                     nChannelID;                     			//channel ID,start from 0
	NET_TIME_EX             stuTime;                                 	//utc time
	char                    szName[DH_MAX_NAME_LEN];        		    // access control name
	char                    szWirelessDevSN[DH_MAX_ACCESS_NAME_LEN];    // wirelesss dev serial number
	BYTE			        bReserved[512];
}ALARM_ACCESS_DOOR_BELL_INFO;

//event type DH_ALARM_ACCESS_FACTORY_RESET (Access control reset factory event) corresponding data description info
typedef struct tagALARM_ACCESS_FACTORY_RESET_INFO
{
	NET_TIME_EX             stuTime;                        			//utc time
	char                    szSmartLockSN[DH_MAX_ACCESS_NAME_LEN];      //smart lock serial number
    BYTE			        bReserved[512];
}ALARM_ACCESS_FACTORY_RESET_INFO;

// Cabinet switch action type 
typedef enum tagEM_NET_CABINET_SWITCH_ACTION_TYPE
{
    NET_CABINET_SWITCH_ACTION_TYPE_UNKNOWN,							// unknown
	NET_CABINET_SWITCH_ACTION_TYPE_OPEN,							// open cabinet
	NET_CABINET_SWITCH_ACTION_TYPE_CLOSE,							// close cabinet
} EM_NET_CABINET_SWITCH_ACTION_TYPE;

// max number of video surveillance channels associated with the storage device
#define MAX_LINK_CHANNEL_NUMBER		16

// Cloud Cabinet Event (DH_ALARM_CABINET)
typedef struct tagALARM_CABINET_INFO
{
    int									nAction;                                // 0:Pulse,1:Start,2:Stop,3:State
	NET_TIME_EX							stuTime;								// event occurrence time
	EM_NET_CABINET_SWITCH_ACTION_TYPE	emType;									// Cabinet switch action type 
	char								szSerialNo[MAX_COMMON_STRING_32];		// item serial number
	int									nLinkChannelNum;						// number of video surveillance channels associated with the storage device
	int									nLinkChannel[MAX_LINK_CHANNEL_NUMBER];	// store the video surveillance channels associated with the storage device
    BYTE								byReserved[1024];                       // reserved
} ALARM_CABINET_INFO;

//event type DH_SWITCH_SCREEN (Switch Screen event) corresponding data description info
typedef struct tagDH_SWITCH_SCREEN_INFO
{
	int            nChannelID;                                    //channel ID, start from 0
	BYTE           bReserved[512];                               
}DH_SWITCH_SCREEN_INFO;

#define MAX_EVENT_INFO_LEN			128          // event info len

//	MCS general capacity low info, correspondging to DH_MCS_GENERAL_CAPACITY_LOW
typedef struct tagALARM_MCS_GENERAL_CAPACITY_LOW_INFO
{
	char		szEventInfo[MAX_EVENT_INFO_LEN];	       // Event info 
	BYTE		byReserved[1024];						   // Reserved
}ALARM_MCS_GENERAL_CAPACITY_LOW_INFO;

// MCS data node offline info,corresponding to DH_MCS_DATA_NODE_OFFLINE
typedef struct tagALARM_MCS_DATA_NODE_OFFLINE_INFO
{
	char		szEventInfo[MAX_EVENT_INFO_LEN];			// Event info 
	BYTE		byReserved[1024];							// Reserved
}ALARM_MCS_DATA_NODE_OFFLINE_INFO;

// MCS disk offline info, corresponding to DH_MCS_DISK_OFFLINE
typedef struct tagALARM_MCS_DISK_OFFLINE_INFO
{
	char		szEventInfo[MAX_EVENT_INFO_LEN];			// Event info 
	BYTE		byReserved[1024];							// Reserved
}ALARM_MCS_DISK_OFFLINE_INFO;

// MCS disk slow info,corresponding to DH_MCS_DISK_SLOW
typedef struct tagALARM_MCS_DISK_SLOW_INFO
{
	char		szEventInfo[MAX_EVENT_INFO_LEN];			// Event info
	BYTE		byReserved[1024];							// Reserved
}ALARM_MCS_DISK_SLOW_INFO;

// MCS disk broken info,corresponding to DH_MCS_DISK_BROKEN
typedef struct tagALARM_MCS_DISK_BROKEN_INFO
{
	char		szEventInfo[MAX_EVENT_INFO_LEN];			// Event info
	BYTE		byReserved[1024];							// Reserved
}ALARM_MCS_DISK_BROKEN_INFO;

// MCS disk unknow error info, corresponding to DH_MCS_DISK_UNKNOW_ERROR
typedef struct tagALARM_MCS_DISK_UNKNOW_ERROR_INFO
{
	char		szEventInfo[MAX_EVENT_INFO_LEN];			// Event info
	BYTE		byReserved[1024];							// Reserved
}ALARM_MCS_DISK_UNKNOW_ERROR_INFO;

// MCS metadata server abnormal info,corresponding to DH_MCS_METADATA_SERVER_ABNORMAL
typedef struct tagALARM_MCS_METADATA_SERVER_ABNORMAL_INFO
{
	char		szEventInfo[MAX_EVENT_INFO_LEN];			// Event info
	BYTE		byReserved[1024];							// Reserved
}ALARM_MCS_METADATA_SERVER_ABNORMAL_INFO;

// MCS catalog server abnormal info,corresponding to DH_MCS_CATALOG_SERVER_ABNORMAL
typedef struct tagALARM_MCS_CATALOG_SERVER_ABNORMAL_INFO
{
	char		szEventInfo[MAX_EVENT_INFO_LEN];			// Event info
	BYTE		byReserved[1024];							// Reserved
}ALARM_MCS_CATALOG_SERVER_ABNORMAL_INFO;

// MCS general capacity resume info,corresponding to DH_MCS_GENERAL_CAPACITY_RESUME
typedef struct tagALARM_MCS_GENERAL_CAPACITY_RESUME_INFO
{
	char		szEventInfo[MAX_EVENT_INFO_LEN];			// Event info
	BYTE		byReserved[1024];							// Reserved
}ALARM_MCS_GENERAL_CAPACITY_RESUME_INFO;

// MCS data node online info,corresponding to DH_MCS_DATA_NODE_ONLINE
typedef struct tagALARM_MCS_DATA_NODE_ONLINE_INFO
{
	char		szEventInfo[MAX_EVENT_INFO_LEN];			// Event info
	BYTE		byReserved[1024];							// Reserved
}ALARM_MCS_DATA_NODE_ONLINE_INFO;

// MCS disk online info,corresponding to DH_MCS_DISK_ONLINE
typedef struct tagALARM_MCS_DISK_ONLINE_INFO
{
	char		szEventInfo[MAX_EVENT_INFO_LEN];			// Event info
	BYTE		byReserved[1024];							// Reserved
}ALARM_MCS_DISK_ONLINE_INFO;

// MCS metadata slave online info,corresponding to DH_MCS_METADATA_SLAVE_ONLINE
typedef struct tagALARM_MCS_METADATA_SLAVE_ONLINE_INFO
{
	char		szEventInfo[MAX_EVENT_INFO_LEN];			// Event info
	BYTE		byReserved[1024];							// Reserved
}ALARM_MCS_METADATA_SLAVE_ONLINE_INFO;

// MCS catalog server online info,corresponding to DH_MCS_CATALOG_SERVER_ONLINE
typedef struct tagALARM_MCS_CATALOG_SERVER_ONLINE_INFO
{
	char		szEventInfo[MAX_EVENT_INFO_LEN];			// Event info
	BYTE		byReserved[1024];							// Reserved
}ALARM_MCS_CATALOG_SERVER_ONLINE_INFO;

//////////////////////////////////ATM support//////////////////////////////////

typedef struct
{
	int					Offset;					// Symbol position bit Offset
	int					Length;					// Symbol position length
	char				Key[16];				// Symbol position value 
} DH_SNIFFER_FRAMEID;

typedef struct 
{
	int					Offset;					// Symbol position bit offset 
	int					Offset2;				// It is invalid now 
	int					Length;					// The symbol position length
	int					Length2;				// It is invalid now
	char				Title[12];  			// Title value 
	char                Key[12];                // Key value
} DH_SNIFFER_CONTENT;

// Network sniffer setup 
typedef struct 
{
	DH_SNIFFER_FRAMEID	snifferFrameId;			// Each FRAME ID option
	DH_SNIFFER_CONTENT	snifferContent[DH_SNIFFER_CONTENT_NUM];	// The corresponding four sniffers in each FRAME
} DH_SNIFFER_FRAME;

// Configuration structure of each sniffer 
typedef struct
{
	char				SnifferSrcIP[DH_MAX_IPADDR_LEN];	// Sniffer source address 	
	int					SnifferSrcPort;						// Sniffer source port 
	char				SnifferDestIP[DH_MAX_IPADDR_LEN];	// Sniffer destination address 
	int					SnifferDestPort;					// Sniffer destination port 
	char				reserved[28];						// Reserved string 
	DH_SNIFFER_FRAME	snifferFrame[DH_SNIFFER_FRAMEID_NUM];// 6 FRAME options 
	int					displayPosition;					// Display position 
	int					recdChannelMask;					// Channel mask
} DH_ATM_SNIFFER_CFG;

typedef struct  
{
	DWORD				dwSize;
	DH_ATM_SNIFFER_CFG	SnifferConfig[4];
	char				reserved[256];						// Reserved string 
} DHDEV_SNIFFER_CFG;

typedef DH_SNIFFER_FRAMEID DH_SNIFFER_FRAMEID_EX;
typedef DH_SNIFFER_CONTENT DH_SNIFFER_CONTENT_EX;

// Capture network configuration
typedef struct  
{
	DH_SNIFFER_FRAMEID	snifferFrameId;								// Each FRAME ID Options
	DH_SNIFFER_CONTENT	snifferContent[DH_SNIFFER_CONTENT_NUM_EX];	// Each FRAME Corresponding to the contents of capture	
} DH_SNIFFER_FRAME_EX;

// Capture each of the corresponding structure
typedef struct
{
	char				SnifferSrcIP[DH_MAX_IPADDR_LEN];					// Source address capture		
	int					SnifferSrcPort;										// Capture source port
	char				SnifferDestIP[DH_MAX_IPADDR_LEN];					// Destination address capture
	int					SnifferDestPort;									// Capture the target port
	DH_SNIFFER_FRAME_EX	snifferFrame[DH_SNIFFER_FRAMEID_NUM];				// 6 FRAME Options
	int					displayPosition;									// Display Position
	int					recdChannelMask;									// Channel mask
	BOOL				bDateScopeEnable;									// Data sources enable
	BOOL				bProtocolEnable;									// Protocol enable
	char				szProtocolName[DH_SNIFFER_PROTOCOL_SIZE];			// Protocol name
	int					nSnifferMode;										// Capture mode; 0:net,1:232.
	int					recdChannelMask1;									// Channel submask  32 ~ 63 channel
	char				reserved[252];
} DH_ATM_SNIFFER_CFG_EX;

// Atm trade type
#define ATM_MAX_TRADE_TYPE_NAME	64
#define ATM_MAX_TRADE_NUM		1024

typedef struct __DH_ATM_QUERY_TRADE   
{
	int					nTradeTypeNum;										// number of trade types
	int					nExceptionTypeNum;									// number of exception events
	char				szSupportTradeType[ATM_MAX_TRADE_NUM][ATM_MAX_TRADE_TYPE_NAME];    // trade events
	char				szSupportExceptionType[ATM_MAX_TRADE_NUM][ATM_MAX_TRADE_TYPE_NAME];// exception events
} DH_ATM_QUERY_TRADE, *LPDH_ATM_QUERY_TRADE;

/////////////////////////////////NVD support/////////////////////////////////
#define nEncoderID nDecoderID
#define byEncoderID byDecoderID

// Decoder information
typedef struct __DEV_DECODER_INFO 
{
	char			szDecType[64];			// type
	int				nMonitorNum;			// TV number
	int				nEncoderNum;			// Decoder channel number
	BYTE			szSplitMode[16];		// Supported by a number of TV screen partition
	BYTE            bMonitorEnable[16];		// TV enable
	BYTE            bTVTipDisplay;          // TV tip display enable 0:not support 1:support.
	BYTE            reserved1[3];
	BYTE            byLayoutEnable[48];     // every channel's tip display enable
    DWORD           dwLayoutEnMask[2];      // Each decoding channel displays overlay info enable mask, from low to high support 64 channels, while dwLayoutEnMask[0] is low 32 bit
	char			reserved[4];
} DEV_DECODER_INFO, *LPDEV_DECODER_INFO;

// Encoder information
#ifndef NANJINGDITIE_NVD
// device encoder information
typedef struct __DEV_ENCODER_INFO 
{
	char			szDevIp[DH_MAX_IPADDR_LEN];			// IP address of Front-end DVR 
	WORD			wDevPort;							// Port of Front-end DVR
	BYTE			bDevChnEnable;                      // Decoder channel enable
	BYTE			byDecoderID;						// deprecated, to get same info, use dwDecoderID instead
	char			szDevUser[DH_USER_NAME_LENGTH_EX];	// User Name
	char			szDevPwd[DH_USER_PSW_LENGTH_EX];	// Password
	int				nDevChannel;						// Channel Number
	int				nStreamType;						// Stream type; 0:Main Stream, 1:Sub-stream
	BYTE			byConnType;							// -1: auto, 0:TCP, 1:UDP, 2:Multicast
	BYTE			byWorkMode;							// 0:Direct Connect, 1:transmit
	WORD			wListenPort;						// Listening port services, for transmit
	DWORD			dwProtoType;						// Protocol type
														// 0:compatible with each other.
														// 1:private 2nd protocol
														// 2:private system integration protocol
														// 3:private DSS protocol
														// 4:private rtsp protocol
	char			szDevName[64];						// Front device name
	BYTE            byVideoInType;                      // video source type:0-SD,1-HD		
	char			szDevIpEx[DH_MAX_IPADDR_OR_DOMAIN_LEN];// szDevIp extended, IP or domain name
	BYTE            bySnapMode;                         // snap mode(when nStreamType==2 effective) 0:That request a frame,1:Time to send a request
	BYTE            byManuFactory;						// The target device manufacturers,See the enum struct EM_IPC_TYPE
	BYTE            byDeviceType;                       // The target device's device type,0:IPC
	BYTE            byDecodePolicy;                     // The target device's decode policy
														// 0:LatencyLevel3 1:LatencyLevel2
														// 2:LatencyLevel1 3:MiddleLevel
														// 4:FluencyLevel3 5:FluencyLevel2
														// 6:FluencyLevel1
	BYTE            bReserved[3];                       // reserved
	DWORD           dwHttpPort;                         // http port 0-65535
	DWORD           dwRtspPort;                         // RTSP port 0-65535
	char			szChnName[32];						// remote channel name
	DWORD           dwDecoderID;                        // The corresponding channel number decoder
} DEV_ENCODER_INFO, *LPDEV_ENCODER_INFO;

#else

// encoder info
typedef struct __DEV_ENCODER_INFO 
{
	char			szDevIp[DH_MAX_IPADDR_LEN];			// IP address of Front-end DVR 
	WORD			wDevPort;							// Port of Front-end DVR
	BYTE			bDevChnEnable;                      // Decoder channel enable
	BYTE			byDecoderID;						// deprecated, to get same info, use dwDecoderID instead
	char			szDevUser[DH_USER_NAME_LENGTH_EX];	// User Name
	char			szDevPwd[DH_USER_PSW_LENGTH_EX];	// Password
	int				nDevChannel;						// Channel Number
	int				nStreamType;						// Stream type; 0:Main Stream, 1:Sub-stream
	BYTE			byConnType;							// -1: auto, 0:TCP, 1:UDP, 2:Multicast
	BYTE			byWorkMode;							// 0:Direct Connect, 1:transmit
	WORD			wListenPort;						// Listening port services, for transmit
	DWORD			dwProtoType;						// Protocol type
														// 0:compatible with each other.
														// 1:private 2nd protocol
														// 2:private system integration protocol
														// 3:private DSS protocol
														// 4:private rtsp protocol
	char			szDevName[32];						// Front device name
	BYTE            byVideoInType;                      // video source type:0-SD,1-HD		
	char			szDevIpEx[DH_MAX_IPADDR_OR_DOMAIN_LEN];// szDevIp extended, IP or domain name
	BYTE            bySnapMode;                         // snap mode(when nStreamType==2 effective) 0:That request a frame,1:Time to send a request
	BYTE            byManuFactory;						// The target device manufacturers,See the enum struct EM_IPC_TYPE
	BYTE            byDeviceType;                       // The target device's device type,0:IPC
	BYTE            byDecodePolicy;                     // The target device's decode policy
														// 0:LatencyLevel3 1:LatencyLevel2
														// 2:LatencyLevel1 3:MiddleLevel
														// 4:FluencyLevel3 5:FluencyLevel2
														// 6:FluencyLevel1
	BYTE            bReserved[3];                       // reserved
	DWORD           dwHttpPort;                         // http port 0-65535
	DWORD           dwRtspPort;                         // RTSP port 0-65535
	char			szChnName[32];						// remote channel name
	char			szMcastIP[DH_MAX_IPADDR_LEN];       // multicast address
    DWORD           dwDecoderID;                        // The corresponding channel number decoder
	char            reserved[124];
} DEV_ENCODER_INFO, *LPDEV_ENCODER_INFO;

#endif

// decoder protocol rtsp url configuration
typedef struct __DHDEV_DECODER_URL_CFG
{
	DWORD			dwSize;
	char			szMainStreamUrl[MAX_PATH];			// main stream url
	char			szExtraStreamUrl[MAX_PATH];			// extra stream url
} DHDEV_DECODER_URL_CFG;

typedef enum tagDH_SPLIT_DISPLAY_TYPE
{
    DH_SPLIT_DISPLAY_TYPE_GENERAL=1,          // Common display types
    DH_SPLIT_DISPLAY_TYPE_PIP=2,              // PIP Display Type
    DH_SPLIT_DISPLAY_TYPE_CUSTOM=3,           // Custom Display Type
} DH_SPLIT_DISPLAY_TYPE;

// CLIENT_CtrlDecTVScreen Interface parameters
typedef struct tagDH_CTRL_DECTV_SCREEN
{
    DWORD           dwSize;                             // The size of the structure
    int             nSplitType;                         // Split mode
    BYTE *          pEncoderChannel;                    // Display Channel, dwDisplayType = DH_SPLIT_DISPLAY_TYPE_GENERAL when Effect
														// the space application by the user, the caller can not be less than the length of the allocated memory size nSplitType
    BYTE            byGroupNo;                          // Input channel group No, when dwDisplayType = DH_SPLIT_DISPLAY_TYPE_PIP said PIP display types are valid
    char            reserved[3];                        // Reserved
    DWORD           dwDisplayType;                      // Display type; see specific display DH_SPLIT_DISPLAY_TYPE (note each mode Content is determined by the "PicInPic", the contents of each mode is displayed by the old rules NVD decision (ie DisChn field decision). Compatible, without which an item, the default display for the general category Type, i.e., "General"
}DH_CTRL_DECTV_SCREEN;

// TV parameters 
typedef struct __DEV_DECODER_TV 
{
	int				nID;								// TV ID
	BOOL			bEnable;							// Enable, open or close
	int				nSplitType;							// Partition number
	DEV_ENCODER_INFO stuDevInfo[16];					// All encoder information
	BYTE			bySupportSplit[10];					// Split mode supported
    BYTE            byGroupNo;     						// Input channel group No, when dwDisplayType = DH_SPLIT_DISPLAY_TYPE_PIP said PIP display types are valid
    char			reserved[1];                        // Reserved bytes
    DWORD           dwDisplayType;                      // Display type; see specific display DH_SPLIT_DISPLAY_TYPE (note each mode 
                                                        // Content is determined by the "PicInPic", the contents of each mode is displayed by the old rules NVD decision (ie DisChn field decision). Compatible, without which an item, the default display for the general category 
                                                        // Type, i.e., "General")

} DEV_DECODER_TV, *LPDEV_DECODER_TV;

// Screen combination of information
typedef struct __DEC_COMBIN_INFO
{
	int				nCombinID;							// Combin ID
	int             nSplitType;							// Partition number
	BYTE            bDisChn[16];						// Display channel
	char			reserved[16];
} DEC_COMBIN_INFO, *LPDEC_COMBIN_INFO;

// Tour Information
#define DEC_COMBIN_NUM 			32						// the number of tour combination
typedef struct __DEC_TOUR_COMBIN 
{
	int				nTourTime;							// Tour Interval(s)
	int				nCombinNum;							// the number of combination
	BYTE			bCombinID[DEC_COMBIN_NUM];			// Combination Table
	char			reserved1[32];
	BYTE			bCombinState[DEC_COMBIN_NUM];		// Combination option state,0:close;1:open
	char			reserved2[32];
} DEC_TOUR_COMBIN, *LPDEC_TOUR_COMBIN;

// Decoder Playback type
typedef enum __DEC_PLAYBACK_MODE
{
	Dec_By_Device_File = 0,								// Front-end DVR--By File
	Dec_By_Device_Time,									// Front-end DVR--By Time
} DEC_PLAYBACK_MODE;

// Decoder Playback control type
typedef enum __DEC_CTRL_PLAYBACK_TYPE
{
	Dec_Playback_Seek = 0,								// Drag
	Dec_Playback_Play,									// Play
	Dec_Playback_Pause,									// Pause
	Dec_Playback_Stop,									// Stop
} DEC_CTRL_PLAYBACK_TYPE;

// tour ctrol type
typedef enum __DEC_CTRL_TOUR_TYPE
{
	Dec_Tour_Stop = 0,									// stop
	Dec_Tour_Start,										// start
	Dec_Tour_Pause,										// pause
	Dec_Tour_Resume,									// resume
} DEC_CTRL_TOUR_TYPE;

// Playback by file Conditions
typedef struct __DEC_PLAYBACK_FILE_PARAM 
{
	char			szDevIp[DH_MAX_IPADDR_LEN];			// IP address of Front-end DVR
	WORD			wDevPort;							// Port of Front-end DVR
	BYTE			bDevChnEnable;                      // Decoder channel enable
	BYTE			byDecoderID;						// The corresponding channel number
	char			szDevUser[DH_USER_NAME_LENGTH_EX];	// User Name
	char			szDevPwd[DH_USER_PSW_LENGTH_EX];	// Password
	NET_RECORDFILE_INFO stuRecordInfo;					// Record file information
	char			reserved[12];
} DEC_PLAYBACK_FILE_PARAM, *LPDEC_PLAYBACK_FILE_PARAM;

// Playback by time Conditions
typedef struct __DEC_PLAYBACK_TIME_PARAM 
{
	char			szDevIp[DH_MAX_IPADDR_LEN];			// IP address of Front-end DVR
	WORD			wDevPort;							// Port of Front-end DVR
	BYTE			bDevChnEnable;                      // Decoder channel enable
	BYTE			byDecoderID;						// The corresponding channel number
	char			szDevUser[DH_USER_NAME_LENGTH_EX];	// User Name
	char			szDevPwd[DH_USER_PSW_LENGTH_EX];	// Password
	int				nChannelID;
	NET_TIME		startTime;
	NET_TIME		endTime;
	char			reserved[12];
} DEC_PLAYBACK_TIME_PARAM, *LPDEC_PLAYBACK_TIME_PARAM;

// Current decoding channel status(including channel status, decoding stream info and etc.)
typedef struct __DEV_DECCHANNEL_STATE
{
	BYTE			byDecoderID;						// Responding decoding channel number
	BYTE            byChnState;                         // Current decoding channel in opertion status:0 -free,1 -realtime monitoring,2 - playback 3 - Decode Tour
	BYTE			byFrame;                            // Current data frame rate
	BYTE            byReserved;                         // Reserved
	int				nChannelFLux;						// Decoding channel data amount
	int             nDecodeFlux;						// Decoding data amount
	char            szResolution[16];                   // Current data resolution
	char			reserved[256];
} DEV_DECCHANNEL_STATE, *LPDEV_DECCHANNEL_STATE;

// Device TV display info
typedef struct __DEV_VIDEOOUT_INFO
{
	DWORD				dwVideoStandardMask;			// NSP,video standard mask,according to the bit which shows video format(not support now)
	int					nVideoStandard;                 // NSP,current format(not support now,please use DHDEV_SYSTEM_ATTR_CFG by VideoStandard to read and config the video format)
	DWORD				dwImageSizeMask;				// Resolution mask,according the bit which shows video resolution
	int                 nImageSize;                     // Current resolution
	char				reserved[256];
}DEV_VIDEOOUT_INFO, *LPDEV_VIDEOOUT_INFO;

// TV adjust
typedef struct __DEV_TVADJUST_CFG
{
	int					nTop;							// top(0 - 100)
	int					nBotton;						// botton(0 - 100)
	int					nLeft;							// left(0 - 100)
	int                 nRight;							// right(0 - 100)
	int					reserved[32];
}DHDEV_TVADJUST_CFG, *LPDHDEV_TVADJUST_CFG;

//PTZ control coordinate unit 
typedef struct tagPTZ_SPEED_UNIT
{
    float                  fPositionX;           //PTZ horizontal speed, normalized to -1~1 
    float                  fPositionY;           //PTZ vertical speed, normalized to -1~1 
    float                  fZoom;                //PTZ aperture magnification, normalized to 0~1 
    char                   szReserve[32];        //Reserved
}PTZ_SPEED_UNIT;

//PTZ control(Relatively) coordinate unit
typedef struct tagPTZ_SPACE_RELATIVELY_UNIT
{
	float			fPositionX;					// PTZ horizontal, effective range -1~1 
	float			fPositionY;					// PTZ vertical , effective range -1~1 
	float			fZoom;						// PTZ aperture magnification, effective range -1~1 
	char            szReserve[32];				// Reserved
} PTZ_SPACE_RELATIVELY_UNIT;

//PTZ control coordinate unit 
typedef struct tagPTZ_SPACE_UNIT
{
    int                    nPositionX;           //PTZ horizontal motion position, effective range:[0,3600]
    int                    nPositionY;           //PTZ vertical motion position, effective range:[-1800,1800]
    int                    nZoom;                //PTZ aperture change position, the effective range:[0,128]
    char                   szReserve[32];        //Reserved
}PTZ_SPACE_UNIT;

// decoder tour configuration
typedef struct __DEV_DECODER_TOUR_SINGLE_CFG
{
	char		szIP[128];								// Front-end device's ip.Such as"10.7.5.21". Support retention of the domain name, end by '\0'.
	int			nPort;									// Front-end device's port.(0, 65535).
	int			nPlayChn;								// front-end device's Request channel [1, 16].
	int			nPlayType;								// front-end device's Stream type, 0:main; 1:sub.
	char		szUserName[32];							// front-end device's user name,end by '\0'.
	char		szPassword[32];							// front-end device's Password,end by '\0'.
	int			nInterval;								// Round tour interval [10, 120],s.
	DWORD		nManuFactory;							// device's factory(enum see IPC_TYPE)
	UINT		nHttpPport;								// device's http port
	UINT		nRtspPort;								// device's rtsp port
	BYTE		byServiceType;							// service type -1:auto,0:TCP;1:UDP;2:Multicast 
	BYTE		bReserved[51];							// reserved.
}DHDEV_DECODER_TOUR_SINGLE_CFG;

typedef struct __DEV_DECODER_TOUR_CFG
{
	int								nCfgNum;			// the number of Configure structures. The biggest support 32. Specific number of support inquiries through capacity.
	DHDEV_DECODER_TOUR_SINGLE_CFG	tourCfg[64];		// Polling configuration array, the effective number of structures by the members of the "nCfgNum" designation. Keep left to expand 32.
	BYTE							bReserved[256];		// reserved.
}DHDEV_DECODER_TOUR_CFG;

/////////////////////////////////intelligent support/////////////////////////////////
// picture info
typedef struct  
{
	DWORD                dwOffSet;                      // current picture file's offset in the binary file, byte
	DWORD                dwFileLenth;                   // current picture file's size, byte
	WORD                 wWidth;                        // picture width, pixel
	WORD                 wHeight;                       // picture high, pixel
    char*                pszFilePath;                   // File path
                                                        // User use this field need to apply for space for copy and storage
    BYTE            	 bIsDetected;					// When submit to the server, the algorithm has checked the image or not 
	BYTE				 bReserved[3];					// reserved data
	int					 nFilePathLen;					// File path Len of pszFilePath
	DH_POINT			 stuPoint;						// The upper left corner of the figure is in the big picture. Absolute coordinates are used				
}DH_PIC_INFO;

// Object corresponding to picture file information (including images path)
typedef struct tagDH_PIC_INFO_EXX
{
    DWORD           dwSize;
    char            szFilePath[DH_COMMON_STRING_256];   // In view of historical reasons, the member is valid when be set or to get
                                                        // File path
    DH_PIC_INFO     stuPicInfo;                         // picture information
}DH_PIC_INFO_EX2;

// picture info
typedef struct  
{
	DWORD                dwOffSet;                      // current picture file's offset in the binary file, byte
	DWORD                dwFileLenth;                   // current picture file's size, byte
	WORD                 wWidth;                        // picture width, pixel
	WORD                 wHeight;                       // picture high, pixel
 	char                 szFilePath[64];                // File path
    BYTE            	 bIsDetected;					// When submit to the server, the algorithm has checked the image or not 
    BYTE            	 bReserved[11];					// Reserved
}DH_PIC_INFO_EX3;

// Extension fields added int64, forced 4 byte alignment
#ifndef LINUX64_JNA
#pragma pack(push)
#pragma pack(4)
#endif
// Struct of object info for video analysis 
typedef struct 
{
	int					nObjectID;						// Object ID,each ID represent a unique object
	char				szObjectType[128];				// Object type
	int					nConfidence;					// Confidence(0~255),a high value indicate a high confidence
	int					nAction;						// Object action:1:Appear 2:Move 3:Stay 4:Remove 5:Disappear 6:Split 7:Merge 8:Rename
	DH_RECT				BoundingBox;					// BoundingBox
	DH_POINT			Center;							// The shape center of the object
	int					nPolygonNum;					// the number of culminations for the polygon
	DH_POINT			Contour[DH_MAX_POLYGON_NUM];	// a polygon that have a exactitude figure
	DWORD				rgbaMainColor;					// The main color of the object;the first byte indicate red value, as byte order as green, blue, transparence, for example:RGB(0,255,0),transparence = 0, rgbaMainColor = 0x00ff0000.
    char				szText[128];					// the interrelated text of object,such as number plate,container number
                                                        // "ObjectType","Vehicle" or "Logo", try to use Logo.Vehicle is used to be compatible with old product, means logo, support:
                                                        // "Unknown" Unknown 
                                                        // "Audi" Audi
                                                        // "Honda" Honda
                                                        // "Buick" Buick
                                                        // "Volkswagen" Volkswagen
                                                        // "Toyota" Toyota
                                                        // "BMW" BMW
                                                        // "Peugeot" Peugeot
                                                        // "Ford" Ford
                                                        // "Mazda" Mazda
                                                        // "Nissan" Nissan
                                                        // "Hyundai" Hyundai
                                                        // "Suzuki" Suzuki
                                                        // "Citroen" Citroen
                                                        // "Benz" Benz
                                                        // "BYD" BYD
                                                        // "Geely" Geely
                                                        // "Lexus" Lexus
                                                        // "Chevrolet" Chevrolet
                                                        // "Chery" Chery
                                                        // "Kia" Kia
                                                        // "Charade" Charade
                                                        // "DF" DF
                                                        // "Naveco" Naveco
                                                        // "SGMW" SGMW
                                                        // "Jinbei" Jinbei

                                                        // "JAC" JAC
                                                        // "Emgrand" Emgrand
                                                        // "ChangAn" ChangAn
                                                        // "Great Wall" Great Wall
                                                        // "Skoda" Skoda
                                                        // "BaoJun" BaoJun
                                                        // "Subaru" Subaru
                                                        // "LandWind" LandWind
                                                        // "Luxgen" Luxgen
                                                        // "Renault" Renault
                                                        // "Mitsubishi" Mitsubishi
                                                        // "Roewe" Roewe
                                                        // "Cadillac" Cadillac
                                                        // "MG" MG
                                                        // "Zotye" Zotye
                                                        // "ZhongHua" ZhongHua
                                                        // "Foton" Foton
                                                        // "SongHuaJiang" SongHuaJiang
                                                        // "Opel" Opel
                                                        // "HongQi" HongQi
                                                        // "Fiat" Fiat
                                                        // "Jaguar" Jaguar
                                                        // "Volvo" Volvo
                                                        // "Acura" Acura
                                                        // "Porsche" Porsche

                                                        // "Jeep" Jeep
                                                        // "Bentley" Bentley
                                                        // "Bugatti" Bugatti
                                                        // "ChuanQi" ChuanQi
                                                        // "Daewoo" Daewoo
                                                        // "DongNan" DongNan
                                                        // "Ferrari" Ferrari
                                                        // "Fudi" Fudi
                                                        // "Huapu" Huapu
                                                        // "HawTai" HawTai
                                                        // "JMC" JMC
                                                        // "JingLong" JingLong
                                                        // "JoyLong" JoyLong
                                                        // "Karry" Karry"
                                                        // "Chrysler" Chrysler
                                                        // "Lamborghini" Lamborghini
                                                        // "RollsRoyce" RollsRoyce
                                                        // "Linian" Linian
                                                        // "LiFan" LiFan
                                                        // "LieBao" LieBao
                                                        // "Lincoln" Lincoln
                                                        // "LandRover" LandRover
                                                        // "Lotus" Lotus
                                                        // "Maserati" Maserati
                                                        // "Maybach" Maybach

                                                        // "Mclaren" Mclaren
                                                        // "Youngman" Youngman
                                                        // "Tesla" Tesla
                                                        // "Rely" Rely
                                                        // "Lsuzu" Lsuzu
                                                        // "Yiqi" Yiqi
                                                        // "Infiniti" Infiniti
                                                        // "YuTong" YuTong
                                                        // "AnKai" AnKai
                                                        // "Canghe" Canghe
                                                        // "HaiMa" HaiMa
                                                        // "Crown" Crown
                                                        // "HuangHai" HuangHai
                                                        // "JinLv" JinLv
                                                        // "JinNing" JinNing
                                                        // "KuBo" KuBo
                                                        // "Europestar" Europestar
                                                        // "MINI" MINI
                                                        // "Gleagle" Gleagle
                                                        // "ShiDai" ShiDai
                                                        // "ShuangHuan" ShuangHuan
                                                        // "TianYe" TianYe
                                                        // "WeiZi" WeiZi
                                                        // "Englon" Englon
                                                        // "ZhongTong" ZhongTong

                                                        // "Changan" Changan
                                                        // "Yuejin" Yuejin
                                                        // "Taurus" Taurus
                                                        // "Alto" Alto
                                                        // "Weiwang" Weiwang
                                                        // "Chenglong" Chenglong
                                                        // "Haige" Haige
                                                        // "Shaolin" Shaolin
                                                        // "Beifang" Beifang
                                                        // "Beijing" Beijing
                                                        // "Hafu" Hafu
														
														// "BeijingTruck" BeiQi
														// "Besturn" Besturn
														// "ChanganBus" Changan
														// "Dodge" Dodge
														// "DongFangHong" Dongfanghong
														// "DongFengTruck" DongFeng
														// "DongFengBus" DongFeng
														// "MultiBrand" MutiBrand
														// "FotonTruck" Foton
														// "FotonBus" Foton
														// "GagcTruck" Gagc
														// "HaFei" HaFei
														// "HowoBus" Howo
														// "JACTruck" JAC
														// "JACBus" JAC
														// "JMCTruck" JMC
														// "JieFangTruck" JieFang
														// "JinBeiTruck" JinBei
														// "KaiMaTruck" KaiMa
														// "CoasterBus" Coaster
														// "MudanBus" Mudan
														// "NanJunTruck" NanJun
														// "QingLing" QingLing
														// "NissanCivilian" Nissan Civilian
														// "NissanTruck" Nissan
														// "MitsubishiFuso" Mitsubishi Fuso
														// "SanyTruck" Sany
														// "ShanQiTruck" ShanQi
														// "ShenLongBus" ShenLong
														// "TangJunTruck" TangJun
														// "MicroTruck" Micro
														// "VolvoBus" Volvo
														// "LsuzuTruck" Lsuzu
														// "WuZhengTruck" WuZheng
														// "Seat" Seat
														// "YangZiBus" YangZi
														// "YiqiBus" Yiqi
														// "YingTianTruck" YingTian
														// "YueJinTruck" YueJin
														// "ZhongDaBus" ZhongDa
														// "ZxAuto" ZxAuto
														// "ZhongQiWangPai" ZhongQiWangPai
														// "WAW" WAW
														// "BeiQiWeiWang" BeiQiWeiWang
														// "BYDDaimler"	BYDDaimler
														// "ChunLan" ChunLan
														// "DaYun" DaYun
														// "DFFengDu" DFFengDu
														// "DFFengGuang" DFFengGuang
														// "DFFengShen" DFFengShen
														// "DFFengXing" DFFengXing
														// "DFLiuQi" DFLiuQi
														// "DFXiaoKang" DFXiaoKang
														// "FeiChi" FeiChi
														// "FordMustang" FordMustang
														// "GuangQi" GuangQi
														// "GuangTong" GuangTong
														// "HuiZhongTruck" HuiZhongTruck
														// "JiangHuai" JiangHuai
														// "SunWin" SunWin
														// "ShiFeng" ShiFeng
														// "TongXin" TongXin
														// "WZL" WZL
														// "XiWo" XiWo
														// "XuGong" XuGong
														// "JingGong" JingGong
														// "SAAB" SAAB
														// "SanHuanShiTong" SanHuanShiTong
														// "KangDi" KangDi
														// "YaoLong" YaoLong

	char                szObjectSubType[62];            // object sub type,different object type has different sub type:
														// Vehicle Category:"Unknown","Motor","Non-Motor","Bus","Bicycle","Motorcycle", 
														// "DregsCar", "Excavator", "Bulldozer", "Crane", "PumpTruck", "MachineshopTruck"
														// Plate Category:"Unknown","mal","Yellow","DoubleYellow","Police","Armed",
														// "Military","DoubleMilitary","SAR","Trainning"
														// "Personal" ,"Agri","Embassy","Moto","Tractor","Other"
														// HumanFace Category:"Normal","HideEye","HideNose","HideMouth","TankCar"
    WORD                wColorLogoIndex;                // the index of car logo
    WORD                wSubBrand;                      // Specifies the sub-brand of vehicle,the real value can be found in a mapping table from the development manual 
	BYTE                byReserved1;                 
	bool                bPicEnble;                      // picture info enable
	DH_PIC_INFO         stPicInfo;                      // picture info
	bool				bShotFrame;						// is shot frame
	bool				bColor;							// rgbaMainColor is enable
	BYTE				byReserved2;
	BYTE                byTimeType;                     // Time indicates the type of detailed instructions, EM_TIME_TYPE
    NET_TIME_EX			stuCurrentTime;					// in view of the video compression,current time(when object snap or reconfnition, the frame will be attached to the frame in a video or pictures,means the frame in the original video of the time)
	NET_TIME_EX			stuStartTime;					// strart time(object appearing for the first time)
	NET_TIME_EX			stuEndTime;						// end time(object appearing for the last time)
	DH_RECT				stuOriginalBoundingBox;			// original bounding box(absolute coordinates)
	DH_RECT             stuSignBoundingBox;             // sign bounding box coordinate
	DWORD				dwCurrentSequence;				// The current frame number (frames when grabbing the object)
	DWORD				dwBeginSequence;				// Start frame number (object appeared When the frame number, 
	DWORD				dwEndSequence;					// The end of the frame number (when the object disappearing Frame number)
	INT64				nBeginFileOffset;				// At the beginning of the file offset, Unit: Word Section (when objects began to appear, the video frames in the original video file offset relative to the beginning of the file, 
	INT64				nEndFileOffset;					// At the end of the file offset, Unit: Word Section (when the object disappeared, video frames in the original video file offset relative to the beginning of the file)
	BYTE                byColorSimilar[NET_COLOR_TYPE_MAX];// Object color similarity, the range :0-100, represents an array subscript Colors, see EM_COLOR_TYPE, 
 	BYTE                byUpperBodyColorSimilar[NET_COLOR_TYPE_MAX]; // When upper body color similarity (valid object type man , 
 	BYTE                byLowerBodyColorSimilar[NET_COLOR_TYPE_MAX]; // Lower body color similarity when objects (object type human valid , 
    int                 nRelativeID;                        // ID of relative object
	char				szSubText[20];						// "ObjectType"is "Vehicle" or "Logo",  means a certain brand under LOGO, such as Audi A6L, since there are so many brands, SDK sends this field in real-time ,device filled as real.
    WORD                wBrandYear;                         // Specifies the model years of vehicle. the real value can be found in a mapping table from the development manual 
} DH_MSG_OBJECT;

// intrusion direction
typedef enum tagEM_MSG_OBJ_PERSON_DIRECTION
{
    EM_MSG_OBJ_PERSON_DIRECTION_UNKOWN,         // unknown direction
    EM_MSG_OBJ_PERSON_DIRECTION_LEFT_TO_RIGHT,  // from left to right
    EM_MSG_OBJ_PERSON_DIRECTION_RIGHT_TO_LEFT   // from right ro left
}EM_MSG_OBJ_PERSON_DIRECTION;

// Video analysis object info expansion structure 
typedef struct tagDH_MSG_OBJECT_EX
{
    DWORD               dwSize;
    int                 nObjectID;                  // object ID, each ID means a exclusive object
    char                szObjectType[128];          // object  type 
    int                 nConfidence;                // confidence coefficient (0~255),  value the bigger means  confidence coefficient the higher
    int                 nAction;                    // object  motion :1:Appear 2:Move 3:Stay 4:Remove 5:Disappear 6:Split 7:Merge 8:Rename
    DH_RECT             BoundingBox;                // box
    DH_POINT            Center;                     // object model center
    int                 nPolygonNum;                // polygon vertex number 
    DH_POINT            Contour[DH_MAX_POLYGON_NUM];// relatively accurate outline the polygon  
    DWORD               rgbaMainColor;              // means plate, vehicle body and etc. object major color, by byte means , are red, green, blue and transparency , such as:RGB value is (0,255,0), transparency is 0, its value is 0x00ff0000.
    char                szText[128];                // same as DH_MSG_OBJECT corresponding field
    char                szObjectSubType[64];        // object sub type , according to different object  types , may use the following sub type :
                                                    // same as DH_MSG_OBJECT field
    BYTE                byReserved1[3];
    bool                bPicEnble;                  // object corresponding to picture file info or not
    DH_PIC_INFO         stPicInfo;                  // object corresponding to picture info 
    bool                bShotFrame;                 // snapshot recognition result or not 
    bool                bColor;                     // object  color (rgbaMainColor) usable or not
    BYTE                bLowerBodyColor;            // lower color (rgbaLowerBodyColor) usable or not
    BYTE                byTimeType;                 // time means type ,  see EM_TIME_TYPE note 
    NET_TIME_EX         stuCurrentTime;             // for video compression,  current time stamp, object snapshot or recognition,  attach this recognition frame in one vire frame or jpegpicture, this frame appearance time in original video, 
    NET_TIME_EX         stuStartTime;               // start time stamp, object start appearance, 
    NET_TIME_EX         stuEndTime;                 // end time stamp, object last aapearance, 
    DH_RECT             stuOriginalBoundingBox;     // box(absolute coordinate)
    DH_RECT             stuSignBoundingBox;         // LGO coordinate box
    DWORD               dwCurrentSequence;          // current frame no., snapshot this object frame, 
    DWORD               dwBeginSequence;            // start frame no., object start appearance frame no., 
    DWORD               dwEndSequence;              // end frame no., object disappearance frame no., 
    INT64               nBeginFileOffset;           // start file shift, unit: byte, object start appearance, video in original video file moves toward file origin, 
    INT64               nEndFileOffset;             // End file shift, unit: byte, object disappearance, video in original video file moves toward file origin, 
    BYTE                byColorSimilar[NET_COLOR_TYPE_MAX]; // object  color similarity, take  value range :0-100, group subscript value represents certain color ,  see EM_COLOR_TYPE
    BYTE                byUpperBodyColorSimilar[NET_COLOR_TYPE_MAX]; // upper object  color  similarity (object  type as human is valid )
    BYTE                byLowerBodyColorSimilar[NET_COLOR_TYPE_MAX]; // lower object  color  similarity (object  type as human is valid )
    int                 nRelativeID;                // related object ID
	char				szSubText[20];              // "ObjectType"is "Vehicle"or "Logo",  means LOGO lower brand, such as Audi A6L, since there are many brands, SDK shows this field in real-time,device filled as real.

	int					nPersonStature;	            // Intrusion staff height, unit cm
	EM_MSG_OBJ_PERSON_DIRECTION	emPersonDirection;  // Staff intrusion direction
    DWORD               rgbaLowerBodyColor;         // Use direction same as rgbaMainColor,object  type as human is valid 	
} DH_MSG_OBJECT_EX;


// Video analysis object info extension structure, extension version 2. 
typedef struct tagDH_MSG_OBJECT_EX2
{
    DWORD				dwSize;
    int                 nObjectID;                          // Object ID. Each ID presents one object. 
    char                szObjectType[128];                  // Object type 
    int                 nConfidence;                        // Confiidence(0-255). The higher the value is, the higher the confidence is. 
    int                 nAction;                            // Object operation. 1:Appear 2:Move 3:Stay 4:Remove 5:Disappear 6:Split 7:Merge 8:Rename
    DH_RECT             BoundingBox;                        // Surrounding rectangle 
    DH_POINT            Center;                             // Object size centre
    int                 nPolygonNum;                        // Top amount of the polygon
    DH_POINT            Contour[DH_MAX_POLYGON_NUM];        // Polygon of generaly accurate frame 
    DWORD               rgbaMainColor;                      // The plate and the vehicle body main color. Use byte to present: red, green, blue and transparent. When RGB value is (0,255,0), transparent is 0, the value is 0x00ff0000.
    char                szText[128];                        // The same as the string of the DH_MSG_OBJECT
    char                szObjectSubType[64];                // Object sub-type. It has the following sub-tyes. 
															// The same as the string of the DH_MSG_OBJECT
    BYTE                byReserved1[3];
    bool                bPicEnble;                          // There is image file info of the corresponding object 
    DH_PIC_INFO         stPicInfo;                          // Image info of the object 
    bool                bShotFrame;                         // Has been snapped or not 
    bool                bColor;                             // Object color (rgbaMainColor) is usable or not. 
    BYTE                bLowerBodyColor;                    // The lower part color (rgbaLowerBodyColor) is usable or not 
    BYTE                byTimeType;                         // Time type. Please refer to EM_TIME_TYPE.
    NET_TIME_EX         stuCurrentTime;                     // For video synopsis. Current time stampl (When snap or recognize the object, use the recognition intelligent frame on one video frame or JPEG.  It is the appearing time of the frame on the original video. )
    NET_TIME_EX         stuStartTime;                       // Start time stamp(When the object first appear )
    NET_TIME_EX         stuEndTime;                         // End time (When the object last appear )
    DH_RECT             stuOriginalBoundingBox;             // Surrounding box(Absolute coordinates)
    DH_RECT             stuSignBoundingBox;                 // Vehicle symbol surrounding box 
    DWORD               dwCurrentSequence;                  // Current frame SN(Frame when snap the object )
    DWORD               dwBeginSequence;                    // Start frame SN (The frame SN when the object start appearing)
    DWORD               dwEndSequence;                      // End frame SN (The frame SN when the object disappering)
    INT64               nBeginFileOffset;                   // The file offset when start. Unit:byte. (When the object appearing, the video frame offset value comparing with the file start positon in the original video)
    INT64               nEndFileOffset;                     // The file offset when stop. Unit: byte. (When the object disappearing, the video frame offset value comparing with the file start position in the original video)
    BYTE                byColorSimilar[NET_COLOR_TYPE_MAX]; // Object color similarity level. The valur ranges from 0 to 100. The underline value of the array represents one color. Plase refer to EM_COLOR_TYPE.
    BYTE                byUpperBodyColorSimilar[NET_COLOR_TYPE_MAX]; // The top body color similarity leve; (When the object is the human)
    BYTE                byLowerBodyColorSimilar[NET_COLOR_TYPE_MAX]; // The lower body color similarity leve; (When the object is the human)
    int                 nRelativeID;                        // Related object ID
    char				szSubText[20];						// When "ObjectType" is "Vehicle" or "Logo", it represents one car series under the card symbol such as Audio A6L. Since there are too many card series, SDK use the network to realize COM transmission (szSubText) to realize this function. 
    
    int					nPersonStature;						// Intrusion person height. Unit is cm. 
    EM_MSG_OBJ_PERSON_DIRECTION	emPersonDirection;			// Intrusion person direction 
    DWORD               rgbaLowerBodyColor;                 // The same usage as the rgbaMainColor, it is valid when the object type is human. 

    //Video synopsis extra info 
    int                 nSynopsisSpeed;                             // Synopsis speed threshold. There are ten levels (1 to 10). 5 means only reserve the object of speed higher than 5. It is a relative unit.  
                                                                    // When it is 0, the string is invalid.
    int                 nSynopsisSize;                              // Synopsis dimension threshold. There are ten levels (1 to 10). 3 means only reserve the object of speed higher than 3. It is a relative unit.  
                                                                    // When it is o, the string is invalid. 
    BOOL                bEnableDirection;                           // When it is True, filter the object moving direction.
                                                                    // When it is False, do not filter the object moving direction. 
    DH_POINT            stuSynopsisStartLocation;                   // Synopsis moving direction, start coordinates. The point coordinates [0,8192), it is valid when bEnableDirection is True. 
    DH_POINT            stuSynopsisEndLocation;                     // Synopsis moving direction, stop coordinates. The point coordinates [0,8192), it is valid when bEnableDirection is True. 
    BYTE                byReserved[2048];                           // Extension byte
} DH_MSG_OBJECT_EX2;
#ifndef LINUX64_JNA
#pragma pack(pop)
#endif


// snapshot info
typedef struct
{
	short              snSpeed;                          // current car speed,km/h
	short              snCarLength;                      // current car length, dm
	float              fRedTime;                         // current red light time, s.ms
	float              fCapTime;                         // current car way snapshot time, s.ms 
	BYTE               bSigSequence;                     // current snapshot Sequence
	BYTE               bType;                            // current snapshot type
														 // 0: radar up speed limit;1: radar low speed limit;2: car detector up speed limit;3:car detector low speed limit
														 // 4: reverse;5: break red light;6: red light on;7: red light off;8: snapshot or traffic gate
	BYTE               bDirection;                       // breaking type :01:left turn;02:straight;03:right
	BYTE               bLightColor;                      // current car way traffic light state,0: green, 1: red, 2: yellow
	BYTE               bSnapFlag[16];                    // snap flag from device
}DH_SIG_CARWAY_INFO;

// Vehicle detector redundancy info
typedef struct
{
	BYTE                byRedundance[8];                // The vehicle detector generates the snap signal redundancy info
	BYTE                bReserved[120];                 // Reserved field
}DH_SIG_CARWAY_INFO_EX;


// car way info
typedef struct  
{
	BYTE                bCarWayID;                           // current car way id 
	BYTE                bReserve[2];                         // reserved
	BYTE                bSigCount;                           // being snapshotted
	DH_SIG_CARWAY_INFO  stuSigInfo[DH_MAX_SNAP_SIGNAL_NUM];  // the snapshot info	
	BYTE                bReserved[12];                       // reserved
}DH_CARWAY_INFO;

// event file info
typedef struct
{
	BYTE               bCount;                               // the file count in the current file's group
	BYTE               bIndex;                               // the index of the file in the group
	BYTE               bFileTag;                             // file tag, see the enum struct EM_EVENT_FILETAG
	BYTE               bFileType;                            // file type,0-normal 1-compose 2-cut picture
	NET_TIME_EX        stuFileTime;                          // file time
	DWORD              nGroupId;                             // the only id of one group file
}DH_EVENT_FILE_INFO;

// pic resolution 
typedef struct
{
	unsigned short   snWidth;    // width
 	unsigned short   snHight;    // hight
}DH_RESOLUTION_INFO;

//  color RGBA
typedef struct tagDH_COLOR_RGBA
{
    int	        nRed;           // red
    int         nGreen;         // green
    int         nBlue;          // blue
    int         nAlpha;         // transparent
} DH_COLOR_RGBA, NET_COLOR_RGBA;

#define	NET_COUNTRY_LENGTH		3		// short for country
#define NET_COMMENT_LENGTH		100		// comment length
#define NET_GROUPID_LENGTH		64		// group id length
#define NET_GROUPNAME_LENGTH	128		// group name length
#define NET_FEATUREVALUE_LENGTH	128		// feature value length

// person info, in the struct of event(shch as EVENT_IVS_FACERECOGNITION), 
// the memory of pszComment/pszGroupID/pszGroupName/pszFeatureValue alloc and release by NetSDK, otherwise by user

//feature type of detected human face
typedef enum tagEM_DEV_EVENT_FACEDETECT_FEATURE_TYPE
{
	EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_UNKNOWN,               // unknown
	EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_WEAR_GLASSES,          // wearing glasses
	EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_SMILE,                 // smile
	EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_ANGER,                 // anger
	EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_SADNESS,               // sadness
	EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_DISGUST,               // disgust
	EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_FEAR,                  // fear
	EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_SURPRISE,              // surprise
	EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_NEUTRAL,               // neutral
	EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_LAUGH,                 // laugh
	EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_NOGLASSES,				// not wear glasses
	EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_HAPPY,					// happy
	EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_CONFUSED,				// confused
	EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_SCREAM,				// scream
	EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_WEAR_SUNGLASSES,       // wearing sun glasses
}EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE;

typedef struct tagFACERECOGNITION_PERSON_INFO
{
	char                szPersonName[DH_MAX_NAME_LEN];		// name                 
	WORD				wYear;								// birth year
	BYTE				byMonth;							// birth month
	BYTE				byDay;								// birth day
	char                szID[DH_MAX_PERSON_ID_LEN];			// the unicle ID for the person
	BYTE                bImportantRank;						// importance level,1~10,the higher value the higher level
	BYTE                bySex;								// sex, 0-man, 1-female
	WORD                wFacePicNum;						// picture number
	DH_PIC_INFO         szFacePicInfo[DH_MAX_PERSON_IMAGE_NUM]; // picture info
	BYTE                byType;                                         // Personnel types, see EM_PERSON_TYPE
	BYTE                byIDType;                                       // Document types, see EM_CERTIFICATE_TYPE
	BYTE				byGlasses;										// Whether wear glasses or not,0-unknown,1-not wear glasses,2-wear glasses	
	BYTE                byAge;											// Age,0 means unknown
	char                szProvince[DH_MAX_PROVINCE_NAME_LEN];           // province
	char                szCity[DH_MAX_CITY_NAME_LEN];                   // city
	char                szPersonNameEx[DH_MAX_PERSON_NAME_LEN];	        // Name, the name is too long due to the presence of 16 bytes can not be Storage problems, the increase in this parameter
    char                szUID[DH_MAX_PERSON_ID_LEN];                    // person unique ID
	char				szCountry[NET_COUNTRY_LENGTH];					// country
	BYTE				byIsCustomType;									// using person type: 0 using byType, 1 using szPersonName
	char				*pszComment;									// comment info, when the memory is alloced by user, 
																		// the value of bCommentLen needs to be filled inrecommended length is NET_COMMENT_LENGTH
																		
	char				*pszGroupID;									// group ID, when the memory is alloced by user, 
																		// the value of bGroupIdLen needs to be filled inrecommended length is NET_GROUPID_LENGTH
																		
	char				*pszGroupName;									// group name, when the memory is alloced by user,
																		// the value of bGroupNameLen needs to be filled inrecommended length is NET_GROUPNAME_LENGTH
																		
	char				*pszFeatureValue;								// the face feature , when the memory is alloced by user, 
																		// the value of bFeatureValueLen needs to be filled inrecommended length is NET_FEATUREVALUE_LENGTH
	BYTE				bGroupIdLen;									// len of pszGroupID
	BYTE				bGroupNameLen;									// len of pszGroupName
	BYTE				bFeatureValueLen;								// len of pszFeatureValue
	BYTE				bCommentLen;									// len of pszComment
	EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE	emEmotion;					// Emotion	
}FACERECOGNITION_PERSON_INFO;

// type of glassess
typedef enum tagEM_GLASSES_TYPE
{
	EM_GLASSES_UNKNOWN,		// unknown
	EM_GLASSES_SUNGLASS,	// sun glasses
	EM_GLASSES_GLASS,		// normal galsses
} EM_GLASSES_TYPE;

// race type
typedef enum tagEM_RACE_TYPE
{
	EM_RACE_UNKNOWN,			// unknown
	EM_RACE_NODISTI,			// no disringuish
	EM_RACE_YELLOW,				// yellow
	EM_RACE_BLACK,				// black
	EM_RACE_WHITE,				// white
} EM_RACE_TYPE;

// eyes state
typedef enum tagEM_EYE_STATE_TYPE
{
	EM_EYE_STATE_UNKNOWN,		// unknown
	EM_EYE_STATE_NODISTI,		// no disringuish
	EM_EYE_STATE_CLOSE,			// close eyes
	EM_EYE_STATE_OPEN,			// open eyes
} EM_EYE_STATE_TYPE;

// mouth state
typedef enum tagEM_MOUTH_STATE_TYPE
{
	EM_MOUTH_STATE_UNKNOWN,		// unknown
	EM_MOUTH_STATE_NODISTI,		// no disringuish
	EM_MOUTH_STATE_CLOSE,		// close mouth
	EM_MOUTH_STATE_OPEN,		// open nouth
} EM_MOUTH_STATE_TYPE;

// mask state
typedef enum tagEM_MASK_STATE_TYPE
{
	EM_MASK_STATE_UNKNOWN,		// unknown
	EM_MASK_STATE_NODISTI,		// no disringuish
	EM_MASK_STATE_NOMASK,		// no mask
	EM_MASK_STATE_WEAR,			// wearing mask
} EM_MASK_STATE_TYPE;

// beard state
typedef enum tagEM_BEARD_STATE_TYPE
{
	EM_BEARD_STATE_UNKNOWN,		// unknown
	EM_BEARD_STATE_NODISTI,	// no disringuish
	EM_BEARD_STATE_NOBEARD,		// no beard
	EM_BEARD_STATE_HAVEBEARD,	// have beard
} EM_BEARD_STATE_TYPE;

// face detection of glasses 
typedef enum tagEM_FACEDETECT_GLASSES_TYPE
{
	EM_FACEDETECT_GLASSES_UNKNOWN,          // Unknown type
	EM_FACEDETECT_WITH_GLASSES,             // Wear glasses
	EM_FACEDETECT_WITHOUT_GLASSES,          // Without glasses
}EM_FACEDETECT_GLASSES_TYPE;

// person feature state
typedef enum tagEM_PERSON_FEATURE_STATE
{
	EM_PERSON_FEATURE_UNKNOWN,			// unknown
	EM_PERSON_FEATURE_FAIL,				// failed to model, need to change the picture
	EM_PERSON_FEATURE_USEFUL,			// success to model, the data can be used for face recognition
	EM_PERSON_FEATURE_CALCULATING,		// under calculating
	EM_PERSON_FEATURE_UNUSEFUL,			// once modeling was successful, but became unusable after upgrading, need to abstract
} EM_PERSON_FEATURE_STATE;

// error code of person feature
typedef enum tagEM_PERSON_FEATURE_ERRCODE
{
    EM_PERSON_FEATURE_ERRCODE_UNKNOWN,          // unknown
    EM_PERSON_FEATURE_ERRCODE_PIC_FORMAT,       // invalid picture format
    EM_PERSON_FEATURE_ERRCODE_NO_FACE,          // no face or unclear face
    EM_PERSON_FEATURE_ERRCODE_MULTI_FACE,       // multi face
    EM_PERSON_FEATURE_ERRCODE_PIC_DECODE_FAIL,  // picture decoding failed
    EM_PERSON_FEATURE_ERRCODE_NOT_RECOMMEND,    // not recommended for storage
    EM_PERSON_FEATURE_ERRCODE_FACEDB_FAIL,      // failure of database operation
    EM_PERSON_FEATURE_ERRCODE_GET_PICTURE,      // fail to ge picture
    EM_PERSON_FEATURE_ERRCODE_SYSTEM_ERROR,     // system error
} EM_PERSON_FEATURE_ERRCODE;

#define DH_MAX_PERSON_INFO_LEN            64               // max length of personnel extension information

// extension of registered personnel information
typedef struct tagCUSTOM_PERSON_INFO
{
	char szPersonInfo[DH_MAX_PERSON_INFO_LEN];     // personnel extension information
	BYTE                        byReserved[124];   							// Reserved bytes
} CUSTOM_PERSON_INFO;

// the type of register face DB
typedef enum tagEM_REGISTER_DB_TYPE
{
	EM_REGISTER_DB_TYPE_UNKNOWN,		// unknown
	EM_REGISTER_DB_TYPE_NORMAL,			// normal
	EM_REGISTER_DB_TYPE_BLACKLIST,		// black list
	EM_REGISTER_DB_TYPE_WHITELIST,		// white list
	EM_REGISTER_DB_TYPE_VIP,			// VIP
	EM_REGISTER_DB_TYPE_STAFF,			// staff DB
	EM_REGISTER_DB_TYPE_LEADER,			// leader DB
} EM_REGISTER_DB_TYPE;

#define	DH_MAX_CUSTOM_PERSON_INFO_NUM		4		// max extension number of registered personnel information

// expansion of  personnel information
typedef struct tagFACERECOGNITION_PERSON_INFOEX
{
    char                        szPersonName[DH_MAX_PERSON_NAME_LEN];           // person name             
    WORD                        wYear;                                          // birth year, fill 0 is invalid, when is as a query condition
    BYTE                        byMonth;                                        // birth month, fill 0 is invalid, when is as a query condition
    BYTE                        byDay;                                          // birth day, fill 0 is invalid, when is as a query condition
    BYTE                        bImportantRank;                                 // importance level,1~10,the higher value the higher level. fill 0 is invalid, when is as a query condition
    BYTE                        bySex;                                          // sex, 0-man, 1-female. fill 0 is invalid, when is as a query condition
    char                        szID[DH_MAX_PERSON_ID_LEN];                     //  the unicle ID for the person
    WORD                        wFacePicNum;                                    // picture number
    DH_PIC_INFO                 szFacePicInfo[DH_MAX_PERSON_IMAGE_NUM];         // picture info
    BYTE                        byType;                                         // Personnel types, see EM_PERSON_TYPE
    BYTE                        byIDType;                                       // Document types, see EM_CERTIFICATE_TYPE
    BYTE                        byGlasses;                                      // Whether wear glasses or not,0-unknown,1-not wear glasses,2-wear glasses						
    BYTE                        byAge;                                          // Age,0 means unknown 
    char                        szProvince[DH_MAX_PROVINCE_NAME_LEN];           // province
    char                        szCity[DH_MAX_CITY_NAME_LEN];                   // city
    char                        szUID[DH_MAX_PERSON_ID_LEN];                    // person unique ID
    char                        szCountry[NET_COUNTRY_LENGTH];                  // country
    BYTE                        byIsCustomType;                                 // using person type: 0 using byType, 1 using CustomType
    char                        szCustomType[DH_COMMON_STRING_16];              // custom type of person
    char                        szComment[NET_COMMENT_LENGTH];                  // comment info
    char                        szGroupID[NET_GROUPID_LENGTH];                  // group ID
    char                        szGroupName[NET_GROUPNAME_LENGTH];              // group name
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE    emEmotion;                          // Emotion
    char                        szHomeAddress[DH_COMMON_STRING_128];            // home address of the person
    EM_GLASSES_TYPE             emGlassesType;                                  // glasses type
    EM_RACE_TYPE                emRace;                                         // race
    EM_EYE_STATE_TYPE           emEye;                                          // eye state
    EM_MOUTH_STATE_TYPE         emMouth;                                        // mouth state
    EM_MASK_STATE_TYPE          emMask;                                         // mask state
    EM_BEARD_STATE_TYPE         emBeard;                                        // beard state
    int                         nAttractive;                                    // attractive, -1:invalid, 0:unknown1-100
    EM_PERSON_FEATURE_STATE     emFeatureState;                                 // person feature state
    BOOL                        bAgeEnable;                                     // age range is enabled
    int                         nAgeRange[2];                                   // age range
    int                         nEmotionValidNum;                               // invalid number in array emEmotion, 0 means all emotion
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE    emEmotions[DH_MAX_FACEDETECT_FEATURE_NUM];  // human emotion  set the query condition
    int                         nCustomPersonInfoNum;                           // extension number of registered personnel information
    CUSTOM_PERSON_INFO          szCustomPersonInfo[DH_MAX_CUSTOM_PERSON_INFO_NUM];  // extension of registered personnel information
    EM_REGISTER_DB_TYPE         emRegisterDbType;                               // type of register face DB
    NET_TIME                    stuEffectiveTime;                               // effective time
    EM_PERSON_FEATURE_ERRCODE   emFeatureErrCode;                               // error code of person feature
    BYTE                        byReserved[1112];                               // Reserved bytes
} FACERECOGNITION_PERSON_INFOEX;

// cadidate person info
typedef struct tagCANDIDATE_INFO
{
	FACERECOGNITION_PERSON_INFO  stPersonInfo;            // person info
	BYTE                         bySimilarity;            // similarity
	BYTE                         byRange;                 // Range officer's database, see EM_FACE_DB_TYPE
	BYTE                         byReserved1[2];
	NET_TIME                     stTime;                  // When byRange historical database effectively, which means that the query time staff appeared
	char                         szAddress[MAX_PATH];     // When byRange historical database effectively, which means that people place a query appears
	BOOL                         bIsHit;                  // Is hit, means the result face has compare result in database
	DH_PIC_INFO_EX3              stuSceneImage;           // Scene Image
	int							 nChannelID;			  // ChannelId
    BYTE                         byReserved[32];          // Reserved bytes
}CANDIDATE_INFO;

// Clothes color
typedef enum tagEM_CLOTHES_COLOR
{
    EM_CLOTHES_COLOR_UNKNOWN,       // Unknown
    EM_CLOTHES_COLOR_WHITE,         // White
    EM_CLOTHES_COLOR_ORANGE,        // Orange
    EM_CLOTHES_COLOR_PINK,          // Pink
    EM_CLOTHES_COLOR_BLACK,         // Black
    EM_CLOTHES_COLOR_RED,           // Red
    EM_CLOTHES_COLOR_YELLOW,        // Yellow
    EM_CLOTHES_COLOR_GRAY,          // Gray
    EM_CLOTHES_COLOR_BLUE,          // Blue
    EM_CLOTHES_COLOR_GREEN,         // Green 
    EM_CLOTHES_COLOR_PURPLE,        // Purple
    EM_CLOTHES_COLOR_BROWN,         // Brown
    EM_CLOTHES_COLOR_OTHER,         // Other 
}EM_CLOTHES_COLOR;

// coat type
typedef enum tagEM_COAT_TYPE
{
    EM_COAT_TYPE_UNKNOWN,           // Unknown
    EM_COAT_TYPE_LONG_SLEEVE,       // Long sleeve
    EM_COAT_TYPE_COTTA,             // Cotta
}EM_COAT_TYPE;

// Trousers type
typedef enum tagEM_TROUSERS_TYPE
{
    EM_TROUSERS_TYPE_UNKNOWN,       // Unknown
    EM_TROUSERS_TYPE_TROUSERS,      // Trousers
    EM_TROUSERS_TYPE_SHORTS,        // Shorts
    EM_TROUSERS_TYPE_SKIRT,         // Skirt
}EM_TROUSERS_TYPE;

// Has hat
typedef enum tagEM_HAS_HAT
{
    EM_HAS_HAT_UNKNOWN,             // Unknown
    EM_HAS_HAT_NO,                  // Not has hat
    EM_HAS_HAT_YES,                 // Has hat
}EM_HAS_HAT;

// Has bag
typedef enum tagEM_HAS_BAG
{
    EM_HAS_BAG_UNKNOWN,             // Unknown
    EM_HAS_BAG_NO,                  // No bag
    EM_HAS_BAG_YES,                 // Has bag
}EM_HAS_BAG;

// Has back bag or not
typedef enum tagEM_HAS_BACK_BAG
{
    EM_HAS_BACK_BAG_UNKNOWN,        // Unknown
    EM_HAS_BACK_BAG_NO,             // No back bag
    EM_HAS_BACK_BAG_YES,            // Has back bag
} EM_HAS_BACK_BAG;

// Has carrier bag or not
typedef enum tagEM_HAS_CARRIER_BAG
{
    EM_HAS_CARRIER_BAG_UNKNOWN,     // Unknown
    EM_HAS_CARRIER_BAG_NO,          // No carrier bag
    EM_HAS_CARRIER_BAG_YES,         // Has carrier bag
} EM_HAS_CARRIER_BAG;

// Has shoulder bag or not
typedef enum tagEM_HAS_SHOULDER_BAG
{
    EM_HAS_SHOULDER_BAG_UNKNOWN,    // Unknown
    EM_HAS_SHOULDER_BAG_NO,         // No shoulder bag
    EM_HAS_SHOULDER_BAG_YES,        // Has shoulder bag
} EM_HAS_SHOULDER_BAG;

// Has messenger bag or not
typedef enum tagEM_HAS_MESSENGER_BAG
{
    EM_HAS_MESSENGER_BAG_UNKNOWN,   // Unknown
    EM_HAS_MESSENGER_BAG_NO,        // No messenger bag
    EM_HAS_MESSENGER_BAG_YES,       // Has messenger bag
} EM_HAS_MESSENGER_BAG;

// Angle
typedef enum tagEM_ANGLE_TYPE
{
    EM_ANGLE_UNKNOWN = 0,           // unknown
    EM_ANGLE_FRONT,                 // front
    EM_ANGLE_SIDE,                  // side
    EM_ANGLE_BACK,                  // back
}EM_ANGLE_TYPE;

// Umbrella state
typedef enum tagEM_HAS_UMBRELLA
{
    EM_HAS_UMBRELLA_UNKNOWN,        // unknown
    EM_HAS_UMBRELLA_NO,             // no umbrella
    EM_HAS_UMBRELLA_YES,            // has umbrella
} EM_HAS_UMBRELLA;

// bag type
typedef enum tagEM_BAG_TYPE
{
    EM_BAG_UNKNOWN,                 // unknown
    EM_BAG_HANDBAG,                 // hand bag
    EM_BAG_SHOULDERBAG,             // shoulder bag
    EM_BAG_KNAPSACK,                // knapsack
    EM_BAG_DRAWBARBOX,              // drawar box
    EM_BAG_WAISTPACK,               // waist pack
    EM_BAG_NONE,                    // no bag
} EM_BAG_TYPE;

//Cap type
typedef enum tagEM_CAP_TYPE
{
    EM_CAP_UNKNOWN,         // unknown
    EM_CAP_ORDINARY,        // ordinary
    EM_CAP_HELMET,          // helmet
    EM_CAP_SAFE,            // safe hat
} EM_CAP_TYPE;

// clothes pattern
typedef enum tagEM_CLOTHES_PATTERN
{
    EM_CLOTHES_PATTERN_UNKNOWN,     // unknown
    EM_CLOTHES_PATTERN_PURE,        // pure color
    EM_CLOTHES_PATTERN_STRIPE,      // Stripe
    EM_CLOTHES_PATTERN_PATTERN,     // Pattern
    EM_CLOTHES_PATTERN_GAP,         // Gap
    EM_CLOTHES_PATTERN_LATTICE,     // Lattice
    EM_CLOTHES_PATTERN_SPLITJOIN,   // split join
} EM_CLOTHES_PATTERN;

// hair style
typedef enum tagEM_HAIR_STYLE
{
    EM_HAIR_UNKNOWN = 0,    // unknown
    EM_HAIR_LONG_HAIR,      // long hair
    EM_HAIR_SHORT_HAIR,     // short hair
    EM_HAIR_PONYTAIL,       // ponytail
    EM_HAIR_UPDO,           // updo
    EM_HAIR_HEAD_BLOCKED,   // head blocked
    EM_HAIR_NONE,           // no hair
} EM_HAIR_STYLE;

// sex type
typedef enum tagEM_SEX_TYPE
{
    EM_SEX_TYPE_UNKNOWN,    // Unknown
    EM_SEX_TYPE_MALE,       // Male
    EM_SEX_TYPE_FEMALE,     // Female
}EM_SEX_TYPE;

// Image info of human in history data base
typedef struct tagNET_HISTORY_HUMAN_IMAGE_INFO
{
    int                 nLength;            // Image, unit:byte
    int                 nWidth;             // Image width
    int                 nHeight;            // Image height
    char                szFilePath[260];    // Image path
} NET_HISTORY_HUMAN_IMAGE_INFO;

// Human info in history data base
typedef struct tagNET_HISTORY_HUMAN_INFO
{
    EM_CLOTHES_COLOR                emCoatColor;            // Coat color
    EM_COAT_TYPE                    emCoatType;             // Coat type
    EM_CLOTHES_COLOR                emTrousersColor;        // Trousers color
    EM_TROUSERS_TYPE                emTrousersType;         // Trousers type
    EM_HAS_HAT                      emHasHat;               // Has hat or not
    EM_HAS_BAG                      emHasBag;               // Has bag or not
    NET_RECT                        stuBoundingBox;         // Bounding box
    int                             nAge;                   // Age
    EM_SEX_TYPE                     emSex;                  // Sex
    EM_ANGLE_TYPE                   emAngle;                // Angle
    EM_HAS_UMBRELLA                 emHasUmbrella;          // Has umbrella or not
    EM_BAG_TYPE                     emBag;                  // Bag type
    EM_CLOTHES_PATTERN              emUpperPattern;         // Upper pattern
    EM_HAIR_STYLE                   emHairStyle;            // Hair style
    EM_CAP_TYPE                     emCap;                  // Cap type
    EM_HAS_BACK_BAG                 emHasBackBag;           // Has back bag or not
    EM_HAS_CARRIER_BAG              emHasCarrierBag;        // Has carrier bag or not
    EM_HAS_SHOULDER_BAG             emHasShoulderBag;       // Has shoulder bag or not
    EM_HAS_MESSENGER_BAG            emMessengerBag;         // Has messenger bag or not
    NET_HISTORY_HUMAN_IMAGE_INFO    stuImageInfo;           // Human image info
    NET_HISTORY_HUMAN_IMAGE_INFO    stuFaceImageInfo;       // Face image info
    BYTE                            byReserved[256];        // Reserved
} NET_HISTORY_HUMAN_INFO;

// extend of cadidate person info
typedef struct tagCANDIDATE_INFOEX
{
    FACERECOGNITION_PERSON_INFOEX   stPersonInfo;           // Extend of person info
    BYTE                            bySimilarity;           // Similarity in comparison with query image, expressed in percentage, 1~100
    BYTE                            byRange;                // Range officer's database, see EM_FACE_DB_TYPE
    BYTE                            byReserved1[2];
    NET_TIME                        stTime;                 // When byRange historical database effectively, which means that the query time staff appeared
    char                            szAddress[MAX_PATH];    // When byRange historical database effectively, which means that people place a query appears
    BOOL                            bIsHit;                 // Is hit, means the result face has compare result in database
    DH_PIC_INFO_EX3                 stuSceneImage;          // Scene Image
    int                             nChannelID;             // ChannelId
    char                            szFilePathEx[256];      // File path
    NET_HISTORY_HUMAN_INFO          stuHistoryHumanInfo;    // Human info in history data base
    BYTE                            byReserved[136];        // Reserved bytes
} CANDIDATE_INFOEX;

// calss type  
typedef enum tagEM_CLASS_TYPE        
{
    EM_CLASS_UNKNOWN                    = 0,         
    EM_CLASS_VIDEO_SYNOPSIS             = 1,        
    EM_CLASS_TRAFFIV_GATE               = 2,           
    EM_CLASS_ELECTRONIC_POLICE          = 3,        
    EM_CLASS_SINGLE_PTZ_PARKING         = 4,        
    EM_CLASS_PTZ_PARKINBG               = 5,          
    EM_CLASS_TRAFFIC                    = 6,    // "Traffic"       
    EM_CLASS_NORMAL                     = 7,    // "Normal"       
    EM_CLASS_PRISON                     = 8,    // "Prison"       
    EM_CLASS_ATM                        = 9,    // "ATM"       
    EM_CLASS_METRO                      = 10,       
    EM_CLASS_FACE_DETECTION             = 11,   // "FaceDetection"       
    EM_CLASS_FACE_RECOGNITION           = 12,   // "FaceRecognition"       
    EM_CLASS_NUMBER_STAT                = 13,   // "NumberStat"       
    EM_CLASS_HEAT_MAP                   = 14,   // "HeatMap"       
    EM_CLASS_VIDEO_DIAGNOSIS            = 15,   // "VideoDiagnosis"       
    EM_CLASS_VIDEO_ENHANCE              = 16,        
    EM_CLASS_SMOKEFIRE_DETECT           = 17,          
    EM_CLASS_VEHICLE_ANALYSE            = 18,   // "VehicleAnalyse"       
    EM_CLASS_PERSON_FEATURE             = 19, 
    EM_CLASS_SDFACEDETECTION            = 20,   // "SDFaceDetect"  
    EM_CLASS_HEAT_MAP_PLAN              = 21,   // "HeatMapPlan" 
    EM_CLASS_NUMBERSTAT_PLAN            = 22,   // "NumberStatPlan"
    EM_CLASS_ATMFD                      = 23,   // "ATMFD"
    EM_CLASS_HIGHWAY                    = 24,   // "Highway"
    EM_CLASS_CITY                       = 25,   // "City"
    EM_CLASS_LETRACK                    = 26,   // "LeTrack"
    EM_CLASS_SCR                        = 27,   // "SCR"
    EM_CLASS_STEREO_VISION              = 28,   // "StereoVision"
    EM_CLASS_HUMANDETECT                = 29,   // "HumanDetect"
    EM_CLASS_FACE_ANALYSIS              = 30,   // "FaceAnalysis"
    EM_CALSS_XRAY_DETECTION             = 31,   // "XRayDetection"
    EM_CLASS_STEREO_NUMBER              = 32,   // "StereoNumber"
    EM_CLASS_CROWDDISTRIMAP             = 33,   // "CrowdDistriMap"
    EM_CLASS_OBJECTDETECT               = 34,   // "ObjectDetect"
    EM_CLASS_FACEATTRIBUTE              = 35,   // "FaceAttribute" 
    EM_CLASS_FACECOMPARE                = 36,   // "FaceCompare" 
    EM_CALSS_STEREO_BEHAVIOR            = 37,   // "StereoBehavior"
    EM_CALSS_INTELLICITYMANAGER         = 38,   // "IntelliCityMgr"
    EM_CALSS_PROTECTIVECABIN            = 39,   // "ProtectiveCabin"
    EM_CALSS_AIRPLANEDETECT             = 40,   // "AirplaneDetect"
    EM_CALSS_CROWDPOSTURE               = 41,   // "CrowdPosture"
    EM_CLASS_PHONECALLDETECT            = 42,   // "PhoneCallDetect"
    EM_CLASS_SMOKEDETECTION             = 43,   // "SmokeDetection"
    EM_CLASS_BOATDETECTION              = 44,   // "BoatDetection"
    EM_CLASS_SMOKINGDETECT              = 45,   // "SmokingDetect"
    EM_CLASS_WATERMONITOR               = 46,   // "WaterMonitor"
    EM_CLASS_GENERATEGRAPHDETECTION     = 47,   // "GenerateGraphDetection" 
    EM_CLASS_TRAFFIC_PARK               = 48,   // "TrafficPark"
    EM_CLASS_OPERATEMONITOR             = 49,   // "OperateMonitor"
    EM_CLASS_INTELLI_RETAIL             = 50,   // "IntelliRetail"
    EM_CLASS_CLASSROOM_ANALYSE          = 51,   // ClassroomAnalyse"
    EM_CLASS_FEATURE_ABSTRACT           = 52,   // "FeatureAbstract" 
    EM_CLASS_FACEBODY_DETECT            = 53,   // "FaceBodyDetect"
    EM_CLASS_FACEBODY_ANALYSE           = 54,   // "FaceBodyAnalyse"
    EM_CLASS_VEHICLES_DISTRI            = 55,   // "VehiclesDistri"
    EM_CLASS_INTELLI_BREED              = 56,   // "IntelliBreed"
    EM_CLASS_INTELLI_PRISON             = 57,   // "IntelliPrison"
    EM_CLASS_ELECTRIC_DETECT            = 58,   // "ElectricDetect"
	EM_CLASS_RADAR_DETECT				= 59,     // "RadarDetect"
    EM_CLASS_PARKINGSPACE               = 60,   // "ParkingSpace"
} EM_CLASS_TYPE;

//same as EM_SCENE_TYPE
typedef enum tagEM_SCENE_CLASS_TYPE
{
	EM_SCENE_CLASS_UNKNOW,			// unknow
	EM_SCENE_CLASS_NORMAL,			// "Normal"
	EM_SCENE_CLASS_TRAFFIC,			// "Traffic" 
	EM_SCENE_CLASS_TRAFFIC_PATROL,	// "TrafficPatrol" 
	EM_SCENE_CLASS_FACEDETECTION,	// "FaceDetection" 
	EM_SCENE_CLASS_ATM,				// "ATM"
	EM_SENCE_CLASS_INDOOR,			// "Indoor"  
	EM_SENCE_CLASS_FACERECOGNITION,	// "FaceRecognition" 
	EM_SENCE_CLASS_PRISON,			// "Prison" 
	EM_SENCE_CLASS_NUMBERSTAT,		// "NumberStat" 
	EM_SENCE_CLASS_HEAT_MAP,		// "HeatMap" 
	EM_SENCE_CLASS_VIDEODIAGNOSIS,	// "VideoDiagnosis" 
	EM_SENCE_CLASS_VEHICLEANALYSE,	// "VehicleAnalyse" 
	EM_SENCE_CLASS_COURSERECORD,	// "CourseRecord" 
	EM_SENCE_CLASS_VEHICLE,			// "Vehicle" 
	EM_SENCE_CLASS_STANDUPDETECTION,// "StandUpDetection" 
	EM_SCENE_CLASS_GATE,			// "Gate"
	EM_SCENE_CLASS_SDFACEDETECTION,	// "SDFaceDetect"
	EM_SCENE_CLASS_HEAT_MAP_PLAN,	// "HeatMapPlan"
	EM_SCENE_CLASS_NUMBERSTAT_PLAN,	// "NumberStatPlan"
	EM_SCENE_CLASS_ATMFD,			// "ATMFD"
	EM_SCENE_CLASS_HIGHWAY,			// "Highway" 
	EM_SCENE_CLASS_CITY,			// "City" 
	EM_SCENE_CLASS_LETRACK,			// "LeTrack" 
	EM_SCENE_CLASS_SCR,				// "SCR"
	EM_SCENE_CLASS_STEREO_VISION,   // "StereoVision"
	EM_SCENE_CLASS_HUMANDETECT,		// "HumanDetect"
	EM_SCENE_CLASS_FACEANALYSIS,	// "FaceAnalysis"
	EM_SCENE_CLASS_XRAY_DETECTION,	// "XRayDetection"
	EM_SCENE_CLASS_STEREO_NUMBER,	// "StereoNumber"
	EM_SCENE_CLASS_CROWDDISTRIMAP,	// "CrowdDistriMap"
	EM_SCENE_CLASS_OBJECTDETECT,	// "ObjectDetect"
	EM_SCENE_CLASS_FACEATTRIBUTE,	// "FaceAttribute"
	EM_SCENE_CLASS_FACECOMPARE,		// "FaceCompare"
    EM_SCENE_CLASS_STEREO_BEHAVIOR,	// "StereoBehavior"
	EM_SCENE_CLASS_INTELLICITYMANAGER,	// "IntelliCityMgr"
	EM_SCENE_CLASS_PROTECTIVECABIN,	// "ProtectiveCabin"
	EM_SCENE_CLASS_AIRPLANEDETECT,	// "AirplaneDetect"
	EM_SCENE_CLASS_CROWDPOSTURE,	// "CrowdPosture"
	EM_SCENE_CLASS_PHONECALLDETECT,	// "PhoneCallDetect"
	EM_SCENE_CLASS_SMOKEDETECTION,	// "SmokeDetection"
	EM_SCENE_CLASS_BOATDETECTION,	// "BoatDetection"
	EM_SCENE_CLASS_SMOKINGDETECT,	// "SmokingDetect"
	EM_SCENE_CLASS_WATERMONITOR,	// "WaterMonitor"
    EM_SCENE_CLASS_GENERATEGRAPHDETECTION,	// "GenerateGraphDetection"
	EM_SCENE_CLASS_TRAFFIC_PARK,	// "TrafficPark"	
    EM_SCENE_CLASS_OPERATEMONITOR,	// "OperateMonitor"	
    EM_SCENE_CLASS_INTELLI_RETAIL,	// IntelliRetail" 
    EM_SCENE_CLASS_CLASSROOM_ANALYSE,// "ClassroomAnalyse" 
    EM_SCENE_CLASS_FEATURE_ABSTRACT, // "FeatureAbstract"
	EM_SCENE_CLASS_FACEBODY_DETECT,	 // "FaceBodyDetect" 
	EM_SCENE_CLASS_FACEBODY_ANALYSE, // "FaceBodyAnalyse"
	EM_SCENE_CLASS_VEHICLES_DISTRI,	 // "VehiclesDistri"
	EM_SCENE_CLASS_INTELLI_BREED,    // "IntelliBreed"
	EM_SCENE_CLASS_INTELLI_PRISON,   // "IntelliPrison"
	EM_SCENE_CLASS_ELECTRIC_DETECT,  // "ElectricDetect"
	EM_SCENE_CLASS_RADAR_DETECT,       // "RadarDetect"
    EM_SCENE_CLASS_PARKINGSPACE,     // "ParkingSpace"
} EM_SCENE_CLASS_TYPE;

// intelli event comm info
typedef struct tagEVENT_INTELLI_COMM_INFO
{
	EM_CLASS_TYPE		emClassType;								// class type
	int					nPresetID;									// Preset ID, value range is 0~255 and when the value is greater than 0 is valied
	BYTE                bReserved[124];                     		// reserved
} EVENT_INTELLI_COMM_INFO;

// intelli image information
typedef struct tagNET_INTELLIGENCE_IMAGE_INFO
{
	UINT				nOffSet;					// The offset of image data in binary data   
	UINT				nLength;					// The image data length, Unit:Byte
	UINT				nWidth;						// Image width(pixel)
	UINT				nHeight;					// Image height(pixel)
	BYTE				byReserved[48];				// Reserved
}NET_INTELLIGENCE_IMAGE_INFO;

// part of traffic car info
typedef struct tagEVENT_TRAFFIC_CAR_PART_INFO
{
    char                szMachineName[128];                  // Local or remote device name    
    char                szRoadwayNo[32];                     // road way number
    char                szPlateNumber[32];                   // plate number
    char                szCategory[32];                      // category
    BYTE                bReserved[288];                      // reserved
}EVENT_TRAFFIC_CAR_PART_INFO;


// traffic car move direction type
typedef enum tagEM_TRAFFICCAR_MOVE_DIRECTION
{
    EM_TRAFFICCAR_MOVE_DIRECTION_UNKNOWN,                           // unknown
    EM_TRAFFICCAR_MOVE_DIRECTION_STRAIGHT,                          // straight
    EM_TRAFFICCAR_MOVE_DIRECTION_TURN_LEFT,                         // turn left
    EM_TRAFFICCAR_MOVE_DIRECTION_TURN_RIGHT,                        // turn right
    EM_TRAFFICCAR_MOVE_DIRECTION_TURN_AROUND,                       // turn around
}EM_TRAFFICCAR_MOVE_DIRECTION;

// authority list of white list
typedef struct tagNET_WHITE_LIST_AUTHORITY_LIST
{
    BOOL                bOpenGate;                         // true:having open gate authority,false:no having open gate authority
    BYTE                bReserved[16];                      // reserved
}NET_WHITE_LIST_AUTHORITY_LIST;

// white list information
typedef struct tagNET_TRAFFICCAR_WHITE_LIST
{
    BOOL                          bTrustCar;                // true: the car is trust car,false:the car is not trust car
    NET_TIME                       stuBeginTime;             // begin time of white list
    NET_TIME                       stuCancelTime;             // cancel time of white list
    NET_WHITE_LIST_AUTHORITY_LIST         stuAuthorityList;         // authority list of white list
    BYTE                          bReserved[32];             // reserved
}NET_TRAFFICCAR_WHITE_LIST;

// Blacklist information
typedef struct tagNET_TRAFFICCAR_BLACK_LIST
{
    BOOL                          bEnable;					// Enable blacklist
	BOOL						  bIsBlackCar;				// Is the plate on the blacklist?
    NET_TIME                      stuBeginTime;				// Begin time
    NET_TIME                      stuCancelTime;			// Cancel time
    BYTE                          bReserved[32];			// Reserved
}NET_TRAFFICCAR_BLACK_LIST;

// car type
typedef enum tagEM_TRAFFICCAR_CAR_TYPE
{
    EM_TRAFFICCAR_CAR_TYPE_UNKNOWN,                          // unknown
    EM_TRAFFICCAR_CAR_TYPE_TRUST_CAR,                        // trust car
    EM_TRAFFICCAR_CAR_TYPE_SUSPICIOUS_CAR,                   // suspicious car
    EM_TRAFFICCAR_CAR_TYPE_NORMAL_CAR,                       // normal car
}EM_TRAFFICCAR_CAR_TYPE;

// Lane type
typedef enum tagEM_TRAFFICCAR_LANE_TYPE
{
    EM_TRAFFICCAR_LANE_TYPE_UNKNOWN,						// unknown
    EM_TRAFFICCAR_LANE_TYPE_NORMAL,							// Normal
    EM_TRAFFICCAR_LANE_TYPE_NONMOTOR,						// Non-motor
	EM_TRAFFICCAR_LANE_TYPE_LIGHT_DUTY,                     // Light-Duty
	EM_TRAFFICCAR_LANE_TYPE_BUS,							// Bus
	EM_TRAFFICCAR_LANE_TYPE_EMERGENCY,						// Emergency
	EM_TRAFFICCAR_LANE_TYPE_DANGEROUS,						// Dangerous
}EM_TRAFFICCAR_LANE_TYPE;

// TrafficCar information
typedef struct tagDEV_EVENT_TRAFFIC_TRAFFICCAR_INFO
{
    char               szPlateNumber[32];               // plate number
    char               szPlateType[32];                 // Plate type: "Unknown" =Unknown; "Normal"=Blue and black plate. "Yellow"=Yellow plate. "DoubleYellow"=Double-layer yellow plate 
                                                        // "Police"=Police plate ; "Armed"= =Military police plate; "Military"=Army plate; "DoubleMilitary"=Army double-layer 
                                                        // "SAR" =HK SAR or Macao SAR plate; "Trainning" =rehearsal plate; "Personal"=Personal plate; "Agri"=Agricultural plate
                                                        // "Embassy"=Embassy plate; "Moto"=Moto plate ; "Tractor"=Tractor plate; "Other"=Other plate 
    char               szPlateColor[32];                // plate color, "Blue","Yellow", "White","Black","YellowbottomBlackText","BluebottomWhiteText","BlackBottomWhiteText","ShadowGreen","YellowGreen"
    char               szVehicleColor[32];              // vehicle color, "White", "Black", "Red", "Yellow", "Gray", "Blue","Green"
    int                nSpeed;                          // speed, Km/H
    char               szEvent[64];                     // trigger event type
    char               szViolationCode[32];             // violation code, see TrafficGlobal.ViolationCode
    char               szViolationDesc[64];             // violation describe
    int                nLowerSpeedLimit;                // lower speed limit
    int                nUpperSpeedLimit;                // upper speed limit
    int                nOverSpeedMargin;                // over speed margin, km/h 
    int                nUnderSpeedMargin;               // under speed margin, km/h 
    int                nLane;                           // lane	
    int                nVehicleSize;                    // vehicle size, see VideoAnalyseRule's describe
                                                        // Bit 0:"Light-duty", small car
                                                        // Bit 1:"Medium", medium car
                                                        // Bit 2:"Oversize", large car
                                                        // Bit 3:"Minisize", mini car
                                                        // Bit 4:"Largesize", long car
    float              fVehicleLength;                  // vehicle length, m
    int                nSnapshotMode;                   // snap mode 0-normal,1-globle,2-near,4-snap on the same side,8-snap on the reverse side,16-plant picture
    char               szChannelName[32];               // channel name
    char               szMachineName[256];              // Machine name
    char               szMachineGroup[256];             // machine group
    char               szRoadwayNo[64];                 // road way number	
    char               szDrivingDirection[3][DH_MAX_DRIVINGDIRECTION];   
                                                                            // DrivingDirection: for example ["Approach", "Shanghai", "Hangzhou"]
                                                                            // "Approach" means driving direction,where the car is more near;"Leave"-means where if mor far to the car
                                                                            // the second and third param means the location of the driving direction
    char              *szDeviceAddress;                 // device address,OSD superimposed onto the image,from TrafficSnapshot.DeviceAddress,'\0'means end.
    char               szVehicleSign[32];               // Vehicle identification, such as "Unknown" - unknown "Audi" - Audi, "Honda" - Honda ...
    DH_SIG_CARWAY_INFO_EX stuSigInfo;                   // Generated by the vehicle inspection device to capture the signal redundancy
    char              *szMachineAddr;                   // Equipment deployment locations
    float              fActualShutter;                  // Current picture exposure time, in milliseconds
    BYTE               byActualGain;                    // Current picture gain, ranging from 0 to 100
    BYTE               byDirection;                     // Lane Direction,0 - south to north 1- Southwest to northeast 2 - West to east, 3 - Northwest to southeast 4 - north to south 5 - northeast to southwest 6 - East to West 7 - Southeast to northwest 8 - Unknown 9-customized
    BYTE               byReserved[2];
    char*              szDetailedAddress;                   // Address, as szDeviceAddress supplement, 
    char               szDefendCode[DH_COMMON_STRING_64];   // waterproof  
    int                nTrafficBlackListID;                 // Link black list data recorddefualt main keyID, 0, invalid, > 0, black list data record
    DH_COLOR_RGBA      stuRGBA;                             // bofy color RGBA
    NET_TIME           stSnapTime;                          // snap time
    int                nRecNo;                              // Rec No
    char               szCustomParkNo[DH_COMMON_STRING_32 + 1]; // self defined parking space number, for parking, 
    BYTE               byReserved1[3];
    int                nDeckNo;                             // Metal plate No. 
    int                nFreeDeckCount;                      // Free metal plate No.
    int                nFullDeckCount;                      // Occupized metal plate No. 
    int                nTotalDeckCount;                     // Total metal plate No. 
    char               szViolationName[64];                 // violation name
    unsigned int	   nWeight;                             // Weight of car(kg)
    char               szCustomRoadwayDirection[32];        // custom road way, valid when byDirection is 9
    BYTE               byPhysicalLane;                      // the physical lane number,value form 0 to 5
    BYTE               byReserved2[3];
    EM_TRAFFICCAR_MOVE_DIRECTION emMovingDirection;         // moving direction
    NET_TIME           stuEleTagInfoUTC;                    // corresponding to throughTime
    NET_RECT           stuCarWindowBoundingBox;             // The BoundingBox of car window , 0~8191
    NET_TRAFFICCAR_WHITE_LIST   stuWhiteList;               // white list information
    EM_TRAFFICCAR_CAR_TYPE      emCarType;                  // car type
    EM_TRAFFICCAR_LANE_TYPE     emLaneType;                 // Lane type
    char               szVehicleBrandYearText[64];          // Translated year of vehicle
    char               szCategory[32];                      // category
	NET_TRAFFICCAR_BLACK_LIST	stuBlackList;				// Blacklist information
    BYTE               bReserved[240];                      // Reserved bytes.
}DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO;

#ifndef LINUX64_JNA
#pragma pack(push)
#pragma pack(4)
#endif
// GPS Infomation
typedef struct tagNET_GPS_INFO
{
    unsigned int                    nLongitude;         	// Longitude(unit:1/1000000 degree)
                                                            // west Longitude: 0 - 180000000            practical value = 180*1000000 - dwLongitude
                                                            // east Longitude: 180000000 - 360000000    practical value = dwLongitude - 180*1000000
															// eg: Longitude:300168866  (300168866 - 180*1000000)/1000000  equal east Longitude 120.168866 degree

    unsigned int					nLatidude;              // Latidude(unit:1/1000000 degree)
                                                            // north Latidude: 0 - 90000000				practical value = 90*1000000 - dwLatidude
                                                            // south Latidude: 90000000 - 180000000	practical value = dwLatidude - 90*1000000
															// eg: Latidude:120186268 (120186268 - 90*1000000)/1000000 equal south Latidude 30. 186268 degree
    double                          dbAltitude;             // altitude,unit:m
    double                          dbSpeed;                // Speed,unit:km/H
    double                          dbBearing;              // Bearing,unit:
    BYTE                            bReserved[8];           // Reserved bytes
}NET_GPS_INFO;
#ifndef LINUX64_JNA
#pragma pack(pop)
#endif

// Extension info
typedef struct tagNET_EXTENSION_INFO
{
	char        szEventID[MAX_EVENT_ID_LEN];				// Chinese standard event ID
	BYTE        byReserved[80];                             // Reserved
} NET_EXTENSION_INFO;

// Scene image
typedef struct tagSCENE_IMAGE_INFO_EX
{
	unsigned int	   nOffSet;					// mage offset in the data  
	unsigned int	   nLength;					// image data length
	unsigned int	   nWidth;					// image width(pixel)
	unsigned int	   nHeight;					// image Height(pixel)
	char               szFilePath[260];         // file path
	BYTE			   byReserved[512];			// Reserved
}SCENE_IMAGE_INFO_EX;

// Uniform style
typedef enum tagEM_UNIFORM_STYLE
{
    EM_UNIFORM_STYLE_UNKNOWN,						// Unknown
    EM_UNIFORM_STYLE_POLICE,						// Police uniform
}EM_UNIFORM_STYLE;

// Human info 
typedef struct tagNET_VAOBJECT_NUMMAN
{
    UINT                nObjectID;                          // Object ID
    EM_UNIFORM_STYLE    emUniformStyle;                     // Uniform style
    NET_RECT			stuBoundingBox;                     // Bounding box(8192 coordinate system)
    NET_RECT			stuOriginalBoundingBox;             // BoundingBox Rect, absolute coordinates
    BYTE			    byReserved[128];			        // Reserved
}NET_VAOBJECT_NUMMAN;

// the describe of EVENT_IVS_CROSSLINEDETECTION's data
typedef struct tagDEV_EVENT_CROSSLINE_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	DH_POINT            DetectLine[DH_MAX_DETECT_LINE_NUM];    // rule detect line
	int                 nDetectLineNum;                        // rule detect line's point number
	DH_POINT            TrackLine[DH_MAX_TRACK_LINE_NUM];      // object moveing track
	int                 nTrackLineNum;                         // object moveing track's point number
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
	BYTE                bDirection;                     // direction, 0-left to right, 1-right to left
	BYTE                byReserved[1];
	BYTE				byImageIndex;					// Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
    unsigned int        nOccurrenceCount;               // event trigger accumulated times
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelli comm info
	NET_EXTENSION_INFO  stuExtensionInfo;				// Extension info
	SCENE_IMAGE_INFO_EX stuSceneImage;                  // Scene image
    UINT                nObjetcHumansNum;               // Number of people detected
    NET_VAOBJECT_NUMMAN stuObjetcHumans[100];           // People detected
    BYTE			    byReserved1[512];			    // Reserved 
} DEV_EVENT_CROSSLINE_INFO;

// event type EVENT_IVS_CROSSLINEDETECTION_EX(warning line event )corresponding to  datadescriptioninfo 
typedef struct tagDEV_EVENT_CROSSLINE_INFO_EX 
{
    DWORD               dwSize;
    int                 nChannelID;                     // channel no.
    char                szName[128];                    // event name 
    char                bReserved1[4];                  // field align
    float				PTS;                            // time stamp(unit is ms)
    NET_TIME_EX         UTC;                            // event occurance time
    int                 nEventID;                       // event ID
    DH_MSG_OBJECT_EX    stuObject;                      // detection object 
    DH_EVENT_FILE_INFO  stuFileInfo;                    // event corresponding to file info 
    DH_POINT            DetectLine[DH_MAX_DETECT_LINE_NUM]; // rule detection line
    int                 nDetectLineNum;                 // rule detection line top number
    DH_POINT            TrackLine[DH_MAX_TRACK_LINE_NUM];// object motion track
    int                 nTrackLineNum;                  // object motion track top number
    BYTE                bEventAction;                   // event  motion , 0 means pulse event ,1 means continuity event  start ,2 means  continuity  event end;
    BYTE                bDirection;                     // means  intrusion direction, 0- leto to right, 1- right to left
    BYTE                byReserved[1];
    BYTE                byImageIndex;                   // picture no., same one time(accurate to second)may have multiple pictures , start from 0  
    DWORD               dwSnapFlagMask;                 // snapshot mark(by bit), see NET_RESERVED_COMMON
    int                 nSourceIndex;                   // event source device index,-1 means invalid data,-1 means invalid data
    char                szSourceDevice[MAX_PATH];       // event source device SN, field do not existor is null means local device 
    unsigned int        nOccurrenceCount;               // event trigger accumulated times
	int					nMsgObjArrayCount;              // detection object info number 
	DH_MSG_OBJECT_EX*	pMsgObjArray;                   // detection object info group indicator
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelli comm info
	SCENE_IMAGE_INFO_EX stuSceneImage;                  // scene image
    UINT                nObjetcHumansNum;               // Number of people detected
    NET_VAOBJECT_NUMMAN stuObjetcHumans[100];           // People detected
    BYTE			    byReserved1[512];			    // Reserved 
} DEV_EVENT_CROSSLINE_INFO_EX;

// Cargo Channel InfoIPC Jack Logistics
typedef struct tagNET_CUSTOM_INFO
{
	int					nCargoChannelNum;						// Cargo Channel Num
	float				fCoverageRate[MAX_CARGO_CHANNEL_NUM];	// Cargo Coverage Rate
	BYTE				byReserved[40];							// Reserved bytes 
} NET_CUSTOM_INFO;

// the describe of EVENT_IVS_CROSSREGIONDETECTION's data
typedef struct tagDEV_EVENT_CROSSREGION_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved2[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // rule detect region
	int                 nDetectRegionNum;                          // rule detect region's point number
	DH_POINT            TrackLine[DH_MAX_TRACK_LINE_NUM];          // object moving track
	int                 nTrackLineNum;                             // object moving track's point number
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
	BYTE                bDirection;                     // direction, 0-in, 1-out,2-apaer,3-leave
	BYTE                bActionType;                    // action type,0-appear 1-disappear 2-in area 3-cross area
	BYTE				byImageIndex;					// Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
    unsigned int        nOccurrenceCount;               // event trigger times
	NET_CUSTOM_INFO		stuCustom;						// Cargo Channel Info
	NET_EXTENSION_INFO  stuExtensionInfo;				// Extension info
	BYTE				bReserved[328];					// reserved
	int                 nObjectNum;                     // Detect object amount
	DH_MSG_OBJECT		stuObjectIDs[DH_MAX_OBJECT_LIST];// Detected object
	int                 nTrackNum;                      // Locus amount(Corresponding to the detected object amount.)
	DH_POLY_POINTS      stuTrackInfo[DH_MAX_OBJECT_LIST];// Locus info(Corresponding to the detected object)
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;      // intelli comm info
	SCENE_IMAGE_INFO_EX stuSceneImage;                   // scene image
    UINT                nObjetcHumansNum;               // Number of people detected
    NET_VAOBJECT_NUMMAN stuObjetcHumans[100];           // People detected
    BYTE			    byReserved1[512];			    // Reserved 
} DEV_EVENT_CROSSREGION_INFO;

//Special zone type 
typedef enum tagEM_SPECIAL_REGION_TYPE
{
    EM_SPEICAL_REGION_UNKNOW = 0        , // Unknown
    EM_SPEICAL_REGION_HIGH_LIGHT        , // Extra high light:ATM keyboard pane
    EM_SPEICAL_REGION_REGULAR_BLINK     , // Regular flash:ATM insert card zone 
    EM_SPEICAL_REGION_IRREGULAR_BLINK   , // Irregular flash:ATM screen 
}EM_SPECIAL_REGION_TYPE;

// the describe of EVENT_IVS_PASTEDETECTION's data
typedef struct tagDEV_EVENT_PASTE_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	int                 nDetectRegionNum;				// rule detect region's point number
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // rule detect region
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
	BYTE                byReserved[2];
	BYTE				byImageIndex;					// Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
    unsigned int        nOccurrenceCount;               // event trigger accumilated times 
    EM_SPECIAL_REGION_TYPE  emSpecialRegion;			// Special zone type
    EVENT_INTELLI_COMM_INFO stuIntelliCommInfo;         // intelli comm info
    BYTE                    bReserved[748];				// Reserved string. To be delevloped 
	
} DEV_EVENT_PASTE_INFO;

// the describe of EVENT_IVS_LEFTDETECTION's data
typedef struct tagDEV_EVENT_LEFT_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
	BYTE                byReserved[2];
	BYTE				byImageIndex;					// Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	int                 nDetectRegionNum;				// detect region point number
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect region
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
	unsigned int    	nOccurrenceCount;          		// event trigger accumilated times
  	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelli comm info
	short				nPreserID;						// Event triggered preset period, starting from 1 (no unknown)
	char				szPresetName[64];				// Preset name for event triggered
	NET_EXTENSION_INFO  stuExtensionInfo;				// Extension info
	BYTE				bReserved[290];			  		// Reserved	
} DEV_EVENT_LEFT_INFO;

// the describe of EVENT_IVS_PRESERVATION's data
typedef struct tagDEV_EVENT_PRESERVATION_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	int                 nDetectRegionNum;				// detect region point number
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect region
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
	unsigned int    	nOccurrenceCount;          		// event trigger accumilated times 
  	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // pintelli comm info
	BYTE				bReserved[488];			  		// Reserved
	
} DEV_EVENT_PRESERVATION_INFO;

// the describe of EVENT_IVS_STAYDETECTION's data
typedef struct tagDEV_EVENT_STAY_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	int                 nDetectRegionNum;				// detect region point number
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect region
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
	unsigned int    	nOccurrenceCount;          		// event trigger accumilated times 
  	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelli comm info
    int                 nObjectNum;                     // the count of objects
    DH_MSG_OBJECT       stuObjectIDs[DH_MAX_OBJECT_NUM];// have being detected objects
	UINT				nAreaID;						// Area ID(a preset point can correspond to multiple area IDs)
    BOOL                bIsCompliant;                   // Is compliant? TRUE:yes, FALSE:no
	BYTE                bReserved[1016];                // reserved
} DEV_EVENT_STAY_INFO;

// the describe of EVENT_IVS_WANDERDETECTION's data
typedef struct tagDEV_EVENT_WANDER_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];                  // 
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	int                 nObjectNum;                     // detected objects number
	DH_MSG_OBJECT		stuObjectIDs[DH_MAX_OBJECT_LIST];	// detected objects
	int                 nTrackNum;                      // track number
	DH_POLY_POINTS      stuTrackInfo[DH_MAX_OBJECT_LIST];// track info
	int                 nDetectRegionNum;				// detect region point number
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect region
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
	unsigned int    	nOccurrenceCount;          		// event trigger accumilated times 
  	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelli comm info
	short				nPreserID;						// Event triggered preset period, starting from 1 (no unknown)
	char				szPresetName[64];				// Preset name for event triggered
	NET_EXTENSION_INFO  stuExtensionInfo;				// Extension info
	BYTE				bReserved[426];					// reserved
} DEV_EVENT_WANDER_INFO;

// the describe of EVENT_IVS_MOVEDETECTION's data
typedef struct tagDEV_EVENT_MOVE_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	int                 nDetectRegionNum;				// detect region point 
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect region
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
	int                 nTrackLineNum;                  // Object trajectories vertices              
	DH_POINT            stuTrackLine[DH_MAX_TRACK_LINE_NUM]; // Object trajectories			
	unsigned int    	nOccurrenceCount;          		// event trigger accumilated times 
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelli comm info
	NET_EXTENSION_INFO  stuExtensionInfo;				// Extension info
	BYTE				bReserved[272];					// Reserved bytes, leave extended 
} DEV_EVENT_MOVE_INFO;

// the describe of EVENT_IVS_TAILDETECTION's data
typedef struct tagDEV_EVENT_TAIL_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	int                 nDetectRegionNum;				// detect region point 
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    //  detect region
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
	unsigned int    	nOccurrenceCount;          		// event trigger accumilated times 
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelli comm info
	BYTE				bReserved[488];					
	
} DEV_EVENT_TAIL_INFO;

// the describe of EVENT_IVS_RIOTERDETECTION's data
typedef struct tagDEV_EVENT_RIOTER_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	int					nObjectNum;						// have being detected object number
	DH_MSG_OBJECT		stuObjectIDs[DH_MAX_OBJECT_LIST];// have being detected object list
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];                  // 
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	int                 nDetectRegionNum;				// detect region point 
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect region

    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
	unsigned int    	nOccurrenceCount;          		// event trigger accumilated times 
  	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelli comm info
	NET_EXTENSION_INFO	stuExtensionInfo;               // Extension info
	BYTE                bReserved[360];                 // Reserved			
} DEV_EVENT_RIOTERL_INFO;

// the describe of EVENT_IVS_FIGHTDETECTION's data
typedef struct tagDEV_EVENT_FIGHT_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	int					nObjectNum;						// have being detected object number
	DH_MSG_OBJECT		stuObjectIDs[DH_MAX_OBJECT_LIST];// have being detected object list
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];                  // 
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	int                 nDetectRegionNum;				// detect region point 
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect region
	
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
	unsigned int    	nOccurrenceCount;          		// event trigger accumilated times 
  	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelli comm info
	NET_EXTENSION_INFO  stuExtensionInfo;				// Extension info
	BYTE				bReserved[360];					// Reserved
} DEV_EVENT_FIGHT_INFO;

// the describe of EVENT_IVS_FIREDETECTION's data
typedef struct tagDEV_EVENT_FIRE_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];                  // 
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	int                 nDetectRegionNum;				// detect region point
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect region
	
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
	unsigned int    	nOccurrenceCount;          		// event trigger accumilated times 
  	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelli comm info
	BYTE				bReserved[488];					// Reserved
	
} DEV_EVENT_FIRE_INFO;

// Event type EVENT_IVS_GETOUTBEDDETECTION(event of getting out of bed in detention center) data block corresponding description information
typedef struct tagDEV_EVENT_GETOUTBED_INFO 
{
    // Public field
    int                 nChannelID;                         // Channel Id
    char                szName[128];                        // Event name
    char                bReserved1[4];                      // byte alignment
    double              PTS;                                // Timestamp(millisecond)
    NET_TIME_EX         UTC;                                // The event happen time
    int                 nEventID;                           // Event ID
    // Event correspomds to field
    DH_MSG_OBJECT       stuObject;                          // Object said the object information who get off the bed
    int                 nDetectRegionNum;                   // Number of vertex indetection region for rules
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM]; // The detection region for rules
    DH_EVENT_FILE_INFO  stuFileInfo;                        // Event correspomds to file information
    BYTE                bEventAction;                       // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end

    BYTE                byReserved[2];                      // Reserve bytes
    BYTE                byImageIndex;                       // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;                     // flag(by bit),see NET_RESERVED_COMMON    
    BYTE                bReserved[1024];                    // Reserve bytes,left to expand 
} DEV_EVENT_GETOUTBED_INFO;

// Event type EVENT_IVS_PATROLDETECTION(guard detection event) data block corresponding description information
typedef struct tagDEV_EVENT_PATROL_INFO 
{
    // Public field
    int                 nChannelID;                         // Channel Id
    char                szName[128];                        // Event name
    char                bReserved1[4];                      // byte alignment
    double              PTS;                                // Timestamp(millisecond)
    NET_TIME_EX         UTC;                                // the event happen time
    int                 nEventID;                           // Event ID
    // Event correspomds to field
    DH_MSG_OBJECT       stuObject;                          // Object said the information of patrolling object
    int                 nDetectRegionNum;                   // Number of vertex indetection region
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM]; // The detection region for rules
    DH_EVENT_FILE_INFO  stuFileInfo;                        // Event correspomds to file information
    BYTE                bEventAction;                       // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end    
    BYTE                byReserved[2];                      // Reserve bytes
    BYTE                byImageIndex;                       // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;                     // flag(by bit),see NET_RESERVED_COMMON    
    BYTE                bReserved[1024];                    // Reserve bytes,left to expand
} DEV_EVENT_PATROL_INFO;

// Event type EVENT_IVS_ONDUTYDETECTION(guard detection event) data block corresponding description information
typedef struct tagDEV_EVENT_ONDUTY_INFO
{
    // Public field
    int                 nChannelID;                         // Channel Id
    char                szName[128];                        // Event name
    char                bReserved1[4];                      // byte alignment
    double              PTS;                                // Timestamp(millisecond)
    NET_TIME_EX         UTC;                                // the event happen time
    int                 nEventID;                           // Event ID
    // Field corresponding to the event
    DH_MSG_OBJECT       stuObject;                          // Object said the information of patrolling object
    int                 nDetectRegionNum;                   // Number of vertex indetection region for rules
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM]; // The detection region for rules
    DH_EVENT_FILE_INFO  stuFileInfo;                        // Event correspomds to file information
    BYTE                bEventAction;                       // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end
    
    BYTE                byReserved[2];                      // Reserve bytes,left to expand
    BYTE                byImageIndex;                       // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0    DWORD               dwSnapFlagMask;                     // flag(by bit),see NET_RESERVED_COMMON    
    DWORD               dwSnapFlagMask;                     // snap flag mask(by bit), see NET_RESERVED_COMMON    
    BYTE                bReserved[1024];                    // Reserve bytes,left to expand
} DEV_EVENT_ONDUTY_INFO;

// the describe of EVENT_IVS_FIREDETECTION's data
typedef struct tagDEV_EVENT_ELECTROSPARK_INFO 
{
	int					nChannelID;						// Channel Id
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end
    BYTE                byReserved[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	BYTE				bReserved[972];					// reserved
	
} DEV_EVENT_ELECTROSPARK_INFO;

// the describe of EVENT_IVS_SMOKEDETECTION's data
typedef struct tagDEV_EVENT_SMOKE_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	unsigned int    	nOccurrenceCount;				// event trigger accumilated times 
  	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelli comm info
	PTZ_SPACE_UNIT		stuPtzPosition;					// ptz coordinate and zoom
	BYTE				bReserved[792];					
	
} DEV_EVENT_SMOKE_INFO;

// the describe of EVENT_IVS_FLOWSTAT's data
typedef struct tagDEV_EVENT_FLOWSTAT_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	int					nNumberLeft;					// the number of person across from left
	int					nNumberRight;					// the number of person across from right
	int					nUpperLimit;					// upper limit
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	unsigned int    	nOccurrenceCount;          		// event trigger accumilated times 
	BYTE				bReserved[972];					

} DEV_EVENT_FLOWSTAT_INFO;

// the describe of EVENT_IVS_NUMBERSTAT's data
typedef struct tagDEV_EVENT_NUMBERSTAT_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved2[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	int					nNumber;						// the number of object which is in the area
	int					nUpperLimit;					// upper limit
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                bReserved1[2];                  // 
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	int                 nEnteredNumber;                 // entered object number
	int                 nExitedNumber;                  // exited object number
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	unsigned int    	nOccurrenceCount;          		// event trigger accumilated times 
  	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelli comm info
	UINT				nAreaID;						// Area ID, a preset point can correspond to multiple area IDs
    BOOL                bIsCompliant;                   // Is compliant? TRUE:yes, FALSE:no
	BYTE                bReserved[820];                 // Reserved.
} DEV_EVENT_NUMBERSTAT_INFO;

// the describe of EVENT_IVS_CROSSFENCEDETECTION's data
typedef struct tagDEV_EVENT_CROSSFENCEDETECTION_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	int					nUpstairsLinePointNumber;		               // Upstairs Line Point Number
	DH_POINT		    stuUpstairsLine[DH_MAX_DETECT_LINE_NUM];	   // Upstairs Line info
	int					nDownstairsLinePointNumber;		               // Downstairs Line Point Number
	DH_POINT		    stuDownstairsLine[DH_MAX_DETECT_LINE_NUM];     // Downstairs Line info
	int                 nTrackLineNum;                                 // track line point number                
	DH_POINT            TrackLine[DH_MAX_TRACK_LINE_NUM];              // track line info
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
	BYTE                bDirection;                     // direction, 0-left to right, 1-right to left
    BYTE                byReserved[1];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
	unsigned int    	nOccurrenceCount;              	// event trigger accumilated times 
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelli comm info
	BYTE				bReserved[616];					// Reserved
} DEV_EVENT_CROSSFENCEDETECTION_INFO;

// the describe of EVENT_IVS_INREGIONDETECTION's data
typedef struct tagDEV_EVENT_INREGIONDETECTION_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	int                 nObjectNum;                     // have being detected objects number
	DH_MSG_OBJECT		stuObjectIDs[DH_MAX_OBJECT_LIST];	// have being detected objects
	int                 nTrackNum;                      // track line number
	DH_POLY_POINTS      stuTrackInfo[DH_MAX_OBJECT_LIST];// track lines info
	int                 nDetectRegionNum;				// detect regions number
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect regions
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	BYTE				bReserved[1016];				// Reserved
	
} DEV_EVENT_INREGIONDETECTION_INFO;

// the describe of EVENT_IVS_TAKENAWAYDETECTION's data
typedef struct tagDEV_EVENT_TAKENAWAYDETECTION_INFO
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	int                 nDetectRegionNum;				// detect region's point number
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect region info
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
	unsigned int    	nOccurrenceCount;               // event trigger accumilated times 
  	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelli comm info
	short				nPreserID;						// Event triggered preset period, starting from 1 (no unknown)
	char				szPresetName[64];				// Preset name for event triggered
	NET_EXTENSION_INFO  stuExtensionInfo;				// Extension info
	BYTE				bReserved[418];				  	// Reserved
} DEV_EVENT_TAKENAWAYDETECTION_INFO;

// the describe of EVENT_IVS_VIDEOABNORMALDETECTION's data
typedef struct tagDEV_EVENT_VIDEOABNORMALDETECTION_INFO
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
	BYTE                bType;                          // type, 0-video lost, 1-video freeze, 2-video blind, 3-camera moving, 4-too dark, 5-too light, 6-image unbalance, 7-Noise
    BYTE                byReserved[1];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
	unsigned int    	nOccurrenceCount;               // event trigger accumilated times 
  	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelli comm info
	BYTE				bReserved[620];					// Reserved
} DEV_EVENT_VIDEOABNORMALDETECTION_INFO;

// the describe of EVENT_IVS_PARKINGDETECTION's data
typedef struct tagDEV_EVENT_PARKINGDETECTION_INFO
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	int                 nDetectRegionNum;				// detect region's point number
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect region info
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
	unsigned int    	nOccurrenceCount;               // event trigger accumilated times 
  	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;   	// intelli comm info
	NET_EXTENSION_INFO  stuExtensionInfo;				// Extension info
	BYTE				bReserved[484];				  	// Reserved 
} DEV_EVENT_PARKINGDETECTION_INFO;

// Event level
typedef enum tagEM_EVENT_LEVEL
{
	EM_EVENT_LEVEL_HINT = 0,										// Hint
	EM_EVENT_LEVEL_GENERAL,											// General
	EM_EVENT_LEVEL_WARNING											// Warning
}EM_EVENT_LEVEL;


#define HDBJ_MAX_OBJECTS_NUM 200            // The maximum number of detected object 

// the describe of EVENT_IVS_SHOPPRESENCE's data
typedef struct tagDEV_EVENT_SHOPPRESENCE_INFO
{
	int                 nChannelID;                                 // ChannelId
	char                szName[128];                                // Event name
	char                bReserved1[4];                              // byte alignment
	double              PTS;                                        // PTS(ms)
	NET_TIME_EX         UTC;                                        // the event happen time
	int                 nEventID;                                   // event ID
	DH_MSG_OBJECT       stuObject;                                  // have being detected object, recommend to used another character 'stuObjects' to get object info
	int                 nDetectRegionNum;                           // detect region's point number
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];     // detect region info
	DH_EVENT_FILE_INFO  stuFileInfo;                                // event file info
	BYTE                bEventAction;                               // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
	BYTE                byReserved[2];
	BYTE                byImageIndex;                               // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	DWORD               dwSnapFlagMask;                             // flag(by bit),see NET_RESERVED_COMMON  
	int                 nSourceIndex;                               // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];                   // the source device's sign(exclusive),field said local device does not exist or is empty
	unsigned int        nOccurrenceCount;                           // event trigger accumilated times 
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // intelli comm info
	char				szPresetName[DH_COMMON_STRING_64];			// PresetPoint name
	EM_EVENT_LEVEL		emEventLevel;								// Event level
	char				szShopAddress[DH_COMMON_STRING_256];		// Shop address
    UINT                nViolationDuration;                         // Duration of violation of law,unit:second,default value 0 is meaningless
    int					nObjectNum;									// The number of detected object
    DH_MSG_OBJECT		stuObjects[HDBJ_MAX_OBJECTS_NUM];			// Detected object
    char				szSourceID[32];						        // Correlate event ID, evnets arising from same object or picture could have same correlate event ID
    BYTE                byReserved2[2048];							// Reserved
} DEV_EVENT_SHOPPRESENCE_INFO;

// the describe of EVENT_IVS_WASTEDUMPED's data
typedef struct tagDEV_EVENT_WASTEDUMPED_INFO
{
	int                 nChannelID;                                 // ChannelId
	char                szName[128];                                // Event name
	char                bReserved1[4];                              // byte alignment
	double              PTS;                                        // PTS(ms)
	NET_TIME_EX         UTC;                                        // the event happen time
	int                 nEventID;                                   // event ID
	DH_MSG_OBJECT       stuObject;                                  // have being detected object
	int                 nDetectRegionNum;                           // detect region's point number
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];     // detect region info
	DH_EVENT_FILE_INFO  stuFileInfo;                                // event file info
	BYTE                bEventAction;                               // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
	BYTE                byReserved[2];
	BYTE                byImageIndex;                               // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	DWORD               dwSnapFlagMask;                             // flag(by bit),see NET_RESERVED_COMMON  
	int                 nSourceIndex;                               // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];                   // the source device's sign(exclusive),field said local device does not exist or is empty
	unsigned int        nOccurrenceCount;                           // event trigger accumilated times 
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // intelli comm info
	char				szPresetName[DH_COMMON_STRING_64];			// PresetPoint name
	EM_EVENT_LEVEL		emEventLevel;								// Event level
	BYTE                byReserved2[512];							// Reserved
} DEV_EVENT_WASTEDUMPED_INFO;

// the describe of EVENT_IVS_ABNORMALRUNDETECTION's data
typedef struct tagDEV_EVENT_ABNORMALRUNDETECTION 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	double              dbSpeed;                        // speed ,km/h
	double              dbTriggerSpeed;                 // triggerSpeed,km/h
	int                 nDetectRegionNum;				// detect region's point number
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect region info
	int                 nTrackLineNum;                         // track line point number              
	DH_POINT            TrackLine[DH_MAX_TRACK_LINE_NUM];      // track line info
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
	BYTE                bRunType;                       // type, 0-run fast, 1-sudden speedup, 2-sudden speed-down
    BYTE                byReserved[1];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
	unsigned int    	nOccurrenceCount;              	// event trigger accumilated times 
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelligent things info
    BYTE                bReserved[616];                 // Reserved bytes.
	
} DEV_EVENT_ABNORMALRUNDETECTION_INFO;

// the describe of EVENT_IVS_RETROGRADEDETECTION's data
typedef struct tagDEV_EVENT_RETROGRADEDETECTION_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	int                 nTrackLineNum;                           // track line point number                   
	DH_POINT            TrackLine[DH_MAX_TRACK_LINE_NUM];        // track line info
	int                 nDirectionPointNum;                      // direction point number
	DH_POINT            stuDirections[DH_MAX_DETECT_LINE_NUM];   // direction info
	int                 nDetectRegionNum;				         // detect region's point number
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];  // detect region info
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
	unsigned int    	nOccurrenceCount;              	// event trigger accumilated times 
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelli comm info
	BYTE				bReserved[616];				  	// Reserved 
} DEV_EVENT_RETROGRADEDETECTION_INFO;

//sex type of dectected human face
typedef enum tagEM_DEV_EVENT_FACEDETECT_SEX_TYPE
{
    EM_DEV_EVENT_FACEDETECT_SEX_TYPE_UNKNOWN,                   // unknown
    EM_DEV_EVENT_FACEDETECT_SEX_TYPE_MAN,                       // male
    EM_DEV_EVENT_FACEDETECT_SEX_TYPE_WOMAN,                     // female
}EM_DEV_EVENT_FACEDETECT_SEX_TYPE;


//nation
typedef enum tagEM_NATION_TYPE
{
	EM_NATION_TYPE_UNKNOWN,                                             // unknown
	EM_NATION_TYPE_UYGUR,                                               // uygur
	EM_NATION_TYPE_OTHER,                                               // other
	EM_NATION_TYPE_UNIDENTIFIED,                                        // device unidentified
}EM_NATION_TYPE;

// euler angle
typedef struct tagNET_EULER_ANGLE
{
	int		nPitch;				// pitch
	int		nYaw;				// yaw
	int		nRoll;				// roll
} NET_EULER_ANGLE;

// the data of face
typedef struct tagNET_FACE_DATA
{
	EM_DEV_EVENT_FACEDETECT_SEX_TYPE 		emSex;						// sex type
	int        								nAge;						// age, invalid if it is -1
    unsigned int        					nFeatureValidNum;           // invalid number in array emFeature
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE    emFeature[DH_MAX_FACEDETECT_FEATURE_NUM];   // human face features
	EM_RACE_TYPE							emRace;						// race
	EM_EYE_STATE_TYPE						emEye;						// eyes state
	EM_MOUTH_STATE_TYPE						emMouth;					// mouth state
	EM_MASK_STATE_TYPE 						emMask;						// mask state
	EM_BEARD_STATE_TYPE						emBeard;					// beard state
	int										nAttractive;				// Attractive value, -1: invalid, 0:no disringuishrange: 1-100, the higher value, the higher charm
    EM_NATION_TYPE                          emNation;                   // nation
    NET_EULER_ANGLE							stuFaceCaptureAngle;		// euler angle of face in the capture picture, nPitch:pitch of the head, nYaw: yaw of the head, nRoll:roll of the head
    																	// range of the angle value is [-90,90], stuFaceCaptureAngle is invalid if the three angles are 999.
	UINT									nFaceQuality;				// quality about capture picture
    int                                     nFaceAlignScore;            // The score of face picture align.The range is 0~10000,-1 is invalid
    int                                     nFaceClarity;               // The score of face picture clarity.The range is 0~10000,-1 is invalid
	BYTE                					bReserved[100];             // Reserved 
} NET_FACE_DATA;

// Feature data Information
typedef struct tagNET_FEATURE_VECTOR
{
	DWORD				dwOffset;							// Face feature data offset in data block(Unit:BYTE)
	DWORD				dwLength;							// Face feature data length(Unit:BYTE)
	BYTE				byReserved[120];					// Reserved
}NET_FEATURE_VECTOR;

// the status of person in camera picture
typedef enum tagEM_FACE_DETECT_STATUS
{
    EM_FACE_DETECT_UNKNOWN,             // unknown
    EM_FACE_DETECT_APPEAR,              // appear
    EM_FACE_DETECT_INPICTURE,           // in picture
    EM_FACE_DETECT_EXIT,                // exit
} EM_FACE_DETECT_STATUS;

// passerby info
typedef struct tagNET_PASSERBY_INFO
{
	char				szPasserbyUID[MAX_COMMON_STRING_32];			// The unique identifier of the passerby to write to the database
	char                szPasserbyGroupId[MAX_COMMON_STRING_64];		// Passerby group ID
	char				szPasserbyGroupName[MAX_COMMON_STRING_128];		// Passerby group name
	BYTE				byReserved[128];									// Reserved
} NET_PASSERBY_INFO;

// the describe of EVENT_IVS_FACERECOGNITION's data
typedef struct tagDEV_EVENT_FACERECOGNITION_INFO
{
	int					nChannelID;						// ChannelId
	char				szName[128];						// event name
    int                 nEventID;                       // event ID
	NET_TIME_EX			UTC;							// the event happen time
	DH_MSG_OBJECT		stuObject;						// have being detected object
	int                 nCandidateNum;                  // candidate number
    CANDIDATE_INFO      stuCandidates[DH_MAX_CANDIDATE_NUM]; // candidate info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	BYTE				byReserved1[2];				    // reserved
	BOOL                bGlobalScenePic;                // The existence panorama
	DH_PIC_INFO         stuGlobalScenePicInfo;          // Panoramic Photos
    char                szSnapDevAddress[MAX_PATH];     // Snapshot current face aadevice address  
    unsigned int        nOccurrenceCount;               // event trigger accumilated times 
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelligent things info
    NET_FACE_DATA		stuFaceData;					// the data of face
	char				szUID[DH_COMMON_STRING_32];		// The unique identifier of the snap person to write to the database
	NET_FEATURE_VECTOR	stuFeatureVector;				// Feature data information
	char				szFeatureVersion[32];			// The version of the feature data algorithm
	EM_FACE_DETECT_STATUS emFaceDetectStatus;           // The status of person in camera picture
    char				szSourceID[32];					// Correlate event ID, events arising from same object or picture could have same correlate event ID
    NET_PASSERBY_INFO	stuPasserbyInfo;				// passerby info
	unsigned int		nStayTime;						// stay time Unit:s

	NET_GPS_INFO        stuGPSInfo;                     // GPS info
	BYTE                bReserved[432];                 // Reserved
    int					nRetCandidatesExNum;			// the actual return number of stuCandidatesEx
	CANDIDATE_INFOEX    stuCandidatesEx[DH_MAX_CANDIDATE_NUM];     	// the expansion of candidate information
	char				szSerialUUID[22];							// szSerial UUID
																	// The format is as followsFront 2:%d%d:01-video,02-picture,03-file,99-other;
																	// Middle 14:YYYYMMDDhhmmss:year,month,day,hour,minute,second;Last 5:%u%u%u%u%uobject IDas 00001
	BYTE				byReserved[2];				    // reserved
}DEV_EVENT_FACERECOGNITION_INFO;

// Event type EVENT_IVS_DENSITYDETECTION(Population amount detect) corresponding data block description info
typedef struct tagDEV_EVENT_DENSITYDETECTTION_INFO
{
	int					nChannelID;						// Channel No.
	char				szName[128];					// Event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// Time stamp(ms)
	NET_TIME_EX			UTC;							// Event occurred time
	int					nEventID;						// Event ID
	int					nObjectNum;						// Detected object amount
	DH_MSG_OBJECT		stuObjectIDs[DH_MAX_OBJECT_LIST];	// Detected object list
	DH_EVENT_FILE_INFO  stuFileInfo;                    // The corresponding file info of the event
	BYTE                bEventAction;                   // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
	BYTE                byReserved[2];                  // Reserved field
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	int                 nDetectRegionNum;				// Acme amount of the rule detect zone
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // Rule detect zone
	
    DWORD               dwSnapFlagMask;	                // Snap flag(by bit).please refer to NET_RESERVED_COMMON
	int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
    unsigned int        nOccurrenceCount;               // event trigger accumilated times 
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;		// intelligent things info
	int					nUnit;							// Numerical density check test unit(0-Level,1-Percent)
	int					nValue;							// Density value, the unit is Level, the value of 0~3,respectively(very thin, poor, dense, very dense)units for Percent, 1~100
	BYTE                bReserved[612];                 // Reserved bytes.
	
}DEV_EVENT_DENSITYDETECTION_INFO;

// Event type  EVENT_IVS_QUEUEDETECTION(queue detection)corresponding data block description info
typedef struct tagDEV_EVENT_QUEUEDETECTION_INFO 
{
	int					nChannelID;						// channel ID
	char				szName[128];					// event name
	char                bReserved2[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
	BYTE				bReserved1[2];				    // reserved
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	DH_POINT            stuDetectLine[2];               // detect line
    unsigned int        nOccurrenceCount;               // event trigger accumilated times 
    BYTE                bReserved[1012];                // reserved
}DEV_EVENT_QUEUEDETECTION_INFO;

// Event type EVENT_IVS_TRAFFICCONTROL(traffic control)corresponding data block description info
typedef struct tagDEV_EVENT_TRAFFICCONTROL_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
	BYTE                byReserved[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
    NET_GPS_INFO        stuGPSInfo;                     // GPS info ,use in mobile DVR/NVR
	BYTE				bReserved[932];					// Reserved field. For extension use. 

} DEV_EVENT_TRAFFICCONTROL_INFO;

// the describe of EVENT_IVS_TRAFFICACCIDENT's data
typedef struct tagDEV_EVENT_TRAFFICACCIDENT_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	int					nObjectNum;						// have being detected object number
	DH_MSG_OBJECT		stuObjectIDs[DH_MAX_OBJECT_LIST];// have being detected object list
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
	BYTE                byReserved[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
    EVENT_TRAFFIC_CAR_PART_INFO   stuTrafficCarPartInfo;// part of traffic car info
    UINT                nLane;                          // Lane num
    BYTE                bReserved[460];                 // reserved

} DEV_EVENT_TRAFFICACCIDENT_INFO;

#define DH_EVENT_MAX_CARD_NUM       16    // Incident reporting information includes the maximum number of cards
#define DH_EVENT_CARD_LEN           36    // Card Name Length
 
// Incidents reported to carry the card information
typedef struct tagEVENT_CARD_INFO
{
    char szCardNumber[DH_EVENT_CARD_LEN];     // Card number string
    BYTE bReserved[32];	                      // Reserved bytes, leave extended
}EVENT_CARD_INFO;

typedef enum tagEM_OPEN_STROBE_STATE
{
    NET_OPEN_STROBE_STATE_UNKOWN,                   // unknown
    NET_OPEN_STROBE_STATE_CLOSE,                    // close
    NET_OPEN_STROBE_STATE_AUTO,                     // auto open   
    NET_OPEN_STROBE_STATE_MANUAL,                   // manual open
}EM_OPEN_STROBE_STATE;

typedef enum tagEM_VEHICLE_DIRECTION
{
    NET_VEHICLE_DIRECTION_UNKOWN,                   // unknown 
    NET_VEHICLE_DIRECTION_HEAD,                     // head    
    NET_VEHICLE_DIRECTION_TAIL,                     // rear  
}EM_VEHICLE_DIRECTION;

//NTP status 
typedef enum tagEM_NTP_STATUS
{
    NET_NTP_STATUS_UNKNOWN = 0 ,
    NET_NTP_STATUS_DISABLE     , 
    NET_NTP_STATUS_SUCCESSFUL  , 
    NET_NTP_STATUS_FAILED      , 
}EM_NTP_STATUS;

#define COMMON_SEAT_MAX_NUMBER        8             // Max seat number

typedef enum tagEM_COMMON_SEAT_TYPE
{
    COMMON_SEAT_TYPE_UNKNOWN    = 0,                // unknown
    COMMON_SEAT_TYPE_MAIN       = 1,                // main seat
    COMMON_SEAT_TYPE_SLAVE      = 2,                // slave seat
}EM_COMMON_SEAT_TYPE;

// illegal state type of driver
typedef struct tagEVENT_COMM_STATUS                 
{
    BYTE bySmoking;                                 // smoking
    BYTE byCalling;                                 // calling
    char szReserved[14];                            // reversed
}EVENT_COMM_STATUS;

typedef enum tagNET_SAFEBELT_STATE
{
    SS_NUKNOW   = 0 ,				// Unknow
	SS_WITH_SAFE_BELT ,				// WithSafeBelt   
	SS_WITHOUT_SAFE_BELT ,			// WithoutSafeBelt 
}NET_SAFEBELT_STATE;

//sun shade state
typedef enum tagNET_SUNSHADE_STATE
{
    SS_NUKNOW_SUN_SHADE	= 0 ,		// Unknow
	SS_WITH_SUN_SHADE ,				// WithSunShade  
	SS_WITHOUT_SUN_SHADE ,			// WithoutSunShade
}NET_SUNSHADE_STATE;

// driver's illegal info
typedef struct tagEVENT_COMM_SEAT
{
    BOOL                    bEnable;                // whether seat info detected
    EM_COMMON_SEAT_TYPE     emSeatType;             // seat type
    EVENT_COMM_STATUS       stStatus;               // illegal state
	NET_SAFEBELT_STATE      emSafeBeltStatus;       // safe belt state
    NET_SUNSHADE_STATE      emSunShadeStatus;       // sun shade state
    char                    szReserved[24];         // reversed
}EVENT_COMM_SEAT;

typedef enum tagEM_COMM_ATTACHMENT_TYPE      
{       
	COMM_ATTACHMENT_TYPE_UNKNOWN    = 0,            // Unknown type       
	COMM_ATTACHMENT_TYPE_FURNITURE  = 1,            // Furniture       
	COMM_ATTACHMENT_TYPE_PENDANT    = 2,            // Pendant       
	COMM_ATTACHMENT_TYPE_TISSUEBOX  = 3,            // TissueBox       
	COMM_ATTACHMENT_TYPE_DANGER     = 4,            // Danger     
	COMM_ATTACHMENT_TYPE_PERFUMEBOX = 5,			// perfumebox
 }EM_COMM_ATTACHMENT_TYPE; 

// car attachment
typedef struct tagEVENT_COMM_ATTACHMENT
{
    EM_COMM_ATTACHMENT_TYPE     emAttachmentType;       // type
	NET_RECT                    stuRect;                // coordinate
	BYTE						bReserved[20];		    // reserved
}EVENT_COMM_ATTACHMENT;

// traffic event snap picture info
typedef struct tagEVENT_PIC_INFO
{
    DWORD                       nOffset;                // offset
    DWORD                       nLength;                // length of picture
}EVENT_PIC_INFO;

//Vehicle type inToll station
typedef enum tagEM_VEHICLE_TYPE
{
	EM_VEHICLE_TYPE_UNKNOWN,                            // unknown
	EM_VEHICLE_TYPE_PASSENGERCAR1,                      // PassengerCar1
	EM_VEHICLE_TYPE_TRUCK1,                             // Truck1
	EM_VEHICLE_TYPE_PASSENGERCAR2,                      // PassengerCar2 
	EM_VEHICLE_TYPE_TRUCK2,                             // Truck2
	EM_VEHICLE_TYPE_PASSENGERCAR3,                      // PassengerCar3
	EM_VEHICLE_TYPE_TRUCK3,                             // Truck3
	EM_VEHICLE_TYPE_PASSENGERCAR4,                      // PassengerCar4 
	EM_VEHICLE_TYPE_TRUCK4,                             // Truck4
	EM_VEHICLE_TYPE_PASSENGERCAR5,                      // PassengerCar5
	EM_VEHICLE_TYPE_TRUCK5,                             // Truck5
}EM_VEHICLE_TYPE;

//snap category
typedef enum tagEM_SNAPCATEGORY
{
    EM_SNAPCATEGORY_MOTOR,                              // motor
    EM_SNAPCATEGORY_NONMOTOR,                           // nonmotor
}EM_SNAPCATEGORY;

// vehicle type by function
typedef enum tagEM_VEHICLE_TYPE_BY_FUNC
{
    EM_VEHICLE_TYPE_BY_FUNC_UNKNOWN,                // unknown
    /*special vehicle types follow*/
    EM_VEHICLE_TYPE_BY_FUNC_TANK_CAR,               // tank car
    EM_VEHICLE_TYPE_BY_FUNC_SLOT_TANK_CAR,          // slot tank car
    EM_VEHICLE_TYPE_BY_FUNC_DREGS_CAR,              // dregs car
    EM_VEHICLE_TYPE_BY_FUNC_CONCRETE_MIXER_TRUCK,   // concrete mixer truck
    EM_VEHICLE_TYPE_BY_FUNC_TAXI,                   // taxi
    EM_VEHICLE_TYPE_BY_FUNC_POLICE,                 // police car
    EM_VEHICLE_TYPE_BY_FUNC_AMBULANCE,              // ambulance
    EM_VEHICLE_TYPE_BY_FUNC_GENERAL,                // general car
    EM_VEHICLE_TYPE_BY_FUNC_WATERING_CAR,           // watering car
    EM_VEHICLE_TYPE_BY_FUNC_FIRE_ENGINE,            // fire engine
    EM_VEHICLE_TYPE_BY_FUNC_MACHINESHOP_TRUCK,      // machineshop truck
    EM_VEHICLE_TYPE_BY_FUNC_POWER_LOT_VEHICLE,      // power lot vehicle
    EM_VEHICLE_TYPE_BY_FUNC_SUCTION_SEWAGE_TRUCK,   // suction sewage truck
    EM_VEHICLE_TYPE_BY_FUNC_NORMAL_TANK_TRUCK,      // normal tank truck
    EM_VEHICLE_TYPE_BY_FUNC_SCHOOL_BUS,             // school bus
    EM_VEHICLE_TYPE_BY_FUNC_EXCAVATOR,              // exvavator
    EM_VEHICLE_TYPE_BY_FUNC_BULLDOZER,              // bulldozer
    EM_VEHICLE_TYPE_BY_FUNC_CRANE,                  // crane
    EM_VEHICLE_TYPE_BY_FUNC_PUMP_TRUCK,             // pump truck
    /*special vehicle types above*/
} EM_VEHICLE_TYPE_BY_FUNC;

// standard vehicle type
typedef enum tagEM_STANDARD_VEHICLE_TYPE
{
    EM_STANDARD_VEHICLE_UNKNOWN,                    // unkonwon
    EM_STANDARD_VEHICLE_MOTOR,                      // motor
    EM_STANDARD_VEHICLE_BUS,                        // bus
    EM_STANDARD_VEHICLE_UNLICENSED_MOTOR,           // unlicensed motor
    EM_STANDARD_VEHICLE_LARGE_CAR,                  // large car
    EM_STANDARD_VEHICLE_MICRO_CAR,                  // micro car
    EM_STANDARD_VEHICLE_EMBASSY_CAR,                // embassy car
    EM_STANDARD_VEHICLE_MARGINAL_CAR,               // marginal car
    EM_STANDARD_VEHICLE_AREAOUT_CAR,                // areaout car
    EM_STANDARD_VEHICLE_FOREIGN_CAR,                // foreign car
    EM_STANDARD_VEHICLE_FARM_TRANS_CAR,             // farm trans car
    EM_STANDARD_VEHICLE_TRACTOR,                    // tractor
    EM_STANDARD_VEHICLE_TRAILER,                    // trailer
    EM_STANDARD_VEHICLE_COACH_CAR,                  // coach car
    EM_STANDARD_VEHICLE_TRIAL_CAR,                  // trial car
    EM_STANDARD_VEHICLE_TEMPORARYENTRY_CAR,         // temporary entry car
    EM_STANDARD_VEHICLE_TEMPORARYENTRY_MOTORCYCLE,  // temporary entry motorcycle
    EM_STANDARD_VEHICLE_TEMPORARY_STEER_CAR,        // temporary steer car
    EM_STANDARD_VEHICLE_LARGE_TRUCK,                // large truck
    EM_STANDARD_VEHICLE_MID_TRUCK,                  // mid truck
    EM_STANDARD_VEHICLE_MICRO_TRUCK,                // micro truck
    EM_STANDARD_VEHICLE_MICROBUS,                   // microbus
    EM_STANDARD_VEHICLE_SALOON_CAR,                 // saloon car
    EM_STANDARD_VEHICLE_CARRIAGE,                   // carriage
    EM_STANDARD_VEHICLE_MINI_CARRIAGE,              // mini carriage
    EM_STANDARD_VEHICLE_SUV_MPV,                    // SUV or MPV
    EM_STANDARD_VEHICLE_SUV,                        // SUV
    EM_STANDARD_VEHICLE_MPV,                        // MPV
    EM_STANDARD_VEHICLE_PASSENGER_CAR,              // passenger car
    EM_STANDARD_VEHICLE_MOTOR_BUS,                  // motor bus
    EM_STANDARD_VEHICLE_MID_PASSENGER_CAR,          // mid passenger car
    EM_STANDARD_VEHICLE_MINI_BUS,                   // mini bus
    EM_STANDARD_VEHICLE_PICKUP,                     // pickup
    EM_STANDARD_VEHICLE_OILTANK_TRUCK,              // oiltank truck
} EM_STANDARD_VEHICLE_TYPE;

// subcategories of oversea vehicle types
typedef enum tagEM_OVERSEA_VEHICLE_CATEGORY_TYPE
{
    EM_OVERSEA_VEHICLE_CATEGORY_UNKNOWN,                     // unknown
    EM_OVERSEA_VEHICLE_CATEGORY_MOTORCYCLE,                  // motorcycle
    EM_OVERSEA_VEHICLE_CATEGORY_LIGHT_GOODS_VEHICLE,         // light goods vehicle 
    EM_OVERSEA_VEHICLE_CATEGORY_COMPANY_VEHICLE,             // company vehicle 
    EM_OVERSEA_VEHICLE_CATEGORY_PRIVATE_VEHICLE,             // private vehicle 
    EM_OVERSEA_VEHICLE_CATEGORY_TAXI,                        // taxi
    EM_OVERSEA_VEHICLE_CATEGORY_TRAILER,                     // trailer
    EM_OVERSEA_VEHICLE_CATEGORY_ENGINEERING_PLANT_VEHICLE,   // engineering plant vehicle
    EM_OVERSEA_VEHICLE_CATEGORY_VERY_HEAVY_GOODS_VEHICLE,    // very heavy goods vehicle
    EM_OVERSEA_VEHICLE_CATEGORY_HEAVY_GOODS_VEHICLE,         // heavy goods vehicle
    EM_OVERSEA_VEHICLE_CATEGORY_PUBLIC_BUS,                  // public bus   
    EM_OVERSEA_VEHICLE_CATEGORY_PRIVATE_BUS,                 // private bus  
    EM_OVERSEA_VEHICLE_CATEGORY_SPECIAL_VEHICLE,             // special vehicle
}EM_OVERSEA_VEHICLE_CATEGORY_TYPE;

typedef struct tagEVENT_COMM_INFO
{
    EM_NTP_STATUS               emNTPStatus;                                        //NTP time sync status 
    int                         nDriversNum;                                        //driver info number
    DH_MSG_OBJECT_EX*           pstDriversInfo;                                     //driver info data 
    char*                       pszFilePath;                                        //writing path for local disk or sd card, or write to default path if NULL
    char*                       pszFTPPath;                                         //ftp path
    char*                       pszVideoPath;                                       //ftp path for assocated video
    EVENT_COMM_SEAT             stCommSeat[COMMON_SEAT_MAX_NUMBER];                 //Seat info
    int                         nAttachmentNum;                                     // Car Attachment number
    EVENT_COMM_ATTACHMENT       stuAttachment[NET_MAX_ATTACHMENT_NUM];              // Car Attachment 
    int                         nAnnualInspectionNum;                               // Annual Inspection number
    NET_RECT                    stuAnnualInspection[NET_MAX_ANNUUALINSPECTION_NUM]; // Annual Inspection
    float                       fHCRatio;                                           // The ratio of HC,unit,%/1000000
    float                       fNORatio;                                           // The ratio of NO,unit,%/1000000
    float                       fCOPercent;                                         // The percent of CO,unit,% ,range from 0 to 100
    float                       fCO2Percent;                                        // The percent of CO2,unit: % ,range from 0 to 100     
    float                       fLightObscuration;                                  // The obscuration of light,unit,% ,range from 0 to 100
    int                         nPictureNum;                                        // Original pictures info number
    EVENT_PIC_INFO              stuPicInfos[NET_MAX_EVENT_PIC_NUM];                 // Original pictures info data
    float                       fTemperature;                                       // Temperature,unit: centigrade
    int                         nHumidity;                                          // Humidity,unit: %  
    float                       fPressure;                                          // Pressure,unit: Kpa
    float                       fWindForce;                                         // Wind force,unit: m/s
    UINT                        nWindDirection;                                     // Wind direction,unit: degree,range:[0,360]
    float                       fRoadGradient;                                      // Road gradient,unit: degree
    float                       fAcceleration;                                      // Acceleration,unit: m/s2   
    NET_RFIDELETAG_INFO         stuRFIDEleTagInfo;                                  // RFID electronics tag info
    EVENT_PIC_INFO              stuBinarizedPlateInfo;                              // Binarized plate matting
    EVENT_PIC_INFO              stuVehicleBodyInfo;                                 // Vehicle body close-up matting
    EM_VEHICLE_TYPE             emVehicleTypeInTollStation;                         // Vehicle type inToll station
    EM_SNAPCATEGORY             emSnapCategory;                                     // Snap Category
    int                         nRegionCode;                                        // Location code of license plate,(Bangladesh Project),default -1 indicates unrecognized
    EM_VEHICLE_TYPE_BY_FUNC     emVehicleTypeByFunc;                                // Vehicle type by function
    EM_STANDARD_VEHICLE_TYPE    emStandardVehicleType;                              // Standard vehicle type
	UINT                        nExtraPlateCount;                                   // Count of extra plates
    char                        szExtraPlateNumber[3][32];                          // Extra plate number
    EM_OVERSEA_VEHICLE_CATEGORY_TYPE emOverseaVehicleCategory;                      // oversea vehicle category
	char						szProvince[64];										// Province
    BYTE                        bReserved[500];                                     // reserved 
    char                        szCountry[20];                                      // Country
}EVENT_COMM_INFO;

//custom weight info
typedef struct tagEVENT_CUSTOM_WEIGHT_INFO
{
	DWORD        dwRoughWeight;                    // Rough Weight,unit:KG
    DWORD        dwTareWeight;                     // Tare Weight,unit:KG
    DWORD        dwNetWeight;                      // Net Weight,unit:KG
	BYTE		 bReserved[28];					   // reserved 
}EVENT_CUSTOM_WEIGHT_INFO;

// Radar free stream information
typedef struct tagNET_RADAR_FREE_STREAM
{
	TP_U64						nABSTime;	// millisecond from 0001-01-01 00:00:00
	int							nVehicleID; // Vehicle ID
	UINT						unOBUMAC;	// MAC of on board unit
	BYTE						byReserved[16];	// reserved
}NET_RADAR_FREE_STREAM;
//custom info in 
typedef struct tagEVENT_JUNCTION_CUSTOM_INFO
{
	EVENT_CUSTOM_WEIGHT_INFO    stuWeightInfo;      // custom weight info
	DWORD                       nCbirFeatureOffset;                //Content Based Image Retrieval Feature offset,Unit:Byte
	DWORD                       nCbirFeatureLength;                //Content Based Image Retrieval Feature length,Unit:Byte
	DWORD						dwVehicleHeadDirection;	// Head direction 0:Unknown 1:left 2:center 3:right
	BYTE						byReserved1[4];				// Align
	NET_RADAR_FREE_STREAM		stuRadarFreeStream;			// Radar free stream info
	BYTE						bReserved[12];				// Reserved
}EVENT_JUNCTION_CUSTOM_INFO;

// vehicle seat info
typedef struct tagNET_SEAT_INFO
{
    NET_RECT stuFaceRect;   // face rect info(8192 coordinate system)
    BYTE   bySunShade;      // sun shade state,0: unknown 1:with sun shade 2:no sun shade    
    BYTE   byDriverCalling; // calling state 0:unknown 1:no calling 2:calling
    BYTE   byDriverSmoking; // smoking state 0:unknown 1:no smoking 2:smoking
    BYTE   bySafeBelt;      // safe belt state 0:unknown 1:no safe belt 2:with safe belt
    BYTE   byReserved[32];  // reserved
}NET_SEAT_INFO;

// vehicle attach object
typedef struct tagNET_VEHICLE_ATTACH
{
    int         nType;              // attach type	0-unknown 1-Inspect 2-Pendant 3-Paperbox 4-Perfumebox
    NET_RECT    stuBoundingBox;     // bounding box(8192 coordinate system)

    BYTE        byReserved[32];
}NET_VEHICLE_ATTACH;

// Scene image
typedef struct tagSCENE_IMAGE_INFO
{
	UINT	   nOffSet;					// image offset in the data  
	UINT	   nLength;					// image data length
	UINT	   nWidth;					// image width(pixel)
	UINT	   nHeight;					// image Height(pixel)
	BYTE	   byReserved[56];			// Reserved
}SCENE_IMAGE_INFO;

// face scene image
typedef struct tagFACE_SCENE_IMAGE
{
	unsigned int	   nOffSet;					// image offset in the data  
	unsigned int	   nLength;					// image data length
	unsigned int	   nWidth;					// image width(pixel)
	unsigned int	   nHeight;					// image Height(pixel)
	BYTE			   byReserved[56];			// Reserved
} FACE_SCENE_IMAGE;

// Color type
typedef enum tagEM_OBJECT_COLOR_TYPE
{
	EM_OBJECT_COLOR_TYPE_UNKNOWN,									    // unknown
	EM_OBJECT_COLOR_TYPE_WHITE,										    // white
	EM_OBJECT_COLOR_TYPE_ORANGE,									    // orange
	EM_OBJECT_COLOR_TYPE_PINK,										    // pink
	EM_OBJECT_COLOR_TYPE_BLACK,										    // black
	EM_OBJECT_COLOR_TYPE_RED,										    // red
	EM_OBJECT_COLOR_TYPE_YELLOW,									    // yellow
	EM_OBJECT_COLOR_TYPE_GRAY,										    // gray
	EM_OBJECT_COLOR_TYPE_BLUE,										    // blue
	EM_OBJECT_COLOR_TYPE_GREEN,										    // green
	EM_OBJECT_COLOR_TYPE_PURPLE,									    // purple
	EM_OBJECT_COLOR_TYPE_BROWN,										    // brown
	EM_OBJECT_COLOR_TYPE_SLIVER,									    // sliver
	EM_OBJECT_COLOR_TYPE_DARKVIOLET,								    // darkviolet
	EM_OBJECT_COLOR_TYPE_MAROON,									    // maroon
	EM_OBJECT_COLOR_TYPE_DIMGRAY,									    // dimgray
	EM_OBJECT_COLOR_TYPE_WHITESMOKE,								    // whitesmoke
	EM_OBJECT_COLOR_TYPE_DARKORANGE,								    // darkorange
	EM_OBJECT_COLOR_TYPE_MISTYROSE,									    // mistyrose
	EM_OBJECT_COLOR_TYPE_TOMATO,									    // tomato
	EM_OBJECT_COLOR_TYPE_OLIVE,										    // olive
	EM_OBJECT_COLOR_TYPE_GOLD,										    // gold
	EM_OBJECT_COLOR_TYPE_DARKOLIVEGREEN,							    // darkolivegreen
	EM_OBJECT_COLOR_TYPE_CHARTREUSE,								    // chartreuse
	EM_OBJECT_COLOR_TYPE_GREENYELLOW,								    // green-yellow
	EM_OBJECT_COLOR_TYPE_FORESTGREEN,								    // forest-green
	EM_OBJECT_COLOR_TYPE_SEAGREEN,									    // sea-green
	EM_OBJECT_COLOR_TYPE_DEEPSKYBLUE,								    // deepsky-blue
	EM_OBJECT_COLOR_TYPE_CYAN,									        // cyan
	EM_OBJECT_COLOR_TYPE_OTHER,										    // other
}EM_OBJECT_COLOR_TYPE;

// Complexion
typedef enum tagEM_COMPLEXION_TYPE
{
	EM_COMPLEXION_NODISTI,				// Not distinguish
	EM_COMPLEXION_YELLOW,				// Yellow
	EM_COMPLEXION_BLACK,				// Black
	EM_COMPLEXION_WHITE,				// White
} EM_COMPLEXION_TYPE;

// Glasses state
typedef enum tagEM_HAS_GLASS
{
	EM_HAS_GLASS_UNKNOWN,			// unknown
	EM_HAS_GLASS_NO,				// unwear
    EM_HAS_GLASS_NORMAL,			// wear normal glasses
    EM_HAS_GLASS_SUN,				// wear sun glasses
    EM_HAS_GLASS_BLACK,				// wear black glasses
} EM_HAS_GLASS;

// things/objects status
typedef enum tagEM_NONMOTOR_OBJECT_STATUS
{
	EM_NONMOTOR_OBJECT_STATUS_UNKNOWN,								  // unknown
	EM_NONMOTOR_OBJECT_STATUS_NO,									  // no
	EM_NONMOTOR_OBJECT_STATUS_YES,								  	  // yes
}EM_NONMOTOR_OBJECT_STATUS;

// emotion
typedef enum tagEM_EMOTION_TYPE
{
	EM_EMOTION_TYPE_UNKNOWN,                                          // unknown
	EM_EMOTION_TYPE_NORMAL,                                           // normal
	EM_EMOTION_TYPE_SMILE,                                            // smile
	EM_EMOTION_TYPE_ANGER,                                            // anger
	EM_EMOTION_TYPE_SADNESS,                                          // sadness
	EM_EMOTION_TYPE_DISGUST,                                          // disgust
	EM_EMOTION_TYPE_FEAR,                                             // fear
	EM_EMOTION_TYPE_SURPRISE,                                         // surprise
	EM_EMOTION_TYPE_NEUTRAL,                                          // neutral
	EM_EMOTION_TYPE_LAUGH,                                            // laugh
	EM_EMOTION_TYPE_HAPPY,                                            // happy
	EM_EMOTION_TYPE_CONFUSED,                                         // confused
	EM_EMOTION_TYPE_SCREAM,                                           // scream
	EM_EMOTION_TYPE_CALMNESS,                                         // calmness
}EM_EMOTION_TYPE;

typedef enum tagEM_CLOTHES_TYPE
{
	EM_CLOTHES_TYPE_UNKNOWN,                                          //unknown
	EM_CLOTHES_TYPE_LONG_SLEEVE,                                      //long sleeve
	EM_CLOTHES_TYPE_SHORT_SLEEVE,                                     //short sleeve
	EM_CLOTHES_TYPE_TROUSERS,                                         //trousers
	EM_CLOTHES_TYPE_SHORTS,                                           //shorts
	EM_CLOTHES_TYPE_SKIRT,                                            //skirt
	EM_CLOTHES_TYPE_WAISTCOAT,                                        //waistcoat
	EM_CLOTHES_TYPE_MINIPANTS,                                        //mini-pants
	EM_CLOTHES_TYPE_MINISKIRT,                                        //mini-skirt
}EM_CLOTHES_TYPE;

//Non-motor sub type
typedef enum tagEM_CATEGORY_NONMOTOR_TYPE
{
	EM_CATEGORY_NONMOTOR_TYPE_UNKNOWN,									// unknown
	EM_CATEGORY_NONMOTOR_TYPE_TRICYCLE,									// "Tricycle"
	EM_CATEGORY_NONMOTOR_TYPE_MOTORCYCLE,								// "Motorcycle"
	EM_CATEGORY_NONMOTOR_TYPE_NON_MOTOR,								// "Non-Motor" 
	EM_CATEGORY_NONMOTOR_TYPE_BICYCLE,									// "Bicycle"      
	EM_CATEGORY_NONMOTOR_TYPE_DUALTRIWHEELMOTORCYCLE,					// "DualTriWheelMotorcycle"
	EM_CATEGORY_NONMOTOR_TYPE_LIGHTMOTORCYCLE,							// "LightMotorcycle" 
	EM_CATEGORY_NONMOTOR_TYPE_EMBASSYMOTORCYCLE,						// "EmbassyMotorcycle"
	EM_CATEGORY_NONMOTOR_TYPE_MARGINALMOTORCYCLE,						// "MarginalMotorcycle"
	EM_CATEGORY_NONMOTOR_TYPE_AREAOUTMOTORCYCLE,						// "AreaoutMotorcycle"
	EM_CATEGORY_NONMOTOR_TYPE_FOREIGNMOTORCYCLE,						// "ForeignMotorcycle"
	EM_CATEGORY_NONMOTOR_TYPE_TRIALMOTORCYCLE,							// "TrialMotorcycle"
	EM_CATEGORY_NONMOTOR_TYPE_COACHMOTORCYCLE,							// "CoachMotorcycle"
	EM_CATEGORY_NONMOTOR_TYPE_PASSERBY,									// "Passerby" 
    EM_CATEGORY_NONMOTOR_TYPE_VANTRICYCLE,                              // "VanTricycle"
    EM_CATEGORY_NONMOTOR_TYPE_MANNEDCONVERTIBLETRICYCLE,                // "MannedConvertibleTricycle"
    EM_CATEGORY_NONMOTOR_TYPE_NOMANNEDCONVERTIBLETRICYCLE,              // "NoMannedConvertibleTricycle"
}EM_CATEGORY_NONMOTOR_TYPE;

// Non-Motor Image
typedef struct tagNET_NONMOTOR_PIC_INFO
{
	UINT					uOffset;							// Offset
	UINT					uLength;							// Image size, Unit : Byte
	UINT					uWidth;								// Image Width
	UINT					uHeight;							// Image Height
	char					szFilePath[MAX_PATH_LEN];			// FilePath
	BYTE					byReserved[512];					// Reserved
}NET_NONMOTOR_PIC_INFO;

//face image information
typedef struct tagRIDER_FACE_IMAGE_INFO
{
	unsigned int	   nOffSet;					// image offset in the data  
	unsigned int	   nLength;					// Image size, Unit : Byte 
	unsigned int	   nWidth;					// Image width(pixel)
	unsigned int	   nHeight;					// Image height(pixel)
	BYTE			   byReserved[48];			// Reserved
}RIDER_FACE_IMAGE_INFO;

// Strabismus type
typedef enum tagEM_STRABISMUS_TYPE
{
	EM_STRABISMUS_UNKNOWN,			// Unknown
	EM_STRABISMUS_NORMAL,			// Normal
	EM_STRABISMUS_YES,				// Strabismus
} EM_STRABISMUS_TYPE;

// Face attribute
typedef struct tagNET_FACE_ATTRIBUTE_EX
{
	EM_SEX_TYPE 							emSex;						// Sex
	int        								nAge;						// age,-1 means invalid
	EM_COMPLEXION_TYPE						emComplexion;				// Complexion
	EM_EYE_STATE_TYPE						emEye;						// Eye state
	EM_MOUTH_STATE_TYPE						emMouth;					// Mouth state
	EM_MASK_STATE_TYPE 						emMask;						// Mask state
	EM_BEARD_STATE_TYPE						emBeard;					// Beard state
	int										nAttractive;				// Attractive, 0 Not distinguish,Range[1,100], the higher value the more attractive
	EM_HAS_GLASS							emGlass;					// Glasses
	EM_EMOTION_TYPE							emEmotion;					// Emotion
	DH_RECT									stuBoundingBox;				// BoundingBox(8192 Coordinate)
	EM_NATION_TYPE							emNation;					// Nation
	EM_STRABISMUS_TYPE						emStrabismus;				// Strabismus
	BYTE                					byReserved[64];             // Reserved.
} NET_FACE_ATTRIBUTE_EX;

// Rider information
typedef struct tagNET_RIDER_INFO
{
	BOOL						bFeatureValid;							// Enable
	EM_SEX_TYPE		            emSex;								    // its sex
	int					        nAge;								    // its age

	EM_NONMOTOR_OBJECT_STATUS   emHelmet;					  		    // Whether or not wearing a helmet
	EM_NONMOTOR_OBJECT_STATUS   emCall;							        // Whether on the phone
	EM_NONMOTOR_OBJECT_STATUS   emBag;					  			    // Whether or not have bag
	EM_NONMOTOR_OBJECT_STATUS   emCarrierBag;					  	    // Whether or not have carrierbag
	EM_NONMOTOR_OBJECT_STATUS   emUmbrella;					  	        // Whether an umbrella
	EM_NONMOTOR_OBJECT_STATUS   emGlasses;					  	  	    // Whether or not wear glasses
	EM_NONMOTOR_OBJECT_STATUS   emMask;					  	  	        // Whether to wear a face mask

	EM_EMOTION_TYPE             emEmotion;                              // Emotion
	EM_CLOTHES_TYPE             emUpClothes;                            // UpClothes type
	EM_CLOTHES_TYPE             emDownClothes;                          // DownClothes type
	EM_OBJECT_COLOR_TYPE        emUpperBodyColor;                       // UpClothes color
	EM_OBJECT_COLOR_TYPE        emLowerBodyColor;                       // DownClothes color
	BOOL						bHasFaceImage;							// Whether rider's face image information is contained
	RIDER_FACE_IMAGE_INFO		stuFaceImage;							// Rider face image
	BOOL						bHasFaceAttributes;						// Whether rider's face Attributes is contained
	NET_FACE_ATTRIBUTE_EX		stuFaceAttributes;						// face Attributes
    EM_HAS_HAT                  emHasHat;                               // whether has hat
    EM_CAP_TYPE                 emCap;                                  // Cap type
    EM_HAIR_STYLE               emHairStyle;                            // Hair style
	BYTE						byReserved[304];						// Reserved
}NET_RIDER_INFO;

#define MAX_RIDER_NUM 16											// The maximum number of riders

// Position info of non-motor feature data in binary data
typedef struct tagNET_NONMOTOR_FEATURE_VECTOR_INFO
{
    UINT                nOffset;            // The offset of non-motor feature data in binary data, unit:bytes
    UINT                nLength;            // The length of non-motor feature data, unit:bytes
    BYTE                byReserved[32];     // Reserved
} NET_NONMOTOR_FEATURE_VECTOR_INFO;

// The type of feature version
typedef enum tagEM_FEATURE_VERSION
{
    EM_FEATURE_VERSION_UNKNOWN,                             // Unknown
    EM_FEATURE_VERSION_FACE_LARGE_1_01_001          = 1,    // Facelarge model1.01.001
    EM_FEATURE_VERSION_FACE_LARGE_1_02_001,                 // Facelarge model1.02.001
    EM_FEATURE_VERSION_FACE_LARGE_1_03_001,                 // Facelarge model1.03.001
    EM_FEATURE_VERSION_FACE_LARGE_1_04_001,                 // Facelarge model1.04.001
    EM_FEATURE_VERSION_FACE_MIDDLE_1_01_002         = 31,   // Facemiddle model1.01.002
    EM_FEATURE_VERSION_FACE_MIDDLE_1_02_002,                // Facemiddle model1.02.002
    EM_FEATURE_VERSION_FACE_MIDDLE_1_03_002,                // Facemiddle model1.03.002
    EM_FEATURE_VERSION_FACE_MIDDLE_1_04_002,                // Facemiddle model1.04.002
    EM_FEATURE_VERSION_FACE_SMALL_1_01_003          = 61,   // Facesmall model1.01.003
    EM_FEATURE_VERSION_FACE_SMALL_1_02_003,                 // Facesmall model1.02.003
    
    EM_FEATURE_VERSION_HUMAN_NONMOTOR               = 91,   // Human and non-motorno version
    EM_FEATURE_VERSION_HUMAN_NONMOTOR_FLOAT_1_00_01,        // Human and non-motorglobal float1.00.01
    EM_FEATURE_VERSION_HUMAN_NONMOTOR_HASH_1_00_01,         // Human and non-motorglobal hash1.00.01
    EM_FEATURE_VERSION_HUMAN_NONMOTOR_FLOAT_1_01_00,        // Human and non-motorglobal float1.01.00
    EM_FEATURE_VERSION_HUMAN_NONMOTOR_HASH_1_01_00,         // Human and non-motorglobal hash1.01.00
    
    EM_FEATURE_VERSION_TRAFFIC                      = 121,  // Trafficno version
    EM_FEATURE_VERSION_TRAFFIC_FLOAT,                       // Trafficglobal float, 0
    EM_FEATURE_VERSION_TRAFFIC_FLOAT_1_00_01,               // Trafficglobal float, 1.00.01
    EM_FEATURE_VERSION_TRAFFIC_HASH_1_00_01,                // Trafficglobal hash, 1.00.01
    EM_FEATURE_VERSION_TRAFFIC_FLOAT_1_00_02,               // Trafficglobal float, 1.00.02
    EM_FEATURE_VERSION_TRAFFIC_HASH_1_00_02,                // Trafficglobal hash, 1.00.02
    
    EM_FEATURE_VERSION_SHANGTANG_FACE_1_5_0         = 151,  // ShangTangface1.5.0
    EM_FEATURE_VERSION_SHANGTANG_FACE_1_8_1,                // ShangTangface1.8.1
    EM_FEATURE_VERSION_SHANGTANG_FACE_2_1_3,                // ShangTangface2.1.3
    EM_FEATURE_VERSION_SHANGTANG_FACE_2_39_6,               // ShangTangface2.39.6
    EM_FEATURE_VERSION_SHANGTANG_FACE_2_39_7,               // ShangTangface2.39.7
    EM_FEATURE_VERSION_SHANGTANG_FACE_2_39_8,               // ShangTangface2.39.8
    EM_FEATURE_VERSION_SHANGTANG_FACE_239,                  // ShangTangface239
    EM_FEATURE_VERSION_SHANGTANG_FACE_242,                  // ShangTangface242
    EM_FEATURE_VERSION_SHANGTANG_FACE_244,                  // ShangTangface244
    EM_FEATURE_VERSION_SHANGTANG_FACE_245,                  // ShangTangface245
    
    EM_FEATURE_VERSION_SHENMO_HUMAN_TRAFFIC_NON_2_4_2 = 181,// ShenMohuman/traffic/non-motor2.4.2
    EM_FEATURE_VERSION_SHENMO_HUMAN_TRAFFIC_NON_2_5_7,      // ShenMohuman/traffic/non-motor2.5.7
} EM_FEATURE_VERSION;

// The plate image of no-motor
typedef struct tagNET_NONMOTOR_PLATE_IMAGE
{
    UINT        nOffset;            // picture offset in binary data
    UINT        nLength;            // picture size,unit:byte
    UINT        nWidth;             // Image width(Unit:pixel)
    UINT        nHeight;            // Image height(Unit:pixel)
    BYTE        byReserved[512];    // Reserved
}NET_NONMOTOR_PLATE_IMAGE;


//Plate color
typedef enum tagEM_PLATE_COLOR_TYPE
{
    EM_PLATE_COLOR_UNKNOWN,                            // "Unknown"
    EM_PLATE_COLOR_OTHER,                              // "Other"
    EM_PLATE_COLOR_BLUE,                               // "Blue"
    EM_PLATE_COLOR_YELLOW,                             // "Yellow"    
    EM_PLATE_COLOR_WHITE,                              // "White"
    EM_PLATE_COLOR_BLACK,                              // "Black"
    EM_PLATE_COLOR_RED,                                // "Red"
	EM_PLATE_COLOR_GREEN,                          // "Green"
	EM_PLATE_COLOR_SHADOW_GREEN,		       // "ShadowGreen"
	EM_PLATE_COLOR_YELLOW_GREEN,			// "YellowGreen""
}EM_PLATE_COLOR_TYPE;


// Plate info of nomotor
typedef struct tagNET_NONMOTOR_PLATE_INFO
{
    char                        szPlateNumber[128];                 // plate number
    NET_RECT			stuBoundingBox;                     // BoundingBox Rect, 0~8192
    NET_RECT			stuOriginalBoundingBox;             // BoundingBox Rect, absolute coordinates
    NET_NONMOTOR_PLATE_IMAGE    stuPlateImage;                      // plate image info
    EM_PLATE_COLOR_TYPE         emPlateColor;                       // Plate color

    BYTE						byReserved[132];					// Reserved
}NET_NONMOTOR_PLATE_INFO;

// Nonmotor
typedef struct tagVA_OBJECT_NONMOTOR
{
	int							nObjectID;                          // Object id
	EM_CATEGORY_NONMOTOR_TYPE	emCategory;							// Non-motor type
	DH_RECT						stuBoundingBox;                     // BoundingBox Rect, 0~8192
	DH_RECT						stuOriginalBoundingBox;             // BoundingBox Rect, absolute coordinates
	NET_COLOR_RGBA				stuMainColor;						// Non-motor color (RGBA value)
	EM_OBJECT_COLOR_TYPE		emColor;							// Non-motor color enumeration
	BOOL						bHasImage;							// Has image?
	NET_NONMOTOR_PIC_INFO		stuImage;							// Image information
	int							nNumOfCycling;						// The number of rider
	NET_RIDER_INFO				stuRiderList[MAX_RIDER_NUM];		// The information of rider
	SCENE_IMAGE_INFO			stuSceneImage;						// SceneImage
	FACE_SCENE_IMAGE			stuFaceSceneImage;					// Face SceneImage
	int							nNumOfFace;							// The number of face
	float						fSpeed;								// Object speed, Unit:km/h
	NET_NONMOTOR_FEATURE_VECTOR_INFO stuNonMotorFeatureVectorInfo;  // Position info of non-motor feature data in binary data
    EM_FEATURE_VERSION          emNonMotorFeatureVersion;           // Non-motor feature data version
    
    NET_NONMOTOR_PLATE_INFO     stuNomotorPlateInfo;                // Plate info of nomotor
    NET_POINT                   stuObjCenter;                       // Center of object(not center of bounding box), 0-8191 relative coordinates, relative to large graph
    BYTE						byReserved[3072];					// Reserved
}VA_OBJECT_NONMOTOR;

// Event Type EVENT_IVS_TRAFFICJUNCTION (transportation card traffic junctions old rule event / video port on the old electric alarm event rules) corresponding to the description of the data block, 
// Due to historical reasons, if you want to deal with bayonet event, DEV_EVENT_TRAFFICJUNCTION_INFO and EVENT_IVS_TRAFFICGATE be processed together to prevent police and video electrical coil electric alarm occurred while the case access platform, 
// Also EVENT_IVS_TRAFFIC_TOLLGATE only support the new bayonet events, 
typedef struct tagDEV_EVENT_TRAFFICJUNCTION_INFO 
{
    int                 nChannelID;                     // ChannelId
    char                szName[128];                    // event name
    BYTE                byMainSeatBelt;                 // main driver, seat, safety belt , 1-fastened, 2-unfastened
    BYTE                bySlaveSeatBelt;                // co-drvier, seat, safety belt, 1-fastened, 2-unfastened
    BYTE                byVehicleDirection;             // Current snapshot is head or rear, see  EM_VEHICLE_DIRECTION
    BYTE                byOpenStrobeState;              // Open status, see EM_OPEN_STROBE_STATE 
    double              PTS;                            // PTS(ms)
    NET_TIME_EX         UTC;                            // the event happen time
    int                 nEventID;                       // event ID
    DH_MSG_OBJECT       stuObject;                      // have being detected object
    int                 nLane;                          // road number
    DWORD               dwBreakingRule;                 // BreakingRule's mask,first byte: crash red light; 
                                                        // secend byte:break the rule of driving road number; 
                                                        // the third byte:converse; the forth byte:break rule to turn around;
                                                        // the five byte:traffic jam; the six byte:traffic vacancy; 
                                                        // the seven byte: Overline; defalt:trafficJunction                                                        
    NET_TIME_EX         RedLightUTC;                    // the begin time of red light
    DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
    int                 nSequence;                      // snap index,such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
    int                 nSpeed;                         // car's speed (km/h)
    BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byDirection;                    // Intersection direction 1 - denotes the forward 2 - indicates the opposite
    BYTE                byLightState;                   // LightState means red light status:0 unknown,1 green,2 red,3 yellow
    BYTE                byReserved;                     // reserved
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DH_MSG_OBJECT       stuVehicle;                     // vehicle info
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
    DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
    char                szRecordFile[DH_COMMON_STRING_128]; // Alarm corresponding original video file information
    EVENT_JUNCTION_CUSTOM_INFO   stuCustomInfo;         // custom info
    BYTE                byPlateTextSource;              // the source of plate text, 0:Local,1:Server
    BYTE                bReserved1[3];                  // Reserved bytes, leave extended_
    NET_GPS_INFO        stuGPSInfo;                     // GPS info ,use in mobile DVR/NVR

    BYTE                byNoneMotorInfo;                // specified the person info of none motor
                                                        // 1 means 11 fields followed is valid
    BYTE                byBag;                          // 0-unknown 1-no bag   2-bag
    BYTE                byUmbrella;                     // 0-unknown 1-no umbrella   2-Umbrella
    BYTE                byCarrierBag;                   // 0-unknown 1-no carrierBag 2-carrierBag    
    BYTE                byHat;                          // 0-unknown 1-no helmet 2-helmet    
    BYTE                byHelmet;                       // 0-unknown 1-no hat 2-hat 
    BYTE                bySex;                          // 0-unknown 1-man 2-woman
    BYTE                byAge;                          // age
    NET_COLOR_RGBA      stuUpperBodyColor;              // upper body color
    NET_COLOR_RGBA      stuLowerBodyColor;              // lower body color
    BYTE                byUpClothes;                    // upper clothes 0:unknown 1:long sleeve 2:short sleeve 3:trousers 4:breeches 5:skirt 6:vest 7:minipants 8:miniskirt
    BYTE                byDownClothes;                  // lower clothes 0:unknown 1:long sleeve 2:short sleeve 3:trousers 4:breeches 5:skirt 6:vest 7:minipants 8:miniskirt   
    NET_EXTENSION_INFO  stuExtensionInfo;               // Extension info
    BYTE                bReserved[22];                  // Reserved bytes, leave extended
    int                 nTriggerType;                   // Trigger Type:0 vehicle inspection device, 1 radar, 2 video, 3 RSU
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;     // Traffic vehicle info
    DWORD               dwRetCardNumber;                // Card Number
    EVENT_CARD_INFO     stuCardInfo[DH_EVENT_MAX_CARD_NUM];  // Card information
    EVENT_COMM_INFO     stCommInfo;                     // public info 

    BOOL                bNonMotorInfoEx;                // Non-motor info enable
    VA_OBJECT_NONMOTOR  stuNonMotor;                    // Non-motor information
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelli comm info
    BYTE                byReserved2[1916];              // Reserved
} DEV_EVENT_TRAFFICJUNCTION_INFO;

// Event Type EVENT_IVS_TRAFFIC_NONMOTORINMOTORROUTE (Non-motor vehicles occupy the lanes)corresponding to the description of the data block, 
typedef struct tagDEV_EVENT_TRAFFIC_NONMOTORINMOTORROUTE_INFO 
{
	int                 nChannelID;                                 // ChannelId
	char                szName[DH_EVENT_NAME_LEN];                  // event name
	BYTE                bEventAction;                               // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
	BYTE                bReserved1[3];                              // Reserved bytes.
	double              PTS;                                        // PTS(ms)
	NET_TIME_EX         UTC;                                        // the event happen time
	int                 nEventID;                                   // event ID

	DH_EVENT_FILE_INFO  stuFileInfo;                                // event file info

	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // Traffic vehicle info
	DH_MSG_OBJECT       stuObject;                                  // have being detected object
	DH_MSG_OBJECT       stuVehicle;                                 // vehicle info  

	DWORD               dwSnapFlagMask;                             // flag(by bit),see NET_RESERVED_COMMON 
	DH_RESOLUTION_INFO  stuResolution;                              // picture resolution
	char                szRecordFile[DH_COMMON_STRING_128];         // Alarm corresponding original video file information

	int                 nLane;                                      // road number
	int                 nSequence;                                  // snap index,such as 3,2,1,1 means the last one,0 means there has some exception and snap stop 
	EVENT_COMM_INFO     stCommInfo;                                 // public info
	BOOL				bHasNonMotor;								// has NonMotor information?
	VA_OBJECT_NONMOTOR	stuNonMotor;								// NonMotor information
	BYTE                bReserved[4096];                            // Reserved bytes, leave extended_.
} DEV_EVENT_TRAFFIC_NONMOTORINMOTORROUTE_INFO;

// vehicle info
typedef struct tagNET_VEHICLE_INFO
{
    UINT                nUID;                                       // uuid
    char                szGroupID[64];                              // group id
    char                szGroupName[128];                           // group name
    char                szPlateNumber[64];                          // plate number
    char                szPlateCountry[4];                          // plate country
    int                 nPlateType;                                 // plate type     
                                                                    // 01  large vehicle plate, yellow back with black word 
                                                                    // 02  minitype vehicle plate, blue back with white word
                                                                    // 03  diplomatic vehicle plate 
                                                                    // 04  cousulate vehicle plate
                                                                    // 05  offshore vehicle plate 
                                                                    // 06  alien vehicle plate 
                                                                    // 13  peasant transporter plate 
                                                                    // 15  trailer vehicle plate
                                                                    // 16  coach car plate
                                                                    // 18  experiment car plate 
                                                                    // 20  provisional entry car plate 
                                                                    // 22  provisional car plate 
                                                                    // 23  police car plate

    int                 nVehicleType;                               // vehicle type
                                                                    // 001  prowl car 
                                                                    // 002  traffic police car 
                                                                    // 003  fire engine 
                                                                    // 004  individual equipment car
                                                                    // 005  other police car 
                                                                    // 006  other car 
                                                                    // 020  government car 
                                                                    // 031  school bus 
                                                                    // 032  armor cash carrier 
                                                                    // 033  Passenger Transport vehicle
                                                                    // 034  public transport 
                                                                    // 035  taxicab 
                                                                    // 036  dangerous cargo vechile
    int                 nBrand;                                     // brand
    int                 nCarSeries;                                 // series of car
    int                 nCarSeriesModelYearIndex;                   // index of car series model year
    NET_COLOR_RGBA      stuVehicleColor;                            // vehicle color
    NET_COLOR_RGBA      stuPlateColor;                              // plate color
    char                szOwnerName[64];                            // owner name
    int                 nSex;                                       // owner sex 0-unknown,1-man,2-women
    int                 nCertificateType;                           // owner certificate type,0-unknown 1-IC 2-Passport 3-Military
    char                szPersonID[32];                             // person id,such as job number or other number    
    char                szOwnerCountry[4];                          // owner country
    char                szProvince[64];                             // province
    char                szCity[64];                                 // city
    char                szHomeAddress[128];                         // home address
    char                szEmail[32];                                // email
    char                szPhoneNo[128];                             // phone number

    BYTE                bReserved[512];
}NET_VEHICLE_INFO;

#define MAX_CAR_CANDIDATE_NUM (50)

// car candidate info
typedef struct tagNET_CAR_CANDIDATE_INFO
{   
    NET_VEHICLE_INFO    stuVehicleInfo;                             // vehicle info
    int                 nDifferentAttributresNum;                   // different attributres num
    int                 nDifferentAttributres[16];                  // different attributres array,element value:0-unknown 1-Country 2-Brand 3-Type 4-VehicleColor 5-PlateColor

    BYTE                byReserved[512];
}NET_CAR_CANDIDATE_INFO;

// vehicle recognition event info(Event Type EVENT_IVS_VEHICLE_RECOGNITION)
typedef struct tagDEV_EVENT_VEHICLE_RECOGNITION_INFO 
{
    char                szName[128];                                // event name    
    double              PTS;                                        // time stamp(unit is ms)
    NET_TIME_EX         UTC;                                        // event time
    int                 nEventID;                                   // event id
    int                 nVehicleAction;                             // vehicle aciton, 0-unknown,1-Appear,2-Disappear

    DH_MSG_OBJECT       stuObject;                                  // object info   
    DH_MSG_OBJECT       stuVehicle;                                 // vehicle info

    NET_SEAT_INFO       stuMainSeatInfo;                            // main seat info
    NET_SEAT_INFO       stuSlaveSeatInfo;                           // slave seat info
    int                 nVehicleAttachNum;                          // attach num
    NET_VEHICLE_ATTACH  stuVehicleAttach[8];                        // attach data array
    char                szCountry[32];                              // country

    int                 nCarCandidateNum;                           // car candidate num     
    NET_CAR_CANDIDATE_INFO stuCarCandidate[MAX_CAR_CANDIDATE_NUM];  // car candidate data

    EVENT_COMM_INFO     stCommInfo;                                 // common info
    int                 nChannel;                                   // channel id
    BYTE                bReserved[1024];
} DEV_EVENT_VEHICLE_RECOGNITION_INFO;


// the describe of EVENT_IVS_TRAFFICGATE's data
// owing to history, if you want to deal with TRAFFICGATE,DEV_EVENT_TRAFFICJUNCTION_INFO/EVENT_IVS_TRAFFICGATE must be handle together;
// in addition: EVENT_IVS_TRAFFIC_TOLLGATE only support new tollgate event configuration
typedef struct tagDEV_EVENT_TRAFFICGATE_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
    BYTE                byOpenStrobeState;              // Open gateway status, see EM_OPEN_STROBE_STATE
	char                bReserved1[3];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	int					nLane;							// road number
	int					nSpeed;							// the car's actual rate(Km/h)
	int					nSpeedUpperLimit;				// rate upper limit(km/h)
	int					nSpeedLowerLimit;				// rate lower limit(km/h) 
	DWORD				dwBreakingRule;					// BreakingRule's mask,first byte: Retrograde; 
	                                                    // second byte:Overline; the third byte:Overspeed; 
														// the forth byte:UnderSpeed;the five byte: crash red light;the six byte:passing(trafficgate)
	                                                    // the seven byte: OverYellowLine; the eight byte: WrongRunningRoute; the nine byte: YellowVehicleInRoute; default: trafficgate
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	DH_MSG_OBJECT       stuVehicle;                     // vehicle info
	BYTE                szManualSnapNo[64];             // manual snap sequence string                 
	int                 nSequence;                      // snap index,such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
	BYTE                byReserved[3];                  // reserved
	BYTE                szSnapFlag[16];                 // snap flag from device
	BYTE                bySnapMode;                     // snap mode,0-normal 1-globle 2-near 4-snap on the same side 8-snap on the reverse side 16-plant picture
	BYTE                byOverSpeedPercentage;          // over speed percentage
	BYTE                byUnderSpeedingPercentage;      // under speed percentage
	BYTE                byRedLightMargin;               // red light margin, s
	BYTE                byDriveDirection;               // drive direction,0-"Approach",where the car is more near,1-"Leave",means where if mor far to the car
	char                szRoadwayNo[32];                // road way number
	char                szViolationCode[16];            // violation code
	char                szViolationDesc[128];           // violation desc
	DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
	char                szVehicleType[32];              // car type,"Motor", "Light-duty", "Medium", "Oversize", "Huge", "Other" 
	BYTE                byVehicleLenth;                 // car length, m
    BYTE                byLightState;                               // LightState means red light status:0 unknown,1 green,2 red,3 yellow
	BYTE                byReserved1;                 // reserved
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	int                 nOverSpeedMargin;               // over speed margin, km/h 
	int                 nUnderSpeedMargin;              // under speed margin, km/h 
	char                szDrivingDirection[3][DH_MAX_DRIVINGDIRECTION]; //
                                                      	// "DrivingDirection" : ["Approach", "Shanghai", "Hangzhou"],
	                                                  	// "Approach" means driving direction,where the car is more near;"Leave"-means where if mor far to the car
	                                                  	// the second and third param means the location of the driving direction
	char                szMachineName[256];             // machine name
	char                szMachineAddress[256];          // machine address
	char                szMachineGroup[256];            // machine group
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	DH_SIG_CARWAY_INFO_EX stuSigInfo;                   // The vehicle detector generates the snap signal redundancy info
	char                szFilePath[MAX_PATH];           // File path
	NET_TIME_EX			RedLightUTC;					// the begin time of red light
	char              * szDeviceAddress;                // device address,OSD superimposed onto the image,from TrafficSnapshot.DeviceAddress,'\0'means end.
	float               fActualShutter;                 // Current picture exposure time, in milliseconds
	BYTE                byActualGain;                   // Current picture gain, ranging from 0 to 1000
    BYTE                byDirection;                    // 0-S to N  1-SW to NE 2-W to E 3-NW to SE 4-N to S 5-NE to SW 6-E to W 7-SE to NW 8-Unknown
    BYTE                bReserve;                       // Reserved bytes, byte alignment
    BYTE                bRetCardNumber;                 // Card Number
    EVENT_CARD_INFO     stuCardInfo[DH_EVENT_MAX_CARD_NUM];// Card information
    char               szDefendCode[DH_COMMON_STRING_64];// Waterproof
    int                nTrafficBlackListID;             // Link to balcklist main keyID, 0, invalid, > 0, blacklist data record
    EVENT_COMM_INFO     stCommInfo;                     // public info 
    BYTE                bReserved[452];	                // Reserved bytes, leave extended
} DEV_EVENT_TRAFFICGATE_INFO;

//the describe of EVENT_TRAFFICSNAPSHOT's data
typedef struct tagDEV_EVENT_TRAFFICSNAPSHOT_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	BYTE                bReserv[3];                     // reserved 
	BYTE                bCarWayCount;                   // car way number being snapshotting
	DH_CARWAY_INFO      stuCarWayInfo[DH_MAX_CARWAY_NUM]; // car way info being snapshotting
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	BYTE				bReserved[344];		    		// Reserved 
    EVENT_COMM_INFO     stCommInfo;                     // public info 
} DEV_EVENT_TRAFFICSNAPSHOT_INFO;

//the describe of EVENT_IVS_TRAFFIC_RUNREDLIGHT's data
typedef struct tagDEV_EVENT_TRAFFIC_RUNREDLIGHT_INFO
{
	int					nChannelID;						  // channel ID
	char				szName[128];					  // event name
	char                bReserved1[4];                    // byte alignment
	double				PTS;							  // PTS(ms)
	NET_TIME_EX			UTC;				              // the event happen time
	int					nEventID;			              // event ID
	int					nLane;				              // Corresponding Lane number
	DH_MSG_OBJECT		stuObject;	              	      // have being detected object
	DH_MSG_OBJECT       stuVehicle;                       // vehicle info
	DH_EVENT_FILE_INFO  stuFileInfo;                      // event file info
	int					nLightState;	              	  // state of traffic light 0:unknown 1:green 2:red 3:yellow
	int					nSpeed;			              	  // speed,km/h
	int                 nSequence;                        // snap index,such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	BYTE                bEventAction;					  // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];
    BYTE                byImageIndex;					  // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;					  // flag(by bit),see NET_RESERVED_COMMON
	NET_TIME_EX         stRedLightUTC;					  // time of red light starting
	DH_RESOLUTION_INFO  stuResolution;					  // picture resolution
	BYTE                byRedLightMargin;				  // red light margin, s
    BYTE                byAlignment[3];					  // Align string
    int                 nRedLightPeriod;                  // Red light period. The unit is ms. 
    NET_GPS_INFO        stuGPSInfo;                       // GPS info ,use in mobile DVR/NVR
    BYTE                bReserved[928];                   // Reserved string 
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;       // Traffic vehicle info
	EVENT_COMM_INFO   	stCommInfo;                 	  // public info 
	BOOL				bHasNonMotor;					  // has NonMotor information?
	VA_OBJECT_NONMOTOR	stuNonMotor;					  // NonMotor information
} DEV_EVENT_TRAFFIC_RUNREDLIGHT_INFO;

//Data description info of the event type EVENT_IVS_TRAFFIC_PEDESTRAINRUNREDLIGHT(trafic-pedestrian redlight running
typedef struct tagDEV_EVENT_TRAFFIC_PEDESTRAINRUNREDLIGHT_INFO
{
    int                 nChannelID;                                 // Channel No.
    char                szName[128];                                // Event name
    char                bReserved1[4];                              // Align string
    double              PTS;                                        // Time stamp (unit is ms)
    NET_TIME_EX         UTC;                                        // Event occurrence time 
    int                 nEventID;                                   // Event ID
    int                 nLane;                                      // Corresponding lane No. 
    DH_MSG_OBJECT       stuObject;                                  // Pedestrian info 
    DH_EVENT_FILE_INFO  stuFileInfo;                                // Corresponding file inof of the event  
    int                 nSequence;                                  // Snap SN. Such as 3,2,1,1 means stop snap. 0= abnormal stop. 
    BYTE                bEventAction;                               // Event operation. 0=pulse event. 1=continious event begin, 2=continuous event stop
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // Image SN. There can be several images at the same time (unit:second). Begins with 0. 
    DWORD               dwSnapFlagMask;                             // Snap mark (by byte).Please refer to  NET_RESERVED_COMMON 
    DH_RESOLUTION_INFO  stuResolution;                              // Corresponding image resolution 
    BYTE                bReserved[1024];                            // Reserved string 
    EVENT_COMM_INFO     stCommInfo;                                 // Public info 
}DEV_EVENT_TRAFFIC_PEDESTRAINRUNREDLIGHT_INFO;

//Data description info of the event type EVENT_IVS_TRAFFIC_PASSNOTINORDER(trafic-pass not in order)
typedef struct tagDEV_EVENT_TRAFFIC_PASSNOTINORDER_INFO
{
    int                 nChannelID;                                 // Channel No.
    char                szName[DH_EVENT_NAME_LEN];                  // Event name
    char                bReserved1[4];                              // Align string
    double              PTS;                                        // Time stamp (unit is ms)
    NET_TIME_EX         UTC;                                        // Event occurrence time 
    int                 nEventID;                                   // Event ID
    int                 nLane;                                      // Corresponding lane No. 
    DH_MSG_OBJECT       stuObject;                                  // plate info
    DH_MSG_OBJECT       stuVehicle;                                 // Vehicle info 
    DH_EVENT_FILE_INFO  stuFileInfo;                                // Corresponding file inof of the event  
    int                 nSequence;                                  // Snap SN. Such as 3,2,1,1 means stop snap. 0 - abnormal stop. 
    BYTE                bEventAction;                               // Event operation. 0-pulse event. 1-continious event begin, 2-continuous event stop
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // Image SN. There can be several images at the same time (unit:second). Begins with 0. 
    DWORD               dwSnapFlagMask;                             // Snap mark (by byte).Please refer to  NET_RESERVED_COMMON 
    DH_RESOLUTION_INFO  stuResolution;                              // Corresponding image resolution 
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // Traffic Car information
    EVENT_COMM_INFO     stCommInfo;                                 // Public info
    NET_GPS_INFO        stuGPSInfo;                                 // GPS info ,use in mobile DVR/NVR
    BYTE                bReserved[984];                             // Reserved string
}DEV_EVENT_TRAFFIC_PASSNOTINORDER_INFO;

//the describe of EVENT_IVS_TRAFFIC_OVERLINE's data
typedef struct tagDEV_EVENT_TRAFFIC_OVERLINE_INFO
{
	int					nChannelID;			// channel ID
	char				szName[128];		// event name
	char                bReserved1[4];      // byte alignment
	double				PTS;				// PTS(ms)
	NET_TIME_EX			UTC;				// the event happen time
	int					nEventID;			// event ID
	int					nLane;				// Corresponding Lane number
	DH_MSG_OBJECT		stuObject;			// have being detected object
	DH_MSG_OBJECT       stuVehicle;         // vehicle info
	DH_EVENT_FILE_INFO  stuFileInfo;        // event file info
	int                 nSequence;          // snap index,such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	int                 nSpeed;             // speed,km/h
	BYTE                bEventAction;		// Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];
    BYTE                byImageIndex;       // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	    // flag(by bit),see NET_RESERVED_COMMON
	DH_RESOLUTION_INFO  stuResolution;      // picture resolution	
    NET_GPS_INFO        stuGPSInfo;         // GPS info ,use in mobile DVR/NVR
	BYTE				bReserved[968];	    // Reserved 
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;       // Traffic vehicle info
  EVENT_COMM_INFO   stCommInfo;                 // public info 
} DEV_EVENT_TRAFFIC_OVERLINE_INFO;


//the describe of EVENT_IVS_TRAFFIC_RETROGRADE's data
typedef struct tagDEV_EVENT_TRAFFIC_RETROGRADE_INFO
{
	int					nChannelID;			// channel ID
	char				szName[128];		// event name
	char                bReserved1[4];      // byte alignment
	double				PTS;				// PTS(ms)
	NET_TIME_EX			UTC;				// the event happen time
	int					nEventID;			// event ID
	int					nLane;				// Corresponding Lane number
	DH_MSG_OBJECT		stuObject;			// have being detected object
	DH_MSG_OBJECT       stuVehicle;         // vehicle info
	DH_EVENT_FILE_INFO  stuFileInfo;        // event file info
	int                 nSequence;          // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	int                 nSpeed;             // speed, km/h
	BYTE                bEventAction;		// Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];
    BYTE                byImageIndex;        // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	     // flag(by bit),see NET_RESERVED_COMMON
	DH_RESOLUTION_INFO  stuResolution;       // picture resolution
	BOOL                bIsExistAlarmRecord; // a corresponding alarm recording; false: no corresponding alarm recording
	DWORD               dwAlarmRecordSize;   // Video size
	char                szAlarmRecordPath[DH_COMMON_STRING_256]; 	// Video Path
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;              	// intelli comm info
    NET_GPS_INFO        stuGPSInfo;                                 // GPS info ,use in mobile DVR/NVR
	BYTE				bReserved[484];								// Reserved bytes
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;    			 	// Traffic vehicle info
	int                 nDetectNum;									// Acme amount of the rule detect zone
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    	// Rule detect zone 
	EVENT_COMM_INFO   	stCommInfo;         						// public info 
	BOOL				bHasNonMotor;					  			// has NonMotor information?
	VA_OBJECT_NONMOTOR	stuNonMotor;					  			// NonMotor information
} DEV_EVENT_TRAFFIC_RETROGRADE_INFO;

//the describe of EVENT_IVS_TRAFFIC_TURNLEFT's data
typedef struct tagDEV_EVENT_TRAFFIC_TURNLEFT_INFO
{
	int					nChannelID;			// channel ID
	char				szName[128];		// event name
	char                bReserved1[4];      // byte alignment
	double				PTS;				// PTS(ms)
	NET_TIME_EX			UTC;				// the event happen time
	int					nEventID;			// event ID
	int					nLane;				// Corresponding Lane number
	DH_MSG_OBJECT		stuObject;			// have being detected object
	DH_MSG_OBJECT       stuVehicle;         // vehicle info
	DH_EVENT_FILE_INFO  stuFileInfo;        // event file info
	int                 nSequence;          // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	int                 nSpeed;             // speed,km/h
	BYTE                bEventAction;		// Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	    			// flag(by bit),see NET_RESERVED_COMMON
	DH_RESOLUTION_INFO  stuResolution;      			// picture resolution
    NET_GPS_INFO        stuGPSInfo;                     // GPS info ,use in mobile DVR/NVR
	BYTE				bReserved[968];				    // Reserved 
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;     // Traffic vehicle info
	EVENT_COMM_INFO   	stCommInfo;                 	// public info 
} DEV_EVENT_TRAFFIC_TURNLEFT_INFO;


//the describe of EVENT_IVS_TRAFFIC_TURNRIGHT's data
typedef struct tagDEV_EVENT_TRAFFIC_TURNRIGHT_INFO
{
	int					nChannelID;			// channel ID
	char				szName[128];		// event name
	char                bReserved1[4];      // byte alignment
	double				PTS;				// PTS(ms)
	NET_TIME_EX			UTC;				// the event happen time
	int					nEventID;			// event ID
	int					nLane;				// Corresponding Lane number
	DH_MSG_OBJECT		stuObject;			// have being detected object
	DH_MSG_OBJECT       stuVehicle;         // vehicle info
	DH_EVENT_FILE_INFO  stuFileInfo;        // event file info
	int                 nSequence;          // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	int                 nSpeed;             // speed,km/h
	BYTE                bEventAction;		// Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	    			// flag(by bit),see NET_RESERVED_COMMON
	DH_RESOLUTION_INFO  stuResolution;      			// picture resolution
    NET_GPS_INFO        stuGPSInfo;                     // GPS info ,use in mobile DVR/NVR
	BYTE				bReserved[968];				    // Reserved 
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;     // Traffic vehicle info
	EVENT_COMM_INFO   	stCommInfo;                 	// public info 
} DEV_EVENT_TRAFFIC_TURNRIGHT_INFO;

//the describe of EVENT_IVS_TRAFFIC_UTURN's data
typedef struct tagDEV_EVENT_TRAFFIC_UTURN_INFO 
{
	int					nChannelID;						  // channel ID
	char				szName[128];					  // event name
	char                bReserved1[4];                    // byte alignment
	double				PTS;							  // PTS(ms)
	NET_TIME_EX			UTC;						   	  // the event happen time
	int					nEventID;					      // event ID
	int					nLane;							  // Corresponding Lane number
	DH_MSG_OBJECT		stuObject;						  // have being detected object
	DH_MSG_OBJECT       stuVehicle;                       // vehicle info
	DH_EVENT_FILE_INFO  stuFileInfo;					  // event file info
	int                 nSequence;                        // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	int                 nSpeed;             			  // speed,km/h
	BYTE                bEventAction;		              // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                     // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                  // flag(by bit),see NET_RESERVED_COMMON
	DH_RESOLUTION_INFO  stuResolution;                    // picture resolution
    NET_GPS_INFO        stuGPSInfo;                       // GPS info ,use in mobile DVR/NVR
	BYTE				bReserved[968];				      // Reserved 
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;       // Traffic vehicle info
	EVENT_COMM_INFO   	stCommInfo;                 	  // public info 
}DEV_EVENT_TRAFFIC_UTURN_INFO;

//the describe of EVENT_IVS_TRAFFIC_OVERSPEED's data
typedef struct tagDEV_EVENT_TRAFFIC_OVERSPEED_INFO 
{
	int					nChannelID;						  // channel ID
	char				szName[128];					  // event name
	char                bReserved1[4];                    // byte alignment
	double				PTS;							  // PTS(ms)
	NET_TIME_EX			UTC;						   	  // the event happen time
	int					nEventID;					      // event ID
	int					nLane;							  // Corresponding Lane number
	DH_MSG_OBJECT		stuObject;						  // have being detected object
	DH_MSG_OBJECT       stuVehicle;                       // vehicle info
	DH_EVENT_FILE_INFO  stuFileInfo;					  // event file info
    int                 nSpeed;                           // vehicle speed Unit:Km/h
	int					nSpeedUpperLimit;			      // Speed Up limit Unit:km/h
	int					nSpeedLowerLimit;				  // Speed Low limit Unit:km/h 
	int                 nSequence;                        // snap index:such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	BYTE                bEventAction;		              // Event action,0 means pulse event,1 means continuous event's begin,2 means continuous event's end;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                     // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                  // flag(by bit),see NET_RESERVED_COMMON
	DH_RESOLUTION_INFO  stuResolution;                    // picture resolution
    char                szFilePath[MAX_PATH];             // Faile path
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;       // intelli comm info
    NET_GPS_INFO        stuGPSInfo;                       // GPS info ,use in mobile DVR/NVR
	int                 nSpeedingPercentage;              // over speed percentage
	BYTE                bReserved[572];				      // Reserved 
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;       // Traffic vehicle info
	EVENT_COMM_INFO   	stCommInfo;                 	  // public info 	
}DEV_EVENT_TRAFFIC_OVERSPEED_INFO;

//the describe of EVENT_IVS_TRAFFIC_UNDERSPEED's data
typedef struct tagDEV_EVENT_TRAFFIC_UNDERSPEED_INFO 
{
	int					nChannelID;						  // channel ID
	char				szName[128];					  // event name
	char                bReserved2[4];                    // byte alignment
	double				PTS;							  // PTS(ms)
	NET_TIME_EX			UTC;						   	  // the event happen time
	int					nEventID;					      // event ID
	int					nLane;							  // Corresponding Lane number
	DH_MSG_OBJECT		stuObject;						  // have being detected object
	DH_MSG_OBJECT       stuVehicle;                       // vehicle info
	DH_EVENT_FILE_INFO  stuFileInfo;					  // event file info
    int                 nSpeed;                           // vehicle speed Unit:Km/h
	int					nSpeedUpperLimit;			      // Speed Up limit Unit:km/h
	int					nSpeedLowerLimit;				  // Speed Low limit Unit:km/h 
	int                 nSequence;                        // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	BYTE                bEventAction;		              // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                bReserved1[2];                    // reserved
    BYTE                byImageIndex;                     // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	int                 nUnderSpeedingPercentage;         // under speed percentage
    DWORD               dwSnapFlagMask;	                  // flag(by bit),see NET_RESERVED_COMMON
	DH_RESOLUTION_INFO  stuResolution;                    // picture resolution
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;       // intelligence common information
    NET_GPS_INFO        stuGPSInfo;                       // GPS info ,use in mobile DVR/NVR
	BYTE                bReserved[832];				  	  // Reserved 
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;       // Traffic vehicle info
    EVENT_COMM_INFO   stCommInfo;                 		  // public info 
}DEV_EVENT_TRAFFIC_UNDERSPEED_INFO;

//the describe of EVENT_IVS_TRAFFIC_JAM_FORBID_INTO's data
typedef struct tagDEV_EVENT_ALARM_JAMFORBIDINTO_INFO
{
	int                 nChannelID;                         // channel ID
    char                szName[DH_EVENT_NAME_LEN];          // event name
    char                bReserved1[4];                      // byte alignment
    DWORD               PTS;                                // PTS(ms)
    NET_TIME_EX         UTC;                                // the event happen time
    int                 nEventID;                           // event ID
	DH_EVENT_FILE_INFO  stuFileInfo;                        // event file info
	int					nMark;								// frame flag
	int					nSource;						  	// video source
	int					nSequence;						    // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	int					nFrameSequence;						// the sequence of frame
	int					nLane;							    // Corresponding Lane number
	BYTE                byImageIndex;                   	// Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	DH_MSG_OBJECT       stuObject;                      	// have being detected object
    NET_GPS_INFO        stuGPSInfo;                         // GPS info ,use in mobile DVR/NVR
	BYTE                bReserved[984];	                    // Reserved 
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;        // Traffic vehicle info
	EVENT_COMM_INFO     stCommInfo;                     	// public info 
    DH_MSG_OBJECT       stuVehicle;                         // Traffic vehicle info
    DH_RESOLUTION_INFO  stuResolution;                      // picture resolution
} DEV_EVENT_ALARM_JAMFORBIDINTO_INFO;

// the describe of EVENT_IVS_TRAFFIC_JAM_STOP_ON_ZEBRACROSSING's data
typedef struct tagDEV_EVENT_TRAFFIC_JAM_STOP_ON_ZEBRACROSSING_INFO
{
	int                 nChannelID;                                 // channel ID
	char                szName[DH_EVENT_NAME_LEN];                  // event name
	char                bReserved1[4];                              // byte alignment
	double              PTS;                                        // PTS(ms)
	NET_TIME_EX         UTC;                                        // the event happen time
	int                 nEventID;                                   // event ID
	///////////////////////////////The above is a common field//////////////////////////////
	DH_EVENT_FILE_INFO  stuFileInfo;                                // event file info 
	int					nSequence;									// snap index: such as 3,2,1/0  1 means the last one,0 means there has some exception and snap stop
	int					nLane;										// Lane number
	BYTE                byImageIndex;                   			// Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starts from 0  
	BYTE                byReserved[3];
	DH_MSG_OBJECT       stuObject;                      			// have been detected object
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;                // Traffic vehicle information
	EVENT_COMM_INFO     stuCommInfo;                     			// public info
	DH_MSG_OBJECT       stuVehicle;                                 // Vehicle body information
	DH_RESOLUTION_INFO  stuResolution;                              // picture resolution
	DWORD               dwSnapFlagMask;                             // flag(by bit),see NET_RESERVED_COMMON  
	BYTE                bReserved[2048];                            // Reserved
} DEV_EVENT_TRAFFIC_JAM_STOP_ON_ZEBRACROSSING_INFO;

typedef struct tagEVENT_PIC_ANALYSE_INFO
{
	DH_MSG_OBJECT       stuObject;                                  // plate info
    DH_MSG_OBJECT       stuVehicle;                                 // vehicle info
	EVENT_COMM_INFO     stuCommInfo;                     			// public info 
    BYTE                bReserved[1024];                            // Reserved
}EVENT_PIC_ANAKYSE_INFO;

//the describe of DH_ALARM_TRAFFIC_PIC_ANALYSE's data
typedef struct tagDEV_ALARM_PIC_ANALYSE_INFO
{
    int						nIndex;                              
    char					szName[128];                                // event nament
    double					PTS;                                        // PTS(ms)
    NET_TIME_EX				UTC;                                        // the event happen time
    int						nEventID;                                   // event ID
    DH_MSG_OBJECT			stuObject;                                  // plate info
    DH_MSG_OBJECT			stuVehicle;                                 // vehicle info
    int						nGroupID;									// the only id of one group 
	int						nCountInGroup;								// the file count in the current file's group
	int						nIndexInGroup;								// the index of the file in the group
	char					szFilePath[MAX_PATH];						// the path of the file
	EVENT_COMM_INFO			stuCommInfo;                     			// public info 
	EVENT_PIC_ANAKYSE_INFO	stuAnalyseInfo;								// analyse info
	BYTE					bReserved[1024];							// Reserved 
} ALARM_PIC_ANALYSE_INFO;
typedef struct tagNET_BULLET_HOLES_INFO
{
    int                 nObjectID;                          // Object ID,each ID represent a unique object
    char                szObjectType[128];                  // Object type
    DH_RECT             stuBoundingBox;                     // BoundingBox
    DH_POINT            stuCenter;                          // The shape center of the object
	int				    nSequence;							// Sequence
	int                 nScore;							    // Score
    BYTE                byReserved[512];                    // Reserved
}NET_BULLET_HOLES_INFO;
typedef struct tagDEV_ALARM_PIC_SHOOTINGSCORERECOGNITION_INFO
{
    int						nIndex;                                     // channel ID
    char					szName[128];                                // event nament
    double					dbPTS;                                      // PTS(ms)
    NET_TIME_EX				stuUTC;                                     // the event happen time
    int						nEventID;                                   // event ID
    int						nGroupID;									// he only id of one group 
	int						nCountInGroup;								// the file count in the current file's group
	int						nIndexInGroup;								// the index of the file in the group
	char					szFilePath[MAX_PATH];						// the path of the file
	DH_POINT				stuDetectRegion;							// detect region
	int						nValidBulletHolesNum;						// bullet holes number
	NET_BULLET_HOLES_INFO   stuBulletHolesInfo[DH_MAX_BULLET_HOLES];	// detect bullet holes info 
	BYTE					bReserved[1024];							// Reserved
} ALARM_PIC_SHOOTINGSCORERECOGNITION_INFO;

//the describe of DH_ALARM_OIL_4G_OVERFLOW's data
typedef struct tagNET_ALARM_OIL_4G_OVERFLOW_INFO
{	
	int					            nChannelID;						// channel ID	
    double				            dbPTS;							// PTS(ms) 
    NET_TIME_EX			            stuTime;						// the event happen time
	int								nFlowRateCur;					// flow already used of the month(unit:MB)	
	int								nFlowRateMax;					// flow threshold of the month(unit:MB)	
	BYTE                			byReserved[1024];   			// Reserved
}NET_ALARM_OIL_4G_OVERFLOW_INFO;

//the describe of DH_ALARM_POWER_SWITCHER_ALARM's data
typedef struct tagDEV_ALARM_POWERSWITCHER_INFO
{
	int                     nEventAction;                       // Continuous event action: 1 means start,2 means stop;
	int                     nEventIndex;                        // Power supply switch serial number, in accord with the subscript serial number of PowerSwitcher configuration
	char					szName[128];                        // Power switcher name, corresponding with PowerSwitcher configuration name
	NET_TIME_EX				stuUTC;                             // The event happen time
	int                     nPowerVoltage;                      // Power voltage, uint:mV
	int                     nPowerCurrent;                      // Power current, uint:mA
	int                     nPowerValue;                        // Power value, uint:mW
	int						nSwitchOn;							// Switch on or off: 0 means switch off,1 means switch on 
	int                     nPowerState;                        // Power state of mask, 0 means normal,bit0 means under voltage, bit1 means over voltage, bit2 means under current, bit3 means over current, bit4 means invalid(this state is not set with other state at the same time)
	BYTE					byReserved[1024];				    // Reserved
}DEV_ALRAM_POWERSWITCHER_INFO;

//the describe of DH_ALARM_SCENNE_CHANGE_ALARM's data
typedef struct tagDEV_ALARM_PIC_SCENECHANGE_INFO
{
    int						nChannelID;                                 // channel ID
	int						nEventAction;								// Continuous event action: 1 means start,2 means stop;
    double					dbPTS;                                      // PTS(ms)
    NET_TIME_EX				stuUTC;                                     // The event happen time
    int						nEventID;                                   // event ID
	BYTE					bReserved[1024];							// Reserved
} ALARM_PIC_SCENECHANGE_INFO;

//the describe of EVENT_IVS_SCENE_CHANGE's data
typedef struct tagDEV_ALRAM_SCENECHANGE_INFO
{
    int							nChannelID;									// channel ID
	int							nEventAction;								// Continuous event action: 1 means start,2 means stop;
    double						dbPTS;										// PTS(ms)
    NET_TIME_EX					stuUTC;										// The event happen time
    int							nEventID;									// event ID

    DH_EVENT_FILE_INFO			stuFileInfo;								// event file info
    BYTE						byImageIndex;								// Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD						dwSnapFlagMask;								// flag(by bit),see NET_RESERVED_COMMON 
    BYTE						bReserved[1024];							// Reserved 
} DEV_ALRAM_SCENECHANGE_INFO;

//Corresponding to data block description of event type EVENT_IVS_SNAPMANUAL(SnapManual time event) 
typedef struct tagDEV_EVENT_SNAPMANUAL
{
	int                 nChannelID;                                   // Channel number
    char                szName[DH_EVENT_NAME_LEN];                    // Event name
    char                bReserved1[4];                                // Byte alignment
    double              PTS;                                          // Timestamp (in milliseconds)
    NET_TIME_EX         UTC;                                          // Time for the event occurred
    int                 nEventID;                                     // Event ID
    DH_EVENT_FILE_INFO	stuFileInfo;								  // event file info
    BYTE				byImageIndex;							      // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD				dwSnapFlagMask;								  // flag(by bit),see NET_RESERVED_COMMON 
    BYTE				bReserved[1024];							  // Reserved 
}DEV_EVENT_SNAPMANUAL;

// event of swipe overtime
typedef struct tagALARM_SWIPE_OVERTIME_INFO
{                            
    NET_TIME_EX             stuTime;                            // the event happen time
    BYTE					bReserved[1024];
}ALARM_SWIPE_OVERTIME_INFO;

// event of driving without card
typedef struct tagALARM_DRIVING_WITHOUTCARD_INFO
{
    NET_TIME_EX             stuTime;                            // the event happen time
    BYTE					bReserved[1024];
}ALARM_DRIVING_WITHOUTCARD_INFO;

// multi faces detect info
typedef struct tagNET_FACE_INFO
{
    int                 nObjectID;                          // object id
    char                szObjectType[128];                  // object type
    int                 nRelativeID;                        // same with the source picture id
    DH_RECT             BoundingBox;                        // bounding box
    DH_POINT            Center;                             // object center
} NET_FACE_INFO;

//the describe of EVENT_IVS_FACEDETECT's data
typedef struct tagDEV_EVENT_FACEDETECT_INFO 
{
	int					nChannelID;						  // channel ID
	char				szName[128];					  // event name
	char                bReserved1[4];                    // byte alignment
	double				PTS;							  // PTS(ms)
	NET_TIME_EX			UTC;						   	  // the event happen time
	int					nEventID;					      // event ID
	DH_MSG_OBJECT		stuObject;						  // have being detected object
	DH_EVENT_FILE_INFO  stuFileInfo;					  // event file info
	BYTE                bEventAction;                     // Event action: 0 means pulse event,1 means continuous event's begin,2means continuous event's end;
	BYTE                reserved[2];                      // reserved
    BYTE                byImageIndex;                     // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	int                 nDetectRegionNum;				  // detect region point number
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect region
    DWORD               dwSnapFlagMask;	                  // flag(by bit),see NET_RESERVED_COMMON
    char                szSnapDevAddress[MAX_PATH];       // snapshot current face device address
    unsigned int        nOccurrenceCount;                 // event trigger accumilated times 
    EM_DEV_EVENT_FACEDETECT_SEX_TYPE emSex;                         // sex type
    int        			nAge;                                       // age, invalid if it is -1
    unsigned int        nFeatureValidNum;                           // invalid number in array emFeature
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE    emFeature[DH_MAX_FACEDETECT_FEATURE_NUM];   // human face features
    int                 nFacesNum;                                  // number of stuFaces
    NET_FACE_INFO       stuFaces[10];                               // when nFacesNum > 0, stuObject invalid
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // public info 
	EM_RACE_TYPE				emRace;								// race
	EM_EYE_STATE_TYPE			emEye;								// eyes state
	EM_MOUTH_STATE_TYPE			emMouth;							// mouth state
	EM_MASK_STATE_TYPE 			emMask;								// mask state
	EM_BEARD_STATE_TYPE			emBeard;							// beard state
	int							nAttractive;						// Attractive value, -1: invalid, 0:no disringuishrange: 1-100, the higher value, the higher charm
	char						szUID[DH_COMMON_STRING_32];			// The unique identifier of the snap person to write to the database
	EM_NATION_TYPE              emNation;                           // nation
	NET_FEATURE_VECTOR			stuFeatureVector;					// Feature data information
	char						szFeatureVersion[32];				// The version of the feature data algorithm
	EM_FACE_DETECT_STATUS       emFaceDetectStatus;                 // The status of person in camera picture
	NET_EULER_ANGLE				stuFaceCaptureAngle;				// euler angle of face in the capture picture, nPitch:pitch of the head, nYaw: yaw of the head, nRoll:roll of the head
																	// range of the angle value is [-90,90], stuFaceCaptureAngle is invalid if the three angles are 999.
	UINT						nFaceQuality;						// quality about capture picture.The range is 0~10000 
    double                      dHumanSpeed;                        // human speed, km/h
    int                         nFaceAlignScore;                    // The score of face picture align.The range is 0~10000,-1 is invalid
    int                         nFaceClarity;                       // The score of face picture clarity.The range is 0~10000,-1 is invalid
	BYTE                		bReserved[636];                     // Reserved
} DEV_EVENT_FACEDETECT_INFO;

// the describe of EVENT_IVS_TRAFFICJAM's data
typedef struct tagDEV_EVENT_TRAFFICJAM_INFO 
{
	int					nChannelID;						// channel ID
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	int					nLane;							// Corresponding Lane number
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info              
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
	BYTE                bJamLenght;                     // Mean congestion length (percentage of total lane length) 0-100
	BYTE                reserved;                    	// reserved
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	NET_TIME_EX         stuStartJamTime;				// the time of starting jam 
	int                 nSequence;                      // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop(this param work when bEventAction=2) 
	int                 nAlarmIntervalTime;             // interval time of alarm(s).(this is a continuous event,if the interval time of recieving next event go beyond this param, we can judge that this event is over with exception)
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
    int                 nJamRealLength;                 // means actual jam length, unit is meter
	NET_EXTENSION_INFO  stuExtensionInfo;               // Extension info
    BYTE                bReserved[876];                 // Reserved	
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;     // Traffic vehicle info	
    EVENT_COMM_INFO     stCommInfo;                     // public info 
} DEV_EVENT_TRAFFICJAM_INFO;

// the describe of EVENT_IVS_TRAFFIC_PARKING's data
typedef struct tagDEV_EVENT_TRAFFIC_PARKING_INFO 
{
	int					nChannelID;						// channel ID
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	DH_MSG_OBJECT       stuVehicle;                     // vehicle info
	int					nLane;							// Corresponding Lane number
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info               
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
	BYTE                reserved[2];                    // Reserved bytes
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	NET_TIME_EX         stuStartParkingTime;            // the time of starting parking
	int                 nSequence;                      // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop(this param work when bEventAction=2) 
	int                 nAlarmIntervalTime;             // interval time of alarm(s) (this is a continuous event,if the interval time of recieving next event go beyond this param, we can judge that this event is over with exception)
	int                 nParkingAllowedTime;            // the time of legal parking
	int                 nDetectRegionNum;				// detect region point number
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect region point number
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
	BOOL                bIsExistAlarmRecord;            // true:corresponding alarm recording; false: no corresponding alarm recording
	DWORD               dwAlarmRecordSize;              // Video size
	char                szAlarmRecordPath[DH_COMMON_STRING_256]; // Video Path
    char                szFTPPath[DH_COMMON_STRING_256];// FTP path 
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelli comm info
	BYTE				byPreAlarm;						// weather is PreAlarm event,0 :traffic parking event,1 :preAlarm event
	BYTE				bReserved2[3];				    // Reserved 
    NET_GPS_INFO        stuGPSInfo;                     // GPS info ,use in mobile DVR/NVR
	BYTE				bReserved[228];				    // Reserved 
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;     // Traffic vehicle info
    EVENT_COMM_INFO     stCommInfo;                     // public info 
} DEV_EVENT_TRAFFIC_PARKING_INFO, DEV_EVENT_TRAFFIC_PARKING_B_INFO, DEV_EVENT_TRAFFIC_PARKING_C_INFO, DEV_EVENT_TRAFFIC_PARKING_D_INFO,DEV_EVENT_TRAFFIC_PARKING_MANUAL_INFO;

//the describe of EVENT_IVS_TRAFFIC_WRONGROUTE's data
typedef struct tagDEV_EVENT_TRAFFIC_WRONGROUTE_INFO 
{
	int					nChannelID;						// channel ID
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	DH_MSG_OBJECT       stuVehicle;                     // vehicle info
	int					nLane;							// Corresponding Lane number
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info               
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];           
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	int                 nSpeed;                         // speed,km/h
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
    NET_GPS_INFO        stuGPSInfo;                     // GPS info ,use in mobile DVR/NVR
	BYTE				bReserved[972];				    // Reserved 
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;     // Traffic vehicle info
    EVENT_COMM_INFO     stCommInfo;                     // public info 
} DEV_EVENT_TRAFFIC_WRONGROUTE_INFO;

//the describe of EVENT_IVS_TRAFFIC_CROSSLANE's data
typedef struct tagDEV_EVENT_TRAFFIC_CROSSLANE_INFO 
{
	int					nChannelID;						// channel ID
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	DH_MSG_OBJECT       stuVehicle;                     // vehicle info
	int					nLane;							// Corresponding Lane number
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info                 
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];       
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	int                 nSpeed;                         // speed,km/h
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelli comm info
    NET_GPS_INFO        stuGPSInfo;                     // GPS info ,use in mobile DVR/NVR
	BYTE                bReserved[836];                 // Reserved bytes.
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;    // traffic vehicle info
    EVENT_COMM_INFO     stCommInfo;                     // public info 
} DEV_EVENT_TRAFFIC_CROSSLANE_INFO;

//the describe of EVENT_IVS_TRAFFIC_OVERYELLOWLINE's data
typedef struct tagDEV_EVENT_TRAFFIC_OVERYELLOWLINE_INFO 
{
	int					nChannelID;						// channel ID
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	DH_MSG_OBJECT       stuVehicle;                     // vehicle info
	int					nLane;							// Corresponding Lane number
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info                 
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];  
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	int                 nSpeed;                         // speed,km/h
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
	BOOL                bIsExistAlarmRecord;            // true:corresponding alarm recording; false: no corresponding alarm recording
	DWORD               dwAlarmRecordSize;              // Video size
	char                szAlarmRecordPath[DH_COMMON_STRING_256]; // Video Path
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelli comm info
	BYTE				bReserved[532];					// Reserved 
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;     // Traffic vehicle info
	
	int                 nDetectNum;				                   // Acme amount of the rule detect zone 
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // Rule detect zone 	
    EVENT_COMM_INFO     stCommInfo;                                // public info 
} DEV_EVENT_TRAFFIC_OVERYELLOWLINE_INFO;

//the describe of EVENT_IVS_TRAFFIC_DRIVINGONSHOULDER's data
typedef struct tagDEV_EVENT_TRAFFIC_DRIVINGONSHOULDER_INFO
{
	int					nChannelID;						// channel ID
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	DH_MSG_OBJECT       stuVehicle;                     // vehicle info
	int					nLane;							// Corresponding Lane number
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info                                
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];      
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	int                 nSpeed;                         // speed,km/h
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;     // traffic car information
    EVENT_COMM_INFO     stCommInfo;                     // public info 
	
} DEV_EVENT_TRAFFIC_DRIVINGONSHOULDER_INFO;

//the describe of EVENT_IVS_TRAFFIC_YELLOWPLATEINLANE's data
typedef struct tagDEV_EVENT_TRAFFIC_YELLOWPLATEINLANE_INFO
{
	int					nChannelID;						// channel ID
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	DH_MSG_OBJECT       stuVehicle;                     // vehicle info
	int					nLane;							// Corresponding Lane number
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info                                               
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];     
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	int                 nSpeed;                         // speed,km/h
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
	BYTE				bReserved[1016];				// Reserved 
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;     // Traffic vehicle info
    EVENT_COMM_INFO     stCommInfo;                     // public info 
	
} DEV_EVENT_TRAFFIC_YELLOWPLATEINLANE_INFO;


//the describe of EVENT_IVS_TRAFFIC_NOPASSING's data
typedef struct tagDEV_EVENT_TRAFFIC_NOPASSING_INFO
{
	int					nChannelID;						// channel ID
	char				szName[DH_EVENT_NAME_LEN];		// event name
    int                 nTriggerType;                   // Trigger Type, 0 vehicle inspection device, 1 radar, 2 video
	DWORD				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	int                 UTCMS;                          // 
	int                 nMark;                          // 
	int                 nSequence;                      // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info  
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO   stTrafficCar;   // TrafficCar info
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    BYTE                byReserved1[3];
    int                 nLane;                          // Corresponding lane number
    DH_MSG_OBJECT		stuObject;						// Object to be detected
    DH_MSG_OBJECT       stuVehicle;                     // car body information 
    int                 nFrameSequence;                 // Video analysis frame number
    int                 nSource;                        // Data source address of the video analysis
    NET_GPS_INFO        stuGPSInfo;                     // GPS info ,use in mobile DVR/NVR
    BYTE				byReserved[984];                // Reserved bytes
    EVENT_COMM_INFO     stCommInfo;                     // public info 
}DEV_EVENT_TRAFFIC_NOPASSING_INFO;
typedef struct tagDH_TRAFFICFLOWSTAT
{
	char				szMachineAddress[256];			// same as DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO.MachineGroup
	char				szMachineName[256];				// same as DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO.MachineName
	char				szDrivingDirection[3][32];		// DrivingDirection "Approach" means driving direction,where the car is more near;"Leave"-means where if mor far to the car,the scend and third param means the location of the driving direction
	int					nLane;							// lane number
	NET_TIME_EX			UTC;							// Statistic time
	int					nPeriod;						// Statistic period, m
	int					nVehicles;						// passed vehicle number
	float				fAverageSpeed;					// average speed, km/h
	float				fAverageLength;					// average length, m
	float				fTimeOccupyRatio;				// time occupy ratio,
	float				fSpaceOccupyRatio;				// space occupy ratio,
	float				fSpaceHeadway;					// space between two cars,m
	float				fTimeHeadway;					// time between two cars, s
	float				fDensity;						// car density, every km
	int					nOverSpeedVehicles;				// over speed vehicle number
	int					nUnderSpeedVehicles;			// under speed vehicle number
	int					nLargeVehicles;					// big car number  
	int					nMediumVehicles;				// mid car number
	int					nSmallVehicles;					// small car number
	int					nMotoVehicles;					// moto car number
	int					nLongVehicles;					// long vehicle number
}DH_TRAFFICFLOWSTAT;
// the describe of EVENT_IVS_TRAFFIC_FLOWSTATE's data
typedef struct tagDEV_EVENT_TRAFFIC_FLOWSTAT_INFO
{
	char				szName[128];					// name
	double				PTS;							// time stamp(ms)
	NET_TIME_EX			UTC;							// occurrence time
	int					nEventID;						// event id
	int					nLaneCnt;						// channel number
	DH_TRAFFICFLOWSTAT	stTrafficFlowStats[DH_MAX_LANE_NUM];//traffic flow state info
	char				Reserved[4];					// byte alignment
}DEV_EVENT_TRAFFIC_FLOWSTAT_INFO;

// manual-snap custom data
typedef struct tagEVENT_MANUALSNAP_CUSTOM_DATA
{
	EVENT_CUSTOM_WEIGHT_INFO stuWeighInfo;									// custom weight info
	BYTE					 byReserved[472];								// Reserved
}EVENT_MANUALSNAP_CUSTOM_DATA;

//the describe of EVENT_IVS_TRAFFIC_MANUALSNAP's data
typedef struct tagDEV_EVENT_TRAFFIC_MANUALSNAP_INFO
{
	int					nChannelID;						// channel ID
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	int					nLane;							// lane number
	BYTE                szManualSnapNo[64];             // manual snap number 
	DH_MSG_OBJECT		stuObject;						// have being detected object
	DH_MSG_OBJECT       stuVehicle;                     // have being detected vehicle
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO   stTrafficCar;   // TrafficCar info
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byOpenStrobeState;              // Open status, see EM_OPEN_STROBE_STATE
	BYTE                byReserved[1];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
	BYTE                bReserved[504];					
	EVENT_MANUALSNAP_CUSTOM_DATA	stuCustom;			// Custom data
    EVENT_COMM_INFO     stCommInfo;                     // public info 
}DEV_EVENT_TRAFFIC_MANUALSNAP_INFO;

//the describe of EVENT_IVS_TRAFFIC_STAY's data
typedef struct tagDEV_EVENT_TRAFFIC_STAY_INFO
{
	int					nChannelID;						// channel id
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// object info
	DH_MSG_OBJECT       stuVehicle;                     // vehicle info
	int					nLane;							// lane number
	int					nSequence;						// snap index
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO   stTrafficCar;   // TrafficCar info
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info  
	BYTE                bEventAction; 					// Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved0[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
	BYTE                byReserved[1012];           
    EVENT_COMM_INFO     stCommInfo;                     // public info 
}DEV_EVENT_TRAFFIC_STAY_INFO;

//the describe of EVENT_IVS_TRAFFIC_VEHICLEINROUTE's data
typedef struct tagDEV_EVENT_TRAFFIC_VEHICLEINROUTE_INFO
{
	int					nChannelID;						// channel id
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// object info
	DH_MSG_OBJECT       stuVehicle;                     // vehicle info
	int					nLane;							// lane number
	int					nSequence;						// snap index
	int					nSpeed;							// speed
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO   stTrafficCar;   // TrafficCar info
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info            
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved0[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelli comm info
	BYTE                byReserved[884];           
    EVENT_COMM_INFO     stCommInfo;                     // public info 
}DEV_EVENT_TRAFFIC_VEHICLEINROUTE_INFO;

// the describe of EVENT_ALARM_LOCALALARM and EVENT_ALARM_MOTIONALARM's data
typedef struct tagDEV_EVENT_ALARM_INFO
{
	int					nChannelID;						// channel id
	char				szName[128];					// evnent name
	char				Reserved[4];					// byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// evnet ID        
    
    DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info 
	EVENT_COMM_INFO     stCommInfo;                     // public info 
}DEV_EVENT_ALARM_INFO;

// the describe of EVENT_ALARM_VIDEOBLIND's data
typedef struct tagDEV_EVENT_ALARM_VIDEOBLIND
{
    int                 nChannelID;                     // channel id
    char                szName[128];                    // evnent name
    char                Reserved[4];                    // byte alignment
    double              PTS;                            // PTS(ms)
    NET_TIME_EX         UTC;                            // the event happen time
    int                 nEventID;                       // evnet ID        
    
    NET_TIME_EX         stuTime;                        // Action happens time,accurate to seconds
    char                szDriverID[32];                 // driver ID
    NET_GPS_STATUS_INFO stuGPSStatus;                   // GPS
    char                szVideoPath[256];               // ftp path for assocated video
    BYTE                byReserved2[1024];              // reserve text,for extension
}DEV_EVENT_ALARM_VIDEOBLIND;

// Alarm event type EVENT_ALARM_ANALOGALARM(analog alarm channel alarm),
typedef struct tagDEV_EVENT_ALARM_ANALOGALRM_INFO 
{
    int                 nChannelID;                                 // (video)channel no.
    char                szName[DH_COMMON_STRING_128];               // analog alarm channel name
    char                Reserved[4];                                // reserve text align	
    double              PTS;                                        // time stamp(unit is ms)
    NET_TIME_EX         UTC;                                        // event time
    int                 nEventID;                                   // event ID 
    DH_EVENT_FILE_INFO  stuFileInfo;                                // event corresponding file info   
    int                 nIndex;                                     // analog alarm channel no.
    NET_SENSE_METHOD    emSensor;                                   // sensor type
    int                 nStatus;                                    // data status, -1:unknown,0:normal,1:invalid data(over meansure),
                                                                    // 2:over threshold1,3:over threshold2,4:over threshold3,5: over threshold 4,
                                                                    // 6:below threshold 1,7: below threshold 2,8: below threshold 3,9: below threshold 4
    float               fValue;                                     // detector value
    NET_TIME            stuCollectTime;                             // data collection time(UTC)
    DWORD               dwSnapFlagMask;                             // snapshotmark(by bit), see NET_RESERVED_COMMON
    BYTE                bEventAction;                               // event action, 0 means impulse event,1 means continuous event start,2 means continuous event end;
    BYTE                byReserved2[1023];                          // reserve text,for extension
}DEV_EVENT_ALARM_ANALOGALRM_INFO;

//EVENT_ALARM_VEHICLEACC(ACC outage alarm)
typedef struct tagDEV_EVENT_ALARM_VEHICLEACC_INFO
{
	int					nChannelID;						// (Channel number)
	char				szName[DH_COMMON_STRING_128];	// (Event Name)
	char				Reserved[4];					// (Reserved byte alignment)
	double				PTS;							// (Timestamp (in milliseconds)
	NET_TIME_EX			UTC;							// (Time the event occurred)
	int					nEventID;						// (Event ID)   
	NET_GPS_STATUS_INFO stGPSStatusInfo;				// (GPS information)
	int					nACCStatus;						// (ACC status 0: Invalid (compatible with), 1: On, 2: Off)                                                                                 	
	BYTE                bEventAction;                   // (Event action, 0 represents the pulse event, an event starts, said persistent, 2 for persistent event ends;)
	BYTE				bConstantElectricStatus;		// (Often charged state 0: Invalid (compatible with), 1: Connection 2: Disconnect)						
	BYTE                bReserved[1022];                // (Reserved bytes, left extensions.)
}DEV_EVENT_ALARM_VEHICLEACC_INFO;


// alarm event type EVENT_ALARM_VEHICLE_TURNOVER(vehicle side turn) , EVENT_ALARM_VEHICLE_COLLISION(collision)
typedef struct tagDEV_EVENT_VEHICEL_ALARM_INFO
{
	int					nChannelID;						// (Channel number)
	char				szName[128];					// (Event name )
	char				Reserved[4];					// (Reserved bytes, left extensions.)
	double				PTS;							// (Timestamp (in milliseconds))
	NET_TIME_EX			UTC;							// (Time for the event occurred )
	int					nEventID;						// (Event ID)
	NET_GPS_STATUS_INFO stGPSStatusInfo;				// (GPS information)
	DH_EVENT_FILE_INFO  stuFileInfo;                    // (Event corresponding to file information)
	BYTE                bEventAction;                   // (Event action, 0 represents the pulse event, 1 persistent event starts, 2 persistent event ends;)
	BYTE                byReserved[2];					// (With Byte alignment)
	BYTE				byImageIndex;					// (Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0, )
	DWORD               dwSnapFlagMask;                 // (Grab flag (bit), see specific NET_RESERVED_COMMON)
	DH_RESOLUTION_INFO  stuResolution;                  // (Corresponding to the resolution of the picture, 
	BYTE                bReserved[1024];                // (Reserved bytes, left extensions.)
}DEV_EVENT_VEHICEL_ALARM_INFO;

// the describe of  EVENT_IVS_PRISONERRISEDETECTION's data
typedef struct tagDEV_EVENT_PRISONERRISEDETECTION_INFO
{
	int					nChannelID;						  // channel id
	char				szName[128];					  // evnent name
	char                bReserved1[4];                    // byte alignment
	double				PTS;							  // PTS(ms)
	NET_TIME_EX			UTC;						   	  // he event happen time
	int					nEventID;					      // evnet ID           
	DH_MSG_OBJECT		stuObject;						  // object info
	int                 nDetectRegionNum;				  // region point number
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // region
	DH_EVENT_FILE_INFO  stuFileInfo;                      // event file info
	double				dInitialUTC;			  		  // UTC init time
	BYTE                bEventAction;                     // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                     // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                  // flag(by bit),see NET_RESERVED_COMMON
	int                 nSourceIndex;                     // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];         // the source device's sign(exclusive),field said local device does not exist or is empty
    unsigned int        nOccurrenceCount;                 // event trigger accumilated times 
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;       // intelligent things info
    BYTE                bReserved[616];                   // Reserved bytes.
}DEV_EVENT_PRISONERRISEDETECTION_INFO;

//Event type  EVENT_IVS_TRAFFIC_PEDESTRAINPRIORITY(Pedestal has higher priority at the  crosswalk) corresponding data block description info
typedef struct tagDEV_EVENT_TRAFFIC_PEDESTRAINPRIORITY_INFO
{
	int                 nChannelID;                       // Channel No.
	char                szName[128];                      // Event name
	char                bReserved1[4];                    // byte alignment
	double              PTS;                              // Time stamp(ms)
	NET_TIME_EX         UTC;                              // Event occurred time
	int                 nEventID;                         // Event ID
	DH_MSG_OBJECT       stuObject;                        // Detected object
	DH_MSG_OBJECT       stuVehicle;                       // Vehicle body info
	DH_EVENT_FILE_INFO  stuFileInfo;                      // The corresponding file info of the event
	int                 nLane;                            // Corresponding lane No.
	double				dInitialUTC;			  		  // Event initial UTC time 	UTC is the second of the event UTC (1970-1-1 00:00:00)
	BYTE                bEventAction;                     // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                     // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	DWORD               dwSnapFlagMask;                   // Snap flag(by bit),please refer to NET_RESERVED_COMMON		
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO   stTrafficCar;     // The record of the database of the traffic vehicle 
	DH_RESOLUTION_INFO  stuResolution;                    // picture resolution
    NET_GPS_INFO        stuGPSInfo;                       // GPS info ,use in mobile DVR/NVR
	BYTE                bReserved[984];                   // Reserved field for future extension.
    EVENT_COMM_INFO     stCommInfo;                       // public info 
}DEV_EVENT_TRAFFIC_PEDESTRAINPRIORITY_INFO;

//Event type  EVENT_IVS_TRAFFIC_VEHICLEINBUSROUTE(vehicle in bus route)corresponding data block description info
typedef struct tagDEV_EVENT_TRAFFIC_VEHICLEINBUSROUTE_INFO
{
	int                 nChannelID;                       // channel ID
	char                szName[128];                      // event name
	char                bReserved1[4];                    // byte alignment
	double              PTS;                              // Time stamp(ms)
	NET_TIME_EX         UTC;                              // Event occurred time
	int                 nEventID;                         // Event ID
	DH_MSG_OBJECT       stuObject;                        // Detected object
	DH_MSG_OBJECT       stuVehicle;                       // Vehicle body info
	DH_EVENT_FILE_INFO  stuFileInfo;                      // The corresponding file info of the event
	int                 nLane;                            // Corresponding lane No.
	int					nSequence;						  // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	int					nSpeed;							  // speed km/h
	BYTE                bEventAction;                     // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                     // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	DWORD               dwSnapFlagMask;                   // Snap flag(by bit),please refer to NET_RESERVED_COMMON		
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;       // The record of the database of the traffic vehicle 
	DH_RESOLUTION_INFO  stuResolution;                    // picture resolution
    NET_GPS_INFO        stuGPSInfo;                       // GPS info ,use in mobile DVR/NVR
	BYTE                bReserved[980];                   // reserved
    EVENT_COMM_INFO     stCommInfo;                       // public info 
}DEV_EVENT_TRAFFIC_VEHICLEINBUSROUTE_INFO;

//Event type  EVENT_IVS_TRAFFIC_BACKING(traffic backing)corresponding data block description info
typedef struct tagDEV_EVENT_IVS_TRAFFIC_BACKING_INFO
{
	int                 nChannelID;                       // channel ID
	char                szName[128];                      // event name
	char                bReserved1[4];                    // byte alignment
	double              PTS;                              // Time stamp(ms)
	NET_TIME_EX         UTC;                              // Event occurred time
	int                 nEventID;                         // Event ID
	DH_MSG_OBJECT       stuObject;                        // Detected object
	DH_MSG_OBJECT       stuVehicle;                       // Vehicle body info
	DH_EVENT_FILE_INFO  stuFileInfo;                      // The corresponding file info of the event
	int                 nLane;                            // Corresponding lane No.
	int					nSequence;						  // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	int					nSpeed;							  // speed km/h
	BYTE                bEventAction;                     // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                     // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	DWORD               dwSnapFlagMask;                   // Snap flag(by bit),please refer to NET_RESERVED_COMMON		
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;       // The record of the database of the traffic vehicle 
	DH_RESOLUTION_INFO  stuResolution;                    // picture resolution
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;       // intelli comm info
    NET_GPS_INFO        stuGPSInfo;                       // GPS info ,use in mobile DVR/NVR
	BYTE                bReserved[848];                  // reserved
    EVENT_COMM_INFO     stCommInfo;                       // public info 
}DEV_EVENT_IVS_TRAFFIC_BACKING_INFO;

//Event type EVENT_IVS_AUDIO_ABNORMALDETECTION(audio abnormal detection)corresponding data block description info
typedef struct tagDEV_EVENT_IVS_AUDIO_ABNORMALDETECTION_INFO
{
	int                 nChannelID;                       // channel ID
	char                szName[128];                      // event name
	char                bReserved1[4];                    // byte alignment
	double              PTS;                              // Time stamp(ms)
	NET_TIME_EX         UTC;                              // Event occurred time
	int                 nEventID;                         // Event ID
	DH_EVENT_FILE_INFO  stuFileInfo;                      // The corresponding file info of the event
	int                 nDecibel;                         // decubel
	int                 nFrequency;                       // frequency
	BYTE                bEventAction;                     // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                     // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	DWORD               dwSnapFlagMask;                   // Snap flag(by bit),please refer to NET_RESERVED_COMMON	
	DH_RESOLUTION_INFO  stuResolution;                    // picture resolution
	BYTE                bReserved[1024];                  // reserved
}DEV_EVENT_IVS_AUDIO_ABNORMALDETECTION_INFO;

//Event type  EVENT_IVS_TRAFFIC_RUNYELLOWLIGHT(traffic run yellow light)corresponding data block description info
typedef struct tagDEV_EVENT_TRAFFIC_RUNYELLOWLIGHT_INFO
{
	int					nChannelID;						  // channel ID
	char				szName[128];					  // event name
	char                bReserved1[4];                    // byte alignment
	double				PTS;							  // Time stamp(ms)
	NET_TIME_EX			UTC;				              // Event occurred time
	int					nEventID;			              // Event ID
	int					nLane;				              // Corresponding lane No.
	DH_MSG_OBJECT		stuObject;	              	      // have being detected object
	DH_MSG_OBJECT       stuVehicle;                       // Vehicle body info
	DH_EVENT_FILE_INFO  stuFileInfo;                      // The corresponding file info of the event 
	int					nLightState;	              	  // state of traffic light 0:unknown 1:green 2:red 3:yellow
	int					nSpeed;			              	  // speed km/h
	int                 nSequence;                        // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	BYTE                bEventAction;					  // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                     // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                  // Snap flag(by bit),please refer to NET_RESERVED_COMMON		
	NET_TIME_EX         stYellowLightUTC;                 // begin time of yellow light
	unsigned int        nYellowLightPeriod;               // yellow light period time (s)
	DH_RESOLUTION_INFO  stuResolution;                    // picture resolution
 	BYTE                byRedLightMargin;                 // time interval(s)
	char                szSourceDevice[MAX_PATH];         // the source device's sign(exclusive),field said local device does not exist or is empty
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;       // Traffic vehicle info
	BYTE				bReserved[1024];	              // reserved
    EVENT_COMM_INFO     stCommInfo;                       // public info 
} DEV_EVENT_TRAFFIC_RUNYELLOWLIGHT_INFO;

// Trigger mode of leaving post
typedef enum tagEM_LEAVEDETECTION_TRIGGER_MODE
{
    EM_LEAVEDETECTION_TRIGGER_UNKNOEN,          // Unknown
    EM_LEAVEDETECTION_TRIGGER_NOPERSON,         // No person
    EM_LEAVEDETECTION_TRIGGER_LEAVE,            // Leave
    EM_LEAVEDETECTION_TRIGGER_STATIC,           // Static
    EM_LEAVEDETECTION_TRIGGER_OUTPERSONLIMIT,   // Not within the allowed number of people on duty (abnormal number of people on duty)
}EM_LEAVEDETECTION_TRIGGER_MODE;

//Event type  EVENT_IVS_LEAVEDETECTION(leave check)corresponding data block description info
typedef struct tagDEV_EVENT_IVS_LEAVE_INFO
{
	int					nChannelID;						// channel ID
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// Time stamp(ms)
	NET_TIME_EX			UTC;							// Event occurred time
	int					nEventID;						// Event ID
	DH_MSG_OBJECT		stuObject;						// Detected object
	DH_EVENT_FILE_INFO  stuFileInfo;                    // The corresponding file info of the event
	DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
	int                 nDetectRegionNum;				// Rule Detect Area Top Number
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    //Rule Detect Area
	BYTE                bEventAction;                   // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelligent things info
    EM_LEAVEDETECTION_TRIGGER_MODE emTriggerMode;       // Trigger mode of leaving post
	BYTE                bReserved[890];                 // Reserved bytes.
} DEV_EVENT_IVS_LEAVE_INFO;

//Event type  EVENT_IVS_CLIMBDETECTION(climb check)corresponding data block description info
typedef struct tagDEV_EVENT_IVS_CLIMB_INFO
{
	int					nChannelID;						// channel ID
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// Time stamp(ms)
	NET_TIME_EX			UTC;							// Event occurred time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// Detected object
	DH_EVENT_FILE_INFO  stuFileInfo;                    // The corresponding file info of the event
	DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
	int                 nDetectLineNum;                 // Acme amount of the rule detect zone
	DH_POINT            DetectLine[DH_MAX_DETECT_LINE_NUM];    // Rule detect zone 
	BYTE                bEventAction;                   // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
	BYTE				byImageIndex;					// Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    unsigned int        nOccurrenceCount;               // event trigger accumilated times 
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelligent things info
    BYTE                bReserved[890];                 // Reserved bytes.
}DEV_EVENT_IVS_CLIMB_INFO;

//EVENT_IVS_MULTISCENESWITCH Event Type EVENT_IVS_MULTISCENESWITCH (multi-scene change event) corresponding to the description of the data block
typedef struct tagDEV_EVENT_IVS_MULTI_SCENE_SWICH_INFO
{
	int					nChannelID;						// (Channel number)
	char				szName[128];					// (Event name)
	char                bReserved1[4];                  // 
	double				PTS;							// (Timestamp (in milliseconds))
	NET_TIME_EX			UTC;							// (Time for the event occurred )
	int					nEventID;						// (Event ID)
	BYTE                bEventAction;                   // (Event action, 0 represents the pulse event, 1 persistent event starts, 2 persistent event ends;)
	BYTE				bReserved[1027];	            // (Reserved bytes)
} DEV_EVENT_IVS_MULTI_SCENE_SWICH_INFO;

//Event type  EVENT_IVS_TRAFFIC_PARKINGONYELLOWBOX(parking on yellow)corresponding data block description info
typedef struct tagDEV_EVENT_TRAFFIC_PARKINGONYELLOWBOX_INFO
{
	int					nChannelID;						// channel ID 
	char				szName[128];					// event name
	char                bReserved1[8];                  // byte alignment
	DWORD				PTS;							// Time stamp(ms)
	NET_TIME_EX			UTC;							// Event occurred time
	int					nEventID;						// Event ID
	int					nLane;							// Corresponding lane No.
	DH_MSG_OBJECT		stuObject;						// Detected object
	DH_MSG_OBJECT       stuVehicle;                     // Vehicle body info
	DH_EVENT_FILE_INFO  stuFileInfo;                    // The corresponding file info of the event

	int					nInterval1;						// the first and second time interval(s)
	int					nInterval2;						// 3rd and 2nd delay time, unit is second
	int					nFollowTime;					// follow time,if a car and a car before entering the pornographic websites,is less than this value,just as with car to enter, to enter the case if the parkingis not illegal

	BYTE                bEventAction;                   // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	DWORD               dwSnapFlagMask;	                // Snap flag(by bit),please refer to NET_RESERVED_COMMON		
	DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;     // Traffic vehicle info
    NET_GPS_INFO        stuGPSInfo;                     // GPS info ,use in mobile DVR/NVR
	BYTE				bReserved[984];                 // reserved
    EVENT_COMM_INFO     stCommInfo;                     // public info 
}DEV_EVENT_TRAFFIC_PARKINGONYELLOWBOX_INFO;

//Parking lot info
typedef struct tagDEV_TRAFFIC_PARKING_INFO
{
    int           nFeaturePicAreaPointNum;                  // Feature image point number 
    DH_POINT      stFeaturePicArea[DH_MAX_POLYGON_NUM];     // Feature image info
    BYTE          bReserved[572];                           // Reserved string 
}DEV_TRAFFIC_PARKING_INFO;


//Event type  EVENT_IVS_TRAFFIC_PARKINGSPACEPARKING(parking space parking)corresponding data block description info
typedef struct tagDEV_EVENT_TRAFFIC_PARKINGSPACEPARKING_INFO
{
	int					nChannelID;						// channel ID
    char                szName[DH_EVENT_NAME_LEN];      // event name
	char                bReserved1[8];                  // byte alignment
	DWORD				PTS;							// Time stamp(ms)
	NET_TIME_EX			UTC;							// Event occurred time
	int					nEventID;						// Event ID
	int					nLane;							// Corresponding lane No.
	DH_MSG_OBJECT		stuObject;						// Detected object
	DH_MSG_OBJECT       stuVehicle;                     // Vehicle body info
	DH_EVENT_FILE_INFO  stuFileInfo;                    // The corresponding file info of the event
	
	int                 nSequence;                      // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	BYTE                bEventAction;                   // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	DWORD               dwSnapFlagMask;	                // Snap flag(by bit),please refer to NET_RESERVED_COMMON	
	DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;     // Traffic vehicle info
	int                 nParkingSpaceStatus;            // Comprehensive status of parking spaces, 0-occupied, 1-empty, 2-on line
    DEV_TRAFFIC_PARKING_INFO stTrafficParingInfo;       // Traffic parking information
    BYTE                byPlateTextSource;              // The source of plate text, 0:Local,1:Server
	BYTE                byReserved2[3];                 // byte alignment
	char                szParkingNum[32];               // Parking num, SD customize project
	DWORD               dwPresetNum;                    // Preset num, SD customize project
	BOOL                bParkingFault;                  // Parking space fault status, SD customize project
	BYTE                bReserved[364];                 // Reserved 
    EVENT_COMM_INFO     stCommInfo;                     // public info 
    NET_INTELLIGENCE_IMAGE_INFO stuParkingImage;        // The image info of parking space
    BYTE			    byReserved1[1024];			    // Reserved for image info
}DEV_EVENT_TRAFFIC_PARKINGSPACEPARKING_INFO;

//Event type  EVENT_IVS_TRAFFIC_PARKINGSPACENOPARKING(parking space no parking)corresponding data block description info
typedef struct tagDEV_EVENT_TRAFFIC_PARKINGSPACENOPARKING_INFO
{
	int					nChannelID;						// channel ID
    char                szName[DH_EVENT_NAME_LEN];      // event name
	char                bReserved1[8];                  // byte alignment
	DWORD				PTS;							// Time stamp(ms)
	NET_TIME_EX			UTC;							// Event occurred time
	int					nEventID;						// Event ID
	int					nLane;							// Corresponding lane No.
	DH_MSG_OBJECT		stuObject;						// Detected object
	DH_MSG_OBJECT       stuVehicle;                     // Vehicle body info
	DH_EVENT_FILE_INFO  stuFileInfo;                    // The corresponding file info of the event
	
	int                 nSequence;                      // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	BYTE                bEventAction;                   // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	DWORD               dwSnapFlagMask;	                // Snap flag(by bit),please refer to NET_RESERVED_COMMON	
	DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;     // Traffic vehicle info
    DEV_TRAFFIC_PARKING_INFO stTrafficParingInfo;       // traffic parking information
    BYTE                byPlateTextSource;              // the source of plate text, 0:Local,1:Server
	BYTE                byReserved2[3];                 // byte alignment
	char                szParkingNum[32];               // Parking num, SD customize project
	DWORD               dwPresetNum;                    // Preset num, SD customize project
	BOOL                bParkingFault;                  // Parking space fault status, SD customize project
    BYTE                bReserved[368];                 // Reserved
    EVENT_COMM_INFO     stCommInfo;                     // public info 
    NET_INTELLIGENCE_IMAGE_INFO stuGlobalImage;         // The image info of parking no space parking                
    NET_INTELLIGENCE_IMAGE_INFO stuParkingImage;        // The image info of parking space
    BYTE			    byReserved1[1024];			    // Reserved for image info
}DEV_EVENT_TRAFFIC_PARKINGSPACENOPARKING_INFO;

// EVENT_IVS_TRAFFIC_PARKINGSPACEOVERLINE Corresponding data block description
typedef struct tagDEV_EVENT_TRAFFIC_PARKINGSPACEOVERLINE_INFO
{
	int					nChannelID;						// Channel number, 
    char                szName[DH_EVENT_NAME_LEN];      // Event name, 
	DWORD				PTS;							// Timestamp (in milliseconds), 
	NET_TIME_EX			UTC;							// The time of events, 
	int					nEventID;						// (Event ID)
	int					nLane;							// (Corresponding lane number)
	DH_MSG_OBJECT		stuObject;						// (object detected)
	DH_MSG_OBJECT       stuVehicle;                     // (Car Body Information)
	DH_EVENT_FILE_INFO  stuFileInfo;                    // Event corresponding to file information, 
	
	int                 nSequence;                      // Means capture serial number, such as 3,2,1,1 capture end, 0 indicates abnormal end, 
	BYTE                byEventAction;                  // Event action, 0 represents the pulse event, 1 means persistent event starts, 2 means persistent event ends;..., 
	BYTE				byImageIndex;					// (Serial chip, the same time (accurate to seconds) may have multiple images, starting from 0)
	BYTE                byReserved1[2];
	DWORD               dwSnapFlagMask;	                // (Grab flag (bit), see specific NET_RESERVED_COMMON)
	DH_RESOLUTION_INFO  stuResolution;                  // (the resolution of relative picture)
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;    // (Transportation Vehicle Information)
    DEV_TRAFFIC_PARKING_INFO stTrafficParingInfo;       // traffic parking information
    BYTE                byReserved[384];                // Reserved
    EVENT_COMM_INFO     stCommInfo;                     // public info 
}DEV_EVENT_TRAFFIC_PARKINGSPACEOVERLINE_INFO;

// EVENT_IVS_TRAFFIC_TURNLEFTAFTERSTRAIGHT (turn left not give precedence to straight)corresponding data block description info
typedef struct tagDEV_EVENT_TURNLEFTAFTERSTRAIGHT_INFO
{
	int                 nChannelID;                                 // channel ID
    char                szName[DH_EVENT_NAME_LEN];                  // event name
    char                Reserved[4];                                // byte alignment    
    double              PTS;                                        // Time stamp(ms)
    NET_TIME_EX         UTC;                                        // Event occurred time
    DWORD               nEventID;                                   // Event ID
	DH_EVENT_FILE_INFO  stuFileInfo;                                // Event corresponding to file information
    DH_MSG_OBJECT       stuObject;                                  // plate info
    DH_MSG_OBJECT       stuVehicle;                                 // car body info
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO   stTrafficCar;               // Traffic car info
    int                 nLane;                                      // Corresponding lane number
    int                 nSequence;                                  // snap index,such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
    BYTE                byEventAction;                              // Event action, 0 represents the pulse event, 1 means persistent event starts, 2 means persistent event ends
	BYTE				byImageIndex;					            // (Serial chip, the same time (accurate to seconds) may have multiple images, starting from 0)
	BYTE                byReserved1[2];
	DWORD               dwSnapFlagMask;	                            // (Grab flag (bit), see specific NET_RESERVED_COMMON)
	DH_RESOLUTION_INFO  stuResolution;                              // (the resolution of relative picture)
    NET_GPS_INFO        stuGPSInfo;                                 // GPS info ,use in mobile DVR/NVR
	BYTE                byReserved[984];                            // Reserved
	EVENT_COMM_INFO     stCommInfo;                                 // public info 
}DEV_EVENT_TURNLEFTAFTERSTRAIGHT_INFO;

// EVENT_IVS_TRAFFIC_BIGBENDSMALLTURN (small turn on big bend)corresponding data block description info
typedef struct tagDEV_EVENT_BIGBENDSMALLTURN_INFO
{
	int                 nChannelID;                                 // channel ID
    char                szName[DH_EVENT_NAME_LEN];                  // event name
    char                Reserved[4];                                // byte alignment    
    double              PTS;                                        // Time stamp(ms)
    NET_TIME_EX         UTC;                                        // Event occurred time
    DWORD               nEventID;                                   // Event ID
	DH_EVENT_FILE_INFO  stuFileInfo;                                // Event corresponding to file information
    DH_MSG_OBJECT       stuObject;                                  // plate info
    DH_MSG_OBJECT       stuVehicle;                                 // car body info
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO   stTrafficCar;               // Traffic car info
    int                 nLane;                                      // Corresponding lane number
    int                 nSequence;                                  // snap index,such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
    BYTE                byEventAction;                              // Event action, 0 represents the pulse event, 1 means persistent event starts, 2 means persistent event ends
	BYTE				byImageIndex;					            // (Serial chip, the same time (accurate to seconds) may have multiple images, starting from 0)
	BYTE                byReserved1[2];
	DWORD               dwSnapFlagMask;	                            // (Grab flag (bit), see specific NET_RESERVED_COMMON)
	DH_RESOLUTION_INFO  stuResolution;                              // (the resolution of relative picture)
	BYTE                byReserved[1024];                           // Reserved
	EVENT_COMM_INFO     stCommInfo;                                 // public info 
}DEV_EVENT_BIGBENDSMALLTURN_INFO;

// EVENT_IVS_ROAD_CONSTRUCTION (Event of road construction inspection) corresponding data block description info
typedef struct tagDEV_EVENT_ROAD_CONSTRUCTION_INFO
{
	int                 nChannelID;                                 // channel ID
    char                szName[DH_EVENT_NAME_LEN];                  // event name
    char                Reserved[4];                                // byte alignment   
    double              PTS;                                        // Time stamp(ms)
    NET_TIME_EX         UTC;                                        // Event occurred time
    DWORD               nEventID;                                   // Event ID
    int                 nEventAction;                               // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
	EM_CLASS_TYPE		emClassType;								// class type
	DH_RECT				stuBoudingBox;								// the bouding box of construction location,0-8192
	BYTE                byReserved[512];                            // Reserved
} DEV_EVENT_ROAD_CONSTRUCTION_INFO;


// EVENT_IVS_ROAD_BLOCK (Event of road block  detection) corresponding data block description info
typedef struct tagDEV_EVENT_ROAD_BLOCK_INFO
{
	int                 nChannelID;                                 // channel ID
    char                szName[DH_EVENT_NAME_LEN];                  // event name
    char                Reserved[4];                                // byte alignment     
    double              PTS;                                        // Time stamp(ms)
    NET_TIME_EX         UTC;                                        // Event occurred time
    DWORD               nEventID;                                   // Event ID
    int                 nEventAction;                               // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
	EM_CLASS_TYPE		emClassType;								// class type
	DH_RECT				stuBoudingBox;								// the bouding box of roadblock location, 0-8192
	BYTE                byReserved[512];                            // Reserved
} DEV_EVENT_ROAD_BLOCK_INFO;

// EVENT_IVS_INSTALL_CARDREADER (install card reader event) corresponding data block description info
typedef struct tagDEV_EVENT_INSTALL_CARDREADER_INFO
{
    int                 nChannelID;									// Channel id
    char                szName[128];								// Event name
    char                Reserved[4];								// Byte alignment
    double              PTS;										// Time stamp(ms)
    NET_TIME_EX         UTC;										// Event occurred time
    int                 nEventID;									// Event ID        
    BYTE                byReserved[1024];							// Reserve,for extension
}DEV_EVENT_INSTALL_CARDREADER_INFO;

// EVENT_IVS_ACC_OFF_SNAP (Vehicle equipment's ACC off snap event) corresponding data block description info
typedef struct tagDEV_EVENT_ACC_OFF_SNAP_INFO
{
    int                 nChannelID;									// Channel id
    char                szName[128];								// Event name
    char                Reserved[4];								// Byte alignment
    double              PTS;										// Time stamp(ms)
    NET_TIME_EX         UTC;										// Event occurred time
    int                 nEventID;									// Event ID        
    BYTE                byReserved[1024];							// Reserve,for extension
}DEV_EVENT_ACC_OFF_SNAP_INFO;

// danger grade
typedef enum tagEM_DANGER_GRADE_TYPE
{
	EM_DANGER_GRADE_UNKNOWN = -1,	// unknown
	EM_DANGER_GRADE_NORMAL,			// normal
	EM_DANGER_GRADE_WARN,			// warn
	EM_DANGER_GRADE_DANGER,			// danger
} EM_DANGER_GRADE_TYPE;

// package info
typedef struct tagNET_PACKAGE_INFO
{
	EM_DANGER_GRADE_TYPE	emDangerGrade;			// danger grade of the package, highest danger grade is displayed if the package has multiple danger grades
	BYTE            		byReserved[128];		// Reserve,for extension
} NET_PACKAGE_INFO;

// the type of inside object
typedef enum tagEM_INSIDE_OBJECT_TYPE
{
	EM_INSIDE_OBJECT_UNKNOWN,		            // unknown
	EM_INSIDE_OBJECT_KNIFE,			            // Knife
	EM_INSIDE_OBJECT_BOTTLELIQUID,	            // BottleLiquid
	EM_INSIDE_OBJECT_GUN,			            // Gun
	EM_INSIDE_OBJECT_UMBRELLA,		            // Umbrella
	EM_INSIDE_OBJECT_PHONE,			            // Phone
	EM_INSIDE_OBJECT_NOTEBOOK,		            // Notebook
	EM_INSIDE_OBJECT_POWERBANK,		            // Powerbank
	EM_INSIDE_OBJECT_SHOES,			            // Shoes
	EM_INSIDE_OBJECT_ROD,			            // Rod
	EM_INSIDE_OBJECT_METAL,			            // Metal
	EM_INSIDE_OBJECT_EXPLOSIVE,		            // Explosive
	EM_INSIDE_OBJECT_CONTAINERSPRAY,			// ContainerSpray
    EM_INSIDE_OBJECT_EXPLOSIVE_FIREWORKS,		// ExplosiveFireworks
    EM_INSIDE_OBJECT_LIGHTER,					// Lighter
    EM_INSIDE_OBJECT_STICK,						// Stick
    EM_INSIDE_OBJECT_BRASSKNUCKLE,				// Brassknuckle
    EM_INSIDE_OBJECT_HANDCUFFS,					// Handcuffs
    EM_INSIDE_OBJECT_IVORY,						// Ivory
    EM_INSIDE_OBJECT_BOOK,						// Book
    EM_INSIDE_OBJECT_CD,						// CD
    EM_INSIDE_OBJECT_HAMMERS,					// Hammers
    EM_INSIDE_OBJECT_PLIERS,					// Pliers
    EM_INSIDE_OBJECT_AXE,						// Axe
    EM_INSIDE_OBJECT_SCREW_DRIVER,				// Screwdriver
    EM_INSIDE_OBJECT_WRENCH,					// Wrench
    EM_INSIDE_OBJECT_ELECTRIC_SHOCK_STICK,		// Electric shock stick 
} EM_INSIDE_OBJECT_TYPE;

// inside object info
typedef struct tagNET_INSIDE_OBJECT
{
	EM_DANGER_GRADE_TYPE	emDangerGrade;			// danger grade
	EM_INSIDE_OBJECT_TYPE	emObjType;				// inside object type
	UINT					nSimilarity;			// Similarity
	NET_RECT             	stuBoundingBox;         // bounding Box
	BYTE            		byReserved[108];			// Reserve,for extension
} NET_INSIDE_OBJECT;

// Image type of X Ray machine
typedef enum tagEM_XRAY_IMAGE_TYPE
{
	EM_XRAY_IMAGE_TYPE_UNKNOWN = -1,								// unknown type
	EM_XRAY_IMAGE_TYPE_COLOR,										// color
	EM_XRAY_IMAGE_COLOR_TYPE_OVERLAY,								// overlay
}EM_XRAY_IMAGE_TYPE;

// View type of X Ray machine
typedef enum tagEM_XRAY_VIEW_TYPE
{
	EM_XRAY_VIEW_TYPE_UNKNOWN = -1,									// unknown type
	EM_XRAY_VIEW_TYPE_MASTER,										// master view
	EM_XRAY_VIEW_TYPE_SLAVE,										// slave view
}EM_XRAY_VIEW_TYPE;

// Image info of X Ray machine 
typedef struct tagNET_XRAY_IMAGE_INFO
{
	EM_XRAY_VIEW_TYPE		emViewType;								// view type
	EM_XRAY_IMAGE_TYPE		emImageType;							// image type
	unsigned int			nOffset;								// picture offset in binary data
	unsigned int			nLength;								// picture size,unit:byte
	BYTE					byReserved[1024];						// reserved
}NET_XRAY_IMAGE_INFO;

// Customer-defined information. It is used for X-ray.
typedef struct tagNET_XRAY_CUSTOM_INFO
{
    EM_XRAY_VIEW_TYPE               emViewType;             // View type
    char                            szSerialNumber[128];    // Serial number
    BYTE                            byReserved[124];        // Reserved
} NET_XRAY_CUSTOM_INFO;

// EVENI_IVS_XRAY_DETECTION (X ray detection event) corresponding data block description info
typedef struct tagDEV_EVENT_XRAY_DETECTION_INFO
{
    int                 nChannelID;                                 // Channel id
    char                szName[128];                                // Event name
    char                Reserved[4];                                // Byte alignment
    double              PTS;                                        // Time stamp(ms)
    NET_TIME_EX         UTC;                                        // Event occurred time
    int                 nEventID;                                   // Event ID  
    EM_CLASS_TYPE       emClassType;                                // class type
    NET_PACKAGE_INFO    stuPacketInfo;                              // package info
    char                Reserved1[4];                               // Byte alignment
    UINT                nObjectNum;                                 // the count of inside object in master view
    NET_INSIDE_OBJECT   stuInsideObj[MAX_INSIDEOBJECT_NUM];         // inside objects info in master view
    UINT                nSlaveViewObjectNum;                        // the count of inside object in slave view
    NET_INSIDE_OBJECT   stuSlaveViewInsideObj[MAX_INSIDEOBJECT_NUM];// inside objects info in slave view
    UINT                nImageCount;                                // image count
    NET_XRAY_IMAGE_INFO stuImageInfo[8];	                        // image info
    UINT                nViewCustomInfoNum;                         // Count of Customer-defined information
    NET_XRAY_CUSTOM_INFO    stuViewCustomInfo[4];                   // Customer-defined information. It is used for X-ray.
    BYTE                byReserved[1020];                           // Reserve,for extension
} DEV_EVENT_XRAY_DETECTION_INFO;

// EVENT_IVS_NOTCLEARCAR(Not clear car event)corresponding data block description info
typedef struct tagDEV_EVENT_NOTCLEARCAR_INFO
{
	int					nChannelID;									// Channel id
	NET_TIME_EX         UTC;                                        // Event occurred time
	BYTE                byEventAction;								// Event action, 0 represents the pulse event, 1 means persistent event starts, 2 means persistent event ends
	BYTE                byImageIndex;                               // (Serial chip, the same time (accurate to seconds) may have multiple images, starting from 0)
	BYTE                byReserved1[2];
	DWORD               dwSnapFlagMask;                             // (Grab flag (bit), see specific NET_RESERVED_COMMON)
	DH_RESOLUTION_INFO  stuResolution;                              // (the resolution of relative picture)
	BYTE				byReserved[1024];                           // Reserved
	EVENT_COMM_INFO     stCommInfo;                                 // public info 
}DEV_EVENT_NOTCLEARCAR_INFO;

// EVENT_IVS_SOSALEART(SOSAlert)corresponding data block description info
typedef struct tagDEV_EVENT_SOSALEART_INFO
{
	int					nChannelID;									// Channel id
	NET_TIME_EX         UTC;                                        // Event occurred time
	BYTE                byEventAction;								// Event action, 0 represents the pulse event, 1 means persistent event starts, 2 means persistent event ends
	BYTE                byImageIndex;                               // (Serial chip, the same time (accurate to seconds) may have multiple images, starting from 0)
	BYTE                byReserved1[2];
	DWORD               dwSnapFlagMask;                             // (Grab flag (bit), see specific NET_RESERVED_COMMON)
	DH_RESOLUTION_INFO  stuResolution;                              // (the resolution of relative picture)
	BYTE				byReserved[1024];                           // Reserved
	EVENT_COMM_INFO     stCommInfo;                                 // public info 
}DEV_EVENT_SOSALEART_INFO;

// EVENT_IVS_OVERLOAD(OverLoad)corresponding data block description info
typedef struct tagDEV_EVENT_OVERLOAD_INFO
{
	int					nChannelID;									// channel ID
	NET_TIME_EX         UTC;                                        // Event occurred time
	BYTE                byEventAction;								// Event action, 0 represents the pulse event, 1 means persistent event starts, 2 means persistent event ends
	BYTE                byImageIndex;                               // (Serial chip, the same time (accurate to seconds) may have multiple images, starting from 0)
	BYTE                byReserved1[2];
	DWORD               dwSnapFlagMask;                             // (Grab flag (bit), see specific NET_RESERVED_COMMON)
	DH_RESOLUTION_INFO  stuResolution;                              // (the resolution of relative picture)
	BYTE				byReserved[1024];                           // Reserved
	EVENT_COMM_INFO     stCommInfo;                                 // public info 
}DEV_EVENT_OVERLOAD_INFO;

// EVENT_IVS_NONWORKINGTIME(NonWorkingTime)corresponding data block description info
typedef struct tagDEV_EVENT_NONWORKINGTIME_INFO
{
	int					nChannelID;									// channel ID
	NET_TIME_EX         UTC;                                        // Event occurred time
	BYTE                byEventAction;								// Event action, 0 represents the pulse event, 1 means persistent event starts, 2 means persistent event ends
	BYTE                byImageIndex;                               // (Serial chip, the same time (accurate to seconds) may have multiple images, starting from 0)
	BYTE                byReserved1[2];
	DWORD               dwSnapFlagMask;                             // (Grab flag (bit), see specific NET_RESERVED_COMMON)
	DH_RESOLUTION_INFO  stuResolution;                              // (the resolution of relative picture)
	BYTE				byReserved[1024];                           // Reserved
	EVENT_COMM_INFO     stCommInfo;                                 // public info 
}DEV_EVENT_NONWORKINGTIME_INFO;

// EVENT_IVS_TRAFFIC_HIGH_BEAM(traffic high beam)corresponding data block description info
typedef struct tagDEV_EVENT_TRAFFIC_HIGH_BEAM_INFO
{
	int					nChannelID;									// Channel ID
	char				szName[DH_EVENT_NAME_LEN];					// Event name
	BYTE				byReserved1[4];								// Reserved
	double              PTS;                                        // Time stamp,Unit:ms
	int					nEventID;                                   // Event ID
	NET_TIME_EX         UTC;                                        // Event occurred time
	DH_EVENT_FILE_INFO  stuFileInfo;                                // Event corresponding to file information
	BYTE                byImageIndex;                               // Serial chip, the same time (accurate to seconds) may have multiple images, starting from 0
	BYTE                byReserved2[3];								// Reserved
	DH_MSG_OBJECT       stuObject;                                  // Plate info
	DH_MSG_OBJECT       stuVehicle;                                 // Car body info
	int					nLane;										// Corresponding lane number
	int					nSequence;									// Capture end status,3/2/1 means capture ends normally,0 means capture ends abnormal
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO   stuTrafficCar;              // Traffic car info
	DWORD               dwSnapFlagMask;                             // Grab flag (bit), see specific NET_RESERVED_COMMON
	DH_RESOLUTION_INFO  stuResolution;                              // the resolution of relative picture
	EVENT_COMM_INFO     stuCommInfo;                                // public info 
	BYTE				byReserved[1024];                           // Reserved
}DEV_EVENT_TRAFFIC_HIGH_BEAM_INFO;

// EVENT_IVS_TRAFFIC_TRUCKFORBID(truck forbid)corresponding data block description info
typedef struct tagDEV_EVENT_TRAFFICTRUCKFORBID_INFO
{
	int					nChannel;									// channel ID
	char				szName[DH_EVENT_NAME_LEN];					// enent name
	int					nGroupID;									// Event group ID,A detection of multiple human characteristics at the same nGroupID
	int					nCountInGroup;								// nCountInGroup snap amount of one event group
	int					nIndexInGroup;								// IndexInGroup snap SN of one event group 
    double              PTS;                                        // Time stamp(ms)
	NET_TIME_EX         UTC;                                        // Event occurred time
	int					UTCMS;										// Millisecond
    int		            nEventID;                                   // Event ID
	DH_MSG_OBJECT		stuObject;									// plate info
	DH_MSG_OBJECT       stuVehicle;                                 // car body info
	int					nLane;										// Corresponding lane number
    int                 nSequence;                                  // snap index,such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO   stTrafficCar;               // Traffic car info
	EVENT_COMM_INFO     stCommInfo;                                 // public info
	DH_EVENT_FILE_INFO	stuFileInfo;								// Event corresponding to file information
	DWORD               dwSnapFlagMask;                             // Grab flag (bit), see specific NET_RESERVED_COMMON
	DH_RESOLUTION_INFO	stuResolution;								// the resolution of relative picture
	BYTE                byReserved[1016];                           // Reserved
} DEV_EVENT_TRAFFICTRUCKFORBID_INFO;

// EVENT_IVS_DRIVINGWITHOUTCARD(Driving without card)corresponding data block description info
typedef struct tagDEV_EVENT_DRIVINGWITHOUTCARD_INFO
{
	int                 nChannelID;                                 // Channel ID
	BYTE                byEventAction;								// Event action, 0 represents the pulse event, 1 means persistent event starts, 2 means persistent event ends
	BYTE                byReserved[3];								// Reserved 
	double              PTS;                                        // Time stamp(ms)
	NET_TIME_EX         UTC;                                        // Event occurred time
	DWORD				nEventID;									// Event ID
	BYTE				byReserved1[1024];                          // Reserved
}DEV_EVENT_DRIVINGWITHOUTCARD_INFO;

// EVENT_IVS_HIGHSPEED(HighSpeed)corresponding data block description info
typedef struct tagDEV_EVENT_HIGHSPEED_INFO
{
	int								nChannelID;                     // Channel ID
	int                             nAction;                   		// Action,1 means persistent event starts, 2 means persistent event ends
	NET_TIME_EX			            UTC;							// Event occurred time
	BYTE							byReserved[4];					// Reserved
	double				            dbPTS;							// Time stamp(ms)
	NET_GPS_STATUS_INFO 			stGPSStatusInfo;                // GPS info
	int								nSpeedLimit;					// Speed limit(km/h)
	int								nCurSpeed;						// Current speed(km/h)
	int								nMaxSpeed;					    // Max speed(Km/h)
	NET_TIME_EX						stuStartTime;					// Start time(Vehicle custom demand),when nAction is 2,report this field
	BYTE                			byReserved1[1024];       		// Reserved
}DEV_EVENT_HIGHSPEED_INFO;

// Crowd list info(circular description)
typedef struct tagNET_CROWD_LIST_INFO
{
	DH_POINT			stuCenterPoint;				// Center point
	unsigned int		nRadiusNum;					// Radius num
	BYTE				byReserved[1024];			// Reserved
}NET_CROWD_LIST_INFO;

// Region list info
typedef struct tagNET_REGION_LIST_INFO
{	
	unsigned int		nRegionID;				// Region ID
	unsigned int		nPeopleNum;				// People num
	BYTE				byReserved[1024];		// Reserved
}NET_REGION_LIST_INFO;

// Alarm type
typedef enum tagEM_ALARM_TYPE
{
	EM_ALARM_TYPE_UNKNOWN,								// Unknown
	EM_ALARM_TYPE_CROWD_DENSITY,						// Crowd density alarm
	EM_ALARM_TYPE_NUMBER_EXCEED,						// the people number exceeds alarm
	EM_ALARM_TYPE_CROWD_DENSITY_AND_NUMBER_EXCEED,		// Crowd density alarm and the number exceeds alarm
}EM_ALARM_TYPE;

#define RECT_POINT                2              // two point repressnting a rectangle
#define MAX_CROWD_RECT_LIST       5              // max number of rect description

// crowd list info(rect description)
typedef struct tagNET_CROWD_RECT_LIST_INFO
{
    DH_POINT			stuRectPoint[RECT_POINT];   // rect point (upper left point and lower right point), rect of crowd
    BYTE				byReserved[32];			    // Reserved
}NET_CROWD_RECT_LIST_INFO;

// EVENT_IVS_CROWDDETECTION(CrowdDetection)corresponding data block description info
typedef struct tagDEV_EVENT_CROWD_DETECTION_INFO
{
    int					  nChannelID;							// Channel ID
    int					  nEventID;								// Event ID
    double				  PTS;									// Time stamp (Unit:ms)
    NET_TIME_EX			  UTC;									// Event occurrence time 
    int                   nEventAction;							// Event action,1 means continues event start,2 means continuous event stop
    EM_ALARM_TYPE		  emAlarmType;							// Alarm Type
    char				  szName[MAX_CROWD_DETECTION_NAME_LEN];	// Event name
    int					  nCrowdListNum;						// Crowd list num (circular description)
    int					  nRegionListNum;						// Region list num
    NET_CROWD_LIST_INFO	  stuCrowdList[MAX_CROWD_LIST_NUM];		// Crowd list info(circular description)
    NET_REGION_LIST_INFO  stuRegionList[MAX_REGION_LIST_NUM];	// Region list info
    NET_EXTENSION_INFO    stuExtensionInfo;				        // Extension info
    int					  nCrowdRectListNum;					// Crowd list num (rect description)
    NET_CROWD_RECT_LIST_INFO stuCrowdRectList[MAX_CROWD_RECT_LIST];  // Crowd list info(rect description)
    BYTE				  byReserved[692];	                    // Reserved
}DEV_EVENT_CROWD_DETECTION_INFO;

// EVENT_IVS_TRAFFIC_CARDISTANCESHORT (TrafficCarDistanceShort)corresponding data block description info
typedef struct tagDEV_EVENT_TRAFFIC_CARDISTANCESHORT_INFO
{
	int                 nChannelID;											// Channel ID
	BYTE				byReserved[4];										// Reserved
	char				szName[MAX_EVENT_NAME_LEN];							// Event name
	double				dbPTS;												// Time stamp(ms)
	NET_TIME_EX			UTC;												// Event occurred time
	int					nEventID;											// Event ID
	DH_MSG_OBJECT		stuObject;											// Plate info
	DH_MSG_OBJECT       stuVehicle;											// Car body info
	int					nLane;												// Corresponding lane number
	int                 nSequence;											// Snap index,such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO   stTrafficCar;						// Traffic car info
	DH_EVENT_FILE_INFO	stuFileInfo;										// Event corresponding to file information
	BYTE                byReserved1[1024];									// Reserved
	EVENT_COMM_INFO     stCommInfo;											// Public info
}DEV_EVENT_TRAFFIC_CARDISTANCESHORT_INFO;

// EVENT_IVS_TRAFFIC_QUEUEJUMP (car jump a queue) corresponding data block description info
typedef struct tagDEV_EVENT_TRAFFIC_QUEUEJUMP_INFO
{
	int                 nChannelID;                                 // channel ID
    char                szName[DH_EVENT_NAME_LEN];                  // event name
    char                Reserved[4];                                // byte alignment    
    double              PTS;                                        // Time stamp(ms)
    NET_TIME_EX         UTC;                                        // Event occurred time
    DWORD               nEventID;                                   // Event ID
	DH_EVENT_FILE_INFO  stuFileInfo;                                // Event corresponding to file information
    DH_MSG_OBJECT       stuObject;                                  // plate info
    DH_MSG_OBJECT       stuVehicle;                                 // car body info
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO   stTrafficCar;               // Traffic car info
    int                 nLane;                                      // Corresponding lane number
    int                 nSequence;                                  // snap index,such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
    BYTE                byEventAction;                              // Event action, 0 represents the pulse event, 1 means persistent event starts, 2 means persistent event ends
	BYTE				byImageIndex;					            // (Serial chip, the same time (accurate to seconds) may have multiple images, starting from 0)
	BYTE                byReserved1[2];
	DWORD               dwSnapFlagMask;	                            // (Grab flag (bit), see specific NET_RESERVED_COMMON)
	DH_RESOLUTION_INFO  stuResolution;                              // (the resolution of relative picture)
	EVENT_COMM_INFO     stCommInfo;                                 // public info 
	BYTE                byReserved[1024];                           // Reserved
} DEV_EVENT_TRAFFIC_QUEUEJUMP_INFO;

// EVENT_IVS_PEDESTRIAN_JUNCTION (pedestrian junction Event) corresponding data block description info
typedef struct tagDEV_EVENT_PEDESTRIAN_JUNCTION_INFO
{
	int					nChannelID;									// channel ID
	char				szName[DH_EVENT_NAME_LEN];					// evnet name 
	int					nGroupID;									// nGroupID event group ID. The nGroupID is the same for the snap process of the same object 
	int					nCountInGroup;								// nCountInGroup snap amount of one event group 
	int					nIndexInGroup;								// capture Index of an event group,starting from 1
	double				PTS;										// Time stamp(ms)
	NET_TIME_EX			UTC;										// Event occurred time
	int					UTCMS;										// Millisecond
	int					nEventID;									// Event ID
	DH_EVENT_FILE_INFO  stuFileInfo;                                // Event corresponding to file information
	DH_MSG_OBJECT		stuObject;									// face information
	int					nLane;										// Sidewalk number	
	int					nSequence;									// snap index,such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	BYTE				byReserved[1024];							// Reserved
} DEV_EVENT_PEDESTRIAN_JUNCTION_INFO;

// EVENT_IVS_VEHICLE_SUSPICIOUSCAR (Suspicious car) corresponding data block description info
typedef struct tagDEV_EVENT_VEHICLE_SUSPICIOUSCAR_INFO
{
    int                 nChannelID;                                 // channel ID
    char                szName[DH_EVENT_NAME_LEN];                  // event name
    char                Reserved[4];                                // byte alignment    
    double              PTS;                                        // Time stamp(ms)
    NET_TIME_EX         UTC;                                        // Event occurred time
    DWORD               nEventID;                                   // Event ID
    DH_EVENT_FILE_INFO  stuFileInfo;                                // Event corresponding to file information
    DH_MSG_OBJECT       stuObject;                                  // plate info
    DH_MSG_OBJECT       stuVehicle;                                 // car body info
    int                 nSequence;                                  // snap index,such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
    BYTE                byEventAction;                              // Event action, 0 represents the pulse event, 1 means persistent event starts, 2 means persistent event ends
    BYTE                byImageIndex;                               // (Serial chip, the same time (accurate to seconds) may have multiple images, starting from 0)
    BYTE                byReserved1[2];                             // Reserved
    DWORD               dwSnapFlagMask;                             // (Grab flag (bit), see specific NET_RESERVED_COMMON) 
    DH_RESOLUTION_INFO  stuResolution;                              // (the resolution of relative picture)
    NET_GPS_INFO        stuGPSInfo;                                 // GPS info ,use in mobile DVR/NVR
    BYTE                byReserved[4096];                           // Reserved
}DEV_EVENT_VEHICLE_SUSPICIOUSCAR_INFO;

// Pedestrain info
typedef struct tagEVENT_VEHICLE_INFO
{
	char				szCategory[MAX_CATEGORY_LEN];				// Object type,Passerby mean pedestrain
	BYTE				byReserved[64];								// Reserved			
}EVENT_VEHICLE_INFO;

//Event type  EVENT_IVS_TRAFFIC_PEDESTRAIN(pedestrain)corresponding data block description info
typedef struct tagDEV_EVENT_TRAFFIC_PEDESTRAIN_INFO
{
    int                 nChannelID;                     // channel ID
    char                szName[DH_EVENT_NAME_LEN];      // event name
    char                bReserved1[8];                  // byte alignment
    DWORD               PTS;                            // Time stamp(ms)
    NET_TIME_EX         UTC;                            // Event occurred time
    int                 nEventID;                       // Event ID
    DH_EVENT_FILE_INFO  stuFileInfo;                    // The corresponding file info of the event
    DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
    DWORD               dwSnapFlagMask;                 // Snap flag(by bit)0 bit:"*",1 bit:"Timing",2 bit:"Manual",3 bit:"Marked",4 bit:"Event",5 bit:"Mosaic",6 bit:"Cutout" 
    BYTE                bEventAction;                   // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
    BYTE                bReserved2[2];
	BYTE				byImageIndex;					// Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    int                 nLane;                          // Corresponding lane No.
    DH_MSG_OBJECT       stuObject;                      // Detected object
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelli comm info
    EVENT_TRAFFIC_CAR_PART_INFO   stuTrafficCarPartInfo;   // part of traffic car info
	EVENT_VEHICLE_INFO	stuVehicle;						// pedestrain info
    BYTE                bReserved[252];                 // reserved
    EVENT_COMM_INFO     stCommInfo;                     // public info 
}DEV_EVENT_TRAFFIC_PEDESTRAIN_INFO;

//Event type  EVENT_IVS_TRAFFIC_THROW(throw)corresponding data block description info
typedef struct tagDEV_EVENT_TRAFFIC_THROW_INFO
{
    int                 nChannelID;                     // channel ID
    char                szName[DH_EVENT_NAME_LEN];      // event name
    char                bReserved1[8];                  // byte alignment
    DWORD               PTS;                            // Time stamp(ms)
    NET_TIME_EX         UTC;                            // Event occurred time
    int                 nEventID;                       // Event ID
    DH_EVENT_FILE_INFO  stuFileInfo;                    // The corresponding file info of the event
    DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
    DWORD               dwSnapFlagMask;                 // Snap flag(by bit)0 bit:"*",1 bit:"Timing",2 bit:"Manual",3 bit:"Marked",4 bit:"Event",5 bit:"Mosaic",6 bit:"Cutout" 
    BYTE                bEventAction;                   // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
    BYTE                bReserved2[2];
	BYTE				byImageIndex;					// Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    int                 nLane;                          // Corresponding lane No.
    DH_MSG_OBJECT       stuObject;                      // Detected object
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelligent things info
    EVENT_TRAFFIC_CAR_PART_INFO   stuTrafficCarPartInfo;// part of traffic car info
    NET_GPS_INFO        stuGPSInfo;                     // GPS info ,use in mobile DVR/NVR
    BYTE                bReserved[340];                 // reserved 
    EVENT_COMM_INFO     stCommInfo;                     // public info 
}DEV_EVENT_TRAFFIC_THROW_INFO;

//Event type  EVENT_IVS_TRAFFIC_IDLE(idle)corresponding data block description info
typedef struct tagDEV_EVENT_TRAFFIC_IDLE_INFO
{
    int                 nChannelID;                     // channel ID
    char                szName[DH_EVENT_NAME_LEN];      // event name
    char                bReserved1[8];                  // byte alignment
    DWORD               PTS;                            // Time stamp(ms)
    NET_TIME_EX         UTC;                            // Event occurred time
    int                 nEventID;                       // Event ID
    DH_EVENT_FILE_INFO  stuFileInfo;                    // The corresponding file info of the event
    DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
    DWORD               dwSnapFlagMask;                 // Snap flag(by bit)0 bit:"*",1 bit:"Timing",2 bit:"Manual",3 bit:"Marked",4 bit:"Event",5 bit:"Mosaic",6 bit:"Cutout" 
    BYTE                bEventAction;                   // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
    BYTE                bReserved2[2];
	BYTE				byImageIndex;					// Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    int                 nLane;                          // Corresponding lane No.
    BYTE                bReserved[1024];                // reserved
    EVENT_COMM_INFO     stCommInfo;                     // public info 
}DEV_EVENT_TRAFFIC_IDLE_INFO;

// Event type EVENT_IVS_TRAFFIC_TURNRIGHTAFTERSTRAIGHT(Turn right to make a straight event)
typedef struct tagDEV_EVENT_TURNRIGHTAFTERSTRAIGHT_INFO
{
	int                 nChannelID;									// Channel ID
	char				szName[DH_EVENT_NAME_LEN];					// Event name
	char				bReserved[4];								// Reserved
	double				dPTS;										// Timestamp (in milliseconds)
	NET_TIME_EX			stuUTC;										// Event occurred time
	int					nEventID;									// Event ID
	DH_EVENT_FILE_INFO  stuFileInfo;                                // The corresponding file info of the event
	DH_MSG_OBJECT       stuObject;                                  // Detected object
	DH_MSG_OBJECT       stuVehicle;                                 // Pedestrain info   
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO   stTrafficCar;               // Traffic car info
	int					nLane;										// Corresponding lane No.
	int					nSequence;									// Snap index,such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	BYTE                byEventAction;                              // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
	BYTE                byImageIndex;                               // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	BYTE                byReserved1[2];
	DWORD               dwSnapFlagMask;                             // Snap flag(by bit)0 bit:"*",1 bit:"Timing",2 bit:"Manual",3 bit:"Marked",4 bit:"Event",5 bit:"Mosaic",6 bit:"Cutout"     
	DH_RESOLUTION_INFO  stuResolution;                              // picture resolution
	BYTE				byReserved[1012];							// Reserved
	EVENT_COMM_INFO     stCommInfo;                                 // Public info 
}DEV_EVENT_TURNRIGHTAFTERSTRAIGHT_INFO;

// Event type EVENT_IVS_TRAFFIC_TURNRIGHTAFTERPEOPLE(Turn right and go straight to pedestrians)
typedef struct tagDEV_EVENT_TURNRIGHTAFTERPEOPLE_INFO
{
	int                 nChannelID;									// Channel ID
	char				szName[DH_EVENT_NAME_LEN];					// Event name
	char				bReserved[4];								// Reserved
	double				dPTS;										// Timestamp (in milliseconds)
	NET_TIME_EX			stuUTC;										// Event occurred time
	int					nEventID;									// Event ID
	DH_EVENT_FILE_INFO  stuFileInfo;                                // The corresponding file info of the event
	DH_MSG_OBJECT       stuObject;                                  // Detected object
	DH_MSG_OBJECT       stuVehicle;                                 // Pedestrain info
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO   stTrafficCar;               // Traffic car info
	int					nLane;										// Corresponding lane No.
	int					nSequence;									// Snap index,such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	BYTE                byEventAction;                              // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
	BYTE                byImageIndex;                               // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	BYTE                byReserved1[2];
	DWORD               dwSnapFlagMask;                             // Snap flag(by bit)0 bit:"*",1 bit:"Timing",2 bit:"Manual",3 bit:"Marked",4 bit:"Event",5 bit:"Mosaic",6 bit:"Cutout"     
	DH_RESOLUTION_INFO  stuResolution;                              // picture resolution
	BYTE				byReserved[1012];							// Reserved
	EVENT_COMM_INFO     stCommInfo;                                 // Public info 
}DEV_EVENT_TURNRIGHTAFTERPEOPLE_INFO;

#define MAX_DRIVING_DIR_NUM          16                             //  lane direction max quantity

// direction
typedef enum tagNET_FLOWSTAT_DIRECTION
{
	DRIVING_DIR_UNKNOW = 0 ,		// (Before compatible)
	DRIVING_DIR_APPROACH ,			// (Uplink, the vehicle away from the device deployment point is getting closer)
	DRIVING_DIR_LEAVE ,				// (Go down, that the vehicle is farther away from  equipment deployment point)
}NET_FLOWSTAT_DIRECTION;

// road direction
typedef enum tagNET_ROAD_DIRECTION
{
    ROAD_DIR_UNKNOW,             // unknown  
    ROAD_DIR_TURNLEFT,           // left turn 
    ROAD_DIR_TURNRIGHT,          // right turn
    ROAD_DIR_STRAIGHT,           // direction
    ROAD_DIR_UTURU,              // u turn
    ROAD_DIR_NUM,    
}NET_ROAD_DIRECTION;

//Vehicle flow statistics lane direction information
typedef struct tagNET_TRAFFIC_FLOWSTAT_INFO_DIR
{
	NET_FLOWSTAT_DIRECTION		emDrivingDir;							//(Driving direction)
	char						szUpGoing[FLOWSTAT_ADDR_NAME];			//(Uplink locations)
	char						szDownGoing[FLOWSTAT_ADDR_NAME];		//(Go down location)
	BYTE						reserved[32];							//(Reserved bytes)
	
}NET_TRAFFIC_FLOWSTAT_INFO_DIR;

//road jam status
typedef enum tagNET_TRAFFIC_JAM_STATUS
{
    JAM_STATUS_UNKNOW  =0 ,  //unknown 
    JAM_STATUS_CLEAR      ,  //clear
    JAM_STATUS_JAMMED     ,  //jammed
    JAM_STATUS_SLOWED     ,  //slowed
}NET_TRAFFIC_JAM_STATUS;

//road rank
typedef enum tagNET_TRAFFIC_ROAD_RANK
{
	ROAD_RANK_UNKNOWN	=0	,
	ROAD_RANK_RAPID		=1	,	//rapid
	ROAD_RANK_TRUNK		=2	,	//trunk
	ROAD_RANK_SUBTRUNK	=3	,	//subtrunk
	ROAD_RANK_BRANCH	=4	,	//branch
}NET_TRAFFIC_ROAD_RANK;

// Flow attribute
typedef enum tagNET_EM_FLOW_ATTRIBUTE
{
	EM_FLOW_ATTRIBUTE_UNKNOWN = 0,
	EM_FLOW_ATTRIBUTE_FLOW_DETECTION,								// Flow detection
	EM_FLOW_ATTRIBUTE_QUEUE_DETECTION,								// Queue detection
}NET_EM_FLOW_ATTRIBUTE;

typedef struct tagNET_TRAFFIC_FLOW_STATE 
{
	int								nLane;				// (Lane number)
	DWORD							dwState;			// (State value) if emJamState is valid,then dwState is invalid
														// (1 - heavy traffic)
														// (2-heavy traffic recovery)
														// (3-normal)
														// (4 - Flow is too  little)
														// (5-Traffic too low recovery)
	DWORD							dwFlow;				// (Flow value, units: vehicles)
	DWORD							dwPeriod;			// Corresponding statistical time of the flow value,Unit:minute,Used with dwPeriodByMili.
	NET_TRAFFIC_FLOWSTAT_INFO_DIR	stTrafficFlowDir;	// (Lane direction information)
	int					            nVehicles;			// (Total number of passing vehicles)
	float				            fAverageSpeed;		// (Average speed, unit km / h)
	float				            fAverageLength;		// (The average vehicle length, unit meters)
	float				            fTimeOccupyRatio;	// (Share of the time , i.e., The ratio of the sum time for the vehicle passing the cross-section  in  the unit  time and per unit time )
	float				            fSpaceOccupyRatio;	// (Share of the space ,is the result that the average driving distance intervals vehicle is divided the sum of the length of the vehicle measured by the percentage 
	float			            	fSpaceHeadway;		// (Headway, the distance between adjacent vehicles in m / vehicle)
	float				            fTimeHeadway;		// (Headway in seconds / vehicle)
	float				            fDensity;			// (Vehicle density, the number of vehicles per kilometer, unit vehicles / km)
	int					            nOverSpeedVehicles;	// (The number of Speeding vehicles)
	int					            nUnderSpeedVehicles;// (The number of low speeding vehicles)
	int				            	nLargeVehicles;		// (Carts traffic (9 m <car length <12 m), vehicle / unit time)
	int				            	nMediumVehicles;	// (Medium car Traffic 6 m <car length <9 meters), vehicle / unit time
	int				            	nSmallVehicles;		// (Car Traffic 4 m <car length <6 meters), vehicle / unit time
	int				            	nMotoVehicles;		// (Motorized traffic (mini-car, car length <4 m), vehicle / unit time, 
	int				            	nLongVehicles;		// (long traffic (car length> = 12 m), vehicle / unit time, 
	int                             nVolume;            // (Traffic, vehicles / unit time, the number of vehicles which pass through the lane, the road and other vehicles, caculated in one hour)
	int                             nFlowRate;          // (Flow rate of the car, Vehicles / hour, equivalent hours for Vehicle through the lane, a section or a section of the road)
	int                             nBackOfQueue;       // (Queue length, unit: m, distance from the signalized intersection stop line between the upstream end of the line vehicle)(proposed repeal)
	int                             nTravelTime;        // (Travel time, unit: second, a road vehicle used by a certain time. Including all parking delays)
	int                             nDelay;             // (Delay unit: seconds, extra travel time for the driver, passenger or pedestrian spend)
    BYTE                            byDirection[MAX_DRIVING_DIR_NUM]; // lane direction, see NET_ROAD_DIRECTION
    BYTE                            byDirectionNum;     // lane direction quantity
    BYTE                            reserved1[3];       // text align
    NET_TRAFFIC_JAM_STATUS          emJamState;         // road jam status. if emJamState is valid,then dwState is invalid
    //  Traffic statisitcs according to vehicle type
    int                             nPassengerCarVehicles;                      // Passenger vehicle statistics amount (amount/hour)
    int                             nLargeTruckVehicles;                        // Large truck statistics amount 
    int                             nMidTruckVehicles;                          // Medium truck statistics amount (amount/hour)
    int                             nSaloonCarVehicles;                         // Car statistics amount (amount/hour)
    int                             nMicrobusVehicles;                          // Minivan statistics amount (amount/hour)
    int                             nMicroTruckVehicles;                        // Small van statistics amount (amount/hour)
    int                             nTricycleVehicles;                          // Tricycle statistics amount (amount/hour)
    int                             nMotorcycleVehicles;                        // Motor statistics amount (amount/hour)
    int                             nPasserbyVehicles;                          // Pedestrian statistics amount (amount/hour)
	NET_TRAFFIC_ROAD_RANK			emRank;										// road rank
	int								nState;										// State value
																				// (1 - heavy traffic)
																				// (2-heavy traffic recovery)
																				// (3-normal)
																				// (4 - Flow is too  little)
																				// (5-Traffic too low recovery)
    BOOL                            bOccupyHeadCoil;                            // indicating whether the head coil is occupyied
    BOOL                            bOccupyTailCoil;                            // indicating whether the tail coil is occupyied
    BOOL                            bStatistics;                                // indicating whether the statistics is valid
	int								nLeftVehicles;								// (Total nubmer of turn left Vehicles, unit: min)
	int								nRightVehicles;								// (Total number of turn right Vehicles, unit: min)
	int								nStraightVehicles;							// (Total number of straight-head Vehicles,unit: min)
	int								nUTurnVehicles;								// (Total number of U-turn Vehicles,unit: min)
    DH_POINT                        stQueueEnd;                                 // the last car coordinate in a quene of lane,coordinate value 0~8192
	double							dBackOfQueue;								// (Queue length, unit: m, distance from the signalized intersection stop line between the upstream end of the line vehicle)
	DWORD							dwPeriodByMili;								// Corresponding statistical time of the flow millisecond value,Value is not more than 60000.Used with dwPeriod,statistical total time of the flow value:dwPeriod*60*1000+dwPeriodByMili(Unit:millisecond)
	int								nBusVehicles;								// Bus vehicle statistics amount (amount/hour)
	int								nMPVVehicles;								// MPV vehiclestatistics amount (amount/hour)
	int								nMidPassengerCarVehicles;					// midpassenger car vehicle statistics amount (amount/hour)
	int								nMiniCarriageVehicles;						// mini carriage vehicle statistics amount (amount/hour)
	int								nOilTankTruckVehicles;						// oil tank trunk vehicle statistics amount (amount/hour)
	int								nPickupVehicles;							// pick up vehicle statistics amount (amount/hour)
	int								nSUVVehicles;								// SUV vehicle statistics amount (amount/hour)
	int								nSUVorMPVVehicles;							// SUV or MPV vehicle statistics amount (amount/hour)
	int								nTankCarVehicles;							// tank car vehicle statistics amount (amount/hour)
	int								nUnknownVehicles;							// unknown vehicle statistics amount (amount/hour)
	NET_EM_FLOW_ATTRIBUTE			emCustomFlowAttribute;						// Flow attribute
	BYTE                            reserved[720];                              // Reserved
}NET_TRAFFIC_FLOW_STATE;
 
// trafficflowstatinfo (Corresponding data block description)
typedef struct tagNET_TRAFFICFLOWSTATINFO
{
	DH_TRAFFICFLOWSTAT				stuTrafficFlowStat;	// Traffic Flow Stat
	
	double							dbBackOfQueue;		// Queue length
	NET_TRAFFIC_ROAD_RANK			emRank;				// road rank
	int								nState;				// State value
														// (1 - heavy traffic)
														// (2-heavy traffic recovery)
														// (3-normal)
														// (4 - Flow is too  little)
														// (5-Traffic too low recovery)
    BYTE							reserved[1024];		// Reserved string 
}NET_TRAFFICFLOWSTATINFO;


// EVENT_IVS_TRAFFIC_FLOWSTATE (Corresponding data block description)
typedef struct tagDEV_EVENT_TRAFFIC_FLOW_STATE
{
    int                 		nChannelID;                     // (Channel number) 
    char                		szName[DH_EVENT_NAME_LEN];      // (Event name)
    char                		bReserved1[8];                  // (Byte alignment)
    DWORD               		PTS;                            // (Timestamp (in milliseconds))
    NET_TIME_EX         		UTC;                            // (Time for the event occurred)
    int                 		nEventID;                       // (Event ID)
	int							nSequence;						// (No.)
	int							nStateNum;						// (the number of traffic state)
	NET_TRAFFIC_FLOW_STATE 		stuStates[DH_MAX_LANE_NUM];		// (Flow state, each lane corresponding to an element in the array)
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     		// intelli comm info
	BYTE                		bReserved[892];                // (Reserved bytes)
}DEV_EVENT_TRAFFIC_FLOW_STATE;

// EVENT_IVS_VIDEOSTATIC(Corresponding to data block description) 
typedef struct tagDEV_EVENT_ALARM_VIDEOSTATIC_INFO 
{
    int                 nChannelID;                                 // Channel number
    char                szName[DH_EVENT_NAME_LEN];                  // Event name
    char                bReserved1[8];                              // Byte alignment
    DWORD               PTS;                                        // Timestamp (in milliseconds)
    NET_TIME_EX         UTC;                                        // Time for the event occurred
    int                 nEventID;                                   // Event ID
    EM_ALARM_VIDEO_STATIC_MODE  emMode;                             // the mode 
    BYTE                bEventAction;                               // Even action
    BYTE                bReserved[1027];                            // Reserved bytes
}DEV_EVENT_ALARM_VIDEOSTATIC_INFO;

// EVENT_IVS_VIDEOTIMINGCorresponding to data block description) 
typedef struct tagDEV_EVENT_ALARM_VIDEOTIMING_INFO 
{
    int                 nChannelID;                                 // Channel number
    char                szName[DH_EVENT_NAME_LEN];                  // Event name
    char                bReserved1[8];                              // Byte alignment
    DWORD               PTS;                                        // Timestamp (in milliseconds)
    NET_TIME_EX         UTC;                                        // Time for the event occurred
    int                 nEventID;                                   // Event ID
    BYTE                bEventAction;                               // the mode 
    BYTE                bReserved[1027];                            // Reserved bytes
}DEV_EVENT_ALARM_VIDEOTIMING_INFO;


//event source information
typedef struct tagDEV_SRC_INFO
{
    char           szSrcEvent[DH_COMMON_STRING_32];// source event
    NET_TIME_EX    stSrcTime;                      // the time of source event
    int            iSrcChannel;                    // the channel of source event
    BYTE           reserved[512];                  // Reserved bytes
}DEV_SRC_INFO;

//EVENT_IVS_LINKSD(Corresponding to data block description)
typedef struct tagDEV_EVENT_LINK_SD
{
    // common fields
    int                 nChannelID;                         // Channel number
    char                szName[DH_EVENT_NAME_LEN];          // Event name
    char                bReserved1[8];                      // Byte alignment
    DWORD               PTS;                                // Timestamp (in milliseconds)
    NET_TIME_EX         UTC;                                // Time for the event occurred
    int                 nEventID;                           // Event ID

    // event fields
    DEV_SRC_INFO       *pstSrcInfo;                         // event source information
    NET_TIME_EX         stStartTime;                        // The start time of the preset
    NET_TIME_EX         stEndTime;                          // The end time of the preset
    int                 iPresetID;                          // The preset ID
    BYTE                reserved[512];                      // Reserved bytes
}DEV_EVENT_LINK_SD;

// EVENT_IVS_FLOWRATE(Corresponding to flow rate)
typedef struct tagDEV_EVENT_FLOWRATE_INFO
{
	// common fields
    int                 nChannelID;                         // Channel number
    char                szName[DH_EVENT_NAME_LEN];          // Event name
    char                bReserved1[8];                      // Byte alignment
    double              dbPTS;                              // Timestamp (in milliseconds)
    NET_TIME_EX         stuTime;                            // Time for the event occurred
    int                 nEventID;                           // Event ID

	// event fields
	unsigned int 		nFlowRate;							// flow rate
	BYTE                reserved[1024];                     // Reserved bytes
} DEV_EVENT_FLOWRATE_INFO;



// Media file search criteria
typedef struct tagDEV_EVENT_ALARM_CITIZENIDCARD_INFO
{
    int                 nChannelID;                                 // Channel No.
    char                szName[DH_EVENT_NAME_LEN];                  // Event name
    char                bReserved1[8];                              // Align type 
    DWORD               PTS;                                        // Time stamp (unit:ms)
    NET_TIME_EX         UTC;                                        // Event occurrence time 
    int                 nEventID;                                   // Event ID
    ///////////////////////////////The above are the public string//////////////////////////////
    int                 nGroupID;                                   // nGroupID event group ID. The nGroupID is the same for the snap process of the same object 
    int                 nCountInGroup;                              // nCountInGroup snap amount of one event group 
    int                 nIndexInGroup;                              // IndexInGroup snap SN of one event group 
    char                szCitizen[DH_COMMON_STRING_64];             // Name
    EM_CITIZENIDCARD_SEX_TYPE   emSex;                              // Gender 
    int                 nEthnicity;                                 // Nationality 
    // 0 invalid data 
    // 1 Han
    // 2 Mongolian
    // 3 Hui
    // 4 Tibetan
    // 5 Uygur
    // 6 Miao
    // 7 Yi
    // 8 Zhuang
    // 9 Bouyei
    // 10 Korean
    // 11 Manchu
    // 12 Dong
    // 13 Yao
    // 14 Bai
    // 15 Tujia
    // 16 Hani
    // 17 Kazak
    // 18 Dai
    // 19 Li
    // 20 Lisu
    // 21 Va
    // 22 She
    // 23 Gaoshan
    // 24 Lahu
    // 25 Shui
    // 26 Dongxiang
    // 27 Naxi
    // 28 Jingpo
    // 29 Kirgiz
    // 30 Tu
    // 31 Daur
    // 32 Mulam
    // 33 Qoiang
    // 34 Blang
    // 35 Salar
    // 36 Maonan
    // 37 Gelo
    // 38 Xibe
    // 39 Achang
    // 40 Pumi
    // 41 Tajik
    // 42 Nu
    // 43 Ozbek
    // 44 Russian
    // 45 Ewenkl
    // 46 Deang
    // 47 Bonan
    // 48 Yugur
    // 49 Jing
    // 50 Tatar
    // 51 Drung
    // 52 Oroqen
    // 53 Hezhen
    // 54 Moinba
    // 55 Lhoba
    // 56 Jino
    NET_TIME            stuBirth;                                   // Birth date 
    char                szAddress[DH_COMMON_STRING_256];            // Address
    char                szNumber[DH_COMMON_STRING_64];              // ID
    char                szAuthority[DH_COMMON_STRING_256];          // Issued authority 
    NET_TIME            stuStart;                                   // Start date 
    BOOL                bLongTimeValidFlag;                         // When the value is TRUE, the stop date menas always valid, at this time, the  stuEnd is null. 
    // When the value is FALSE, refer to stuEnd value for stop date.
    NET_TIME            stuEnd;                                     // Stop date, it is valid when bLongTimeValidFlag is FALSE.
    char                szReversed[1024];                           // Reserved string 
}DEV_EVENT_ALARM_CITIZENIDCARD_INFO;

// Corresponding data description info of event type EVENT_IVS_PICINFO (image info event) 
typedef struct tagDEV_EVENT_ALARM_PIC_INFO 
{
    int                 nChannelID;                                 // Channel No.
    char                szName[DH_EVENT_NAME_LEN];                  // Event name 
    char                bReserved1[8];                              // Align byte 
    DWORD               PTS;                                        // Time stamp (Unit:ms)
    NET_TIME_EX         UTC;                                        // Event occurrence time (Not for mobile device )
    int                 nEventID;                                   // Event ID
	///////////////////////////////Comon information above //////////////////////////////
	NET_TIME_EX         stuTime;                                    // Event occurrence time (Device time, it may not be utc time).
    DWORD               dwEventType;                                // Event  type
    DWORD               dwSpeed;                                    // Speed. Unit is km/h.
	DWORD               dwSpeedHighLine;                            // Speed limit (max speed)on highway. Unit is km/h.
    DWORD               dwDisk;                                     // Disk No.
    DWORD               dwCluster;                                  // Cluster No.
    DWORD               dwPartition;                                // Partition No.	
    char                szSnapAddr[DH_COMMON_STRING_128];           // Snap position. Valid 64-byte 
    char                szPicID[DH_COMMON_STRING_32];               // Image only ID
    char                szPlate[DH_COMMON_STRING_16];               // Plate 
    char                szReversed[2000];                           // Reserved string 
}DEV_EVENT_ALARM_PIC_INFO;

// access control image type
typedef enum tagEM_ACCESS_CTL_IMAGE_TYPE
{
	EM_ACCESS_CTL_IMAGE_UNKNOWN = -1,					// Unknown
	EM_ACCESS_CTL_IMAGE_LOCAL,							// Local face database 
	EM_ACCESS_CTL_IMAGE_SCENE,							// Cutout of scene picture
	EM_ACCESS_CTL_IMAGE_FACE,							// Cutout of face
    EM_ACCESS_CTL_IMAGE_INFRARED,						// Infrared capture
}EM_ACCESS_CTL_IMAGE_TYPE;

// access control image info
typedef struct tagDEV_ACCESS_CTL_IMAGE_INFO
{
	EM_ACCESS_CTL_IMAGE_TYPE	emType;					// Image type
	UINT						nOffSet;				// Offset in binary block
	UINT						nLength;				// Image size
	UINT						nWidth;					// Image width(Unit:pixel)
	UINT						nHeight;				// Image height(Unit:pixel)
	NET_RECT            		stuBoundingBox;         // Bounding box
	BYTE						byReserved[48];			// Reserved
}DEV_ACCESS_CTL_IMAGE_INFO;

// custom worker info
typedef struct tagDEV_ACCESS_CTL_CUSTOM_WORKER_INFO
{
    NET_ACCESSCTLCARD_SEX       emSex;                                      // sex
    char                        szRole[MAX_COMMON_STRING_32];               // role
    char                        szProjectNo[MAX_COMMON_STRING_32];          // project No.
    char                        szProjectName[MAX_COMMON_STRING_64];        // project name
    char                        szBuilderName[MAX_COMMON_STRING_64];        // builder name
    char                        szBuilderID[MAX_COMMON_STRING_32];          // builder ID
    char                        szBuilderType[MAX_COMMON_STRING_32];        // builder type
    char                        szBuilderTypeID[MAX_COMMON_STRING_8];       // builder type ID
    char                        szPictureID[MAX_COMMON_STRING_64];          // picture ID
    char                        szContractID[MAX_COMMON_STRING_16];         // contract ID in original contract system
    char                        szWorkerTypeID[MAX_COMMON_STRING_8];        // worker type ID
    char                        szWorkerTypeName[MAX_COMMON_STRING_32];     // worker type name
    BOOL                        bPersonStatus;                              // person status, TRUE:enable, FALSE:forbidden
    BYTE						byReserved[256];			                // Reserved
}DEV_ACCESS_CTL_CUSTOM_WORKER_INFO;

// Corresponding data description info of event type EVENT_IVS_ACCESS_CTL (Access control info event) 
typedef struct tagDEV_EVENT_ACCESS_CTL_INFO 
{
    int                         nChannelID;                         // Door Channel Number
    char                        szName[DH_EVENT_NAME_LEN];          // Entrance Guard Name
	char                		bReserved1[4];                      // Align byte 
    double              		PTS;                                // Time stamp (Unit:ms)
    NET_TIME_EX         		UTC;                                // Event occurrence time 
    int                 		nEventID;                           //  Event ID
    DH_MSG_OBJECT           	stuObject;                          // have being detected object
	DH_EVENT_FILE_INFO			stuFileInfo;	                    // The corresponding file info of the event
    NET_ACCESS_CTL_EVENT_TYPE   emEventType;                        // Entrance Guard Event Type
    BOOL                        bStatus;                            // Swing Card Result,True is Success,False is Fail
    NET_ACCESSCTLCARD_TYPE      emCardType;                         // Card Type
    NET_ACCESS_DOOROPEN_METHOD  emOpenMethod;                       // Open The Door Method
    char                        szCardNo[DH_MAX_CARDNO_LEN];        // Card Number
    char                        szPwd[DH_MAX_CARDPWD_LEN];          // Password
    char                        szReaderID[DH_COMMON_STRING_32];    // Reader ID
    char                        szUserID[DH_COMMON_STRING_64];      // unlock user
    char                        szSnapURL[DH_COMMON_STRING_128];    // snapshot picture storage address
    int                         nErrorCode;                         // Reason of unlock failure, only because it is valid when bStatus is FALSE
                                                                    // 0x00 no error
                                                                    // 0x10 unauthorized
                                                                    // 0x11 card lost or cancelled
                                                                    // 0x12 no door right
                                                                    // 0x13 unlock mode error
                                                                    // 0x14 valid period error
                                                                    // 0x15 anti sneak into mode
                                                                    // 0x16 forced alarm not unlocked
                                                                    // 0x17 door NC status
                                                                    // 0x18 AB lock status
                                                                    // 0x19 patrol card
                                                                    // 0x1A device is under intrusion alarm status
                                                                    // 0x20 period error
                                                                    // 0x21 unlock period error in holiday period
                                                                    // 0x30 first card right check required
                                                                    // 0x40 card correct, input password error
                                                                    // 0x41 card correct, input password timed out
                                                                    // 0x42 card correct, input fingerprint error
                                                                    // 0x43 card correct, input fingerprint timed out
                                                                    // 0x44 fingerprint correct, input password error
                                                                    // 0x45 fingerprint correct, input password timed out
                                                                    // 0x50 group unlock sequence error
                                                                    // 0x51 test required for group unlock
                                                                    // 0x60 test passed, control unauthorized
                                                                    // 0x61 card correct, input face error
                                                                    // 0x62 card correct, input face timed out
                                                                    // 0x63 repeat enter
                                                                    // 0x64 unauthorized, requiring back-end platform identification
    int                         nPunchingRecNo;                     // punching record number
	int							nNumbers;							// picture Numbers
    BYTE						byImageIndex;	                    // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	BYTE                        byReserved[3];                      // Align byte 
	DWORD						dwSnapFlagMask;						// Snap flag(by bit)0 bit:"*",1 bit:"Timing",2 bit:"Manual",3 bit:"Marked",4 bit:"Event",5 bit:"Mosaic",6 bit:"Cutout"     
    NET_ATTENDANCESTATE         emAttendanceState;                  // Attendance state 
	char						szClassNumber[MAX_CLASS_NUMBER_LEN];	// Class number(Kenya custom)
	char						szPhoneNumber[MAX_PHONENUMBER_LEN];		// Phone number(Kenya custom)
	char						szCardName[DH_MAX_CARDNAME_LEN];			// Card name
	UINT                    uSimilarity;                            // Face recognition similarity,range is 0~100
	DEV_ACCESS_CTL_IMAGE_INFO	stuImageInfo[6];						// Image information
	int							nImageInfoCount;							// Image information count
	char						szCitizenIDNo[20];						// Citizen ID
	UINT						nGroupID;							// Event group ID
    int				            nCompanionCardCount;					// Companion card count
    char				        szCompanionCards[MAX_COMPANION_CARD_NUM][DH_MAX_CARDINFO_LEN];      // Companion card information
    DEV_ACCESS_CTL_CUSTOM_WORKER_INFO  stuCustomWorkerInfo;                 // custom worker info
	EM_CARD_STATE				emCardState;						// Weather to collect cards
	char						szSN[32];							// Device serial number
	EM_HAT_STYLE				emHatStyle;							// hat style
	EM_UNIFIED_COLOR_TYPE		emHatColor;							// hat color
	EM_LIFT_CALLER_TYPE			emLiftCallerType;					// lift caller type
    BYTE						bReserved[464];						// Reserved
}DEV_EVENT_ACCESS_CTL_INFO;


//Event EVENT_IVS_NETPALYCHECK(Corresponding to data block description)
typedef struct tagDEV_EVENT_ALARM_NETPLAYCHECK_INFO
{
	int                 nChannelID;                                 // Channel number
    char                szName[DH_EVENT_NAME_LEN];                  // Event name
    char                bReserved1[8];                              // Byte alignment
    DWORD               PTS;                                        // Timestamp (in milliseconds)
    NET_TIME_EX         UTC;                                        // Time for the event occurred
    int                 nEventID;                                   // Event ID
    ///////////////////////////////Comon information above//////////////////////////////
	NET_TIME_EX         stuTime;                                    // Event occurrence time (Device time, it may not utc).
	char				szIdentityCard[DH_COMMON_STRING_32];		// Identity Card
	char				szNetBarName[DH_COMMON_STRING_32];			// Internet Bar Name
	char				szNetBarID[DH_COMMON_STRING_32];			// Internet Bar ID
	char				szNetBarAddr[DH_COMMON_STRING_64];			// Network bar address 
}DEV_EVENT_ALARM_NETPLAYCHECK_INFO;

#define MAX_SNAPBYTIME_DATA_NUM 20
// User data
typedef struct tagEVENT_SNAPBYTIME_DATA
{
	DWORD				dwLiquidLevel;								  // LiquidLevel,Unit:mm
	DWORD				dwDistMeasure;								  // DistMeasure,Unit:mm
	int					nTemperature;								  // Temperature,Unit:'C
	int					nHumidity;									  // Humidity,Unit:RH
	DWORD				dwWaterFlow;									  // WaterFlow,Unit:m^3
	BOOL				bAlarmFlag;									  // Alarm flag: Normal-FALSE, Alarm-TRUE
	char                szReversed[40];                               // Reserved
}EVENT_SNAPBYTIME_DATA;

//Corresponding to data block description of event type EVENT_IVS_SNAPBYTIME(snap by time event) 
typedef struct tagDEV_EVENT_SNAPBYTIME
{
	int                 nChannelID;                                 // Channel number
    char                szName[DH_EVENT_NAME_LEN];                  // Event name
    char                bReserved1[4];                              // Byte alignment
    double              PTS;                                        // Timestamp (in milliseconds)
    NET_TIME_EX         UTC;                                        // Time for the event occurred
    int                 nEventID;                                   // Event ID
    ///////////////////////////////Comon information above, In addition to other fields outside the nChannelID is to set aside public space//////////////////////////////
	NET_TIME_EX         stuSnapTime;                                // snap time
	unsigned int		uLiquidLevel;								// Liquid level(mm)
	unsigned int		uDistMeasure;								// Distance measure value(mm)
	int					nTemperature;								// Temperature(C)
	int					nHumidity;									// Humidity(RH)

	int					nDataNum;									  // The number of custom data
	EVENT_SNAPBYTIME_DATA	stuDataList[MAX_SNAPBYTIME_DATA_NUM];	// The list of custom data
    char                szReversed[748];                              // Reserved
}DEV_EVENT_SNAPBYTIME;

// IVS event type EVENT_IVS_MAN_STAND_DETECTION(stereo standing event)data description
typedef struct tagDEV_EVENT_MANSTAND_DETECTION_INFO
{
	int                 		nChannelID;                 // channel ID
    char                		szName[DH_EVENT_NAME_LEN];  // event name
    char                		bReserved1[4];              // keep align, not reserved
    double              		PTS;                        // PTS(ms)
    NET_TIME_EX         		UTC;                        // time of occurrence
    int                 		nEventID;                   // event ID
    ///////////////////////////////up is common//////////////////////////////
    int                 		nAction;                    // event action, 0: Pulse, 1: Start, 2: Stop
	int							nManListCount;				// number of regional personnet list
	MAN_STAND_LIST_INFO			stuManList[MAX_MAN_LIST_COUNT];	// list of petsons within the region
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // intelli comm info
	char                		szReversed[2048];           // reserved
} DEV_EVENT_MANSTAND_DETECTION_INFO;

// IVS event type EVENT_IVS_MAN_NUM_DETECTION(the statistics of people in stereo vision event)data description
typedef struct tagDEV_EVENT_MANNUM_DETECTION_INFO
{
	int                 		nChannelID;                 // channel ID
    char                		szName[DH_EVENT_NAME_LEN];  // event name
    char                		bReserved1[4];              // keep align, not reserved
    double              		PTS;                        // PTS(ms)
    NET_TIME_EX         		UTC;                        // time of occurrence
    int                 		nEventID;                   // event ID
    ///////////////////////////////up is common//////////////////////////////
    int                 		nAction;                    // event action, 0: Pulse, 1: Start, 2: Stop
	int							nManListCount;				// number of regional personnet list
	MAN_NUM_LIST_INFO			stuManList[MAX_MAN_LIST_COUNT];	// list of petsons within the region
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // intelli comm info
	UINT						nAreaID;					// Area ID(a preset point can correspond to multiple area IDs)
    UINT                        nPrevNumber;                // previous number of man
    UINT                        nCurrentNumber;             // current number of man
	char                		szReversed[2036];           // reserved
} DEV_EVENT_MANNUM_DETECTION_INFO;

// IVS event type EVENT_IVS_QUEUENUM_DETECTIONqueue num detection eventdata description
typedef struct tagDEV_EVENT_QUEUENUM_DETECTION_INFO
{
	int                 		nChannelID;                 // channel ID
	char                		szName[DH_EVENT_NAME_LEN];  // event name
	char                		bReserved1[4];              // keep align, not reserved
	double              		PTS;                        // PTS(ms)
	NET_TIME_EX         		UTC;                        // time of occurrence
	DWORD                 		nEventID;                   // event ID
	int							nAction;                     // event action, 0: Pulse, 1: Start, 2: Stop
   ///////////////////////////////up is common//////////////////////////////
	UINT						nAreaID;					// Area ID(a preset point can correspond to multiple area IDs)
	int							nMaxManListNum;				// Number of persons detected in the area
	MAN_NUM_LIST_INFO			stuManList[MAX_MAN_LIST_COUNT];	// Number of Regional Personnel
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // intelli comm info
	DH_EVENT_FILE_INFO			stuFileInfo;                // Event corresponding to file information
	BYTE                		byReversed[1024];           // Reserved
} DEV_EVENT_QUEUENUM_DETECTION_INFO;

// IVS event type EVENT_IVS_GENERATEGRAPH_DETECTIONgenerate graph detection eventdata description
typedef struct tagDEV_EVENT_GENERATEGRAPH_DETECTION_INFO
{	
	int                 		nChannelID;                 // channel ID
	char                		szName[DH_EVENT_NAME_LEN];  // event name
	char                		bReserved1[4];              // keep align, not reserved
	double              		PTS;                        // PTS(ms)
	NET_TIME_EX         		UTC;                        // time of occurrence
	int                 		nEventID;                   // event ID
	int							nAction;                    // event action, 0:Pulse, 1:Start, 2:Stop
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // intelli comm info
	DH_EVENT_FILE_INFO			stuFileInfo;                // Event corresponding to file information
	///////////////////////////////up is common//////////////////////////////
	BYTE                		byReversed[1024];           // Reserved
} DEV_EVENT_GENERATEGRAPH_DETECTION_INFO;

// Corresponding to data block description of event type EVENT_IVS_TRAFFIC_TIREDPHYSIOLOGICAL(physiological fatigue driving events)
typedef struct tagDEV_EVENT_TIREDPHYSIOLOGICAL_INFO
{
    int                 nChannelID;                         // Channel ID
    char                szName[DH_EVENT_NAME_LEN];          // Event name
    char                bReserved1[4];                      // Byte alignment
    double              PTS;                                // Timestamp (in milliseconds)
    NET_TIME_EX         UTC;                                // Time for the event occurred
    int                 nEventID;                           // Event ID
    
    int                 nAction;                            // event action, 0: Pulse, 1: Start, 2: Stop
    NET_GPS_STATUS_INFO stuGPSStatus;                       // GPS info
    char                szDriverID[32];                     // Driver ID
    char                szVideoPath[256];                   // ftp path for assocated video
    BYTE                bReserved[736];                     // Reserved 
} DEV_EVENT_TIREDPHYSIOLOGICAL_INFO;

// Corresponding to data block description of event type EVENT_IVS_TRAFFIC_TIREDLOWERHEAD(Event of driver lower head)
typedef struct tagDEV_EVENT_TIREDLOWERHEAD_INFO
{
    int                 nChannelID;                         // Channel ID
    char                szName[DH_EVENT_NAME_LEN];          // Event name
    char                bReserved1[4];                      // Byte alignment
    double              PTS;                                // Timestamp (in milliseconds)
    NET_TIME_EX         UTC;                                // Time for the event occurred
    int                 nEventID;                           // Event ID
    
    NET_GPS_STATUS_INFO stuGPSStatus;                       // GPS info
    char                szDriverID[32];                     // Driver ID
    char                szVideoPath[256];                   // ftp path for assocated video
    BYTE                bReserved[736];                     // Reserved 
} DEV_EVENT_TIREDLOWERHEAD_INFO;

// Corresponding to data block description of event type EVENT_IVS_TRAFFIC_DRIVERLOOKAROUND(Event of driver look around)
typedef struct tagDEV_EVENT_DRIVERLOOKAROUND_INFO
{
    int                 nChannelID;                         // Channel ID
    char                szName[DH_EVENT_NAME_LEN];          // Event name
    char                bReserved1[4];                      // Byte alignment
    double              PTS;                                // Timestamp (in milliseconds)
    NET_TIME_EX         UTC;                                // Time for the event occurred
    int                 nEventID;                           // Event ID
    
    NET_GPS_STATUS_INFO stuGPSStatus;                       // GPS info
    char                szDriverID[32];                     // Driver ID
    char                szVideoPath[256];                   // ftp path for assocated video
    BYTE                bReserved[736];                     // Reserved 
} DEV_EVENT_DRIVERLOOKAROUND_INFO;

// Corresponding to data block description of event type EVENT_IVS_INFRAREDBLOCK(Event of infrared block)
typedef struct tagDEV_EVENT_INFRAREDBLOCK_INFO
{
    int                 nChannelID;                         // Channel ID
    char                szName[DH_EVENT_NAME_LEN];          // Event name
    char                bReserved1[4];                      // Byte alignment
    double              PTS;                                // Timestamp (in milliseconds)
    NET_TIME_EX         UTC;                                // Time for the event occurred
    int                 nEventID;                           // Event ID
    
    NET_GPS_STATUS_INFO stuGPSStatus;                       // GPS info
    char                szDriverID[32];                     // Driver ID
    char                szVideoPath[256];                   // ftp path for assocated video
    BYTE                bReserved[736];                     // Reserved 
} DEV_EVENT_INFRAREDBLOCK_INFO;

// Corresponding to data block description of event type EVENT_IVS_TRAFFIC_DRIVERLEAVEPOST(Event of driver leave post)
typedef struct tagDEV_EVENT_DRIVERLEAVEPOST_INFO
{
    int                 nChannelID;                                   // Channel ID
    char                szName[DH_EVENT_NAME_LEN];                    // Event name
    char                bReserved1[4];                                // Byte alignment
    double              PTS;                                          // Timestamp (in milliseconds)
    NET_TIME_EX         UTC;                                          // Time for the event occurred
    int                 nEventID;                                     // Event ID
    
    NET_GPS_STATUS_INFO stuGPSStatus;                                 // GPS info
    char                szDriverID[32];                               // Driver ID
    char                szVideoPath[256];                             // ftp path for assocated video
    BYTE                bReserved[736];                               // Reserved 
} DEV_EVENT_DRIVERLEAVEPOST_INFO;

// Corresponding to data block description of event type EVENT_IVS_TRAFFIC_DRIVERYAWN (Event of driver yawn)
typedef struct tagDEV_EVENT_DRIVERYAWN_INFO
{
    int                 nChannelID;                                   // Channel ID
    char                szName[DH_EVENT_NAME_LEN];                    // Event name
    char                szReserved1[4];                               // Byte alignment
    double              PTS;                                          // Timestamp (in milliseconds)
    NET_TIME_EX         UTC;                                          // Time for the event occurred
    int                 nEventID;                                     // Event ID

    NET_GPS_STATUS_INFO stuGPSStatus;                                 // GPS info
    char                szDriverID[32];                               // Driver ID
    char                szVideoPath[256];                             // ftp path for assocated video
    BYTE                byReserved[736];                              // Reserved 
} DEV_EVENT_DRIVERYAWN_INFO;

// Picture type
typedef enum tagEM_FIREWARNING_PIC_TYPE
{
	EM_PIC_UNKNOWN,		// Unknown
	EM_PIC_NONE,		// None
	EM_PIC_OVERVIEW,	// Overview
	EM_PIC_DETAIL,		// Detail
}EM_FIREWARNING_PIC_TYPE;
// Corresponding to data block description of event type EVENT_IVS_FIREWARNING(Event of fire-warning) 
typedef struct tagDEV_EVENT_FIREWARNING_INFO
{
	int                 			nChannelID;									// Channel ID
	char							szName[DH_EVENT_NAME_LEN];                  // Event name
	DH_EVENT_FILE_INFO  			stuFileInfo;								// The corresponding file info of the event
	int                 			nAction;									// event action, 0: Pulse, 1: Start, 2: Stop
	UINT							nFSID;										// Uint32	fire status id
	EM_FIREWARNING_PIC_TYPE			emPicType;									// Picture type
	BOOL							bIsLeaveFireDetect;							// Whether it belongs to off post fire point detection item (TRUE: Yes FALSE: No)
	BYTE							byReserved[1012];							// Reserved
}DEV_EVENT_FIREWARNING_INFO;

// Detect Object
typedef enum tagEM_DETECT_OBJECT
{
	EM_DETECT_OBJECT_UNKNOWN,					// Unknown
	EM_DETECT_OBJECT_HUMAN_BODY_AND_FACE,		// Both human body and human face
	EM_DETECT_OBJECT_HUMAN_BODY,				// Only human body
	EM_DETECT_OBJECT_HUMAN_FACE,				// Only human face
}EM_DETECT_OBJECT;

// Human image info
typedef struct tagHUMAN_IMAGE_INFO
{
	UINT       nOffSet;					// Offset 		
	UINT	   nLength;					// image length,Unit:byte
	UINT	   nWidth;					// Width
	UINT	   nHeight;					// Height
	BYTE       byReserved[56];			// Reserved
}HUMAN_IMAGE_INFO;

// Face image info
typedef struct tagFACE_IMAGE_INFO
{
	UINT	   nOffSet;					// Offset  
	UINT	   nLength;					// image length,Unit:byte
	UINT	   nWidth;					// Width
	UINT	   nHeight;					// Height
	BYTE	   byReserved[56];			// Reserved
}FACE_IMAGE_INFO;

// Human attributes info
typedef struct tagHUMAN_ATTRIBUTES_INFO
{
	EM_CLOTHES_COLOR    emCoatColor;									// Coat color
	EM_COAT_TYPE		emCoatType;										// Coat type
	EM_CLOTHES_COLOR	emTrousersColor;								// Trousers color
	EM_TROUSERS_TYPE	emTrousersType;									// Trousers type
	EM_HAS_HAT			emHasHat;										// whether has hat
	EM_HAS_BAG			emHasBag;										// whether has bag
	NET_RECT            stuBoundingBox;								    // BoundingBox(8192 coordinates)
	
	int					nAge;											// Age
	EM_SEX_TYPE			emSex;											// Six
	EM_ANGLE_TYPE		emAngle;										// Angle
	EM_HAS_UMBRELLA		emHasUmbrella;									// Umbrella state
	EM_BAG_TYPE			emBag;											// Bag type
	EM_CLOTHES_PATTERN	emUpperPattern;									// Upper Pattern
	EM_HAIR_STYLE		emHairStyle;									// Hair style
	EM_CAP_TYPE			emCap;											// Cap type
	NET_POINT           stuHumanCenter;                                 // Center of human(not center of bounding box), 0-8191 relative coordinates, relative to large graph
	BYTE				byReserved[76];									// Reserved
}HUMAN_ATTRIBUTES_INFO;

// Humantrait extension info
typedef struct tagNET_FACE_ATTRIBUTE
{
	EM_DEV_EVENT_FACEDETECT_SEX_TYPE 		emSex;						// Sex
	int        								nAge;						// Age,-1 means invaild value
    unsigned int        					nFeatureValidNum;           // Feature valid num,used in combination with emFeature
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE    emFeatures[DH_MAX_FACEDETECT_FEATURE_NUM];   // Feature,used in combination with nFeatureValidNum
	EM_COMPLEXION_TYPE						emComplexion;				// Complextion
	EM_EYE_STATE_TYPE						emEye;						// Eye state
	EM_MOUTH_STATE_TYPE						emMouth;					// Mouth state
	EM_MASK_STATE_TYPE 						emMask;						// Mask state
	EM_BEARD_STATE_TYPE						emBeard;					// Beard state
	int										nAttractive;				// Attractive, 0 means undistingushrange:1-100
	NET_RECT								stuBoundingBox;				// Bounding box(8192 coordinates)
    NET_EULER_ANGLE				            stuFaceCaptureAngle;		// euler angle of face in the capture picture, nPitch:pitch of the head, nYaw: yaw of the head, nRoll:roll of the head
                                                                        // range of the angle value is [-90,90], stuFaceCaptureAngle is invalid if the three angles are 999.
    UINT                                    nFaceQuality;               // The quality of face picture.The range is 0~10000 
    int                                     nFaceAlignScore;            // The score of face picture align.The range is 0~10000,-1 is invalid
    int                                     nFaceClarity;               // The score of face picture clarity.The range is 0~10000,-1 is invalid
    NET_POINT                               stuFaceCenter;              // Center of face(not center of bounding box), 0-8191 relative coordinates, relative to large graph
    BYTE                					bReserved[84];               // Reserved
} NET_FACE_ATTRIBUTE;

// Extension event code
typedef struct tagNET_HUMANTRAIT_EXTENSION_INFO
{
	char                szAdditionalCode[MAX_HUMANTRAIT_EVENT_LEN];     // Extension event code which produce human trait
	BYTE                byReserved[32];                                 // Reserved
} NET_HUMANTRAIT_EXTENSION_INFO;

// Position info of human feature data in binary data
typedef struct tagNET_HUMAN_FEATURE_VECTOR_INFO
{
    UINT                nOffset;            // The offset of human feature data in binary data, unit:bytes
    UINT                nLength;            // The length of human feature data, unit:bytes
    BYTE                byReserved[32];     // Reserved
} NET_HUMAN_FEATURE_VECTOR_INFO;

// Position info of face feature data in binary data
typedef struct tagNET_FACE_FEATURE_VECTOR_INFO
{
    UINT                nOffset;            // The offset of face feature data in binary data, unit:bytes
    UINT                nLength;            // The length of face feature data, unit:bytes
    BYTE                byReserved[32];     // Reserved
} NET_FACE_FEATURE_VECTOR_INFO;

// Corresponding to data block description of event type EVENT_IVS_HUMANTRAIT(Event of human trait)
typedef struct tagDEV_EVENT_HUMANTRAIT_INFO
{
	int					nChannelID;									  // Channel ID
	char				szName[DH_EVENT_NAME_LEN];					  // Event name
	int                 nEventID;                                     // Event ID
	double              PTS;                                          // Timestamp (in milliseconds)
	NET_TIME_EX         UTC;                                          // Time for the event occurred
	int                 nAction;                                      // 1:Start 2:Stop

	EM_CLASS_TYPE		emClassType;								  // Class type 
	int					nGroupID;									  // Event group ID,A detection of multiple human characteristics at the same nGroupID
	int					nCountInGroup;								  // the captured human number within an event group,A detection of multiple human characteristics at the same nCountInGroup
	int					nIndexInGroup;								  // capture Index of an event group,starting from 1
	HUMAN_IMAGE_INFO	stuHumanImage;								  // Human body image info
	FACE_IMAGE_INFO		stuFaceImage;								  // Human face image info
	EM_DETECT_OBJECT	emDetectObject;								  // Detect Object
	HUMAN_ATTRIBUTES_INFO  stuHumanAttributes;						  // Human attributes
    SCENE_IMAGE_INFO    stuSceneImage;                                // Scene image info
	NET_FACE_ATTRIBUTE	stuFaceAttributes;							  // Face attribute
	FACE_SCENE_IMAGE	stuFaceSceneImage;							  // Face scene image
	NET_EXTENSION_INFO  stuExtensionInfo;                             // Extension info
 	NET_HUMANTRAIT_EXTENSION_INFO   stuHumanTrait;                    // Extension event code which produce human trait
    NET_HUMAN_FEATURE_VECTOR_INFO   stuHumanFeatureVectorInfo;        // Position info of human feature data in binary data
    EM_FEATURE_VERSION              emHumanFeatureVersion;            // Human feature data version
    NET_FACE_FEATURE_VECTOR_INFO    stuFaceFeatureVectorInfo;         // Position info of face feature data in binary data
    EM_FEATURE_VERSION              emFaceFeatureVersion;             // Face feature data version
}DEV_EVENT_HUMANTRAIT_INFO;

// Corresponding to data block description of event type EVENT_IVS_TRAFFIC_BUSSHARPTURN(bus sharp trun events)
typedef struct tagDEV_EVENT_BUSSHARPTURN_INFO
{
	int                 nChannelID;                                   // Channel ID
    char                szName[DH_EVENT_NAME_LEN];                    // Event name
    char                bReserved1[4];                                // Byte alignment
    double              PTS;                                          // Timestamp (in milliseconds)
    NET_TIME_EX         UTC;                                          // Time for the event occurred
    int                 nEventID;                                     // Event ID

    int                 nAction;                                      // event action, 0: Pulse, 1: Start, 2: Stop
	NET_GPS_STATUS_INFO stuGPSStatus;                                 // GPS info
    BYTE				bReserved[1024];							  // Reserved 
} DEV_EVENT_BUSSHARPTURN_INFO;

// Corresponding to data block description of event type EVENT_IVS_TRAFFIC_ELETAGINFO(RFID electronic tag  events)
typedef struct tagDEV_EVENT_TRAFFIC_ELETAGINFO_INFO
{
	
	int                 nChannelID;							// channel ID
    char                szName[DH_EVENT_NAME_LEN];			// Event name
    char                bReserved1[4];						// Byte alignment
    double              PTS;								// Timestamp (in milliseconds)
    NET_TIME_EX         UTC;								// Time for the event occurred
    int                 nEventID;							// Event ID
    ///////////////////////////////Comon information above//////////////////////////////
    int                 nAction;                            // event action, 0: Pulse, 1: Start, 2: Stop
    NET_RFIDELETAG_INFO	stuRFIDEleTagInfo;					// RFID electronic tag  info
	int					nRetChannelNum;						// Number of return channels
	int					nLinkChannel[DH_MAX_CHANNUM];		// Associated camera channel, the channel number starts at 0
	BYTE				bReserved[956];						// Reserved string 
} DEV_EVENT_TRAFFIC_ELETAGINFO_INFO;


// picture type
typedef enum tagEM_PASS_CHANGE_PICTURE_TYPE
{
	EM_PASS_CHANGE_PICTURE_TYPE_UNKNOWN,					// unknown
	EM_PASS_CHANGE_PICTURE_TYPE_PASS,						// Pass
	EM_PASS_CHANGE_PICTURE_TYPE_REAL,						// Real
} EM_PASS_CHANGE_PICTURE_TYPE;

// Corresponding to data block description of event type EVENT_IVS_PASS_CHANGE(Pass Change events)
typedef struct tagDEV_EVENT_PASS_CHANGE_INFO
{
	int                 nChannelID;							// channel ID
    char                szName[DH_EVENT_NAME_LEN];          // evnet name
    char                szReserved1[4];                     // reserved
    double              dbPTS;                              // Timestamp (in milliseconds)
    NET_TIME_EX         UTC;                                // Time for the event occurred
    int                 nEventID;                           // Event ID
	
	int					nPresetID;							// Preset ID, start from 1
	int					nGroupID;							// Group ID
	int					nCountInGroup;						// Count In Group
	int					nIndexInGroup;						// Index In Group, start from 1
	EM_PASS_CHANGE_PICTURE_TYPE			emPictureType;		// picture type
	BYTE                byReserved1[1020];				    // reserved
} DEV_EVENT_PASS_CHANGE_INFO;

// EVENT_IVS_TRAFFIC_WAITINGAREA (TrafficWaitingArea)corresponding data block description info
typedef struct tagDEV_EVENT_TRAFFIC_WAITINGAREA_INFO
{
	int                 nChannelID;											// Channel ID
	BYTE				byReserved[4];										// Reserved
	char				szName[MAX_EVENT_NAME_LEN];							// Event name
	double				dbPTS;												// Time stamp(ms)
	NET_TIME_EX			UTC;												// Event occurred time
	int					nEventID;											// Event ID
	DH_MSG_OBJECT		stuObject;											// Plate info
	DH_MSG_OBJECT       stuVehicle;											// Car body info
	int					nLane;												// Corresponding lane number
	int                 nSequence;											// Snap index,such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO   stTrafficCar;						// Traffic car info
	DH_EVENT_FILE_INFO	stuFileInfo;										// Event corresponding to file information
	BYTE                byReserved1[1024];									// Reserved
	EVENT_COMM_INFO     stCommInfo;											// Public info
}DEV_EVENT_TRAFFIC_WAITINGAREA_INFO;

#define MAX_OBJECT_NUM			32	//  the max obiect number

// IVS event type EVENT_IVS_QUEUESTAY_DETECTION(queue stay detection event)data description
typedef struct tagDEV_EVENT_QUEUESTAY_DETECTION_INFO
{
	int                 		nChannelID;                 // channel ID
	char                		szName[DH_EVENT_NAME_LEN];  // event name
	char                		bReserved1[4];              // keep align, not reserved
	double              		PTS;                        // PTS(ms)
	NET_TIME_EX         		UTC;                        // time of occurrence
	int                 		nEventID;                   // event ID
	int							nAction;                    // event action, 0: Pulse, 1: Start, 2: Stop
	///////////////////////////////up is common//////////////////////////////
	int							nGroupID;					 // Event group ID,A detection of multiple human characteristics at the same nGroupID
	int							nCountInGroup;				// the captured human number within an event group,A detection of multiple human characteristics at the same nCountInGroup
	int							nIndexInGroup;				// capture Index of an event group,starting from 1
	DH_MSG_OBJECT				stuObject;					// Have been detected object info
	int							nObjectNum;					// detected objects numbers
	DH_MSG_OBJECT				stuObjects[MAX_OBJECT_NUM]; // detected objects
	int							nDetectRegionNum;						// Number of actual detected areas	
	DH_POINT					stuDetectRegion[DH_MAX_DETECT_REGION_NUM];	// Detect Region
	UINT						nAreaID;					// Area ID(a preset point can correspond to multiple area IDs)
	int							nCount;						// Event Attach Count
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // intelli comm info
	DH_EVENT_FILE_INFO			stuFileInfo;                // Event corresponding to file information
	BYTE                		byReversed[1024];           // Reserved
} DEV_EVENT_QUEUESTAY_DETECTION_INFO;

// EVENT_IVS_BANNER_DETECTION(BannerDetection)corresponding data block description info
typedef struct tagDEV_EVENT_BANNER_DETECTION_INFO
{
	int					nChannelID;									  // Channel ID
	int                 nEventID;                                     // Event ID
	char				szName[DH_EVENT_NAME_LEN];					  // Event name
	double              PTS;                                          // Time stamp(unit:ms)
	NET_TIME_EX         UTC;                                          // Event occurred time
	int                 nAction;                                      // Action:1-start 2-stop

	EM_CLASS_TYPE		emClassType;								  // IVS Event Class Type
	DH_EVENT_FILE_INFO	stuFileInfo;								  // Event corresponding to file information
	int					nObjectNum;									  // Detect Object number
	DH_MSG_OBJECT       stuObjects[MAX_OBJECT_NUM];                    // Detect Object
	int                 nDetectRegionNum;                   		  // Detect Region point number	
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM]; 	  // Detect Region
	int					nCount;										  // Event Attach Count
	int				    nPresetID;									  // Preset ID
	NET_EXTENSION_INFO  stuExtensionInfo;                             // Extension info
	BYTE				byReserved[1028];							  // Reserved
} DEV_EVENT_BANNER_DETECTION_INFO;

typedef struct tagNONMOTOR_IMAGE_INFO
{
    int nOffset;                                                        // offset in the binary data
    int nLength;                                                        // image size (Byte)
}NONMOTOR_IMAGE_INFO;

// EVENT_IVS_NONMOTORDETECT(NonMotorDetect) corresponding data block description info
typedef struct tagDEV_EVENT_NONMOTORDETECT_INFO
{
    int					nChannelID;									    // Channel number
    int                 nEventID;                                       // Event id
    char				szName[DH_EVENT_NAME_LEN];					    // Event name
    double              PTS;                                            // Time stamp(ms)
    NET_TIME_EX         UTC;                                            // Event occurred time
    int                 nAction;                   					    // Event action, 0: Pulse, 1: Start, 2: Stop

    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                     // intelli comm info
    DWORD               dwSnapFlagMask;                                 // snapshot mark (by bit), see NET_RESERVED_COMMON   
    DH_RESOLUTION_INFO  stuResolution;                                  // corresponding picture resolution

    NONMOTOR_IMAGE_INFO stuImageInfo;                                   // cut image info
    int					nNumOfCycling;								    // Cycling number
    EM_OBJECT_COLOR_TYPE emNonMotorColor;							    // Non-Motor color
    DH_RECT				        stuBoundingBox;                         // BoundingBox
    EM_SEX_TYPE		            emSex;								    // its sex(when only one person in the non-motor)
    int					        nAge;								    // its age(when only one person in the non-motor)

    EM_NONMOTOR_OBJECT_STATUS   emHelmet;					  		    // Whether or not wearing a helmet
    EM_NONMOTOR_OBJECT_STATUS   emCall;							        // Whether on the phone(when only one person in the non-motor)
    EM_NONMOTOR_OBJECT_STATUS   emHat;					  			    // Whether or not wearing a hat(when only one person in the non-motor)
    EM_NONMOTOR_OBJECT_STATUS   emBag;					  			    // Whether or not have bag(when only one person in the non-motor)
    EM_NONMOTOR_OBJECT_STATUS   emCarrierBag;					  	    // Whether or not have carrierbag(when only one person in the non-motor)
    EM_NONMOTOR_OBJECT_STATUS   emUmbrella;					  	        // Whether an umbrella(when only one person in the non-motor)
    EM_NONMOTOR_OBJECT_STATUS   emGlasses;					  	  	    // Whether or not wear glasses(when only one person in the non-motor)
    EM_NONMOTOR_OBJECT_STATUS   emMask;					  	  	        // Whether to wear a face mask(when only one person in the non-motor)

    EM_EMOTION_TYPE             emEmotion;                              // Emotion(when only one person in the non-motor)
    EM_CLOTHES_TYPE             emUpClothes;                            // UpClothes type(when only one person in the non-motor)
    EM_CLOTHES_TYPE             emDownClothes;                          // DownClothes type(when only one person in the non-motor)
    EM_OBJECT_COLOR_TYPE        emUpperBodyColor;                       // UpClothes color(when only one person in the non-motor)
    EM_OBJECT_COLOR_TYPE        emLowerBodyColor;                       // DownClothes color(when only one person in the non-motor)
	EM_CATEGORY_NONMOTOR_TYPE   emCategoryType;                         // CategoryType
	BYTE						byReserved[1024];						// Reserved
}DEV_EVENT_NONMOTORDETECT_INFO;

// Trigger type
typedef enum tagEM_TRIGGER_TYPE
{
	EM_TRIGGER_TYPE_UNKNOWN = -1,          // Unknown
	EM_TRIGGER_TYPE_CAR_INSPECTION_DEV,	   // Car inspection device
	EM_TRIGGER_TYPE_DADAR,				   // Dadar
	EM_TRIGGER_TYPE_VIDEO,				   // Video
}EM_TRIGGER_TYPE;

// Violation alarm type
typedef enum tagEM_VIOLATION_ALARM_TYPE
{
	EM_VIOLATION_ALARM_TYPE_UNKNOWN = -1,				// Unknown
	EM_VIOLATION_ALARM_TYPE_PARKING_VIOLATION,		// Parking violation
	EM_VIOLATION_ALARM_TYPE_PREALARM,				// PreAlarm
}EM_VIOLATION_ALARM_TYPE;

// Custom GPS info(vehicle require)
typedef struct tagNET_CUSTOM_GPS_INFO
{
	double                  dbLongitude;                      // Longitude(1/1000000,range[0-360])
	double                  dbLatidude;                       // Latitude(1/1000000,range[0-180])
	double					dbAltitude;						  // Altitude,Unit:meter
	double				    dbSpeed;						  // Speed,Unit:km/H
	double					dbBearing;						  // Bearing,Unit:degree
	BYTE					byReserved[1024];				  // Reserved
}NET_CUSTOM_GPS_INFO;

// EVENT_IVS_TRAFFIC_BAN (TrafficBan)corresponding data block description info
typedef struct tagDEV_EVENT_TRAFFIC_BAN_INFO
{
	int							nChannelID;											// Channel ID
	EM_TRIGGER_TYPE				emTriggerType;										// Trigger type
	char						szName[MAX_EVENT_NAME_LEN];							// Event name
	double						dbPTS;												// Time stamp(ms)
	NET_TIME_EX					UTC;												// Event occurred time
	int							nEventID;											// Event ID
	DH_MSG_OBJECT				stuObject;											// Plate info
	DH_MSG_OBJECT				stuVehicle;											// Car body info
	int							nMark;												// Bottom generated trigger snapshot frame mark
	int							nSource;											// Video analysis data source address
	int							nFrameSequence;										// Video analysis frame sequence
	int							nLane;											    // Lane number
	NET_TIME					stuStartParkingTime;								// Start parking time
	int							nAlarmInterval;										// Alarm internal,Unit:second
	int							nParkingAllowedTime;								// Parking allowed time,Unit:second
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO   stTrafficCar;								// Traffic car info
	DH_EVENT_FILE_INFO			stuFileInfo;										// File info
	NET_CUSTOM_GPS_INFO			stuCustomGPSStatus;									// Custom GPS info
	EM_VIOLATION_ALARM_TYPE		emViolationAlarmType;								// Violation alarm type 
	int							nSequence;											// Snap index,such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	BYTE						byReserved[1024];									// Reserved
	EVENT_COMM_INFO				stCommInfo;											// Public info
}DEV_EVENT_TRAFFIC_BAN_INFO;

// Corresponding to data block description of event type EVENT_IVS_ELEVATOR_ABNORMAL(elevator abnormal)
typedef struct tagDEV_EVENT_ELEVATOR_ABNORMAL_INFO
{
	int                 nChannelID;							// channel ID
	int                 nEventID;                           // Event ID
	char                szName[DH_EVENT_NAME_LEN];          // evnet name
	double              dbPTS;                              // Timestamp (in milliseconds)
	NET_TIME_EX         UTC;                                // Time for the event occurred
    
    int                 nAction;                            // 1: Start, 2: Stop
    EM_CLASS_TYPE		emClassType;						// class type
    int					nDetectRegionPointNum;				// Number of points in elevator detection area
    NET_POINT		    stuDetectRegion[20];				// Polygon area of elevator detection area.The coordinates are normalized to [08192] interval.
    NET_POINT           stuDirection[2];                    // The movement direction of the elevator. The first point is the starting point and the second is the end point. The coordinates are normalized to [08192] interval.
    BYTE                byReserved1[920];				    // Reserved
} DEV_EVENT_ELEVATOR_ABNORMAL_INFO;

// item info in pos exchange
typedef struct tagNET_POS_ITEM_INFO
{
	char				szItemName[DH_COMMON_STRING_32];					// item name
	double				dbPrice;											// price
	double				dbQuantity;											// quantity
	double				dbAmount;											// amount
	char				szUnit[DH_COMMON_STRING_8];							// price unit
	BYTE				byReserved[256];									// reserved
} NET_POS_ITEM_INFO;

//  Corresponding to data block description of event type EVENT_IVS_POS_EXCHANGE(POSExchange events)
typedef struct tagDEV_EVENT_POS_EXCHANGE_INFO
{
	int                 nChannelID;							// Channel ID
    int                 nAction;                            // event action, 0: Pulse, 1: Start, 2: Stop
	char                szName[DH_EVENT_NAME_LEN];			// Event name
    double              dbPTS;								// Time stamp(unit:ms)
    NET_TIME_EX         UTC;								// Event occurred time
    int                 nEventID;							// Event ID
	
	char				szDealNum[DH_COMMON_STRING_16];		// Deal number
	char				szCardID[DH_COMMON_STRING_16];		// Card ID
	BYTE				byReserved1[4];						// byte alignment
	int					nItemListCount;						// Item list count 
	NET_POS_ITEM_INFO	*pstItemList;						// Item List, size is nItemListCount*sizeof(NET_POS_ITEM_INFO)
	NET_RECT			stRect;								// Rect
	NET_COLOR_RGBA      stFrontColor;						// OSD front color
	unsigned int		nFontSize;							// Font Size, unit:px
	BYTE                byReserved[1020];				    // reserved  
} DEV_EVENT_POS_EXCHANGE_INFO;

// Corresponding to data block description of event type EVENT_IVS_DISTANCE_DETECTION (distance detection)
typedef struct tagDEV_EVENT_DISTANCE_DETECTION_INFO
{
	int                 nChannelID;                         // Channel ID
	char                szName[128];                        // Evnet name
	int                 nAction;                            // Event action, 0: Pulse, 1: Start, 2: Stop
	double              PTS;                                // Timestamp (in milliseconds)
	NET_TIME_EX         UTC;                                // Time for the event occurred
	int                 nEventID;                           // Event ID
	DH_MSG_OBJECT       stuObject;                          // Have being detected object
	int                 nDetectRegionNum;                   // Rule detect region's point number
	NET_POINT           stuDetectRegion[DH_MAX_DETECT_REGION_NUM]; // Rule detect region
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // Intelli comm info
	BYTE                byReserved[1024];				    // Reserved bytes 
} DEV_EVENT_DISTANCE_DETECTION_INFO;

// Corresponding to data block description of event type EVENT_IVS_FORWARDCOLLISION_WARNNING(forwad collision warnning)
typedef struct tagDEV_EVENT_FORWARDCOLLISION_WARNNING_INFO
{
    int                     nChannelID;                                 // Channel ID
    int                     nEventID;                                   // Event ID
    char                    szName[DH_EVENT_NAME_LEN];                  // Evnet name
    double                  PTS;                                        // Timestamp (in milliseconds)
    NET_TIME_EX             UTC;                                        // Time for the event occurred
    int                     nAction;                                    // Event action, 0: Pulse, 1: Start, 2: Stop

    NET_GPS_STATUS_INFO     stuGPSStatusInfo;                           // GPS info
    char                    szDriverID[32];                             // Driver ID
    char                    szVideoPath[256];                           // ftp path for assocated video
    BYTE                    byReserved[736];                            // Reserved bytes
} DEV_EVENT_FORWARDCOLLISION_WARNNING_INFO;

// Corresponding to data block description of event type EVENT_IVS_MATERIALSSTAY(MaterialsStay)
typedef struct tagDEV_EVENT_MATERIALSSTAY_INFO
{
	int						nChannelID;										// Channel ID
	int						nEventID;										// Event ID
	char					szName[DH_EVENT_NAME_LEN];						// Event Name
	double					PTS;											// Timestamp (in milliseconds)
	NET_TIME_EX				UTC;											// Time for the event occurred
	int						nAction;										// Event action, 0: Pulse, 1: Start, 2: Stop

	DH_EVENT_FILE_INFO		stuFileInfo;									// File info
	int						nDetectRegionNum;                   			// Detect region's point number	
	DH_POINT				DetectRegion[DH_MAX_DETECT_REGION_NUM]; 		// Detect region
	char					szPresetName[64];								// Preset name
	EVENT_INTELLI_COMM_INFO stuIntelliCommInfo;								// Intelli comm info 
	BYTE					byReserved[4092];								// Reserved  
} DEV_EVENT_MATERIALSSTAY_INFO;

// Corresponding to data block description of event type EVNET_IVS_LANEDEPARTURE_WARNNING(lane departure warnning)
typedef struct tagDEV_EVENT_LANEDEPARTURE_WARNNING_INFO
{
    int                     nChannelID;                                 // Channel ID
    int                     nEventID;                                   // Event ID
    char                    szName[DH_EVENT_NAME_LEN];                  // Evnet name
    double                  PTS;                                        // Timestamp (in milliseconds)
    NET_TIME_EX             UTC;                                        // Time for the event occurred
    int                     nAction;                                    // Event action, 0: Pulse, 1: Start, 2: Stop

    NET_GPS_STATUS_INFO     stuGPSStatusInfo;                           // GPS info
    char                    szDriverID[32];                             // Driver ID
    char                    szVideoPath[256];                           // ftp path for assocated video
    BYTE                    byReserved[736];                            // Reserved bytes
} DEV_EVENT_LANEDEPARTURE_WARNNING_INFO;


// Corresponding to data block description of event type EVENT_IVS_TRAFFIC_NONMOTOR_OVERLOAD (Non-motor overload)
typedef struct tagDEV_EVENT_TRAFFIC_NONMOTOR_OVERLOAD_INFO
{
	int							nChannelID;                         // Channel ID
	char						szName[128];                        // Evnet name
	int							nAction;                            // Event action, 0: Pulse, 1: Start, 2: Stop
	double						PTS;                                // Timestamp (in milliseconds)
	NET_TIME_EX					UTC;                                // Time for the event occurred
	int							nEventID;                           // Event ID
	DH_EVENT_FILE_INFO			stuFileInfo;						// Event corresponding to file information
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;					// Intelli comm info 
	DWORD						dwSnapFlagMask;                     // snapshot mark (by bit), see NET_RESERVED_COMMON   
	DH_RESOLUTION_INFO			stuResolution;                      // picture resolution

	VA_OBJECT_NONMOTOR			stuNonMotor;						// NonMotor information
	int							nLane;								// Line number
	int							nSequence;							// Snap index,such as 3,2,1/0.  1 means the last one,0 means there has some exception and snap stop
	EVENT_COMM_INFO				stuCommInfo;						// common information
	BYTE						byReserved[2048];				    // Reserved  
} DEV_EVENT_TRAFFIC_NONMOTOR_OVERLOAD_INFO;

// Corresponding to data block description of event type EVENT_IVS_TRAFFIC_NONMOTOR_WITHOUTSAFEHAT (Non-motor without safehat)
typedef struct tagDEV_EVENT_TRAFFIC_NONMOTOR_WITHOUTSAFEHAT_INFO
{
	int							nChannelID;                         // Channel ID
	char						szName[128];                        // Evnet name
	int							nAction;                            // Event action, 0: Pulse, 1: Start, 2: Stop
	double						PTS;                                // Timestamp (in milliseconds)
	NET_TIME_EX					UTC;                                // Time for the event occurred
	int							nEventID;                           // Event ID
	DH_EVENT_FILE_INFO			stuFileInfo;						// Event corresponding to file information
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;					// Intelli comm info  
	DWORD						dwSnapFlagMask;                     // snapshot mark (by bit), see NET_RESERVED_COMMON       
	DH_RESOLUTION_INFO			stuResolution;                      // picture resolution

	VA_OBJECT_NONMOTOR			stuNonMotor;						// NonMotor information
	int							nLane;								// Line number
	int							nSequence;							// Snap index,such as 3,2,1/0. 1 means the last one,0 means there has some exception and snap stop
	EVENT_COMM_INFO				stuCommInfo;						// common information
	BYTE						byReserved[2048];				    // Reserved  
} DEV_EVENT_TRAFFIC_NONMOTOR_WITHOUTSAFEHAT_INFO; 

// Corresponding to data block description of event type EVENT_IVS_TRAFFIC_NONMOTOR_HOLDUMBRELLA
typedef struct tagDEV_EVENT_TRAFFIC_NONMOTOR_HOLDUMBRELLA_INFO
{
	int							nChannelID;                         // Channel ID
	int							nAction;                            // Event action, 0: Pulse, 1: Start, 2: Stop
	char						szName[128];                        // Evnet name
	double						PTS;                                // Timestamp (in milliseconds)
	NET_TIME_EX					UTC;                                // Time for the event occurred
	int							nEventID;                           // Event ID
	DH_EVENT_FILE_INFO			stuFileInfo;						// Event corresponding to file information
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;					// The common information of intelligence event 
	DWORD						dwSnapFlagMask;                     // snapshot mark (by bit), see NET_RESERVED_COMMON     
	DH_RESOLUTION_INFO			stuResolution;                      // picture resolution

	DH_MSG_OBJECT				stuObject;                          // Object
	VA_OBJECT_NONMOTOR			stuNonMotor;						// NonMotor information
	int							nLane;								// Line number
	int							nSequence;							// Snap index,such as 3,2,1/0. 1 means the last one,0 means there has some exception and snap stop
	EVENT_COMM_INFO				stCommInfo;                         // Common information
	BYTE						byReserved[4096];				    // Reserved  
}DEV_EVENT_TRAFFIC_NONMOTOR_HOLDUMBRELLA_INFO;

// Corresponding to data block description of event type EVENT_IVS_VIDEOUNFOCUS_ALARM (Video unfocus)
typedef struct tagDEV_EVENT_VIDEOUNFOCUS_INFO
{
	int						nChannelID;									  // Channel ID
	int						nEventID;                                     // Event ID
	char					szName[DH_EVENT_NAME_LEN];					  // Evnet name
	double					PTS;                                          // Timestamp (in milliseconds)
	NET_TIME_EX				UTC;                                          // Time for the event occurred
	int						nAction;                                      // Event action, 0: Pulse, 1: Start, 2: Stop
	BYTE					byReserved[4096];				    		  // Reserved  
}DEV_EVENT_VIDEOUNFOCUS_INFO; 

// Corresponding to data block description of event type EVENT_IVS_FLOWBUSINESS (FlowBusiness)
typedef struct tagDEV_EVENT_FLOWBUSINESS_INFO
{
	int                 nChannelID;										// Channel ID
	int                 nAction;										// Event action, 0: Pulse, 1: Start, 2: Stop
	char                szName[128];									// Event name
	double              PTS;											// Timestamp (in milliseconds)
	NET_TIME_EX         UTC;											// Time for the event occurred
	int                 nEventID;										// Event ID

	DH_EVENT_FILE_INFO	stuFileInfo;									// Event corresponding to file information
	int                 nDetectRegionNum;                   			// Detect Region point number		
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM]; 		// Detect Region	
	char				szPresetName[64];								// Preset name
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;						// Intelli comm info 
    UINT                nViolationDuration;                            // Duration of violation of law,unit:second,default value 0 is meaningless
    int					nObjectNum;										// The number of detected object
    DH_MSG_OBJECT		stuObjects[HDBJ_MAX_OBJECTS_NUM];				// Detected object
    char				szSourceID[32];						            // Correlate event ID, events arising from same object or picture could have same correlate event ID
	DWORD               dwSnapFlagMask;									// flag(by bit),see NET_RESERVED_COMMON      
	BYTE                byReserved[2044];								// Reserved  
} DEV_EVENT_FLOWBUSINESS_INFO;

// Corresponding to data block description of event type EVENT_IVS_CITY_MOTORPARKING (CityMotorParking)
typedef struct tagDEV_EVENT_CITY_MOTORPARKING_INFO
{
	int                 nChannelID;										// Channel ID
	int                 nAction;										// Event action, 0: Pulse, 1: Start, 2: Stop
	char                szName[128];									// Event name
	double              PTS;											// Timestamp (in milliseconds)
	NET_TIME_EX         UTC;											// Time for the event occurred
	int                 nEventID;										// Event ID

	DH_EVENT_FILE_INFO	stuFileInfo;									// Event corresponding to file information
	int					nObjectNum;										// Have been detected object number
	DH_MSG_OBJECT		stuObjects[MAX_OBJECT_NUM];					// Have been detected object list
	int                 nDetectRegionNum;                   			// Detect Region point number	
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM]; 		// Detect Region
	char				szPresetName[64];								// Preset name
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;						// Intelli comm info
    UINT                nParkingDuration;                               // Duration of violation of parking,unit:second,default value 0 is meaningless
	char				szSourceID[32];						            // Correlate event ID, events arising from same object or picture could have same correlate event ID
	DWORD               dwSnapFlagMask;									// flag(by bit),see NET_RESERVED_COMMON         
	BYTE                byReserved[4056];								// Reserved  
} DEV_EVENT_CITY_MOTORPARKING_INFO;

// Corresponding to data block description of event type EVENT_IVS_CITY_NONMOTORPARKING (CityNonMotorParking)
typedef struct tagDEV_EVENT_CITY_NONMOTORPARKING_INFO
{
	int                 nChannelID;										// Channel ID
	int                 nAction;										// Event action, 0: Pulse, 1: Start, 2: Stop
	char                szName[128];									// Event name
	double              PTS;											// Timestamp (in milliseconds)
	NET_TIME_EX         UTC;											// Time for the event occurred
	int                 nEventID;										// Event ID

	DH_EVENT_FILE_INFO	stuFileInfo;									// Event corresponding to file information
	int                 nDetectRegionNum;                   			// Detect Region point number	
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM]; 		// Detect Region
	int					nAlarmNum;										// Alarm threshold
	int					nNoMotorNum;									// The number of non-motor
	char				szPresetName[64];								// Preset name
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;						// Intelli comm info  
    UINT                nViolationDuration;                             // Duration of violation of law,unit:second,default value 0 is meaningless
    int					nObjectNum;										// The number of detected object
    DH_MSG_OBJECT		stuObjects[HDBJ_MAX_OBJECTS_NUM];				// Detected object
    char				szSourceID[32];						            // Correlate event ID, events arising from same object or picture could have same correlate event ID
	DWORD               dwSnapFlagMask;									// flag(by bit),see NET_RESERVED_COMMON     
	BYTE                byReserved[2044];								// Reserved 
} DEV_EVENT_CITY_NONMOTORPARKING_INFO;

// AirPlane state
typedef enum tagEM_AIRPLANE_STATE
{
	EM_AIRPLANE_STATE_UNKNOWN = 0,
	EM_AIRPLANE_STATE_ENTER,						// Enter
	EM_AIRPLANE_STATE_LEAVE,						// Leave
	EM_AIRPLANE_STATE_CHOCKON,						// Chock On
	EM_AIRPLANE_STATE_CHOCKOFF,						// Chock Off
	EM_AIRPLANE_STATE_NEARBRIDGE,					// Near bridge
	EM_AIRPLANE_STATE_LEAVEBRIDGE,					// Leave bridge
	EM_AIRPLANE_STATE_OPENDOOR,						// Open door
	EM_AIRPLANE_STATE_CLOSEDOOR						// Close door
}EM_AIRPLANE_STATE;

// Corresponding to data block description of event type EVENT_IVS_AIRPLANE_DETECTION  (AirPlaneDetection)
typedef struct tagDEV_EVENT_AIRPLANE_DETECTION_INFO
{
	int                 nChannelID;										// Channel ID
	int                 nAction;										// Event action, 0: Pulse, 1: Start, 2: Stop
	char                szName[128];									// Event name
	double              PTS;											// Timestamp (in milliseconds)
	NET_TIME_EX         UTC;											// Event occurrence time
	int                 nEventID;										// Event ID

	DH_EVENT_FILE_INFO	stuFileInfo;									// Event corresponding to file information
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;						// General intelligent information

	NET_POINT			stuGuideLine[2];								// The configuration of guide line
	NET_POINT			stuStopLine[10][2];								// The configuration of stop line
	int					nStopLineNum;									// The number of stop line configuration
	int					nAirPlaneID;									// AirPlane ID
	NET_POINT			stuAirPlaneStopLine[2];							// The stop line of airplane
	NET_RECT			stuRect;										// The position rect of airplane
	EM_AIRPLANE_STATE	emAirPlaneState;								// The state of airplane

	BYTE                byReserved[4096];								// Reserved  
} DEV_EVENT_AIRPLANE_DETECTION_INFO;

// Corresponding to data block description of event type EVENT_IVS_PHONECALL_DETECT  (phone call detect event)
typedef struct tagDEV_EVENT_PHONECALL_DETECT_INFO
{
	int                 nChannelID;										// Channel ID
	int                 nAction;										// Event action, 0:Pulse, 1:Start, 2:Stop
	char                szName[MAX_EVENT_NAME];							// Event name
	double              PTS;											// Timestamp (in milliseconds)
	NET_TIME_EX         UTC;											// Event occurrence time
	int                 nEventID;										// Event ID

	int					nGroupID;										// id of event group
	int					nCountInGroup;									// the file count in the current file's group
	int					nIndexInGroup;									// the index of the file in the group
	unsigned int		UTCMS;											// UTC corresponds to milliseconds
	DH_MSG_OBJECT		stuObject;										// detect object
	int					nDetectRegionNum;								// rule detect region's point number
	DH_POINT			stuDetectRegion[DH_MAX_DETECT_REGION_NUM];		// rule detect region
	EVENT_INTELLI_COMM_INFO  stuIntelliCommInfo;						// The common information of intelligence event
	BYTE				byReserved[1024];								// Reserved
} DEV_EVENT_PHONECALL_DETECT_INFO;

// Corresponding to data block description of event type EVENT_IVS_SMOKING_DETECT(smoking detect)
typedef struct tagDEV_EVENT_SMOKING_DETECT_INFO
{
	int                 nChannelID;										// Channel ID
	int                 nAction;										// Event action, 0:Pulse, 1:Start, 2:Stop
	char                szName[MAX_EVENT_NAME];							// Event name
	double              PTS;											// Timestamp (in milliseconds)
	NET_TIME_EX         UTC;											// Event occurrence time
	int                 nEventID;										// Event ID

	int					nGroupID;										// id of event group
	int					nCountInGroup;									// the file count in the current file's group
	int					nIndexInGroup;									// the index of the file in the group
	unsigned int		UTCMS;											// UTC corresponds to milliseconds
	DH_MSG_OBJECT		stuObject;										// detect object
	int					nDetectRegionNum;								// rule detect region's point number
	DH_POINT			stuDetectRegion[DH_MAX_DETECT_REGION_NUM];		// rule detect region
	EVENT_INTELLI_COMM_INFO  stuIntelliCommInfo;						// The common information of intelligence event
	BYTE				byReserved[1024];								// Reserved
} DEV_EVENT_SMOKING_DETECT_INFO;

// Corresponding to data block description of event type EVENT_IVS_RADAR_SPEED_LIMIT_ALARM(radar speed limit alarm)
typedef struct tagDEV_EVENT_RADAR_SPEED_LIMIT_ALARM_INFO
{
	int                 nChannelID;                                     // Channel ID
	int                 nAction;                                        // Event action, 0:Pulse 1:Start 2:Stop
    char                szAddress[32];                                  // Device IP address
    int                 nSpeed;                                         // Speed, km/h
    NET_TIME_EX         UTC;                                            // Event occurrence time

    int                 nGroupID;                                       // id of event group
    int                 nCountInGroup;                                  // the file count in the current file's group
    int                 nIndexInGroup;                                  // the index of the file in the group
    EVENT_INTELLI_COMM_INFO    stuIntelliCommInfo;                      // The common information of intelligence event
    BYTE                byReserved[1024];                               // Reserved
}DEV_EVENT_RADAR_SPEED_LIMIT_ALARM_INFO;

// fruit type
typedef enum tagEM_FRUIT_TYPE
{
	EM_FRUIT_TYPE_UNKNOWN,					// unknown
	EM_FRUIT_TYPE_GREEN_TANGERINE,			// green tangerine
	EM_FRUIT_TYPE_YELLOW_TANGERINE_ORANGE,	// yellow tangerine, orange
	EM_FRUIT_TYPE_GRAPEFRUIT,				// grapefruit
	EM_FRUIT_TYPE_LEMON,					// lemon
	EM_FRUIT_TYPE_WATERMELON,				// watermelon
	EM_FRUIT_TYPE_BANANA,					// banana
	EM_FRUIT_TYPE_RED_APPLE,				// red apple
	EM_FRUIT_TYPE_GREEN_APPLE,				// green apple
	EM_FRUIT_TYPE_MUSKMELON,				// muskmelon
	EM_FRUIT_TYPE_HAMIMELON,				// hamimelon
	EM_FRUIT_TYPE_PEAR,						// pear
	EM_FRUIT_TYPE_KIWI,						// kiwi
	EM_FRUIT_TYPE_PAPAYA,					// papaya
	EM_FRUIT_TYPE_PINEAPPLE,				// pineapple
	EM_FRUIT_TYPE_MANGO,					// mango
	EM_FRUIT_TYPE_LONGAN,					// longan
	EM_FRUIT_TYPE_GINSENG_FRUIT,			//  ginseng fruit
	EM_FRUIT_TYPE_POMEGRABATE,				// pomegrabate
	EM_FRUIT_TYPE_COCONUT,					// coconut
	EM_FRUIT_TYPE_CREAM_JUJUBE,				// cream jujube
	EM_FRUIT_TYPE_WINTER_JUJUBE,			// winter jujube
	EM_FRUIT_TYPE_AVOCADO,					// avocado
	EM_FRUIT_TYPE_RED_PLUM,					// red plum
	EM_FRUIT_TYPE_PITAYA,					// pitaya
	EM_FRUIT_TYPE_GUAVA,					// guava
	EM_FRUIT_TYPE_PERSIMMON,				// persimmon
	EM_FRUIT_TYPE_YACON,					// yacon
} EM_FRUIT_TYPE;

// the info of fruit
typedef struct tagNET_CANDIDATE_FRUIT_INFO
{
	UINT				nSimilarity;				// similarity
	EM_FRUIT_TYPE		emFruitType;				// fruit type
	BYTE                byReserved[1024];            // reserved
} NET_CANDIDATE_FRUIT_INFO;

// Corresponding to data block description of event type EVENT_IVS_WEIGHING_PLATFORM_DETECTION(event of weighing platform detection)
typedef struct tagDEV_EVENT_WEIGHING_PLATFORM_DETECTION_INFO
{
	int                 		nChannelID;					// Channel ID
	int                 		nAction;					// Event action, 0:Pulse, 1:Start, 2:Stop
	char                		szName[MAX_EVENT_NAME];		// Event name
	double              		PTS;						// Timestamp (in milliseconds)
	NET_TIME_EX         		UTC;						// Event occurrence time
	int                 		nEventID;					// Event ID

	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // The common information of intelligence event
	UINT						nCandidateFruitNum;			// Number of fruits which are detectioned
	NET_CANDIDATE_FRUIT_INFO	stuFruitInfos[100];			// The info of fruits which are detectioned
	SCENE_IMAGE_INFO_EX			stuSceneImage;				// Scene image
	SCENE_IMAGE_INFO_EX			stuFruitImage;				// Fruit image
	BYTE                		byReserved[1024];           // Reserved
} DEV_EVENT_WEIGHING_PLATFORM_DETECTION_INFO;

// media file query condition
typedef enum __EM_FILE_QUERY_TYPE
{
	DH_FILE_QUERY_TRAFFICCAR,							// Vehicle information,corresponding structure is MEDIA_QUERY_TRAFFICCAR_PARAM
	DH_FILE_QUERY_ATM,									// ATM information
	DH_FILE_QUERY_ATMTXN,								// ATM transaction information 
	DH_FILE_QUERY_FACE,  								// Face info
    DH_FILE_QUERY_FILE,                                 // file info, corresponding to NET_IN_MEDIA_QUERY_FILE and NET_OUT_MEDIAFILE_FILE
	DH_FILE_QUERY_TRAFFICCAR_EX,						// Transportation vehicle information, expand DH_FILE_QUERY_TRAFFICCAR, support more fields,corresponding structure is MEDIA_QUERY_TRAFFICCAR_PARAM_EX
    DH_FILE_QUERY_FACE_DETECTION,                       // face recognition event info MEDIAFILE_FACE_DETECTION_PARAM  and MEDIAFILE_FACE_DETECTION_INFO
    DH_FILE_QUERY_IVS_EVENT,                            // ivs event info MEDIAFILE_IVS_EVENT_PARAM and MEDIAFILE_IVS_EVENT_INFO
    DH_FILE_QUERY_ANALYSE_OBJECT,                       // analyse object info MEDIAFILE_ANALYSE_OBJECT_PARAM and MEDIAFILE_ANALYSE_OBJECT_INFO
	DH_FILE_QUERY_MPT_RECORD_FILE,                      // query mpt record file,corresponding to MEDIAFILE_MPT_RECORD_FILE_PARAM and MEDIAFILE_MPT_RECORD_FILE_INFO
	DH_FILE_QUERY_XRAY_DETECTION,						// X-ray package info,corresponding to MEDIAFILE_XRAY_DETECTION_PARAM and MEDIAFILE_XRAY_DETECTION_INFO
    DH_FILE_QUERY_HUMAN_TRAIT,                          // Human traut info,corresponding to MEDIAFILE_HUMAN_TRAIT_PARAM and MEDIAFILE_HUMAN_TRAIT_INFO
	DH_FILE_QUERY_NONMOTOR,								// nonmotor record info,  corresponding to MEDIAFILE_NONMOTOR_PARAM and MEDIAFILE_NONMOTOR_INFO
	DH_FILE_QUERY_DOORCONTROL_RECORD,					// door control record info, corresponding to MEDIAFILE_DOORCONTROL_RECORD_PARAM and MEDIAFILE_DOORCONTROL_RECORD_INFO
	DH_FILE_QUERY_FACEBODY_DETECT,						// face body detect infoMEDIAFILE_FACEBODY_DETECT_PARAM and MEDIAFILE_FACEBODY_DETECT_INFO
	DH_FILE_QUERY_FACEBODY_ANALYSE,						// face body analyseMEDIAFILE_FACEBODY_ANALYSE_PARAM and MEDIAFILE_FACEBODY_ANALYSE_INFO
	DH_FILE_QUERY_FILE_EX,								// file info extended(customized), corresponding to NET_IN_MEDIA_QUERY_FILE and NET_OUT_MEDIAFILE_FILE
														// stuEventInfo and nEventInfoCount in NET_IN_MEDIA_QUERY_FILE are valid; nEventLists and nEventCount are invalid
} EM_FILE_QUERY_TYPE;

typedef enum _EM_RECORD_SNAP_FLAG_TYPE
{
    FLAG_TYPE_TIMING ,                  //Schele
    FLAG_TYPE_MANUAL ,                  //Manual
    FLAG_TYPE_MARKED ,                  //Important
    FLAG_TYPE_EVENT  ,                  //Event
    FLAG_TYPE_MOSAIC ,                  //Combined
    FLAG_TYPE_CUTOUT ,                  //Cut
    FLAG_TYPE_LEAVE_WORD ,              //Message
    FLAG_TYPE_TALKBACK_LOCAL_SIDE ,     //Talk Local
    FLAG_TYPE_TALKBACK_REMOTE_SIDE ,    //Talk Remote
    FLAG_TYPE_SYNOPSIS_VIDEO ,          //Compressed Video
    FLAG_TYPE_ORIGINAL_VIDEO ,          //Original Video
    FLAG_TYPE_PRE_ORIGINAL_VIDEO ,      //Processed
    FLAG_TYPE_BLACK_PLATE ,             //Blacklist Picture
    FLAG_TYPE_ORIGINAL_PIC ,            //Original Picture
    FLAG_TYPE_CARD,                     //card no. record
    FLAG_TYPE_MAX = 128, 
}EM_RECORD_SNAP_FLAG_TYPE;

// ATM trsaction type
typedef enum
{
    ATM_TRADE_ALL,                      // all types
    ATM_TRADE_ENQUIRY,                  // search
    ATM_TRADE_WITHDRAW,                 // withdraw
    ATM_TRADE_MODIFY_PASSWORD,          // change password
    ATM_TRADE_TRANSFER,                 // transfer
    ATM_TRADE_DEPOSIT,                  // deposit
    ATM_TRADE_CARDLESS_ENQUIRY,         // search without card
    ATM_TRADE_CARDLESS_DEPOSIT,         // deposit without card
    ATM_TRADE_OTHER,                    // other
}EM_ATM_TRADE_TYPE;

// card no. record info
typedef struct
{
    DWORD               dwSize;
    int                 nType;          				// type, 0-Card, 1-Field
    char                szCardNo[DH_MAX_CARD_INFO_LEN]; // card no.
    EM_ATM_TRADE_TYPE   emTradeType;    				// transaction type
    char                szAmount[DH_COMMON_STRING_64]; 	// transaction amount, nullstring means no limit amount
    int                 nError;         				// error code, 0-all errors, 1-retain cash, 2-retain card
    int                 nFieldCount;    				// domain quantity, by domain search is valid
    char                szFields[MAX_CARD_RECORD_FIELD_NUM][DH_COMMON_STRING_256];   // domain info, by domain search is valid
	char				szChange[DH_COMMON_STRING_32];	// change
}NET_RECORD_CARD_INFO;

#define MAX_IVS_EVENT_NUM    256
#define MAX_QUERY_USER_NUM   4                 // max number of user

// the order of result order 
typedef enum tagEM_RESULT_ORDER_TYPE
{
    EM_RESULT_ORDER_UNKNOWN,                    // unknown order type
    EM_RESULT_ORDER_ASCENT_BYTIME,              // ascent by time
    EM_RESULT_ORDER_DESCENT_BYTIME,             // descent by time   
}EM_RESULT_ORDER_TYPE;

// record info, corresponde to CLIENT_FindFileEx, search condition
// support paths search in curent
typedef struct  tagNET_IN_MEDIA_QUERY_FILE
{
    DWORD               			dwSize;                 // size 
    char*               			szDirs;                 // working directory list,can inquire multiple directory at a atime,separated by ";",example "/mnt/dvr/sda0;/mnt/dvr/sda1",if szDirs==null or szDirs == "" ,means search all
    int								nMediaType;		        // file info,0:any type,1:search jpg image,2:search dav
    int                 			nChannelID;             // Channel start from 0, -1 means search all channel
    NET_TIME            			stuStartTime;           // start time	
    NET_TIME            			stuEndTime;             // end time
    int                 			nEventLists[MAX_IVS_EVENT_NUM]; // Event type list, see intelligent analysis event type
    int                 			nEventCount;            // event total
    BYTE                			byVideoStream;          // video stream 0-unknown; 1-main; 2-sub 1; 3-sub 2; 4- sub 3; 5-ExtraX 
    BYTE                			bReserved[3];           // aligh text
    EM_RECORD_SNAP_FLAG_TYPE 		emFalgLists[FLAG_TYPE_MAX]; // Record or snapshot file mark, not set mark to search all files
    int                 			nFalgCount;             // total mark
    NET_RECORD_CARD_INFO 			stuCardInfo;           	// card no. record info, emFalgLists including card no. video is valid
    int                 			nUserCount;             // user total
    char                			szUserName[MAX_QUERY_USER_NUM][DH_NEW_USER_NAME_LENGTH]; // user name
    EM_RESULT_ORDER_TYPE 			emResultOrder;         	// result order
    BOOL                			bTime;                  // find file by time
	NET_EM_COMBINATION_MODE			emCombination;			// Whether to combine video
	EVENT_INFO						stuEventInfo[16];		// event info(customized),when query type in EM_FILE_QUERY_TYPE is DH_FILE_QUERY_FILE_EX valid
	int								nEventInfoCount;		// stuEventInfo's count
}NET_IN_MEDIA_QUERY_FILE;

// record info, corresponde to CLIENT_FindFileEx, search result
typedef struct 
{
    char szKey[DH_COMMON_STRING_64]   ;      // Abstract name 
    char szValue[DH_COMMON_STRING_512] ;     // Abstract contents 
    BYTE bReserved[256];                     // Reserved string    
}NET_FILE_SUMMARY_INFO;
//  record information corresponding to DH_FILE_QUERY_FILE command when use CLIENT_FindFileEx interface
typedef struct  
{
    DWORD               dwSize;                 // size
    int					nChannelID;				// channel ID,from 0,-1 means search all
    NET_TIME			stuStartTime;			// start time
    NET_TIME			stuEndTime;				// end time
    unsigned int		nFileSize;				// size of file,This field is discarded,please use the nFileSizeEx
    BYTE				byFileType;				// file type 1:jpg, 2: dav
    BYTE                byDriveNo;              // deprecated, to get same info, use nDriveNo instead
    BYTE                byPartition;            // zone no.
    BYTE                byVideoStream;          // video stream 0-unknown  1-main 2-sub 1 3-sub 4-sub 
    unsigned int        nCluster;               // cluster
	char				szFilePath[MAX_PATH];	// FilePath
    int                 nEventLists[MAX_IVS_EVENT_NUM]; // Link event list,see event intelligent analysis event type
    int                 nEventCount;            //event total
    EM_RECORD_SNAP_FLAG_TYPE emFalgLists[FLAG_TYPE_MAX]; // record or snapshot file mark 
    int                 nFalgCount;             //mark total
    unsigned int        nDriveNo;               // disk driver number
    char szSynopsisPicPath[DH_COMMON_STRING_512];              // snap file path when pre-process the file
    int                 nSynopsisMaxTime;                      // video synopsis max time. Unit is second. 
    int                 nSynopsisMinTime;                      // video synopsis min time. Unit is second. 
    int                 nFileSummaryNum;                       // file summary number
    NET_FILE_SUMMARY_INFO   stFileSummaryInfo[MAX_FILE_SUMMARY_NUM];        // file summary info
	INT64               nFileSizeEx;                           	// size of file extension, Support file length is greater than 4G,unit:Byte
	UINT				nTotalFrame;							// all frames' num, not distinguish by frame type(customized)
}NET_OUT_MEDIA_QUERY_FILE;

// safe belt status
typedef enum tagEM_SAFE_BELT_STATE
{
	EM_SAFE_BELT_UNKNOWN,			// unknown
	EM_SAFE_BELT_OTHER,				// unidentified
	EM_SAFE_BELT_WITH,				// with safe belt
	EM_SAFE_BELT_WITHOUT,			// without safe belt
} EM_SAFE_BELT_STATE;

// attachment type
typedef enum tagEM_ATTACHMENT_TYPE
{
	EM_ATTACHMENT_UNKNOWN,			// unknown
	EM_ATTACHMENT_OTHER,			// other
	EM_ATTACHMENT_FURNITURE,		// furniture
	EM_ATTACHMENT_PENDANT,			// pendant
	EM_ATTACHMENT_TISSUEBOX,		// tissue box
	EM_ATTACHMENT_DANGER,			// danger
	EM_ATTACHMENT_PERFUMEBOX,		// perfume box
} EM_ATTACHMENT_TYPE;

// calling state
typedef enum tagEM_CALLING_STATE
{
	EM_CALLING_UNKNOWN,				// unknown
	EM_CALLING_OTHER,				// unidentified
	EM_CALLING_NO,					// not calling
	EM_CALLING_YES,					// calling
} EM_CALLING_STATE;

// car type
typedef enum tagEM_CATEGORY_TYPE
{
	EM_CATEGORY_UNKNOWN,					// Unknown
	EM_CATEGORY_OTHER,						// Other
	EM_CATEGORY_MOTOR,						// Motor
	EM_CATEGORY_BUS,						// Bus
	EM_CATEGORY_UNLICENSED_MOTOR,			// UnlicensedMotor
	EM_CATEGORY_LARGE_CAR,					// LargeCar
	EM_CATEGORY_MICRO_CAR,					// MicroCar
	EM_CATEGORY_EMBASSY_CAR,				// EmbassyCar
	EM_CATEGORY_MARGINAL_CAR,				// MarginalCar
	EM_CATEGORY_AREAOUT_CAR,				// AreaoutCar
	EM_CATEGORY_FOREIGN_CAR,				// ForeignCar
	EM_CATEGORY_FARMTRANSMIT_CAR,			// FarmTransmitCar
	EM_CATEGORY_TRACTOR,					// Tractor
	EM_CATEGORY_TRAILER,					// Trailer
	EM_CATEGORY_COACH_CAR,					// CoachCar
	EM_CATEGORY_TRIAL_CAR,					// TrialCar
	EM_CATEGORY_TEMPORARY_ENTRY_CAR,		// TemporaryEntryCar
	EM_CATEGORY_TEMPORARY_ENTRY_MOTORCYCLE,	// TemporaryEntryMotorcycle
	EM_CATEGORY_TEMPORARY_STEER_CAR,		// TemporarySteerCar
	EM_CATEGORY_LARGE_TRUCK,				// LargeTruck
	EM_CATEGORY_MID_TRUCK,					// MidTruck
	EM_CATEGORY_MICRO_TRUCK,				// MicroTruck
	EM_CATEGORY_MICROBUS,					// Microbus
	EM_CATEGORY_SALOON_CAR,					// SaloonCar
	EM_CATEGORY_CARRIAGE,					// Carriage
	EM_CATEGORY_MINI_CARRIAGE,				// MiniCarriage
	EM_CATEGORY_SUV_MPV,					// SUV or MPV
	EM_CATEGORY_SUV,						// SUV
	EM_CATEGORY_MPV,						// MPV
	EM_CATEGORY_PASSENGER_CAR,				// PassengerCar
	EM_CATEGORY_MOTOR_BUS,					// MotorBus
	EM_CATEGORY_MID_PASSENGER_CAR,			// MidPassengerCar
	EM_CATEGORY_MINI_BUS,					// MiniBus
	EM_CATEGORY_PICKUP,						// Pickup
	EM_CATEGORY_OILTANK_TRUCK,				// OilTankTruck
	EM_CATEGORY_TANK_CAR,					// TankCar
	EM_CATEGORY_SLOT_TANK_CAR,				// SlotTankCar
	EM_CATEGORY_DREGS_CAR,					// DregsCar
	EM_CATEGORY_CONCRETE_MIXER_TRUCK,		// ConcreteMixerTruck
	EM_CATEGORY_TAXI,						// Taxi
	EM_CATEGORY_POLICE,						// Police
	EM_CATEGORY_AMBULANCE,					// Ambulance
	EM_CATEGORY_GENERAL,					// General
	EM_CATEGORY_WATERING_CAR,				// WateringCar
	EM_CATEGORY_FIRE_ENGINE,				// FireEngine
	EM_CATEGORY_MACHINE_TRUCK,				// MachineshopTruck
	EM_CATEGORY_POWER_LOT_VEHICLE,			// PowerLotVehicle
	EM_CATEGORY_SUCTION_SEWAGE_TRUCK,		// SuctionSewageTruck
	EM_CATEGORY_NORMAL_TANK_TRUCK,			// NormalTankTrunk
	EM_CATEGORY_SCHOOL_BUS,					// School Bus
	EM_CATEGORY_EXCAVATOR,					// Excavator
	EM_CATEGORY_BULLDOZER,					// Bulldozer
	EM_CATEGORY_CRANE,						// Cranz
	EM_CATEGORY_PIMP_TRUCK,					// PimpTruck
} EM_CATEGORY_TYPE;

//The corresponding search criteria of  DH_MEDIA_QUERY_TRAFFICCARtypedef struct  
typedef struct
{
	int					nChannelID;						// The channel number begins with 0. -1 is to search information of all channels .
	NET_TIME			StartTime;						// Start time 	
	NET_TIME			EndTime;						// End time 
	int					nMediaType;						// File type:0=search any type.1=search jpg file
	int					nEventType;						// deprecated, to get same info, use pEventType instead
	char				szPlateNumber[32];				// Vehicle plate. "\0" is to search any plate number.
	int					nSpeedUpperLimit;				// The searched vehicle speed range. Max speed unit is km/h
	int					nSpeedLowerLimit;				// The searched vehicle speed range. Min speed unit is km/h
	BOOL				bSpeedLimit;					// Search according to the speed or not.  TRUE: search according to the speed.nSpeedUpperLimit and nSpeedLowerLimit is valid.
    DWORD				dwBreakingRule;					// Illegal type:
														// When event type is EVENT_IVS_TRAFFICGATE
														//		bit1: Retrograde;   bit2: Overline; 
														//		bit3: Overspend; 	bit4:Under speed; 
														//		bit5: RunRedLight;
														// When event type is EVENT_IVS_TRAFFICJUNCTION
														//		bit1: RunRedLight;  bit2: WrongLan;  
														//		bit3: Retrograde; 	bit4:UTurn;
														//	    bit5: Overline;
	char                szPlateType[32];                // Plate type: "Unknown" =Unknown; "Normal"=Blue and black plate. "Yellow"=Yellow plate. "DoubleYellow"=Double-layer yellow plate 
												        // "Police"=Police plate ; "Armed"= =Military police plate; "Military"=Army plate; "DoubleMilitary"=Army double-layer 
												        // "SAR" =HK SAR or Macao SAR plate; "Trainning" =rehearsal plate; "Personal"=Personal plate; "Agri"=Agricultural plate
												        // "Embassy"=Embassy plate; "Moto"=Moto plate ; "Tractor"=Tractor plate; "Other"=Other plate 
	char                szPlateColor[16];               // plate color, "Blue","Yellow", "White","Black"
	char				szVehicleColor[16];		        // vehicle color:"White", "Black", "Red", "Yellow", "Gray", "Blue","Green"
	char				szVehicleSize[16];		        // vehicle type:"Light-duty";"Medium"; "Oversize"
	int                 nGroupID;                       // id of event group(it works when >= 0)
	short               byLane;                         // lane number(it works when >= 0)
	BYTE				byFileFlag;						// file flag, 0xFF-use nFileFlagEx, 0-all record, 1-timing file, 2-manual, 3-event, 4-important, 5-mosaic
	BYTE				byRandomAccess;                 // The need for random jumps in the query process, 0 - no need 1 - need
	int					nFileFlagEx;					// file flag, bit0-timing, bit1-manual, bit2-event, bit3-important, bit4-mosaic, 0xFFFFFFFF-all
	int					nDirection;				        // direction(to the direction of car)	0-north 1-northeast 2-east 3-southeast 4-south 5-southwest 6-west 7-northwest 8-unknown -1-all directions
	char*               szDirs;                         // working directory list,can inquire multiple directory at a atime,separated by ";",example "/mnt/dvr/sda0;/mnt/dvr/sda1",if szDirs==null or szDirs == "" ,means search all
	int*                pEventTypes;                    // Check the event type to be an array of pointers, event type, see "intelligent analysis event type", if the query is NULL considered all events (buffer required to apply by the user)
	int                 nEventTypeNum;                  // Event Type array size
	char*				pszDeviceAddress;               // Device address, NULL indicates that the field does not work
	char*				pszMachineAddress;				// Machine deployment locations, NULL indicates that the field does not work
	char*				pszVehicleSign;					// Vehicle identification, such as "Unknown" - unknown, "Audi" - Audi, "Honda" - Honda ... NULL indicates that the field does not work
	WORD                wVehicleSubBrand;               // Specifies the sub-brand of vehicle,the real value can be found in a mapping table from the development manual
    WORD                wVehicleYearModel;              // Specifies the model years of vehicle. the real value can be found in a mapping table from the development manual
	EM_SAFE_BELT_STATE	emSafeBeltState;				// Safe belt state
	EM_CALLING_STATE	emCallingState;					// Calling state
	EM_ATTACHMENT_TYPE	emAttachMentType;				// Attachment type
	EM_CATEGORY_TYPE	emCarType;						// Car type
	int					bReserved[12];					// Reserved field for future extension.
} MEDIA_QUERY_TRAFFICCAR_PARAM;

// refuel type
typedef enum tagEM_REFUEL_TYPE
{
    EM_REFUEL_TYPE_UNKNOWN = 0,							// unknown
	EM_REFUEL_TYPE_NINETY_EIGHT,						// "98#"
	EM_REFUEL_TYPE_NINETY_SEVEN,						// "97#"
	EM_REFUEL_TYPE_NINETY_FIVE,							// "95#"
	EM_REFUEL_TYPE_NINETY_THREE,                        // "93#"
	EM_REFUEL_TYPE_NINETY,								// "90#"
	EM_REFUEL_TYPE_TEN,									// "10#"
	EM_REFUEL_TYPE_FIVE,								// "5#"
	EM_REFUEL_TYPE_ZERO,								// "0#"
	EM_REFUEL_TYPE_NEGATIVE_TEN,						// "-10#"
	EM_REFUEL_TYPE_NEGATIVE_TWENTY,						// "-20#"
	EM_REFUEL_TYPE_NEGATIVE_THIRTY_FIVE,				// "-35#"
	EM_REFUEL_TYPE_NEGATIVE_FIFTY,						// "-50#"
}EM_REFUEL_TYPE;

// The media file information searched by DH_MEDIA_QUERY_TRAFFICCAR
typedef struct
{
    unsigned int		ch;						// Channel number
    char				szFilePath[128];		// File path 
    unsigned int		size;					// File length,This field is discarded,please use the sizeEx 
    NET_TIME			starttime;				// Start time
    NET_TIME			endtime;				// End time
    unsigned int		nWorkDirSN;				// Working directory serial number									
	BYTE				nFileType;				// File type.  1:picture  2:video 
	BYTE                bHint;					// File location index
	BYTE                bDriveNo;               // drive number
	BYTE                bReserved2;
	unsigned int        nCluster;               // cluster number
	BYTE				byPictureType;			// picture type or file flag, 0-Normal, 1-Mosaic, 2-Cutout. more flags information ref to MEDIAFILE_TRAFFICCAR_INFO_EX's filed emFalgLists
	BYTE                byVideoStream;			// video stream 0-unknown  1-main 2-sub1 3-sub2 4-sub3 
	BYTE                byPartition;			// accurate positioning No.
	BYTE                bReserved[1];           // Reserved field for future extension. 

	//The following contents is the vehicle information 
	char				szPlateNumber[32];		// Vehicle plate number
	char				szPlateType[32];		// Plate type: "Unknown" =Unknown; "Normal"=Blue and black plate. "Yellow"=Yellow plate. "DoubleYellow"=Double-layer yellow plate 
												// "Police"=Police plate ; "Armed"= =Military police plate; "Military"=Army plate; "DoubleMilitary"=Army double-layer 
												// "SAR" =HK SAR or Macao SAR plate; "Trainning" =rehearsal plate; "Personal"=Personal plate; "Agri"=Agricultural plate
												// "Embassy"=Embassy plate; "Moto"=Moto plate ; "Tractor"=Tractor plate; "Other"=Other plate 
	char				szPlateColor[16];		// Plate color:"Blue","Yellow", "White","Black"
	char				szVehicleColor[16];		// Vehicle color:"White", "Black", "Red", "Yellow", "Gray", "Blue","Green"
	int					nSpeed;					// Speed. The unit is Km/H
	int					nEventsNum;				// Activation event amount 
	int					nEvents[32];			// Activation event list. The number refers to the corresponding event. Please refer to Intelligent Analytics Event Type.		
	DWORD				dwBreakingRule;			// Detailed offense type subnet mask. The first bit means redlight offense, the second bit is illegal straight/left-turn/right-turn driving. 
	                                            // The third bit is the wrong way driving; the four bit is illegal U-turn. Otherwise default value is intersection accident. 
	char				szVehicleSize[16];		// Vehicle type:"Light-duty"=small;"Medium"=medium; "Oversize"=large
	char				szChannelName[DH_CHAN_NAME_LEN];// Local or remote channel name
	char				szMachineName[DH_MAX_NAME_LEN];	// Local or remote device name
	int					nSpeedUpperLimit;	    // up limit of speed, km/h
	int					nSpeedLowerLimit;		// lower limit of speed km/h	
	int                 nGroupID;               // id of event group
	BYTE                byCountInGroup;         // total count of the event group
	BYTE                byIndexInGroup;         // the index of this event
	BYTE                byLane;                 // lane number
	BYTE                bReserved1[21];			// reserved
    NET_TIME            stSnapTime;             // snap time
	int					nDirection;				// direction,MEDIA_QUERY_TRAFFICCAR_PARAM
	char                szMachineAddress[MAX_PATH]; // machine address
	INT64               sizeEx;                 // size of file extension, Support file length is greater than 4G,unit:Byte
} MEDIAFILE_TRAFFICCAR_INFO, *LPMEDIAFILE_TRAFFICCAR_INFO;

// DH_MEDIA_QUERY_TRAFFICCAR_EX Corresponding query
typedef struct tagMEDIA_QUERY_TRAFFICCAR_PARAM_EX
{
	DWORD				dwSize;
	MEDIA_QUERY_TRAFFICCAR_PARAM stuParam;	        	// The basic query parameters
} MEDIA_QUERY_TRAFFICCAR_PARAM_EX;

// attachement info
typedef struct tagNET_ATTACH_MENET_INFO
{
	EM_ATTACHMENT_TYPE	emAttachMentType;					// attachment type
	BYTE                bReserved1[128];                    // Reserved 
} NET_ATTACH_MENET_INFO;

// smoking state
typedef enum tagEM_SMOKING_STATE
{
	EM_SMOKING_UNKNOWN,			// unknown
	EM_SMOKING_NO,				// not smoking
	EM_SMOKING_YES,				// smoking
}EM_SMOKING_STATE;

// DH_MEDIA_QUERY_TRAFFICCAR_EX Check out the file information
typedef struct tagMEDIAFILE_TRAFFICCAR_INFO_EX
{
	DWORD				dwSize;
	MEDIAFILE_TRAFFICCAR_INFO stuInfo;			        	// Basic Information
	char				szDeviceAddr[DH_COMMON_STRING_256];	// Device Address
	char				szVehicleSign[DH_COMMON_STRING_32];	// Vehicle identification, such as "Unknown" - unknown, "Audi" - Audi, "Honda" - Honda ..
    char                szCustomParkNo[DH_COMMON_STRING_64];// self defined parking space number, for parking, 
    WORD                wVehicleSubBrand;                   // Specifies the sub-brand of vehicle,the real value can be found in a mapping table from the development manual
    WORD                wVehicleYearModel;                  // Specifies the model years of vehicle. the real value can be found in a mapping table from the development manual
	NET_TIME			stuEleTagInfoUTC;					// corresponding to throughTime in electronic tag info
	EM_RECORD_SNAP_FLAG_TYPE emFalgLists[FLAG_TYPE_MAX];	// record or snapshot file mark 
    int                 nFalgCount;							// mark total	
    EM_SAFE_BELT_STATE	emSafeBelSate;						// safe belt state
    EM_CALLING_STATE	emCallingState;						// calling state
    int					nAttachMentNum;						// the count of attachment
	NET_ATTACH_MENET_INFO stuAttachMent[MAX_ATTACHMENT_NUM];// attachment info
	char				szCountry[DH_COMMON_STRING_32];		// the country about the plate
	EM_CATEGORY_TYPE	emCarType;							// car type
	NET_SUNSHADE_STATE	emSunShadeState;					// sun shade state
	EM_SMOKING_STATE	emSmokingState;						//smoking state
	int					nAnnualInspection;					// the count of annual inspections
} MEDIAFILE_TRAFFICCAR_INFO_EX;

// FINDNEXT Find input parameter
typedef struct __NET_FINDNEXT_RESERVED
{
	DWORD               dwSize;                 // Structure size
	
	unsigned int        nBeginNumber;           // Search begin number, start from begin number, 0<=beginNumber<= totalCount-1
}NET_FINDNEXT_RESERVED;

// Enquiry jump condition
typedef struct __NET_FINDING_JUMP_OPTION_INFO
{
	DWORD           dwSize;
	int             nOffset;                            // Query results offset relative to the first query results position offset current query
}NET_FINDING_JUMP_OPTION_INFO;

// DH_FILE_QUERY_FACE Corresponding face recognition service search parameter
typedef struct __MEDIAFILE_FACERECOGNITION_PARAM
{
	DWORD               dwSize;                 		// Structure size

	// Search filter criteria
   	NET_TIME			stStartTime;			       	// start time 
    NET_TIME			stEndTime;				       	// closing time
	char                szMachineAddress[MAX_PATH];    	// Place to support fuzzy matching
	int                 nAlarmType;                    	// To query the type of alarm, see EM_FACERECOGNITION_ALARM_TYPE
    BOOL                abPersonInfo;                   // staff info is valid or not
    FACERECOGNITION_PERSON_INFO stPersonInfo;           // staff info
    int                 nChannelId;                     // channel no.  
    int                 nGroupIdNum;                    // staff group  
    char                szGroupId[MAX_GOURP_NUM][DH_COMMON_STRING_64]; // staff group ID 
	
	BOOL                abPersonInfoEx;                 // stPersonInfoEx is valid or not
	FACERECOGNITION_PERSON_INFOEX	stPersonInfoEx;		//  expansion of personnel information

	BOOL				bSimilaryRangeEnable;			//similaryRange enable
	int					nSimilaryRange[2];				//similaryRange
}MEDIAFILE_FACERECOGNITION_PARAM;

typedef struct  tagDH_PIC_INFO_EX
{
	DWORD                dwSize;                        // structure size
	DWORD                dwFileLenth;                   // file size,unit:bite
	char                 szFilePath[MAX_PATH];          // file path   
}DH_PIC_INFO_EX;

typedef struct  tagNET_PIC_INFO
{
    DWORD                dwFileLenth;                   // file size,unit:bite
    char                 szFilePath[MAX_PATH];          // file path 
	BYTE                 bReserved[256];                // reserved
}NET_PIC_INFO;

typedef struct __NET_CANDIDAT_PIC_PATHS
{
	DWORD                dwSize;                        	// structure size
	int                  nFileCount;                    	// actual file amount
	DH_PIC_INFO_EX       stFiles[DH_MAX_PERSON_IMAGE_NUM];	// file information
}NET_CANDIDAT_PIC_PATHS;

typedef struct tagNET_CANDIDAT_PIC_PATHS_EX
{
    int                  nFileCount;                      // actual file amount
    NET_PIC_INFO	     stFiles[DH_MAX_PERSON_IMAGE_NUM];// file information
	BYTE                 bReserved[256];				  // reserved
}NET_CANDIDAT_PIC_PATHS_EX;

// Image info
typedef struct tagIMAGE_INFO
{
	int					nLength;			// Length,Unit:Byte
	int					nWidth;				// Width
	int					nHeight;			// Height
	char				szFilePath[260];	// File path
	BYTE				byReserved[512];	// Reserved
}IMAGE_INFO;

// Face info
typedef struct tagFACE_INFO_OBJECT
{
	IMAGE_INFO							   stuImageInfo;			// Image info
	EM_DEV_EVENT_FACEDETECT_SEX_TYPE       emSex;                   // Sex
	unsigned int                           nAge;                    // Age
	EM_FACEDETECT_GLASSES_TYPE             emGlasses;               // Whether or not wear glasses
	EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE   emEmotion;               // Emotion
	EM_COMPLEXION_TYPE				       emComplexion;			// Complexion
	EM_EYE_STATE_TYPE			           emEye;					// Eye state
	EM_MOUTH_STATE_TYPE			           emMouth;					// Mouth state
	EM_MASK_STATE_TYPE			           emMask;				    // Whether or not wear mask
	EM_BEARD_STATE_TYPE			           emBeard;				    // Whehter or not has beard
	int							           nAttractive;				// Attractive,0 means unidentification,valid range:1-100,The higer the value,the more attractive
	NET_EULER_ANGLE				   		   stuFaceCaptureAngle;		// euler angle of face in the capture picture, nPitch:pitch of the head, nYaw: yaw of the head, nRoll:roll of the head
																	// range of the angle value is [-90,90], stuFaceCaptureAngle is invalid if the three angles are 999.
	UINT								   nFaceQuality;			// quality about capture picture
	BYTE                                   byReserved[2032];			// Reserved
}FACE_INFO_OBJECT;

// corresponding facial recognition service  DH_FILE_QUERY_FACE FINDNEXT search returned parameter
typedef struct __MEDIAFILE_FACERECOGNITION_INFO
{
	DWORD               dwSize;                                   // Structure size
	BOOL                bGlobalScenePic;                          // The existence panorama
	DH_PIC_INFO_EX      stGlobalScenePic;                         // Panoramic image file path
	DH_MSG_OBJECT		stuObject;						          // the target face object information
	DH_PIC_INFO_EX      stObjectPic;                              // the target face file path
	int                 nCandidateNum;                            // Face Matching the current number of candidates
    CANDIDATE_INFO      stuCandidates[DH_MAX_CANDIDATE_NUM];      // Face candidates to match this informatio
	NET_CANDIDAT_PIC_PATHS stuCandidatesPic[DH_MAX_CANDIDATE_NUM];// The current face matching candidates to the image file path
	NET_TIME            stTime;                                   // time for an alarm
	char                szAddress[MAX_PATH];                      // Place for an alarm
    int                 nChannelId;                               // channel no.   
    BOOL				bUseCandidatesEx;						  // whether or not to use stuCandidatesEx
																  // stuCandidatesEx is effective and stuCandidates is invalid when the bUseCandidatesEx is TRUE, otherwise, on the contrary
	int					nCandidateExNum;						  // the actual return number of stuCandidatesEx														
    CANDIDATE_INFOEX	stuCandidatesEx[DH_MAX_CANDIDATE_NUM];	  // the expansion of candidate information
	FACE_INFO_OBJECT	stuFaceInfoObject;						  // Face info object
	NET_POINT           stuFaceCenter;                            // Center of face(not center of bounding box), 0-8191 relative coordinates, relative to small graph
}MEDIAFILE_FACERECOGNITION_INFO; 

typedef enum __EM_FACEPIC_TYPE
{
    NET_FACEPIC_TYPE_UNKOWN,            // unknown type
    NET_FACEPIC_TYPE_GLOBAL_SENCE,      // face full size picture
    NET_FACEPIC_TYPE_SMALL,             // face small pictrure
}EM_FACEPIC_TYPE;

#define  NET_MAX_FRAMESEQUENCE_NUM     2
#define  NET_MAX_TIMESTAMP_NUM         2

typedef struct __MEDIAFILE_FACE_DETECTION_DETAIL_PARAM
{
    DWORD               dwSize;
    DWORD               dwObjectId;                     // object ID
    DWORD               dwFrameSequence;                // frame no.
    NET_TIME_EX         stTime;                         // time
}MEDIAFILE_FACE_DETECTION_DETAIL_PARAM;
 
// DH_FILE_QUERY_FACE_DETECTION corresponding face recognition service search parameter
typedef struct __MEDIAFILE_FACE_DETECTION_PARAM
{
    DWORD               dwSize;                         // structure size
    
    // search filter
    int                 nChannelID;                     // channel no.
    NET_TIME            stuStartTime;                   // start time
    NET_TIME            stuEndTime;                     // end time
    EM_FACEPIC_TYPE     emPicType;                      // picture type, see  EM_FACEPIC_TYPE
    BOOL                bDetailEnable;                  // if has detailed info
    MEDIAFILE_FACE_DETECTION_DETAIL_PARAM stuDetail;    // parameter detailed info
    EM_DEV_EVENT_FACEDETECT_SEX_TYPE emSex;             // sex
    BOOL                bAgeEnable;                     // age range is enabled
    int                 nAgeRange[2];                   // age range
    int                 nEmotionValidNum;               // invalid number in array emEmotion, 0 means all emotion
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE    emEmotion[DH_MAX_FACEDETECT_FEATURE_NUM];   // human emotion
    EM_FACEDETECT_GLASSES_TYPE  emGlasses;              // wear glasses info  
    EM_MASK_STATE_TYPE			emMask;					// wear mask info
	EM_BEARD_STATE_TYPE			emBeard;				// beard info
	int					nIsStranger;					// 0-all;1-Stranger mode disabled only;2-Stranger mode enable only
}MEDIAFILE_FACE_DETECTION_PARAM;

// Scene image info for face detection record
typedef struct tagNET_FACEDETECT_IMAGE_INFO
{
    UINT            nLength;                // File length
    char            szFilePath[260];        // File path
    BYTE            byReserved[128];        // Reserved
} NET_FACEDETECT_IMAGE_INFO;

// DH_FILE_QUERY_FACE_DETECTIONcorresponding face recognition service FINDNEXT search return parameter
typedef struct __MEDIAFILE_FACE_DETECTION_INFO
{
    DWORD               dwSize;                                     // structure size

    unsigned int        ch;                                         // channel no.
    char                szFilePath[128];                            // file path
    unsigned int        size;                                       // file lengthThis field is discarded,please use the sizeEx
    NET_TIME            starttime;                                  // start time
    NET_TIME            endtime;                                    // end time
    unsigned int        nWorkDirSN;                                 // working directory no.                                    
    BYTE                nFileType;                                  // file type  1:jpg picture
    BYTE                bHint;                                      // file positioning index
    BYTE                bDriveNo;                                   // disk no.
    BYTE                byPictureType;                              // picture type, 0-normal, 1-combined, 2-cut
    unsigned int        nCluster;                                   // cluster no.
    
    EM_FACEPIC_TYPE     emPicType;                                  // picture type, see EM_FACEPIC_TYPE
    DWORD               dwObjectId;                                 // object ID
    DWORD               dwFrameSequence[NET_MAX_FRAMESEQUENCE_NUM]; // frame no.,group has two elements, one means small picture, two means large picture
    int                 nFrameSequenceNum;                          // frame no.quantity 
    NET_TIME_EX         stTimes[NET_MAX_TIMESTAMP_NUM];             // time, group has two elements, one means small picture, two means large picture
    int                 nTimeStampNum;
    int                 nPicIndex;                                  // Picture number in the cluster
                                                                    // For packaged multiple images in the same cluster,provides indexed mode to position pictures
    EM_DEV_EVENT_FACEDETECT_SEX_TYPE emSex;                         // sex type
    int                 nAge;                                       // age
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE    emEmotion;              // human emotion
    EM_FACEDETECT_GLASSES_TYPE  emGlasses;                          // wear glasses info
    INT64               sizeEx;                                     // size of file extension, Support file length is greater than 4G,unit:Byte
    EM_MASK_STATE_TYPE          emMask;                             // mask type
    EM_BEARD_STATE_TYPE         emBeard;                            // beard type
    EM_RACE_TYPE                emRace;                             // race type
    EM_EYE_STATE_TYPE           emEye;                              // eye type
    EM_MOUTH_STATE_TYPE         emMouth;                            // mouth type
    int                         nAttractive;                        // attractive
    int                         nIsStranger;                        // 0-unknown;1-Stranger mode disabled;2-Stranger mode enable
    char                        szFaceObjectUrl[128];               // if emPicType is NET_FACEPIC_TYPE_GLOBAL_SENCE, means face file's path
    NET_EULER_ANGLE             stuFaceCaptureAngle;                // euler angle of face in the capture picture, nPitch:pitch of the head, nYaw: yaw of the head, nRoll:roll of the head
                                                                    // range of the angle value is [-90,90], stuFaceCaptureAngle is invalid if the three angles are 999.
    UINT                        nFaceQuality;                       // quality about capture picture
    NET_FACEDETECT_IMAGE_INFO   stuSceneImage;                      // Scene image
    NET_POINT                   stuFaceCenter;                      // Center of face(not center of bounding box), 0-8191 relative coordinates, relative to small graph
}MEDIAFILE_FACE_DETECTION_INFO;

//Warning zone detected operation type 
typedef enum tagNET_CROSSREGION_ACTION_INFO
{
    EM_CROSSREGION_ACTION_UNKNOW = 0    , 
    EM_CROSSREGION_ACTION_INSIDE        ,   //In the area
    EM_CROSSREGION_ACTION_CROSS         ,   //Cross area
    EM_CROSSREGION_ACTION_APPEAR        ,   //Appear
    EM_CROSSREGION_ACTION_DISAPPEAR     ,   //Disappear 
}NET_CROSSREGION_ACTION_INFO;

// object type corresponding to rule
typedef enum tagEM_MEDIAFILE_IVS_OBJECT
{
	EM_MEDIAFILE_IVS_UNKNOWN,		// unknown
	EM_MEDIAFILE_IVS_OTHER,			// other
	EM_MEDIAFILE_IVS_HUMAN,			// human
	EM_MEDIAFILE_IVS_VEHICLE,		// vehicle
	EM_MEDIAFILE_IVS_NONMOTOR,		// nonmotor
} EM_MEDIAFILE_IVS_OBJECT;

//  DH_FILE_QUERY_IVS_EVENT corresponding face recognition service search parameter
typedef struct __MEDIAFILE_IVS_EVENT_PARAM
{
    DWORD               dwSize;                         // structure size
    int                 nChannelID;                     // channel no.
    NET_TIME            stuStartTime;                   // start time
    NET_TIME            stuEndTime;                     // end time
    int                 nMediaType;                     // file type, 0: any, 1:jpg , 2:dav
    int                 nVideoStream;                   // video stream  0-unknown 1-master 2-sub1 3-sub2 4-sub3 
    int                 nEventLists[MAX_IVS_EVENT_NUM]; // link event list,see event intelligent analysis event type
    int                 nEventCount;                    // event total count
    EM_RECORD_SNAP_FLAG_TYPE emFalgLists[FLAG_TYPE_MAX];// video or snap picture flags
    int                 nFalgCount;                     // flag total
    int                 nRuleType;                      // rule type, see event intelligent analysis event type
    NET_CROSSREGION_ACTION_INFO emAction;               // event action type
    int					nIvsObjectNum;					// the count of  IVS object
    EM_MEDIAFILE_IVS_OBJECT		emIvsObject[DH_MAX_OBJECT_LIST];	// the list of IVS object type
}MEDIAFILE_IVS_EVENT_PARAM;

// event image info
typedef struct tagNET_EVENT_IMAGE_INFO
{
	int			nImageLength;							// image length
	char		szImagePath[DH_COMMON_STRING_128];		// image path
	BYTE        bReserved[256];                			// reserved
} NET_EVENT_IMAGE_INFO;

// DH_FILE_QUERY_IVS_EVENT corresponding face recognition service FINDNEXT search return parameter
typedef struct __MEDIAFILE_IVS_EVENT_INFO
{
    DWORD               dwSize;                          // structure size
    int                 nChannelID;                      // channel no.
    NET_TIME            stuStartTime;                    // start time
    NET_TIME            stuEndTime;                      // end time
    char                szFilePath[128];                 // file path
    int                 nMediaType;                      // file type, 0: any, 1:jpg , 2:dav
    unsigned int        nFileLength;                     // file length,This field is discarded,please use the nFileLengthEx
    unsigned int        nCluster;                        // cluster no.
    unsigned int        nHint;                           // hint
    unsigned int        nDriveNo;                        // drive no.       
    int                 nVideoStream;                    // video stream  0-unknown 1-master 2-sub1 3-sub2 4-sub3 
    int                 nEventLists[MAX_IVS_EVENT_NUM];  // link event list,see event intelligent analysis event type
    int                 nEventCount;                     // event total count
    EM_RECORD_SNAP_FLAG_TYPE emFalgLists[FLAG_TYPE_MAX]; // video or snap picture flags
    int                 nFalgCount;                      // flag total count
    int                 nRuleType;                       // rule type, see event intelligent analysis event type
    NET_CROSSREGION_ACTION_INFO emAction;                // event action type
	INT64               nFileLengthEx;                   // length of file extension, Support file length is greater than 4G,unit:Byte
	EM_MEDIAFILE_IVS_OBJECT	emIvsObject;				 // object type corresponding to rule
	NET_EVENT_IMAGE_INFO	stuEventImageInfo;			 // event image info
	NET_POINT               stuObjCenter;                // Center of object(not center of bounding box), 0-8191 relative coordinates, relative to small graph
}MEDIAFILE_IVS_EVENT_INFO;

// analyse object type
typedef enum tagEM_ANALYSE_OBJECT_TYPE
{
    EM_ANALYSE_OBJECT_TYPE_UNKNOWN,           // unknown 
    EM_ANALYSE_OBJECT_TYPE_HUMAN,             // human 
    EM_ANALYSE_OBJECT_TYPE_VEHICLE,           // vehicle
    EM_ANALYSE_OBJECT_TYPE_FIRE,              // fire
    EM_ANALYSE_OBJECT_TYPE_SMOKE,             // smoke
    EM_ANALYSE_OBJECT_TYPE_PLATE,             // plate             
    EM_ANALYSE_OBJECT_TYPE_HUMANFACE,         // human face
    EM_ANALYSE_OBJECT_TYPE_CONTAINER,         // container
    EM_ANALYSE_OBJECT_TYPE_ANIMAL,            // animal
    EM_ANALYSE_OBJECT_TYPE_TRAFFICLIGHT,      // traffic light
    EM_ANALYSE_OBJECT_TYPE_PASTEPAPER,        // paster paper
    EM_ANALYSE_OBJECT_TYPE_HUMANHEAD,         // human head
    EM_ANALYSE_OBJECT_TYPE_ENTITY,            // entity
}EM_ANALYSE_OBJECT_TYPE;

// DH_FILE_QUERY_ANALYSE_OBJECT corresponding face recognition service search parameter
typedef struct __MEDIAFILE_ANALYSE_OBJECT_PARAM
{
    DWORD               dwSize;                         // structure size
    int                 nChannelID;                     // channel no.
    NET_TIME            stuStartTime;                   // start time
    NET_TIME            stuEndTime;                     // stop time
    int                 nMediaType;                     // file type, 0: any, 1:jpg , 2:dav
    int                 nVideoStream;                   // video stream  0-unknown 1-master 2-sub1 3-sub2 4-sub3 
    int                 nEventLists[MAX_IVS_EVENT_NUM]; // link event list,see event intelligent analysis event type
    int                 nEventCount;                    // event total count
    EM_RECORD_SNAP_FLAG_TYPE emFalgLists[FLAG_TYPE_MAX];// video or snap picture flags
    int                 nFalgCount;                     // flag total count
    EM_ANALYSE_OBJECT_TYPE emObject;                    // object type
}MEDIAFILE_ANALYSE_OBJECT_PARAM;

// DH_FILE_QUERY_ANALYSE_OBJECT corresponding face recognition service FINDNEXT search return parameter
typedef struct __MEDIAFILE_ANALYSE_OBJECT_INFO
{
    DWORD               dwSize;                          // structure size
    int                 nChannelID;                      // channel no.
    NET_TIME            stuStartTime;                    // start time
    NET_TIME            stuEndTime;                      // stop time
    char                szFilePath[128];                 // file path
    int                 nMediaType;                      // file type, 0: any, 1:jpg , 2:dav
    unsigned int        nFileLength;                     // file lengthThis field is discarded,please use the nFileLengthEx
    unsigned int        nCluster;                        // cluster no.
    unsigned int        nHint;                           // hint
    unsigned int        nDriveNo;                        // drive no. 
    int                 nVideoStream;                    // video stream  0-unknown 1-master 2-sub1 3-sub2 4-sub3 
    int                 nEventLists[MAX_IVS_EVENT_NUM];  // link event list,see event intelligent analysis event type
    int                 nEventCount;                     // event total count
    EM_RECORD_SNAP_FLAG_TYPE emFalgLists[FLAG_TYPE_MAX]; // video or snap picture flags
    int                 nFalgCount;                      // flag total count
    EM_ANALYSE_OBJECT_TYPE emObject;                     // object type
	INT64               nFileLengthEx;                   // length of file extension, Support file length is greater than 4G,unit:Byte
}MEDIAFILE_ANALYSE_OBJECT_INFO;

// the param of find the MPT record file(corresponding to DH_FILE_QUERY_MPT_RECORD_FILE)
typedef struct __MEDIAFILE_MPT_RECORD_FILE_PARAM
{
    DWORD               dwSize;                         // struct size

    // the common file info
    int                 nChannelID;                                 // channel id
    NET_TIME            stuStartTime;                               // start time
    NET_TIME            stuEndTime;                                 // end time
    int                 nMediaType;                                 // file type,0:all type, 1:jpg, 2:dav
    int                 nVideoStream;                               // video stream, 0-unknown 1-master 2-sub1 3-sub2 4-sub3

    // the MPT record file info
    char                szPoliceID[DH_COMMON_STRING_32];            // police id,empty means this field is invalid
    int                 nCrimeType;                                 // crime type,zero means this field is invalid
    int                 nCrimeTag;                                  // crime tag,zero means this field is invalid
    char                szSerialNumber[DH_COMMON_STRING_32];        // SN of MPT,empty means this field is invalid   
}MEDIAFILE_MPT_RECORD_FILE_PARAM;

// the MPT record file info(corresponding to DH_FILE_QUERY_MPT_RECORD_FILE)  
typedef struct __MEDIAFILE_MPT_RECORD_FILE_INFO
{
    DWORD               dwSize;                          // struct size
    int                 nChannelID;                      // channel id
    NET_TIME            stuStartTime;                    // start time
    NET_TIME            stuEndTime;                      // end time
    char                szFilePath[DH_COMMON_STRING_128];// file path
    int                 nMediaType;                      // file type,0:all type, 1:jpg, 2:dav
    int                 nVideoStream;                    // video stream, 0-unknown 1-master 2-sub1 3-sub2 4-sub3
    unsigned int        nFileLength;                     // file lengthThis field is discarded,please use the nFileLength
    unsigned int        nCluster;                        // cluster
    unsigned int        nHint;                           // file hit
    unsigned int        nDriveNo;                        // drive number

    int                 nCrimeType;                      // crime type
    int                 nCrimeTag;                       // crime tag
    char                szComment[DH_COMMON_STRING_256]; // comment for mark
	INT64               nFileLengthEx;                   // size of file extension, Support file length is greater than 4G,unit:Byte
}MEDIAFILE_MPT_RECORD_FILE_INFO;

// Inside type of dangerous object in the package
typedef enum tagNET_EM_INSIDE_TYPE
{
	NET_EM_INSIDE_TYPE_GRADE,			// Grade type
	NET_EM_INSIDE_TYPE_OBJECT,			// Object type
}NET_EM_INSIDE_TYPE;

// the param of find record file(corresponding to DH_FILE_QUERY_XRAY_DETECTION)
typedef struct tagMEDIAFILE_XRAY_DETECTION_PARAM
{
	DWORD					dwSize;                                 // Struct size
	// condition
	int						nChannelID;                             // Channel ID
	NET_TIME				stuStartTime;                           // Start time
	NET_TIME				stuEndTime;                             // End time

	NET_EM_INSIDE_TYPE		emInsideType;							// Inside type of dangerous object in the package,Required
	int						nDangerGradeNum;						// package danger grade valid number
	EM_DANGER_GRADE_TYPE	emDangerGrade[MAX_DANGER_GRADE_NUM];	// package danger grade,Valid when emInsideType is NET_EM_INSIDE_TYPE_GRADE
	int						nInsideObjTypeNum;						// package inside object type valid number
	EM_INSIDE_OBJECT_TYPE	emInsideObjType[MAX_INSIDE_OBJECT_TYPE_NUM];	// package inside object type,Valid when emInsideType is NET_EM_INSIDE_TYPE_OBJECT
}MEDIAFILE_XRAY_DETECTION_PARAM;

// the record file info(corresponding to DH_FILE_QUERY_XRAY_DETECTION)  
typedef struct tagMEDIAFILE_XRAY_DETECTION_INFO
{
	DWORD					dwSize;											// Struct size
	int						nChannelID;										// Channel ID
	NET_TIME				stuStartTime;									// Start time
	NET_TIME				stuEndTime;										// End time

	char					szProcessedFilePath[MAX_PATH_LEN];				// Processed X-ray image file path
	char					szOriginalPath[MAX_PATH_LEN];					// Original path
	unsigned int			nOriginalLength;								// Original image Length,Unit:Byte
	EM_DANGER_GRADE_TYPE	emDangerGrade;									// Package danger grade
	EM_INSIDE_OBJECT_TYPE	emInsideObjectType[MAX_INSIDE_OBJECT_TYPE_NUM];	// Inside object type of package
	int						nRetInsideObjectTypeNum;						// Inside object type number of returned package	
}MEDIAFILE_XRAY_DETECTION_INFO;

#define MAX_CLOTH_NUM		4 // maximum number of cloath
#define MAX_CLOTHTYPE_NUM	2 // maximum number of cloath type

// the param of find record file(corresponding to DH_FILE_QUERY_HUMAN_TRAIT)
typedef struct tagMEDIAFILE_HUMAN_TRAIT_PARAM
{
    DWORD               dwSize;                 				// the size of this struct
    int                 nChannel;               				// channel 
    NET_TIME            stStartTime;            				// start time
    NET_TIME            stEndTime;              				// end time

    EM_CLOTHES_COLOR    emCoatColor[MAX_CLOTH_NUM];         	// coat color
    EM_CLOTHES_COLOR    emTrousersColor[MAX_CLOTH_NUM];     	// trousers color
    EM_COAT_TYPE        emCoatType[MAX_CLOTHTYPE_NUM];          // coat type
    EM_TROUSERS_TYPE	emTrousersType[MAX_CLOTHTYPE_NUM];      // trousers type

    UINT                nCoatColorNum;         					// the number of coat color
    UINT                nTrousersColorNum;     					// the number of trousers color
    UINT                nCoatTypeNum;          					// the number of coat type
    UINT                nTrousersTypeNum;      					// the number of trousers type
    EM_HAS_HAT          emHasHat;               				// wear hat or not
    EM_HAS_BAG          emHasBag;               				// has bag or not
    EM_SEX_TYPE			emSex;									// sex
    EM_HAIR_STYLE		emHairStyle;							// hair style
    UINT				nAgeMin;								// minimum age
    UINT				nAgeMax;								// maximum age
}MEDIAFILE_HUMAN_TRAIT_PARAM;

// the human trait info be found
typedef struct tagHUMAN_TRAIT_INFO
{
    EM_CLOTHES_COLOR    emCoatColor;            // coat color
    EM_CLOTHES_COLOR    emTrousersColor;        // trousers color
    EM_COAT_TYPE        emCoatType;             // coat type
    EM_TROUSERS_TYPE    emTrousersType;         // trousers type
    EM_HAS_HAT          emHasHat;               // has hat or not
    EM_HAS_BAG          emHasBag;               // has bag or not
    EM_SEX_TYPE			emSex;					// sex
    UINT				nAge;					// age
    EM_HAIR_STYLE		emHairStyle;			// hair style
    EM_HAS_UMBRELLA		emHasUmbrella;			// has umbrella or not
    EM_BAG_TYPE			emBagType;				// bag type
    EM_CAP_TYPE			emCapType;				// cap type
    BYTE                byReserved[1024];       // reserved
}HUMAN_TRAIT_INFO;

// galss state

// face attribute be found
typedef struct tagNET_HUMAN_FACE_ATTRIBUTE
{
    EM_SEX_TYPE			emSex;					// sex
    int					nAge;					// age
    EM_MASK_STATE_TYPE 	emMask;					// mask state
    EM_BEARD_STATE_TYPE	emBeard;				// beard state
    EM_HAS_GLASS		emHasGlass;				// has glasses
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE emEmotion;	 // emotion
    BYTE                byReserved[1024];       // reserved
} NET_HUMAN_FACE_ATTRIBUTE;

// the record file info(corresponding to DH_FILE_QUERY_HUMAN_TRAIT)  
typedef struct tagMEDIAFILE_HUMAN_TRAIT_INFO
{  
    DWORD               dwSize;                 // the size of this struct

    // file attribute
    int                 nChannel;               // channel
    NET_TIME            stStartTime;            // start time
    NET_TIME            stEndTime;              // end time
    char                szFilePath[MAX_PATH];   // file path
    int                 nFileSize;              // file size

    char				szFacePath[MAX_PATH];		// face image path
    char				szFaceScenePath[MAX_PATH];	// face scene image path
    char				szHumanPath[MAX_PATH];		// human image path
    char				szHumanSceneImage[MAX_PATH];// human scene image path

    UINT				nFaceImageLength;			// face image size, unit:byte
    UINT				nFaceSceneImageLength;		// face scene image size, unit:byte
    UINT				nHumanImageLength;			// human image size, unit:byte
    UINT				nHumanSceneImageLength;		// human scene image size, unit:byte

    // human trait info
    HUMAN_TRAIT_INFO    stuHumanTrait;          // human trait info be found

    // face attribute
    NET_HUMAN_FACE_ATTRIBUTE stuFaceAttribute;	// face attribute be found
    NET_POINT           stuFaceCenter;          // Center of face(not center of bounding box), 0-8191 relative coordinates, relative to small graph
    NET_POINT           stuHumanCenter;         // Center of human(not center of bounding box), 0-8191 relative coordinates, relative to small graph
}MEDIAFILE_HUMAN_TRAIT_INFO;

// nonmotor color
typedef enum tagEM_NONMOTOR_COLOR
{
	EM_NONMOTOR_UNKNOWN,						// Unknown
	EM_NONMOTOR_COLOR_OTHER,					// Other
	EM_NONMOTOR_COLOR_WHITE,					// White
	EM_NONMOTOR_COLOR_ORANGE,					// Orange
	EM_NONMOTOR_COLOR_PINK,						// Pink
	EM_NONMOTOR_COLOR_BLACK,					// Black
	EM_NONMOTOR_COLOR_RED,						// Red
	EM_NONMOTOR_COLOR_YELLOW,					// Yellow
	EM_NONMOTOR_COLOR_GRAY,						// Gray
	EM_NONMOTOR_COLOR_BLUE,						// Blue
	EM_NONMOTOR_COLOR_GREEN,					// Green
	EM_NONMOTOR_COLOR_PURPLE,					// Purple
	EM_NONMOTOR_COLOR_BROWN,					// Brown
	EM_NONMOTOR_COLOR_SLIVER,					// Sliver
	EM_NONMOTOR_COLOR_DARKVIOLET,				// Darkviolet
	EM_NONMOTOR_COLOR_MAROON,					// Maroon
	EM_NONMOTOR_COLOR_DIMGRAY,					// Dimgray
	EM_NONMOTOR_COLOR_WHITESMOKE,				// Whitesmoke
	EM_NONMOTOR_COLOR_DARKORANGE,				// Darkorange
	EM_NONMOTOR_COLOR_MISTYROSE,				// Mistyrose
	EM_NONMOTOR_COLOR_TOMATO,					// Tomato
	EM_NONMOTOR_COLOR_OLIVE,					// Olive
	EM_NONMOTOR_COLOR_GOLD,						// Gold
	EM_NONMOTOR_COLOR_DARKOLIVEGREEN,			// Darkolivegreen
	EM_NONMOTOR_COLOR_CHARTREUSE,				// Chartreuse
	EM_NONMOTOR_COLOR_GREENYELLOW,				// Greenyellow
	EM_NONMOTOR_COLOR_FORESTGREEN,				// Forestgreen
	EM_NONMOTOR_COLOR_SEAGREEN,					// Seagreen
	EM_NONMOTOR_COLOR_DEEPSKYBLUE,				// Deepskyblue
	EM_NONMOTOR_COLOR_CYAN,						// Cyan
} EM_NONMOTOR_COLOR;

// nonmotor subtype
typedef enum tagEM_NONMOTOR_SUBTYPE
{
	EM_NONMOTOR_SUBTYPE_UNKNOWN,				// Unknown
	EM_NONMOTOR_SUBTYPE_NONMOTOR,				// Non-Motor
	EM_NONMOTOR_SUBTYPE_BICYCLE,				// Bicycle
	EM_NONMOTOR_SUBTYPE_TRICYCLE,				// Tricycle
	EM_NONMOTOR_SUBTYPE_MOTORCYCLE,				// Motorcycle
	EM_NONMOTOR_SUBTYPE_DUALTRIWHEEL,			// DualTriWheelMotorcycle
	EM_NONMOTOR_SUBTYPE_LIGHT_MOTORCYCLE,		// LightMotorcycle
	EM_NONMOTOR_SUBTYPE_EMBASSY_MOTORCYCLE,		// EmbassyMotorcycle
	EM_NONMOTOR_SUBTYPE_MARGINAL_MOTORCYCLE,	// MarginalMotorcycle
	EM_NONMOTOR_SUBTYPE_AREAOUT_MOTORCYCLE,		// AreaoutMotorcycle
	EM_NONMOTOR_SUBTYPE_FOREIGN_MOTORCYCLE,		// ForeignMotorcycle
	EM_NONMOTOR_SUBTYPE_TRIAL_MOTORCYCLE,		// TrialMotorcycle
	EM_NONMOTOR_SUBTYPE_COACH_MOTORCYCLE,		// CoachMotorcycle
	EM_NONMOTOR_SUBTYPE_PASSERBY,				// Passerby
}EM_NONMOTOR_SUBTYPE;

// helmet state
typedef enum tagEM_HELMET_STATE
{
	EM_HELMET_UNKNOWN,			// unknown
	EM_HELMET_OTHER,			// unidentified
	EM_HELMET_NO,				// not wear helmet
	EM_HELMET_YES,				// wear helmet
} EM_HELMET_STATE;

// the param of find record file(corresponding to DH_FILE_QUERY_NONMOTOR)
typedef struct tagMEDIAFILE_NONMOTOR_PARAM
{
	DWORD               dwSize;             // the size of this struct
	int                 nChannel;           // channel
	NET_TIME            stStartTime;        // start time
	NET_TIME            stEndTime;          // end time
	
	UINT				nNumOfCyclingMin;	// minimum number of cycling
	UINT				nNumOfCyclingMax;	// maximum number of cycling
	EM_NONMOTOR_COLOR	emNonmotorColor;	// nonmotor color
	EM_NONMOTOR_SUBTYPE	emNonmotorSubtype;	// nonmotor subtype
	EM_HELMET_STATE 	emHelmetState;		// helmet state
} MEDIAFILE_NONMOTOR_PARAM;

// the record file info(corresponding to DH_FILE_QUERY_NONMOTOR)  
typedef struct tagMEDIAFILE_NONMOTOR_INFO
{
	DWORD               dwSize;             	// the size of this struct
   
	// file attribute
	int                 nChannel;               // channel
	NET_TIME            stStartTime;            // start time
	NET_TIME            stEndTime;              // end  time
	char                szFilePath[MAX_PATH];   // file path
	int                 nFileSize;              // file size
   
	// nonmotor info
	UINT				nNumOfCycling;			// number of cycling
	EM_NONMOTOR_COLOR	emNonmotorColor;		// nonmotor color
	EM_NONMOTOR_SUBTYPE	emNonmotorSubtype;		// nonmotor subtype
	EM_HELMET_STATE 	emHelmetState;			// helmet state
	NET_POINT           stuFaceCenter;          // Center of face(not center of bounding box), 0-8191 relative coordinates, relative to small graph
} MEDIAFILE_NONMOTOR_INFO;

// Inforamtion of face picture
typedef struct tagNET_FACE_IMAGE_INFO
{
    DWORD       dwOffSet;                               // Offset position of the picture in binary data, unit:bytes
    DWORD       dwFileLength;                           // Size of the picture, unit:bytes
    DWORD       dwWidth;                                // Width of the picture
    DWORD       dwHeight;                               // Height of the picture
    BOOL        bIsDetected;                            // Is hte picture detected by the algorithm.If it has been detected,there is no need to detect the matting again 
                                                        //when submitting the identification server. TRUE:detected, FALSE:not detected.
	char        szPicFilePath[DH_COMMON_STRING_256];    // The path of the face picture. It is mutual exclusion with dwOffSet and dwFileLenth
	BYTE        bReserved[512];					        // Reserved
} NET_FACE_IMAGE_INFO;

// find file type
typedef enum tagEM_FINDFILE_TYPE
{
	EM_FINDFILE_UNKNOWN,		// unknown
	EM_FINDFILE_JPG,			// picture
	EM_FINDFILE_DAV,			// video
	EM_FINDFILE_LOG,			// log info
	EM_FINDFILE_GPS,			// gps info
} EM_FINDFILE_TYPE;

// open door method
typedef enum tagEM_OPEN_DOOR_METHOD
{
	EM_OPEN_DOOR_METHOD_UNKNOWN		= -1,		// unknown
	EM_OPEN_DOOR_METHOD_OTHER,					// other
	EM_OPEN_DOOR_METHOD_FACE,					// face
} EM_OPEN_DOOR_METHOD;

// open door state
typedef enum tagEM_OPEN_DOOR_STATE
{
	EM_OPEN_DOOR_STATE_UNKNOWN		= -1,		// unknown
	EM_OPEN_DOOR_STATE_FAIL,					// fail
	EM_OPEN_DOOR_STATE_SUCCESS,					// success
} EM_OPEN_DOOR_STATE;

// the param of find door control file(corresponding to DH_FILE_QUERY_DOORCONTROL_RECORD)
typedef struct tagMEDIAFILE_DOORCONTROL_RECORD_PARAM
{
	DWORD               	dwSize;             	// struct size

	// file attr
	int                 	nChannel;               // channel
	NET_TIME            	stStartTime;            // statr time
	NET_TIME            	stEndTime;              // end time
	UINT					nFileTypeNum;			// counts of file type, find any file if the count is 0
	EM_FINDFILE_TYPE		emFileType[32];			//file type

	// coor control info
	EM_OPEN_DOOR_METHOD		emOpenDoorMethod;		// open door method, find any open door method if the value is EM_OPEN_DOOR_METHOD_UNKNOWN 
	EM_OPEN_DOOR_STATE		emOpenDoorState;		// open door state, find any open door state if the value is EM_OPEN_DOOR_STATE_UNKNOWN 
} MEDIAFILE_DOORCONTROL_RECORD_PARAM;


// emotion type
typedef enum tagEM_FACE_TRAIT_EMOTION_TYPE
{
	EM_FACE_TRAIT_EMOTION_UNKNOWN,					// unknown
	EM_FACE_TRAIT_EMOTION_UNRECOGNIZE,				// unrecognize
	EM_FACE_TRAIT_EMOTION_ANGRY,					// angry
	EM_FACE_TRAIT_EMOTION_SAD,						// sad
	EM_FACE_TRAIT_EMOTION_DISGUST,					// disgust
	EM_FACE_TRAIT_EMOTION_FEAR,						// fear
	EM_FACE_TRAIT_EMOTION_SURPRISE,					// surprise
	EM_FACE_TRAIT_EMOTION_CALM,						// calm
	EM_FACE_TRAIT_EMOTION_SMILE,					// smile
	EM_FACE_TRAIT_EMOTION_LAUGH,					// laugh
	EM_FACE_TRAIT_EMOTION_HAPPY,					// happy
	EM_FACE_TRAIT_EMOTION_CONFUSED,					// confused
	EM_FACE_TRAIT_EMOTION_SCREAM,					// scream
}EM_FACE_TRAIT_EMOTION_TYPE;


// living type
typedef enum tagEM_FACE_TRAIT_ALIVE_TYPE
{
	EM_FACE_TRAIT_ALIVE_UNKNOWN,					// unknown	
	EM_FACE_TRAIT_ALIVE_NON,						// non-living	
	EM_FACE_TRAIT_ALIVE,							// living
}EM_FACE_TRAIT_ALIVE_TYPE;


// face trait (customized)
typedef struct tagFACE_TRAIT
{
	EM_SEX_TYPE					emSex;				// sex
	UINT						nAge;				// age
	EM_HAS_GLASS				emGlass;			// glass
	EM_BEARD_STATE_TYPE			emBeard;			// beard
	EM_COMPLEXION_TYPE			emComplexion;		// complexion
	EM_MASK_STATE_TYPE			emMask;				// mask
	EM_FACE_TRAIT_EMOTION_TYPE	emEmotion;			// emotion
	NET_TIME_EX					stuSnapTime;		// snap time
	EM_FACE_TRAIT_ALIVE_TYPE    emAlive;			// alive info
	BYTE						byReserved[1020];	// reserved
}FACE_TRAIT;

// age group
typedef enum tagEM_AGE_GROUP_TYPE
{
	EM_AGE_GROUP_UNKNOWN,							// unknown
	EM_AGE_GROUP_OLD,								// old
	EM_AGE_GROUP_ADULT,								// adult
	EM_AGE_GROUP_CHILD,								// child
}EM_AGE_GROUP_TYPE;

// is there any thing on the chest
typedef enum tagEM_HAS_HOLD
{
	EM_HAS_HOLD_UNKNOWN,							// unknown
	EM_HAS_HOLD_NO,									// no hold
	EM_HAS_HOLD_YES,								// has hold
} EM_HAS_HOLD;

// upper clothes type
typedef enum tagEM_UPPER_TYPE
{
	EM_UPPER_UNKNOWN,								// unknown
	EM_UPPER_LONGCOAT,								// long coat
	EM_UPPER_JACKETORJEANS,							// jacket or jeans
	EM_UPPER_TSHIRT,								// T-shirt
	EM_UPPER_SPORTSWEAR,							// sport wear
	EM_UPPER_DOWNJACKET,							// downjacket
	EM_UPPER_SHIRT,									// shirt
	EM_UPPER_DRESS,									// dress
	EM_UPPER_SUIT,									// suit
}EM_UPPER_TYPE;

// shoes type
typedef enum tagEM_SHOES_TYPE
{
	EM_SHOES_UNKNOWN,								// unknown
	EM_SHOES_LEATHER,								// leather
	EM_SHOES_BOOTS,									// boots
	EM_SHOES_CASUAL,								// casual
	EM_SHOES_SANDALS,								// sandals
} EM_SHOES_TYPE;



// mask type
typedef enum tagEM_MASK_TYPE
{
	EM_MASK_UNKNOWN,								// unknown
	EM_MASK_NO,										// not wear
	EM_MASK_YES,									// wear
}EM_MASK_TYPE;



// body trait(customized)
typedef struct tagBODY_TRAIT
{
	EM_SEX_TYPE				emSex;					// sex
	EM_AGE_GROUP_TYPE		emAgeGroup;				// age group
	EM_COAT_TYPE			emCoatType;				// coat type
	EM_TROUSERS_TYPE		emTrousersType;			// trousers type
	EM_ANGLE_TYPE			emAngle;				// angle
	EM_CLOTHES_PATTERN		emUpperPattern;			// upper pattern	
	EM_UNIFIED_COLOR_TYPE	emTrousersColor;		// trousers color
	EM_HAS_UMBRELLA			emUmbrella;				// umbrella
	EM_UNIFIED_COLOR_TYPE	emUmbrellaColor;		// umbrella color
	EM_HAS_HOLD				emHold;					// hold
	EM_CLOTHES_PATTERN		emTrousersPattern;		// trousers pattern
	EM_HAT_STYLE			emHatType;				// hat type
	EM_UNIFIED_COLOR_TYPE	emHatColor;				// hat color
	EM_UPPER_TYPE			emUpperType;			// upper type
	EM_UNIFIED_COLOR_TYPE	emCoatColor;				// coat color
	EM_HAIR_STYLE			emHairStyle;			// hair style
	EM_UNIFIED_COLOR_TYPE	emHairColor;			// hair color
	EM_SHOES_TYPE			emShoesType;			// shoes type
	EM_UNIFIED_COLOR_TYPE	emShoesColor;			// shoes color
	EM_BAG_TYPE				emBagType;				// bag type
	EM_UNIFIED_COLOR_TYPE	emBagColor;				// bag color
	EM_MASK_TYPE			emMaskType;				// mask type
	EM_UNIFIED_COLOR_TYPE	emMaskColor;			// mask color
	NET_TIME_EX				stuSnapTime;			// snap time
	BYTE					szReserved[1024];		// reserved
}BODY_TRAIT;

// filter info of find face body detect record info
typedef struct tagFACEBODY_DETECT_RECORDFILTER
{
	int			nAgeRange[2]; 						// age range:[0, 0] query unknown,[0, 200]:all
	FACE_TRAIT	stuFaceTrait;						// face trait
	BODY_TRAIT	stuBodyTrait;						// body trait
	BYTE		byReserved[1024];					// reserved
}FACEBODY_DETECT_RECORDFILTER;


// image offset info
typedef struct tagNET_EVENT_IMAGE_OFFSET_INFO
{
	unsigned int       nOffSet;						// offset 		
	unsigned int	   nLength;						// image length,unit:byte
	unsigned int	   nWidth;						// image width
	unsigned int	   nHeight;						// image height
	char			   szPath[260];					// image path
	BYTE			   byReserved[252];				// reserved
}NET_EVENT_IMAGE_OFFSET_INFO;


// search condition of CLIENT_FindFileEx with DH_FILE_QUERY_FACEBODY_DETECT
typedef struct tagMEDIAFILE_FACEBODY_DETECT_PARAM
{
	DWORD               			dwSize;                			// struct size 
    int                 			nFileType;             			// file info,0:any type,1:search jpg image,2:search dav
    int                 			nChannelID;             		// ChannelID, start from 0, -1 means search all channel 
    UINT               				nVideoStream;          			// video stream 0-unknown; 1-main; 2-sub 1; 3-sub 2; 4- sub 3; 5-ExtraX 
	NET_TIME            			stuBeginTime;           		// start time   
	NET_TIME            			stuEndTime;             		// end time  
	EM_RECORD_SNAP_FLAG_TYPE 		emFlagList[FLAG_TYPE_MAX]; 		// Record or snapshot file mark, not set mark to search all files
    int                 			nFlagCount;            			// flag num
    NET_RECORD_CARD_INFO 			stuCardInfo;           			// card num record info, invalid if emFlagLists including card num
    EM_RESULT_ORDER_TYPE 			emResultOrder;         			// result order
    BOOL							bTime;                  		// find file by time
	FACEBODY_DETECT_RECORDFILTER	stuFilter;						// filter info of face body detect query
} MEDIAFILE_FACEBODY_DETECT_PARAM;


// search result of CLIENT_FindFileEx with DH_FILE_QUERY_FACEBODY_DETECT
typedef struct tagMEDIAFILE_FACEBODY_DETECT_INFO
{
	DWORD               			dwSize;                			// struct size 
    int                 			nChannelID;             		// ChannelID, start from 0, -1 means search all channel 
    NET_TIME            			stuBeginTime;           		// start time  
    NET_TIME            			stuEndTime;             		// end time 
	UINT                			nFileType;             			// file type 1:jpg, 2: dav    
    UINT        					nFileSize;              		// file size


    UINT                			nVideoStream;          			// video stream 0-unknown  1-main 2-sub 1 3-sub 4-sub 
    UINT                			nPartition;            			// zone no.
    UINT        					nCluster;               		// cluster
    char                			szFilePath[MAX_PATH];   		// file path   
    EM_RECORD_SNAP_FLAG_TYPE 		emFlagList[FLAG_TYPE_MAX]; 		// Record or snapshot file mark, not set mark to search all files
    int                 			nFlagCount;             		// flag num
    UINT       						nDriveNo;               		// drive no   
	FACE_TRAIT						stuFaceTrait;					// face trait
	BODY_TRAIT						stuBodyTrait;					// body trait
	NET_EVENT_IMAGE_OFFSET_INFO		stuFaceImage; 					// face image info
	NET_EVENT_IMAGE_OFFSET_INFO		stuBodyImage;					// body image info	
	NET_EVENT_IMAGE_OFFSET_INFO		stuSceneImage;					// scene image info
} MEDIAFILE_FACEBODY_DETECT_INFO;

// filter info of find face body analyse record info
typedef struct tagFACEBODY_ANALYSE_RECORDFILTER
{
	int								nAgeRange[2]; 					// age range:[0, 0] means unknwon[0, 200] means all
	EM_SEX_TYPE						emSex;							// sex
	char							szCountry[NET_COUNTRY_LENGTH];	// country, ISO3166 Standard
	BYTE							byReserved1;					// byte align
	char                			szProvince[DH_MAX_PROVINCE_NAME_LEN];      // province
	char                			szCity[DH_MAX_CITY_NAME_LEN];   // city
	char                			szID[DH_MAX_PERSON_ID_LEN];     // id(IC,passport,military, etc)
	EM_CERTIFICATE_TYPE				emCertificateType;				// certificate type		
	BYTE							byReserved[1028];				// reserved
} FACEBODY_ANALYSE_RECORDFILTER;

// search condition of CLIENT_FindFileEx with DH_FILE_QUERY_FACEBODY_ANALYSE
typedef struct tagMEDIAFILE_FACEBODY_ANALYSE_PARAM
{
	DWORD               			dwSize;                			// struct size  
    int                 			nFileType;             			// file info,0:any type,1:search jpg image,2:search dav
    int                 			nChannelID;             		// ChannelID, start from 0, -1 means search all channel
    UINT               				nVideoStream;          			// video stream 0-unknown; 1-main; 2-sub 1; 3-sub 2; 4- sub 3; 5-ExtraX 
	NET_TIME            			stuBeginTime;           		// begin time  
	NET_TIME            			stuEndTime;             		// end time 
	EM_RECORD_SNAP_FLAG_TYPE 		emFlagLists[FLAG_TYPE_MAX]; 	// Record or snapshot file mark, not set mark to search all files
    int                 			nFlagCount;            			// flag count
    NET_RECORD_CARD_INFO 			stuCardInfo;           			// card num record info, invalid if emFlagLists including card num
    EM_RESULT_ORDER_TYPE 			emResultOrder;         			// result order
    BOOL							bTime;                  		// find file by time
	FACEBODY_ANALYSE_RECORDFILTER	stuFilter;						// filter info of face body analyse query
} MEDIAFILE_FACEBODY_ANALYSE_PARAM;

// search result of CLIENT_FindFileEx with DH_FILE_QUERY_FACEBODY_ANALYSE
typedef struct tagMEDIAFILE_FACEBODY_ANALYSE_INFO
{
	DWORD               			dwSize;                			// struct size
	int                 			nChannelID;             		// ChannelID, start from 0, -1 means search all channel
	NET_TIME            			stuBeginTime;           		// begin time     
	NET_TIME            			stuEndTime;             		// end time
	UINT        					nFileSize;              		// file size,unit:byte
	UINT                			nFileType;             			// file type 1:jpg, 2: dav    	
	UINT                			nVideoStream;          			// video stream 0-unknown; 1-main; 2-sub 1; 3-sub 2; 4- sub 3; 5-ExtraX 
	UINT                			nPartition;            			// zone
	UINT        					nCluster;               		// cluster
	char                			szFilePath[MAX_PATH];   		// file path 
	EM_RECORD_SNAP_FLAG_TYPE 		emFlagLists[FLAG_TYPE_MAX]; 	// Record or snapshot file mark, not set mark to search all files
	int                 			nFlagCount;             		// flag count
	UINT		        			nDriveNo;               		// drive no   
	FACE_TRAIT						stuFaceTrait;					// face trait
	BODY_TRAIT						stuBodyTrait;					// body trait
	NET_EVENT_IMAGE_OFFSET_INFO		stuFaceImage; 					// face image info
	NET_EVENT_IMAGE_OFFSET_INFO		stuBodyImage;					// body image info	
	NET_EVENT_IMAGE_OFFSET_INFO		stuSceneImage;					// scene image info
	CANDIDATE_INFOEX				stuCandidates[DH_MAX_CANDIDATE_NUM];	// Candidates info
	int								nCandidateNum;							// Candidates count
} MEDIAFILE_FACEBODY_ANALYSE_INFO;

// the face info of the object
typedef struct tagNET_DOORCONTROL_FACE_OBJECT
{
	NET_RECT            stuBoundingBox;                 // bounding box
	IMAGE_INFO			stuFaceImageInfo;				// face image
	BYTE				byReserved[512];	            // reserved
} NET_DOORCONTROL_FACE_OBJECT;

//  register person info
typedef struct tagNET_REGISTER_PERSON_INFO
{
	char                		szUID[DH_MAX_PERSON_ID_LEN];                    // person unique ID, cteated by server
                                                                        		// it must be setted a value when modify an remove
    char						szGroupID[NET_GROUPID_LENGTH];					// group ID
	char						szGroupName[NET_GROUPNAME_LENGTH];				// group name
	EM_REGISTER_DB_TYPE			emRegisterDbType;								// register DB type
	EM_SEX_TYPE                 emSexType;                                      // sex
	UINT                		nFacePicNum;                                    // count of pictures
	NET_FACE_IMAGE_INFO			stuFacePicInfo[DH_MAX_PERSON_IMAGE_NUM];        // the picture info of this person
	EM_PERSON_FEATURE_STATE		emFeatureState;									// feature state of this person

	char                		szPersonName[DH_MAX_PERSON_NAME_LEN];           // name  
	NET_TIME					stuBirthday;									// birthday
	char						szCountry[NET_COUNTRY_LENGTH];					// country
	char                		szProvince[DH_MAX_PROVINCE_NAME_LEN];           // provincce
	char                		szCity[DH_MAX_CITY_NAME_LEN];                   // city
	char						szHomeAddress[DH_COMMON_STRING_128];			// home address
	EM_CERTIFICATE_TYPE			emCertificateType;								// certificate type
	char                		szID[DH_MAX_PERSON_ID_LEN];                     // ID number, or job number or other ID of this person
	UINT						nImportant;										// important level, [1,10]the bigger the vslue, the more important
	char						szComment[NET_COMMENT_LENGTH];					// comment
	BYTE                        byReserved[2048];   								// reserved
} NET_REGISTER_PERSON_INFO;

// cancidate info of door control
typedef struct tagNET_DOORCONTROL_CANDIDATE
{
	UINT						nSimilarity;			// similarity, [1,100]
	NET_REGISTER_PERSON_INFO	stuPersonInfo;			// register person info
	BYTE                        byReserved[1024];   		// reserved
} NET_DOORCONTROL_CANDIDATE;

// the record file info(corresponding to DH_FILE_QUERY_DOORCONTROL_RECORD) 
typedef struct tagMEDIAFILE_DOORCONTROL_RECORD_INFO
{
	DWORD               		dwSize;             					// struct size
   
	// file attr
	int                 		nChannel;               				// channel
	UINT        				nDriveNo;               				// drive number
	UINT        				nCluster;               				// cluster number
	UINT						nHint;									// hint
	char                		szFilePath[MAX_PATH];   				// file path
	int                 		nFileSize;              				// file size
   
	// door control
	EM_OPEN_DOOR_METHOD			emOpenDoorMethod;						// open door method
	EM_OPEN_DOOR_STATE			emOpenDoorState;						// open door state
	IMAGE_INFO					stuSceneImageInfo;						// scene image info
	NET_TIME					stuSnapTime;							// snap time
	NET_DOORCONTROL_FACE_OBJECT	stuFaceObject;							// face info of object
	UINT						nCandidatesNum;							// candidate number
	NET_DOORCONTROL_CANDIDATE	stuCandidates[DH_MAX_CANDIDATE_NUM]; 	// candidate info
} MEDIAFILE_DOORCONTROL_RECORD_INFO;

// query video synopsis param
typedef struct __MEDIA_QUERY_VIDEOSYNOPSIS_PARAM
{
	DWORD               dwSize;
	NET_TIME			StartTime;						// start time	
	NET_TIME			EndTime;						// end time
	int					nMediaType;						// file type,0:arbitrariness,1:image,2:record
	int                 nQueryType;                     // query type,1:source video file 2:reduce video file
}MEDIA_QUERY_VIDEOSYNOPSIS_PARAM;

// query video synopsis param
typedef struct __MEDIAFILE_VIDEOSYNOPSIS_INFO
{
    char				szFilePath[128];		// file path
    unsigned int		size;					// file size
    NET_TIME			starttime;				// start time
    NET_TIME			endtime;				// end time
    unsigned int		nWorkDirSN;				// work dir serial number						
	BYTE				nFileType;				// file type  1:jpg
	BYTE                bHint;					// index file location
	BYTE                bDriveNo;               // drive no.
	BYTE                bReserved2;
	unsigned int        nCluster;               // cluster
	BYTE				byPictureType;			// picture type, 0-normal, 1-synthesis, 2-cutout
	BYTE                bReserved[3];           // reserved

	// video source file info
	int                nTaskID;                 // task ID
	char               szCurrentState[DH_MAX_SYNOPSIS_STATE_NAME]; //video synopsis state
	int                nProgress;               // sorresponding state
	int                nObjectNum;              // object number

	// video synopsis file info
	int                nDurationTime;           // duration time (s)
}MEDIAFILE_VIDEOSYNOPSIS_INFO;
// correlate with NET_IN_SNAPSHOT, flash control,array,each element corresponding to a flash light configuration
typedef struct __NET_FLASHCONTROL
{
	DWORD				dwSize;					// struct size
	int					nMode;					// work mode 0-no flash,1-always flash,2-auto flash
}NET_FLASHCONTROL;

// Capture client type
typedef enum tagSNAP_CLIENT_TYPE
{
    SNAP_CLIENT_TYPE_COMMON,               // Corresponding to "Common" type, the default type
    SNAP_CLIENT_TYPE_PARKINGSPACE,         // Correspondence "ParkingSpace" type, parking
}SNAP_CLIENT_TYPE;

#define DH_MAX_USER_DEFINE_INFO        1024

// when nTriggerType==2, client snap info
typedef struct _NET_CLIENT_SNAP_INFO
{
	DWORD				dwSize;					// struct info 
	unsigned int        nFrameSequence;         // frame sequence
	double              PTS;                    // pts,64 bit
	char				szUserDefinedInfo[DH_MAX_USER_DEFINE_INFO];	// String, custom client, "\ 0" at the end
	SNAP_CLIENT_TYPE    emSNAP_CLIENT_TYPE;     // Client Type
	DWORD               dwRetCardNumber;        // card amount
    EVENT_CARD_INFO     stuCardInfo[DH_EVENT_MAX_CARD_NUM];  // card information
}NET_CLIENT_SNAP_INFO;

// CLIENT_TrafficSnapByNetwork's input param
typedef struct __NET_IN_SNAPSHOT
{
	DWORD				dwSize;					// struct size
	int					nTriggerType;			// trigger type	0-unknown 1-zhongmeng net trigger
	int					nLaneID;				// lane id
	int					nGroupID;				// group id
	int					nGrabTimes;				// picture number
	int					nStartPicNum;			// the start picture id
	int					nDirection;				// road direction 0-north 1-east north 2-east 3-east south 4-south 5-west south 6-west 7-west north 8-unknown
	int					nGrabWaitTime;			// pGrabWaitTime group member number
	DWORD*				pGrabWaitTime;			// interval time between two picture, the space is nGrabWaitTime by the user
	int					nLowerSpeedLimit;		// lower speed limit, km/h
	int					nUpperSpeedLimit;		// upper speed limit, km/h
	int					nSpeed;					// speed, km/h
	int					nViolationNo;			// violation number 0-not transgress
												// 1-black shit
												// 2-over speed not over 50% 
												// 3-over speed between 50% and 100% 
												// 4-over speed over 100% 
												// 5-retrograde
												// 6-run red
												// 7-under speed
												// 8-no passing,wrong route
	int					nRedLightTime;			// red light time,s
	int					nFlashControl;			// pFlashControl group member number
	NET_FLASHCONTROL*   pFlashControl;			// flash control,the space is sizeof(NET_FLASHCONTROL)*nFlashControl by the user
	DWORD				dwUser;					// user data
	NET_CLIENT_SNAP_INFO stClientInfo;          // the incoming snap parameter
}NET_IN_SNAPSHOT;

// CLIENT_TrafficSnapByNetwork's output param
typedef struct __NET_OUT_SNAPSHOT
{
	DWORD				dwSize;					// structure size
}NET_OUT_SNAPSHOT;

// interface(CLIENT_TrafficForceLightState)input parameter
typedef struct __NET_IN_FORCELIGHTSTATE
{
	DWORD				dwSize;					// struct size
	unsigned int        nDirection;             // 0 bit:"Straight",1 bit:"TurnLeft",2 bit:"TurnRight",3 bit:"U-Turn"
}NET_IN_FORCELIGHTSTATE;

// interface (CLIENT_TrafficForceLightState)output parameter
typedef struct __NET_OUT_FORCELIGHTSTATE
{
	DWORD				dwSize;					// struct size
}NET_OUT_FORCELIGHTSTATE;
// CLIENT_StartTrafficFluxStat's callback function
typedef int  (CALLBACK *fFluxStatDataCallBack)(LLONG lFluxStatHandle, DWORD dwEventType, void* pEventInfo, BYTE *pBuffer, DWORD dwBufSize, LDWORD dwUser, int nSequence, void *reserved);

// CLIENT_StartTrafficFluxStat's input param
typedef struct __NET_IN_TRAFFICFLUXSTAT
{
	DWORD				dwSize;					// structure size
	fFluxStatDataCallBack		cbData;			// callback function pointer
	LDWORD				dwUser;					// user data
}NET_IN_TRAFFICFLUXSTAT;

// CLIENT_StartTrafficFluxStat's output param
typedef struct __NET_OUT_TRAFFICFLUXSTAT
{
	DWORD				dwSize;					// structure size	
}NET_OUT_TRAFFICFLUXSTAT;

// CLIENT_StartFindFluxStat's input param
typedef struct __NET_IN_TRAFFICSTARTFINDSTAT
{
	DWORD				dwSize;					// structure size
	NET_TIME			stStartTime;			// start time, temporarily  
	NET_TIME			stEndTime;				// end time, temporarily 
	int					nWaittime;				// the time to wait result
}NET_IN_TRAFFICSTARTFINDSTAT;

// CLIENT_StartFindFluxStat's output param
typedef struct __NET_OUT_TRAFFICSTARTFINDSTAT
{
	DWORD				dwSize;					// structure size
	DWORD               dwTotalCount;           // The total amount that matched current search criteria                 
}NET_OUT_TRAFFICSTARTFINDSTAT;

// CLIENT_DoFindFluxStat's input param
typedef struct __NET_IN_TRAFFICDOFINDSTAT
{
	DWORD				dwSize;					// structure size
	unsigned int		nCount;					// the number of flow Statistic for query
	int					nWaittime;				// the time to wait result
}NET_IN_TRAFFICDOFINDSTAT;

typedef struct
{
	DWORD				dwSize;					// structure size

	int					nStatInfo;				// the number of statistic info
	DH_TRAFFICFLOWSTAT *pStatInfo;				// the statistic pointer, the space application by the user, length is sizeof(DH_TRAFFICFLOWSTAT)*nStatInfo
}DH_TRAFFICFLOWSTAT_OUT;

// CLIENT_DoFindFluxStat's out param
typedef struct __NET_OUT_TRAFFICDOFINDSTAT
{
	DWORD				dwSize;					// structure size
	
	DH_TRAFFICFLOWSTAT_OUT stStatInfo;			// the statistic pointer
}NET_OUT_TRAFFICDOFINDSTAT;

// The type of rule
typedef enum tagEM_RULE_TYPE
{
	EM_RULE_UNKNOWN,			// Unknown
	EM_RULE_NUMBER_STAT,		// NumberStat 
	EM_RULE_MAN_NUM_DETECTION,	// Man number detection
    EM_RULE_QUEUE_DETECTION,	// Queue detection
} EM_RULE_TYPE;

// other rule
typedef enum tagEM_OTHER_RULE_TYPE
{
	EM_OTHER_RULE_TYPE_UNKOWN,				// Unknow
	EM_OTHER_RULE_TYPE_AVERAGE_STAYTIME,	// Average Stay Time 	
} EM_OTHER_RULE_TYPE; 

// interface(CLIENT_StartFindNumberStat)'s input param
typedef struct __NET_IN_FINDNUMBERSTAT
{
	DWORD				dwSize;					// size
	int                 nChannelID;             // channel ID
	NET_TIME			stStartTime;			// start time
	NET_TIME			stEndTime;				// end time
	int                 nGranularityType;       // granularity type, 0:minute,1:hour,2:day,3:week,4:month,5:quarter,6:year
												// 7:instant, 8:person(7 and 8 are valid only when the emRuleType is EM_RULE_MAN_NUM_DETECTION)
	int					nWaittime;				// wait time    
    UINT                nPlanID;                // Plan ID,Speed Dome use,start from 1
	EM_RULE_TYPE		emRuleType;				// rule type
	int					nMinStayTime;			// the minimum stay timedefault value is 0; return the number of persons, the stay time of these persons are greater or equal to this time
												// this parameter is not required when the find type is NumberStat 
	int					nAreaIDNum;				// area id num
	UINT				nAreaID[20];			// Area ID(a preset point can correspond to multiple area IDs)
	EM_OTHER_RULE_TYPE	emOtherRule;			// other rule
}NET_IN_FINDNUMBERSTAT;

// CLIENT_StartFindNumberStat's output param
typedef struct __NET_OUT_FINDNUMBERSTAT
{
	DWORD				dwSize;					 
	DWORD               dwTotalCount;           // total count
}NET_OUT_FINDNUMBERSTAT;

// CLIENT_DoFindNumberStat's input param
typedef struct __NET_IN_DOFINDNUMBERSTAT
{
	DWORD				dwSize;					 
	unsigned int        nBeginNumber;           // [0, totalCount-1]
	unsigned int		nCount;					// count
	int					nWaittime;				// wait time
}NET_IN_DOFINDNUMBERSTAT;

typedef struct __DH_NUMBERSTAT
{
	DWORD    dwSize;
	int      nChannelID;                           // channel id
	char     szRuleName[DH_CHAN_NAME_LEN];         // rule name
	NET_TIME stuStartTime;                         // start time
	NET_TIME stuEndTime;                           // end time
    int      nEnteredSubTotal;                     // entered total
	int      nExitedSubtotal;                      // entered total
    int      nAvgInside;                           // average number inside
	int      nMaxInside;                           // max number inside
    int      nEnteredWithHelmet;                   // people enter with helmet count
    int      nEnteredWithoutHelmet;                // people enter without helmet count
    int      nExitedWithHelmet;                    // people exit with helmet count
    int      nExitedWithoutHelmet;                 // people exit without helmet count
    int		 nInsideSubtotal;					   // the count of peoples in the region
	UINT     nPlanID;							   // Plan ID,Speed Dome use,start from 1
	UINT	 nAreaID;							   // Area ID(a preset point can correspond to multiple area IDs)
	UINT	 nAverageStayTime;					   // Average Stay Time
}DH_NUMBERSTAT;

// CLIENT_DoFindNumberStat's ouput param
typedef struct __NET_OUT_DOFINDNUMBERSTAT
{
	DWORD				dwSize;					             
	int                 nCount;                              // count
	DH_NUMBERSTAT       *pstuNumberStat;                     // state array, the space application by the user
    int                 nBufferLen;                          // the space application yb the user, the length unit is the dwsize of DH_NUMBERSTAT
    int					nMinStayTime;					 	 // the minimum stay time when the find type is ManNumDetection
}NET_OUT_DOFINDNUMBERSTAT;

// video statistical subtotal
typedef struct tagNET_VIDEOSTAT_SUBTOTAL 
{
    int                 nTotal;                         // count since device operation
    int                 nHour;                          // count in the last hour
    int                 nToday;                         // count for today
    int                 nOSD;                           // count for today, on screen display 
    char                reserved[252];
} NET_VIDEOSTAT_SUBTOTAL;

#define MAX_EXIT_MAN_NUM	32		// Maximum count of the peoples left

// The stay time of the peoples left
typedef struct tagNET_EXITMAN_STAY_STAT
{
	NET_TIME	stuEnterTime;		// Time to enter the region
	NET_TIME	stuExitTime;		// Time to exit the region
	BYTE		reserved[128];		// Reserved
} NET_EXITMAN_STAY_STAT;

// Video statistical summary
typedef struct tagNET_VIDEOSTAT_SUMMARY
{
    int                     nChannelID;                 // Channel ID
    char                    szRuleName[32];             // Rule name
    NET_TIME_EX             stuTime;                    // Time of this statistics
    NET_VIDEOSTAT_SUBTOTAL  stuEnteredSubtotal;         // Subtotal for the entered
    NET_VIDEOSTAT_SUBTOTAL  stuExitedSubtotal;          // Subtotal for the exited
	UINT					nInsidePeopleNum;			// Total number of people in the area
    EM_RULE_TYPE			emRuleType;								// Rule type
	int						nRetExitManNum;							// The count of peoples left
	NET_EXITMAN_STAY_STAT	stuExitManStayInfo[MAX_EXIT_MAN_NUM];	// The stay time of the peoples left
	UINT					nPlanID;								// Plan ID,Speed Dome use,start from 
	UINT					nAreaID;								// Area ID(a preset point can correspond to multiple area IDs)
    UINT                    nCurrentDayInsidePeopleNum;             // Total number of people current day in the area
	BYTE					reserved[1012];							// Reserved
} NET_VIDEOSTAT_SUMMARY;

// video statistical summary callback function type, lAttachHandle is the return value of CLIENT_AttachVideoStatSummary
typedef void (CALLBACK *fVideoStatSumCallBack) (LLONG lAttachHandle, NET_VIDEOSTAT_SUMMARY* pBuf, DWORD dwBufLen, LDWORD dwUser);

// input param for CLIENT_AttachVideoStatSummary
typedef struct tagNET_IN_ATTACH_VIDEOSTAT_SUM
{
    DWORD                   dwSize;
    int                     nChannel;                    // video channel ID       
    fVideoStatSumCallBack   cbVideoStatSum;              // video statistical summary callback
    LDWORD                  dwUser;						 // user data             
} NET_IN_ATTACH_VIDEOSTAT_SUM;

// output param for CLIENT_AttachVideoStatSummary
typedef struct tagNET_OUT_ATTACH_VIDEOSTAT_SUM
{
    DWORD                   dwSize;
} NET_OUT_ATTACH_VIDEOSTAT_SUM;

// HeatMap type
typedef enum tagEM_HEATMAP_TYPE
{
	EM_HEATMAP_UNKNOWN,									// Unknown
	EM_HEATMAP_AVERAGESTAYTIME,							// Average stay time heatmap
	EM_HEATMAP_HUMANSTATISTICS,							// Human statistics heatmap
	EM_HEATMAP_HUMANTRACK,								// Human track
}EM_HEATMAP_TYPE;

// Input param of CLIENT_GetVideoStatHeatMap
typedef struct tagNET_IN_GET_VIDEOSTAT_HEATMAP
{
	DWORD                   dwSize;						 // struct size
	int						nPlanID;					 // Plan ID(Preset point, Enable for SD only, Range[1, MaxNumberStatPlan])
	NET_TIME				stuStartTime;				 // Start time
	NET_TIME				stuEndTime;					 // End time
	EM_HEATMAP_TYPE			emHeatMapType;				 // Ai HeatMap type
}NET_IN_GET_VIDEOSTAT_HEATMAP;

// Output param of CLIENT_GetVideoStatHeatMap
typedef struct tagNET_OUT_GET_VIDEOSTAT_HEATMAP
{
	DWORD                   dwSize;						// struct size
	UINT					nToken;						// Token
}NET_OUT_GET_VIDEOSTAT_HEATMAP;

// Heatmap data information 
typedef struct tagNET_CB_VIDEOSTAT_HEATMAP
{
	UINT					nToken;
	EM_HEATMAP_TYPE			emHeatMapType;				// HeatMap type
	BYTE					byReserved[1024];			// Reserved
}NET_CB_VIDEOSTAT_HEATMAP;

// The callback of HeatMap data
typedef void (CALLBACK *fVideoStatHeatMapCallBack) (LLONG lAttachHandle, NET_CB_VIDEOSTAT_HEATMAP* pBuf, const char* pBinData, DWORD dwBinDataLen, LDWORD dwUser);

// Input param of CLIENT_AttachVideoStatHeatMap
typedef struct tagNET_IN_ATTACH_VIDEOSTAT_HEATMAP
{
	DWORD                   dwSize;						 // struct size
	int                     nChannel;                    // Channel Id  
	fVideoStatHeatMapCallBack cbVideoStatHeatMap;        // Heatmap data callback
	LDWORD                  dwUser;                      // User data                   
} NET_IN_ATTACH_VIDEOSTAT_HEATMAP;

// Output param of CLIENT_AttachVideoStatHeatMap
typedef struct tagNET_OUT_ATTACH_VIDEOSTAT_HEATMAP
{
	DWORD                   dwSize;
} NET_OUT_ATTACH_VIDEOSTAT_HEATMAP;

//// intelligent traffic detector

// CLIENT_GetParkingSpaceStatus's input param
typedef struct tagNET_IN_GET_PARKINGSPACE_STATUS
{
	DWORD                dwSize;                         // struct size
	DWORD                dwWaitTime;                     // wait time
	int                  nChannelID;                     // channel ID
	int *                pLaneID;                        // range[0,255], pLaneID==NULL means all parking space, the max number is DH_PRODUCTION_DEFNITION.nMaxRoadWays
	int                  nLaneCount;                     // apply to sizeof(int)*nLaneCount memory
} NET_IN_GET_PARKINGSPACE_STATUS;

typedef struct tagNET_LANE_PARKINGSPACE_STATUS
{
	DWORD                dwSize;                         // struct size
	int                  nLaneID;                        // lane ID
	unsigned int         nPictureId;                     // picture ID,get picture data
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;      // traffic car info
} NET_LANE_PARKINGSPACE_STATUS;

// CLIENT_GetParkingSpaceStatus's output param
typedef struct tagNET_OUT_GET_PARKINGSPACE_STATUS
{
	DWORD                dwSize;                         // struct size
	NET_LANE_PARKINGSPACE_STATUS* pStatus;               // status, the space application by the user
	int                  nMaxStatus;                     // need apply to sizeof(NET_LANE_PARKINGSPACE_STATUS)*nMaxStatus, and nMaxStatus == DH_PRODUCTION_DEFNITION.nMaxRoadWays memory
	int                  nRetStatus;                     // actual returns status number of parking spaces
} NET_OUT_GET_PARKINGSPACE_STATUS;

// CLIENT_AttachParkingSpaceData's input param
typedef struct tagNET_CB_PARKINGSPACE_DATA
{
	DWORD                dwSize;                         // struct size
	void*                pPicBuffer;                     // image binary data
	unsigned int         nPicLength;                     // picture length
} NET_CB_PARKINGSPACE_DATA;

// CLIENT_AttachParkingSpaceData callback function , pBuf is json and image data info , nBufLen is pBuf length,for forwarding services
typedef int (CALLBACK *fNotifySnapData)(LLONG lParkingHandle, NET_CB_PARKINGSPACE_DATA* pDiagnosisInfo, void* pBuf, int nBufLen, LDWORD dwUser);

// CLIENT_AttachParkingSpaceData's input param
typedef struct tagNET_IN_ATTACH_PARKINGSPACE
{
	DWORD                dwSize;                         // struct size
	DWORD                dwWaitTime;                     // wait time
	int                  nChannelID;                     // channel ID
	unsigned int         nPictureId;                     // picture ID, can look for NET_LANE_PARKINGSPACE_STATUS.nPictureId
	
	fNotifySnapData      cbNotifySnapData;               // callback function
	LDWORD               dwUser;                         // user-defined parameters
} NET_IN_ATTACH_PARKINGSPACE;

// fingerprint data
typedef struct tagNET_CB_FINGERPRINT_INFO
{
	UINT 		nIndex;                                     // fingerprint index,range 0 -9,count form left pinkty to right pinky
	char        szFingerprintData[DH_COMMON_STRING_2048];   // fingerprint data,base64 string           
	BYTE        bReserved[256];                             // reserved  bytes
}NET_CB_FINGERPRINT_INFO;

// person info collect info
typedef struct tagNET_CB_PERSON_INFO
{
    UINT                 nSID;                           // SID
	UINT 	             nPicLength;                     // person picture length
	char                 szUserID[DH_MAX_USERID_LEN];    // user id
    UINT                 nRetFaceDataNum;                // return face detection data number 
    char                 szFaceData[MAX_FACE_DATA_NUM][MAX_FACE_DATA_LEN];  // person face detection data    
	char                 szPassword[DH_COMMON_STRING_64];//card password
    char                 szCardNo[DH_MAX_CARDNO_LEN];    // card no
    char                 szCardName[DH_COMMON_STRING_32];// card name
    UINT                 nFingerPrintNum;                // return fingerprint num
    NET_CB_FINGERPRINT_INFO stuFingerPrintInfo[MAX_FINGERPRINT_NUM];//fingerprint info
	BYTE                 bReserved[2048];                // reserved  bytes
}NET_CB_PERSON_INFO;

// callback function of person info collect 
typedef int (CALLBACK *fNotifyPersonInfo)(LLONG lLoginID, LLONG lPersonHandle, NET_CB_PERSON_INFO *pstuPersonInfo, BYTE *pBuffer, DWORD dwBufSize, LDWORD dwUser, void *reserved);

// CLIENT_AttachPersonInfoCollect  in param
typedef struct tagNET_IN_ATTACH_PERSONINFOCOLLECT
{
	DWORD 				dwSize;                         // struct size
	DWORD               dwWaitTime;                     // wait time
	fNotifyPersonInfo   cbNotifyPersonInfo;             // callback function
	LDWORD              dwUser;                         // user-defined parameters
}NET_IN_ATTACH_PERSONINFOCOLLECT;

//CLIENT_AttachPersonInfoCollect out param
typedef struct tagNET_OUT_ATTACH_PERSONINFOCOLLECT
{
	DWORD               dwSize;                         // struct size
}NET_OUT_ATTACH_PERSONINFOCOLLECT;

// CLIENT_DetachPersonInfoColloect in param
typedef struct tagNET_IN_DETACH_PERSONINFOCOLLECT
{
	DWORD 				dwSize;                        //struct size
	DWORD               dwWaitTime;                    // wait time 
	LLONG               lPersonHandle;                 // CLIENT_AttachPersonInfoCollect return handle
}NET_IN_DETACH_PERSONINFOCOLLECT;

//CLIENT_DetachPersonInfoColloect out param
typedef struct tagNET_OUT_DETACH_PERSONINFOCOLLECT
{
	DWORD               dwSize;                        // struct size
}NET_OUT_DETACH_PERSONINFOCOLLECT;

/******************************************************************************
function	:attach person info collect
return :	return attach handle,use to detach opearator
******************************************************************************/
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachPersonInfoCollect(LLONG lLoginID, NET_IN_ATTACH_PERSONINFOCOLLECT *pstuInParam, NET_OUT_ATTACH_PERSONINFOCOLLECT *pstuOutParam);

/******************************************************************************
function	:detach person info collect
pstuInParam's lPersonHandle is returned by CLIENT_AttachPersonInfoCollect
******************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachPersonInfoColloect(NET_IN_DETACH_PERSONINFOCOLLECT* pstuInParam, NET_OUT_DETACH_PERSONINFOCOLLECT* pstuOutParam);

//NET_CAR_PASS_INFOS related enumerated type
typedef enum tagNET_CAR_SIZE
{
    CAR_SIZE_UNKNOWN  = 0 ,     //unknown
    CAR_SIZE_SAMLL        ,     //small car
    CAR_SIZE_BIG          ,     //big car 
}NET_CAR_SIZE;

typedef enum tagNET_CAR_ACTION
{
    CAR_ACTION_UNKNOWN = 0 , 
    CAR_ACTION_ENTER       ,  //Enter the detection area
    CAR_ACTION_LEAVE       ,  //Leave the detection area
}NET_CAR_ACTION;


//CLIENT_AttachCarPassInfo callback function returns the structure of the car pass information typedef struct tagNET_CAR_PASS_INFO
typedef struct tagNET_CAR_PASS_INFO
{
     DWORD                dwSize; 
       
     DWORD                nID;                              // Car ID
     DWORD                nLaneNumber;                      // Start from0,for example, if there is 3 lane, the number of the lane is 0 1 2 respectively
     DWORD                nRoadwayNumber;                   // Custom lane number, User configurable lane number, the current value in the range of 1-16
     DWORD                nSpeed;                           // Car speed (km/h)
     NET_CAR_SIZE         emCarSize;                        // Car size type
     NET_CAR_ACTION       emCarAction;                      // Car action type
     NET_TIME_EX          stuTime;                          // Action happens time,accurate to seconds
}NET_CAR_PASS_INFO;

// Port CLIENT_AttachCarPassInfo callback function
// nInfoNum the number of car pass information
// pstuCarPassInfos the array of car pass information number
typedef int (CALLBACK *fNotifyCarPassInfo)(LLONG lCarPassHandle, NET_CAR_PASS_INFO* pstuCarPassInfos,  int nInfoNum ,   LDWORD dwUser);

// Port CLIENT_AttachCarPassInfo input parameter
typedef struct tagNET_IN_ATTACH_CAR_PASS_INFO
{
    DWORD                dwSize;                         // he size of the structure is too small,should be assigned
    int                  nChannelID;                     // Channel ID

    fNotifyCarPassInfo   cbNotifyCarPassInfo;            // Callback function, when thereis a car information,a callback to the top
    LDWORD               dwUser;                         // User-defined parameters
}NET_IN_ATTACH_CAR_PASS_INFO;

//Port CLIENT_AttachCarPassInfo output parameter
typedef struct tagNET_OUT_ATTACH_CAR_PASS_INFO
{
    DWORD       dwSize;         // The size of the structure is too small,should be assigned
}NET_OUT_ATTACH_CAR_PASS_INFO;

// CLIENT_AttachParkingSpaceData's output param
typedef struct tagNET_OUT_ATTACH_PARKINGSPACE
{
	DWORD                dwSize;                         // struct size
} NET_OUT_ATTACH_PARKINGSPACE;

// CLIENT_DetachParkingSpaceData's input param
typedef struct tagNET_IN_DETACH_PARKINGSPACE
{
	DWORD                dwSize;                         // struct size
	DWORD                dwWaitTime;                     // wait time
	LLONG                lParkingHandle;                 // CLIENT_AttachParkingSpaceData return handle
} NET_IN_DETACH_PARKINGSPACE;
// CLIENT_DetachParkingSpaceData's output param
typedef struct tagNET_OUT_DETACH_PARKINGSPACE
{
	DWORD                dwSize;                         // struct size
} NET_OUT_DETACH_PARKINGSPACE;

// Get Parking Lock Status, CLIENT_GetParkingLockState input param
typedef struct tagNET_IN_GET_PARKINGLOCK_STATE_INFO
{
	DWORD				dwSize;							// struct size
} NET_IN_GET_PARKINGLOCK_STATE_INFO;

// Parking Lock Status
typedef enum tagEM_STATE_TYPE
{
	EM_STATE_TYPE_UNKNOW,		// unknow
	EM_STATE_TYPE_LOCKRISE,		// lock rise
	EM_STATE_TYPE_LOCKDOWN,		// lock down
	EM_STATE_TYPE_LOCKERROR,	// lock error
} EM_STATE_TYPE;

// Parking Lock State Communication Interface Parameters
typedef struct tagNET_STATE_LIST_INFO
{
	unsigned int		 nLane;				// Parking number
	EM_STATE_TYPE		 emState;			// Parking lock status
	BYTE				 byReserved[256];	// reserved
} NET_STATE_LIST_INFO;

// Get Parking Lock Status CLIENT_GetParkingLockState output param
typedef struct tagNET_OUT_GET_PARKINGLOCK_STATE_INFO
{
	DWORD					dwSize;											// Struct size
	int						nStateListNum;									// Number of parking lock states
	NET_STATE_LIST_INFO		stuStateList[MAX_PARKINGLOCK_STATE_NUM];		// Parking lock status
} NET_OUT_GET_PARKINGLOCK_STATE_INFO;

// Set Parking Lock StatusCLIENT_SetParkingLockState input param
typedef struct tagNET_IN_SET_PARKINGLOCK_STATE_INFO
{
	DWORD					dwSize;											// Struct size
	int						nStateListNum;									// Number of parking lock states
	NET_STATE_LIST_INFO		stuStateList[MAX_PARKINGLOCK_STATE_NUM];		// Parking lock status
} NET_IN_SET_PARKINGLOCK_STATE_INFO;

// Set Parking Lock StatusCLIENT_SetParkingLockState out param
typedef	struct tagNET_OUT_SET_PARKINGLOCK_STATE_INFO
{
	DWORD					dwSize;											// struct size
} NET_OUT_SET_PARKINGLOCK_STATE_INFO; 

// Input param of CLIENT_SetParkingRule
typedef struct tagNET_IN_SET_PARKINGRULE_INFO
{
	DWORD					dwSize;										// struct size
	UINT					nParkingTimeThreshold;					    // The timeout threshold of parking, Unit:s
} NET_IN_SET_PARKINGRULE_INFO;

// Output param of CLIENT_SetParkingRule
typedef	struct tagNET_OUT_SET_PARKINGRULE_INFO
{
	DWORD					dwSize;										// struct size
} NET_OUT_SET_PARKINGRULE_INFO; 

// Batch download file

// Download progress callback function prototypes,  nError Indicates that an error occurred during the download of, 1-insufficient buffer, 2-parity errof of return data, 3-failed to download current file, 4-failed to create corresponding storage file
// When download according to the file,ID setting by the User is dwFileID, When download according to the conditions,ID setting by the User is dwConditionID                    
typedef void (CALLBACK *fMultiFileDownLoadPosCB)(LLONG lDownLoadHandle, DWORD dwID, DWORD dwFileTotalSize, DWORD dwDownLoadSize, int nError, LDWORD dwUser, void* pReserved);

//Ways to download file
typedef enum tagEM_DOWNLOAD_FILE_TYPE
{
   EM_DOWNLOAD_BY_FILENAME = 0      ,       //Download according to file name
   EM_DOWNLOAD_BY_CONDITION         ,       //Download according to query conditions
}EM_DOWNLOAD_FILE_TYPE;

//Download time type
typedef enum tagEM_DOWNLOAD_TIME_TYPE
{
    EM_DOWNLOAD_TIME_SNAP = 0       ,         //Snap time
    EM_DOWNLOAD_TIME_STORAGE        ,         //Storage time
}EM_DOWNLOAD_TIME_TYPE;

//Download data type
typedef enum tagEM_DOWNLOAD_DATA_TYPE
{
    EM_DOWNLOAD_DATA_RECORD = 0 ,               //Record
    EM_DOWNLOAD_DATA_PICTURE ,                  //Picture
}EM_DOWNLOAD_DATA_TYPE;

// CLIENT_DownLoadMultiFile  port parameter
typedef struct tagNET_DOWNLOADFILE_INFO
{
	DWORD               dwSize;
	DWORD               dwFileID;                       // Document ID, assigned by the user
	int                 nFileSize;                      // Query to the file size
	char                szSourceFilePath[MAX_PATH];     // Query to the file path
	char                szSavedFileName[MAX_PATH];      // Save the file path
}NET_DOWNLOADFILE_INFO;

typedef struct tagNET_DOWNLOAD_CONDITION_INFO
{
    DWORD                   dwSize;
    DWORD                   dwConditionID;                  // Condition ID, assign by the User
    int                     nChannel;                       // Channel ID
    NET_TIME                stuStartTime;                   // Start time
    NET_TIME                stuEndTime;                     // End time
    EM_DOWNLOAD_TIME_TYPE   emTimeType;                     // Time type
    EM_DOWNLOAD_DATA_TYPE   emDataType;                     // Data type 
    char                    szSavedFileName[MAX_PATH];      //Save the file path
}NET_DOWNLOAD_CONDITION_INFO;

typedef struct tagNET_IN_DOWNLOAD_MULTI_FILE
{
	DWORD               dwSize;
    // Download according to file name
    int                 nFileCount;                     // The number of files to be downloaded
	NET_DOWNLOADFILE_INFO* pFileInfos;                  // File information to be downloaded
														// the space application by the user,apply to sizeof(NET_DOWNLOADFILE_INFO)*nFileCount   
	fMultiFileDownLoadPosCB cbPosCallBack;              // Progress callback function
	LDWORD              dwUserData;                     // User data
    EM_DOWNLOAD_FILE_TYPE           emDownloadType;     // Download ways
    //Download according to query conditions
    int                             nConditionCount;    // Number of download conditions,emDownloadType is EM_DOWNLOAD_BY_CONDITION valid
    NET_DOWNLOAD_CONDITION_INFO*    pConditionInfos;    // Download conditions,emDownloadType is EM_DOWNLOAD_BY_CONDITION valid      
														// the space application by the user,apply to sizeof(NET_DOWNLOAD_CONDITION_INFO)*nConditionCount 
}NET_IN_DOWNLOAD_MULTI_FILE;

typedef struct tagNET_OUT_DOWNLOAD_MULTI_FILE
{
	DWORD               dwSize;
	LLONG               lDownLoadHandle;                // Download the handle
}NET_OUT_DOWNLOAD_MULTI_FILE;

typedef struct __NET_VIDEOANALYSE_STATE
{
	DWORD              dwSize;
	DWORD              dwProgress;                   		// Analysis of progress, 0-100
	char               szState[DH_COMMON_STRING_64]; 		// Channel Status,Running":Run, "Stop":Stop, "NoStart":Not started, "Failed":failed , "Successed":successed
	char               szFailedCode[DH_COMMON_STRING_64]; 	// Error code
}NET_VIDEOANALYSE_STATE;

//Real-time video analysis progress status callbacks
typedef int (CALLBACK *fVideoAnalyseState)(LLONG lAttachHandle, NET_VIDEOANALYSE_STATE* pAnalyseStateInfos, LDWORD dwUser, void* pReserved);

// CLIENT_AttachVideoAnalyseState  Interface input parameters
typedef struct __NET_IN_ATTACH_VIDEOANALYSE_STATE 
{
	DWORD              dwSize;
	int                nChannleId;            // Channel number
	fVideoAnalyseState cbVideoAnalyseState;   // Video analysis status callback function
	LDWORD             dwUser;                // User Information
}NET_IN_ATTACH_VIDEOANALYSE_STATE;

// CLIENT_AttachVideoAnalyseState  Interface output parameters
typedef struct __NET_OUT_ATTACH_VIDEOANALYSE_STATE 
{
	DWORD              dwSize;
	LLONG              lAttachHandle;         // Analysis of the progress of the analysis progress handle that uniquely identifies a particular channel
}NET_OUT_ATTACH_VIDEOANALYSE_STATE;

// Bidirectional talk status 
typedef enum tagEM_TALK_STATE
{
    EM_TALK_STATE_UNKNOWN,                 // Unknown 
    EM_TALK_STATE_INVITING,                // Caller 
    EM_TALK_STATE_RINGING,                 // Callee
    EM_TALK_STATE_ANSWER,                  // Answer
    EM_TALK_STATE_REFUSE,                  // Refuse
    EM_TALK_STATE_HANGUP,                  // Hang up 
    EM_TALK_STATE_BUSYING,                 // Busy
    EM_TALK_STATE_CANCEL,                  // Cancel calling 
} EM_TALK_STATE;

#define NET_CALL_NUM_MAX           128         // Max communication No. amount 

// Bidirectional talk status of call function CLIENT_AttachTalkState
typedef struct tagNET_TALK_STATE
{
    DWORD                dwSize; 
    char                 szCallID[DH_COMMON_STRING_64];  // Call unique symbole
    int                  nAudioPort;                     // Audio port 
    int                  nVideoPort;                     // Video port 
	char                 szMediaAddr[DH_MAX_IPADDR_LEN]; // Getting stream address 
    EM_TALK_STATE        emState;                        // Status 
    int                  nNumberCount;                   // Call No. amount 
    char                 szNumbers[NET_CALL_NUM_MAX][DH_COMMON_STRING_32]; // Call No. list 
} NET_TALK_STATE;

// Call function of  CLIENT_AttachTalkState 
typedef void (CALLBACK *fNotifyTalkState)(LLONG lAttachHandle, NET_TALK_STATE* pstuState, int nLen, LDWORD dwUser);

// Input parameters of CLIENT_AttachTalkState 
typedef struct tagNET_IN_ATTACH_TALK_STATE
{
    DWORD                dwSize;                         // Structure size, must have a value 
    int                  nChnId;                         // Channel No. It is to mark bidirectional talk unit. 
    fNotifyTalkState     cbCallBack;                     // Call function. Call the upper-level when there is bidirectional talk in process. 
    LDWORD               dwUser;                         // Customized paramters 
}NET_IN_ATTACH_TALK_STATE;

// Output parameters of the CLIENT_AttachTalkState
typedef struct tagNET_OUT_ATTACH_TALK_STATE
{
    DWORD       dwSize;                                  // Structure size. Must have a value
    char        szCallID[DH_COMMON_STRING_64];           // Call unique mark 
}NET_OUT_ATTACH_TALK_STATE;

///////////////////////////////// IVS server video analysis module /////////////////////////////////
// Video analysis  report result detect type definition
#define NET_DIAGNOSIS_DITHER                    "VideoDitherDetection"                       // Video vibration detect  Corresponding structure body(NET_VIDEO_DITHER_DETECTIONRESULT)
#define NET_DIAGNOSIS_STRIATION                 "VideoStriationDetection"                    // Video stria detect  Corresponding structure body(NET_VIDEO_STRIATION_DETECTIONRESULT)
#define NET_DIAGNOSIS_LOSS                      "VideoLossDetection"                         // Video loss detect  Corresponding structure body(NET_VIDEO_LOSS_DETECTIONRESULT)
#define NET_DIAGNOSIS_COVER                     "VideoCoverDetection"                        // Camera masking detect Corresponding structure body(NET_VIDEO_COVER_DETECTIONRESULT)
#define NET_DIAGNOSIS_FROZEN                    "VideoFrozenDetection"                       // Video freeze detect Corresponding structure body(NET_VIDEO_FROZEN_DETECTIONRESULT)
#define NET_DIAGNOSIS_BRIGHTNESS                "VideoBrightnessDetection"                   // Video brightness abnormal detect Corresponding structure body(NET_VIDEO_BRIGHTNESS_DETECTIONRESULT)
#define NET_DIAGNOSIS_CONTRAST                  "VideoContrastDetection"                     // Video contrast abnormal detect  Corresponding structure body(NET_VIDEO_CONTRAST_DETECTIONRESULT)
#define NET_DIAGNOSIS_UNBALANCE                 "VideoUnbalanceDetection"                    // Video color cast detect Corresponding structure body(NET_VIDEO_UNBALANCE_DETECTIONRESULT)
#define NET_DIAGNOSIS_NOISE                     "VideoNoiseDetection"                        // Video noise detect Corresponding structure body(NET_VIDEO_NOISE_DETECTIONRESULT)
#define NET_DIAGNOSIS_BLUR                      "VideoBlurDetection"                         // Video blur detect Corresponding structure body(NET_VIDEO_BLUR_DETECTIONRESULT)
#define NET_DIAGNOSIS_SCENECHANGE               "VideoSceneChangeDetection"                  // Video scene change detect Corresponding structure body(NET_VIDEO_SCENECHANGE_DETECTIONRESULT)
#define NET_DIAGNOSIS_VIDEO_DELAY               "VideoDelay"                                 // Video Delay, Corresponding structure body(NET_VIDEO_DELAY_DETECTIONRESUL)
#define NET_DIAGNOSIS_PTZ_MOVING                "PTZMoving"                                  // PTZ Moving, Corresponding structure body(NET_PTZ_MOVING_DETECTIONRESULT)
#define NET_DIAGNOSIS_BLACK_WHITE				"VideoBlackAndWhite"						 // black and white image detection, Corresponding structure body(NET_BLACK_WHITE_DETECTIONRESULT)
#define NET_DIAGNOSIS_DRAMATIC_CHANGE			"VideoDramaticChange"						 // dramatic change of scene detection, Corresponding structure body(NET_DIAGNOSIS_DRAMATIC_DETECTIONRESULT)
#define NET_DIAGNOSIS_VIDEO_AVAILABILITY	    "VideoAvailability"						     // video availability detect Corresponding structure body(NET_VIDEO_AVAILABILITY_DETECTIONRESULT)


typedef enum tagNET_STATE_TYPE
{
	NET_EM_STATE_ERR,        // Others
	NET_EM_STATE_NORMAL,     // "Normal"  
	NET_EM_STATE_WARNING,    // "Warning" 
	NET_EM_STATE_ABNORMAL,   // "Abnormal" 
}NET_STATE_TYPE;
// Video diagnosis type
typedef enum tagNET_VIDEODIAGNOSIS_RESULT_TYPE
{
	NET_EM_ROTATION   ,					// "Rotation"	-Video analysis of polling
	NET_EM_REAL		  ,					// "Real" -Real-time video analysis
	NET_EM_NR_UNKNOW  ,					// Undefined
}NET_VIDEODIAGNOSIS_RESULT_TYPE;
//Video causes of diagnostic error
typedef enum tagNET_VIDEODIAGNOSIS_FAIL_TYPE
{
	NET_EM_NO_ERROR				 ,			// Diagnostic success
	NET_EM_DISCONNECT			 ,			// "Disconnect"				- End devices can be connected
	NET_EM_CH_NOT_EXIST			 ,			// "ChannelNotExist"		- Channel does not exist
	NET_EM_LOGIN_OVER_TIME		 ,			// "LoginOverTime"			- Login Timeout
	NET_EM_NO_VIDEO				 ,			// "NoVideo"				- No video successful login
	NET_EM_NO_RIGHT				 ,			// "NoRight"				- No operating authority
	NET_EM_PLATFROM_LOGIN_FAILED ,			// "PlatformLoginFailed"	- Login failed platform
	NET_EM_PLATFROM_DISCONNECT 	 ,			// "PlatformDisconnect"		- Disconnect platform
	NET_EM_GET_STREAM_OVER_TIME  ,			// "GetStreamOverTime"		- Get stream timeout
    NET_EM_GET_NO_ENOUGH_STREAM  ,          // "NoEnoughStream"         - no enought stream
    NET_EM_DECODE_STREAM_FAILED  ,          // "DecodeStreamFailed"     - decode stream failed
    NET_EM_GET_OFF_LINE          ,          // "OffLine"                - device offline
	NET_EM_NF_UNKNOW			 ,			// Other reasons, as detailed in the structure described in the reason for the failure 
    NET_EM_NOT_SD                ,          // "NotSD"                  - not SD device, PTZ detect invalid

    NET_EM_RTSP_PROCESS_FAILED,             //  "RtspProcesssFailed"    - The process of RTSP failed
    NET_EM_PLAY_FAILED,                     //  "PlayFailed"            - Play failed
    NET_EM_SNAP_FAILED,                     //  "SnapFailed"            - Snap failed
    NET_EM_FULL_CHANNEL_LINKS,              //  "FullChannelLinks"      - All channel link is full, whitch cause play failed
}NET_VIDEODIAGNOSIS_FAIL_TYPE;

// General long character ended with '\0'
typedef struct tagNET_ARRAY
{
	DWORD                dwSize;                         // Current structure body size 
	char*                pArray;                         // Buffer zone. Now the min value is 260 byte.Caller shall apply for the memory. The filling in data shall ended with '\0'.
	DWORD                dwArrayLen;                     // Buffer space length
}NET_ARRAY;

#define MAX_BACKPIC_COUNT	8	// max count of background pictures

// Video analysis result report general data
typedef struct tagNET_VIDEODIAGNOSIS_COMMON_INFO
{
	DWORD                dwSize;                         // Current structure body size 
	int                  nDiagnosisID;                   // Detect channel
	NET_ARRAY            stProject;                      // Project name
	NET_ARRAY            stTask;                         // Task name
	NET_ARRAY            stProfile;                      // Parameter list name
	NET_ARRAY            stDeviceID;                     // Device unique ID
	NET_TIME             stStartTime;                    // Start time
	NET_TIME             stEndTime;                      // End time
	int                  nVideoChannelID;                // Video channel No. The channel of the front-end device such as DVR,IPC.
	NET_STREAM_TYPE      emVideoStream;                  // Video bit stream
	NET_VIDEODIAGNOSIS_RESULT_TYPE	emResultType;					// Diagnosis type
	BOOL							bCollectivityState;             // Diagnostic results
	NET_VIDEODIAGNOSIS_FAIL_TYPE	emFailedCause;					// Reasons for failure
	char                            szFailedCode[DH_COMMON_STRING_64]; 		// Describe the reason for the failure
    char                            szResultAddress[DH_COMMON_STRING_128];  // Diagnosis result storage address,suggest use szResultAddressEx 
    int                             nFrameRate;                             // Frame Rate(kb/s)  update by day
    int                             nFrameWidth;                            // Frame Width       update by day
    int                             nFrameHeight;                           // Frame Height      update by day
	int								nBackPic;								// counts of background pictures
	char							szBackPicAddress[MAX_BACKPIC_COUNT][DH_COMMON_STRING_128];	// the address of these background pictures
	char                            szResultAddressEx[DH_COMMON_STRING_256];  // Diagnosis result storage address extension
}NET_VIDEODIAGNOSIS_COMMON_INFO;

// The result of detect type (NET_DIAGNOSIS_DITHER)  Video vibration detect -- Video change,wind or vibration,rotation including the PTZ movement.
typedef struct tagNET_VIDEO_DITHER_DETECTIONRESULT
{
	DWORD                dwSize;                         // Current structure body size 
	int                  nValue;                         // Detect result value 
	NET_STATE_TYPE       emState;                        // Detect result status  Usually smaller than is normal. Larger than is abnormal and the value in the middle is warning. 
	int                  nDuration;                      // Status lasts time  Detect item last time. It is null right now. 
}NET_VIDEO_DITHER_DETECTIONRESULT;

// The result of detect type (NET_DIAGNOSIS_STRIATION) Video stria detect  -- There is abnormal stria on the camera resulting from the interference.
typedef struct tagNET_VIDEO_STRIATION_DETECTIONRESULT
{
	DWORD                dwSize;                         // Current structure body size 
	int                  nValue;                         // Detect result value 
	NET_STATE_TYPE       emState;                        // Detect result status
	int                  nDuration;                      // Status lasts time
}NET_VIDEO_STRIATION_DETECTIONRESULT;

// The result of detect type (NET_DIAGNOSIS_LOSS) Video loss detect  -- Result from power failure or disconnection.
typedef struct tagNET_VIDEO_LOSS_DETECTIONRESULT
{
	DWORD                dwSize;                         // Current structure body size 
	NET_STATE_TYPE       emState;                        // Detect result status
	int                  nDuration;                      // Status lasts time
}NET_VIDEO_LOSS_DETECTIONRESULT;

// The result of detect type (NET_DIAGNOSIS_COVER) Camera masking detect -- The camera masking occurred
typedef struct tagNET_VIDEO_COVER_DETECTIONRESULT
{
	DWORD                dwSize;                         // Current structure body size 
	int                  nValue;                         // Detect result value 
	NET_STATE_TYPE       emState;                        // Detect result status
	int                  nDuration;                      // Status lasts time
}NET_VIDEO_COVER_DETECTIONRESULT;

// The result of detect type (NET_DIAGNOSIS_FROZEN) Video freeze detect -- The video idles for specified time is regarded as freeze.
typedef struct tagNET_VIDEO_FROZEN_DETECTIONRESULT
{
	DWORD                dwSize;                         // Current structure body size 
	NET_STATE_TYPE       emState;                        // Detect result status
	int                  nDuration;                      // Status lasts time
}NET_VIDEO_FROZEN_DETECTIONRESULT;

// The result of detect type (NET_DIAGNOSIS_BRIGHTNESS) Video brightness abnormal detect --The following contents are some camera improper setup detect.
typedef struct tagNET_VIDEO_BRIGHTNESS_DETECTIONRESULT
{
	DWORD                dwSize;                         // Current structure body size 
	int                  nValue;                         // Detect result value 
	NET_STATE_TYPE       emState;                        // Detect result status
	int                  nDuration;                      // Status lasts time
}NET_VIDEO_BRIGHTNESS_DETECTIONRESULT;

// The result of detect type (NET_DIAGNOSIS_CONTRAST) Video contrast abnormal detect
typedef struct tagNET_VIDEO_CONTRAST_DETECTIONRESULT
{
	DWORD                dwSize;                         // Current structure body size 
	int                  nValue;                         // Detect result value 
	NET_STATE_TYPE       emState;                        // Detect result status
	int                  nDuration;                      // Status lasts time
}NET_VIDEO_CONTRAST_DETECTIONRESULT;

// The result of detect type (NET_DIAGNOSIS_UNBALANCE) Video color cast detect
typedef struct tagNET_VIDEO_UNBALANCE_DETECTIONRESULT
{
	DWORD                dwSize;                         // Current structure body size 
	int                  nValue;                         // Detect result value 
	NET_STATE_TYPE       emState;                        // Detect result status
	int                  nDuration;                      // Status lasts time
}NET_VIDEO_UNBALANCE_DETECTIONRESULT;

// The result of detect type (NET_DIAGNOSIS_NOISE) Video noise detect
typedef struct tagNET_VIDEO_NOISE_DETECTIONRESULT
{
	DWORD                dwSize;                         // Current structure body size 
	int                  nValue;                         // Detect result value 
	NET_STATE_TYPE       emState;                        // Detect result status
	int                  nDuration;                      // Status lasts time
}NET_VIDEO_NOISE_DETECTIONRESULT;

// The result of detect type (NET_DIAGNOSIS_BLUR) Video blur detect
typedef struct tagNET_VIDEO_BLUR_DETECTIONRESULT
{
	DWORD                dwSize;                         // Current structure body size 
	int                  nValue;                         // Detect result value 
	NET_STATE_TYPE       emState;                        // Detect result status
	int                  nDuration;                      // Status lasts time
}NET_VIDEO_BLUR_DETECTIONRESULT;

// The result of detect type (NET_DIAGNOSIS_SCENECHANGE) Video scene change detect
typedef struct tagNET_VIDEO_SCENECHANGE_DETECTIONRESULT
{
	DWORD                dwSize;                         // Current structure body size 
	int                  nValue;                         // Detect result value 
	NET_STATE_TYPE       emState;                        // Detect result status
	int                  nDuration;                      // Status lasts time
}NET_VIDEO_SCENECHANGE_DETECTIONRESULT;

//  PTZ moving result type        
typedef enum tagEM_PTZ_MOVING_RESULT_TYPE  
{          
    EM_PTZ_MOVING_UNKNOWN ,      // unknown       
    EM_PTZ_MOVING_NORMAL  ,      // normal       
    EM_PTZ_MOVING_NOTOBEY ,      // not tobey       
    EM_PTZ_MOVING_NOTMOVE ,      // not move       
    EM_PTZ_MOVING_NOTDETECT ,    // not detect       
}EM_PTZ_MOVING_RESULT_TYPE; 

// The result of detect type (NET_DIAGNOSIS_PTZ_MOVING) PTZ moving detect
typedef struct tagNET_PTZ_MOVING_DETECTIONRESULT
{
    DWORD                       dwSize;                 // Current structure body size 
    EM_PTZ_MOVING_RESULT_TYPE   emPTZMovingUp;          // moving up detect result 
    EM_PTZ_MOVING_RESULT_TYPE   emPTZMovingDown;        // moving down detect result 
    EM_PTZ_MOVING_RESULT_TYPE   emPTZMovingLeft;        // moving left detect result 
    EM_PTZ_MOVING_RESULT_TYPE   emPTZMovingRight;       // moving right detect result 
    EM_PTZ_MOVING_RESULT_TYPE   emPTZMovingZoomWide;    // moving zoom wide detect result 
    EM_PTZ_MOVING_RESULT_TYPE   emPTZMovingZoomTele;    // moving zoom tele detect result     
}NET_PTZ_MOVING_DETECTIONRESULT;

// The result of detect type(NET_DIAGNOSIS_BLACK_WHITE)  black and white image detection
typedef struct tagNET_BLACK_WHITE_DETECTIONRESULT
{
	DWORD                dwSize;                 // Current structure body size 
	int                  nValue;                 // Detect result value 
    NET_STATE_TYPE       emState;                // Detect result status
    int                  nDuration;              // Status lasts time
} NET_BLACK_WHITE_DETECTIONRESULT;

// The result of detect type(NET_DIAGNOSIS_DRAMATIC_CHANGE) dramatic change of scene
typedef struct tagNET_DIAGNOSIS_DRAMATIC_DETECTIONRESULT
{
	DWORD                dwSize;                 // Current structure body size 
	int                  nValue;                 // Detect result value 
    NET_STATE_TYPE       emState;                // Detect result status
    int                  nDuration;              // Status lasts time
} NET_DIAGNOSIS_DRAMATIC_DETECTIONRESULT;


// The result of detect type(NET_DIAGNOSIS_VIDEO_DELAY)video delay detect
typedef struct tagNET_VIDEO_DELAY_DETECTIONRESUL
{
    DWORD       dwSize;             // Current structure body size 
    int         nSignalDelay;       // single delay(-1 mean detect failed),  unit ms
    int         nStreamDelay;       // video stream delay(-1 mean detect failed), unit ms
    int         nIFrameDelay;       // IFrame delay(-1 mean detect failed), unit ms
}NET_VIDEO_DELAY_DETECTIONRESUL;

typedef struct tagNET_DIAGNOSIS_RESULT_HEADER
{
	DWORD                dwSize;                         // Current structure body size 
	
	char                 szDiagnosisType[MAX_PATH];      // Analysis type. Please refer to dhnetsdk.h for "video analysis report result type definition"  such as NET_DIAGNOSIS_DITHER
	int                  nDiagnosisTypeLen;              // The structure body size of current analysis type
}NET_DIAGNOSIS_RESULT_HEADER;

// cbVideoDiagnosis Call parameter type
typedef struct tagNET_REAL_DIAGNOSIS_RESULT
{
	DWORD                dwSize;                         // Current structure body size 
	
    NET_VIDEODIAGNOSIS_COMMON_INFO* pstDiagnosisCommonInfo;  //Video analysisi general info
	
	int					 nTypeCount;					 // Analysis result data analysis type amount
	void*                pDiagnosisResult;               // The analysis result data for once. The format is as NET_DIAGNOSIS_RESULT_HEADER+analysis type1+NET_DIAGNOSIS_RESULT_HEADER+analysis type 2+...
	DWORD                dwBufSize;                      // Buffer length
}NET_REAL_DIAGNOSIS_RESULT;

// Video analysis result report call function
typedef int (CALLBACK *fRealVideoDiagnosis)(LLONG lDiagnosisHandle, NET_REAL_DIAGNOSIS_RESULT* pDiagnosisInfo, void* pBuf, int nBufLen, LDWORD dwUser);

//The input parameter of interface  CLIENT_StartVideoDiagnosis
typedef struct tagNET_IN_VIDEODIAGNOSIS
{
	DWORD                dwSize;                         // Current structure body size 
	int                  nDiagnosisID;                   // Video analysis ID begins with 0
	DWORD                dwWaitTime;                     // Interface time out waiting time
	
	fRealVideoDiagnosis  cbVideoDiagnosis;               // Video analysis result call function.
	LDWORD                dwUser;                        // User customized parameter
}NET_IN_VIDEODIAGNOSIS;

// The output parameter of interface CLIENT_StartVideoDiagnosis 
typedef struct tagNET_OUT_ATTACH_REALDIAGNOSIS
{
	DWORD                dwSize;                         // Current structure body size 
	LLONG                 lDiagnosisHandle;              // Subscribe handle
}NET_OUT_VIDEODIAGNOSIS;

// The input parameter of interface CLIENT_StartFindDiagnosisResult 
typedef struct tagNET_IN_FIND_DIAGNOSIS
{
	DWORD                dwSize;                         // Current structure body size 
	int                  nDiagnosisID;                   // Video analysis ID begins with 0
	DWORD                dwWaitTime;                     // Interface time out waiting time
	
	NET_ARRAY            stuDeviceID;                    // Device unique ID.pArray:NULL means does not search by device ID.
	NET_TIME             stuStartTime;                   // Start time
	NET_TIME             stuEndTime;                     // End time
	int                  nVideoChannel;                  // Video channel No.,-1: All channel No.
	int                  nTypeCount;                     // Analysis type amount.0:Do not use analysis type to search.
	NET_ARRAY*           pstDiagnosisTypes;              // Analysis type array. It is the analysis type to be searched. 
														 // the space application by the user,apply to sizeof(NET_ARRAY)*nTypeCount
	char                 szProjectName[MAX_PATH];        // Project name
} NET_IN_FIND_DIAGNOSIS;

// The output parameter of interface CLIENT_StartFindDiagnosisResult
typedef struct tagNET_OUT_FIND_DIAGNOSIS
{
	DWORD                dwSize;                         // Current structure body size 
	LLONG                 lFindHandle;                   // Search handle
	DWORD                dwTotalCount;                   // The total amount that matched the criteria
}NET_OUT_FIND_DIAGNOSIS;

// The input parameter of interface CLIENT_DoFindDiagnosisResult 
typedef struct tagNET_IN_DIAGNOSIS_INFO
{
	DWORD                dwSize;                         // Current structure body size 
	int                  nDiagnosisID;                   // Video analysis ID begins with 0
	DWORD                dwWaitTime;                     // Interface time out waiting time
	
	int                  nFindCount;                     // The video analysis result amount of each search
	int                  nBeginNumber;                   // Search initial SN 0<=beginNumber<= totalCount-1
}NET_IN_DIAGNOSIS_INFO;

// CLIENT_StartRealTimeProject Interface input parameters
typedef struct tagNET_IN_START_RT_PROJECT_INFO
{
	DWORD                dwSize;                         // This structure size
	char*                pszProjectInfo;                 // Real-time schedule information by calling dhconfigsdk.dll get the package in the interface CLIENT_PacketData
                            	                         // Package command corresponding CFG_CMD_VIDEODIAGNOSIS_REALPROJECT                      
}NET_IN_START_RT_PROJECT_INFO;

// CLIENT_StartRealTimeProject Interface output parameters
typedef struct tagNET_OUT_START_RT_PROJECT_INFO
{
	DWORD                dwSize;                         // This structure size
}NET_OUT_START_RT_PROJECT_INFO;

// CLIENT_UpdateProjectBackGround Interface input parameters
typedef struct tagNET_IN_UPDATE_PROJECT_BCKGROUND_INFO
{
    DWORD                dwSize;                         // This structure size
    char                 szProjectName[MAX_PATH];        // project nameupdate the background of all projects if the name is ""
    char                 szTaskName[MAX_PATH];           // task nameupdate the background of all tasks if the name is ""
    char                 szDeviceID[MAX_PATH];           // device idupdate the background of all devices if the name is ""
    int                  nChannelID;                     // channel idupdate the background of all the channels on this device if the value is -1
} NET_IN_UPDATE_PROJECT_BACKGROUND_INFO;

// CLIENT_UpdateProjectBackGround Interface output parameters
typedef struct tagNET_OUT_UPDATE_PROJECT_BACKGROUND_INFO
{
    DWORD                dwSize;                         // This structure size
} NET_OUT_UPDATE_PROJECT_BACKGROUND_INFO;


// CLIENT_StopRealTimeProject Interface output parameters
typedef struct tagNET_IN_STOP_RT_PROJECT_INFO
{
	DWORD                dwSize;                         // This structure size
	char*                 pszProjectNames;               // Program name to the name of the separator && as the example:Project1&&Project2   
}NET_IN_STOP_RT_PROJECT_INFO; 

// CLIENT_StopRealTimeProject Interface output parameters
typedef struct tagNET_OUT_STOP_RT_PROJECT_INFO
{
	DWORD                dwSize;                         // This structure size
}NET_OUT_STOP_RT_PROJECT_INFO;

#define MAX_VIDEODIAGNOSIS_PROJECT_NAME_LEN    260     // Max length of video diagnosis project name
#define MAX_VIDEODIAGNOSIS_TASK_NAME_LEN       260     // Max length of video diagnosis task name

// Input parameter of CLIENT_StartManualDiagnosisProject
typedef struct tagNET_IN_START_MANUAL_PROJECT_INFO
{
    DWORD               dwSize;                                                 // Struct size
    char                szProjectName[MAX_VIDEODIAGNOSIS_PROJECT_NAME_LEN];     // Diagnosis project name
    NET_TIME            stuStartTime;                                           // Start time of diagnosis project
    BOOL                bIsCycle;                                               // Whether to circulate
    char                szTaskName[MAX_VIDEODIAGNOSIS_TASK_NAME_LEN];           // Diagnosis task name
} NET_IN_START_MANUAL_PROJECT_INFO;

// Output parameter of CLIENT_StartManualDiagnosisProject
typedef struct tagNET_OUT_START_MANUAL_PROJECT_INFO
{
    DWORD                dwSize;                                // Struct size
} NET_OUT_START_MANUAL_PROJECT_INFO;

// Input parameter of CLIENT_StopManualDiagnosisProject
typedef struct tagNET_IN_STOP_MANUAL_PROJECT_INFO
{
    DWORD               dwSize;                                                 // Struct size
    char                szProjectName[MAX_VIDEODIAGNOSIS_PROJECT_NAME_LEN];    // Diagnosis project name
} NET_IN_STOP_MANUAL_PROJECT_INFO;

// Output parameter of CLIENT_StopManualDiagnosisProject
typedef struct tagNET_OUT_STOP_MANUAL_PROJECT_INFO
{
    DWORD               dwSize;                                 // Struct size
} NET_OUT_STOP_MANUAL_PROJECT_INFO;

// carport light info
typedef struct tagNET_CARPORTLIGHT_INFO
{
	DWORD               dwSize;  
	NET_CARPORTLIGHT_TYPE emType;                        // carport type
	NET_CARPORTLIGHT_MODE emMode;                        // light way
}NET_CARPORTLIGHT_INFO;

// carpor light status
typedef struct tagNET_CARPORTLIGHT_STATUS
{
	DWORD                dwSize;                         		// struct size 
	int                  nLightNum;                      		// light num
	NET_CARPORTLIGHT_INFO stuLights[DH_MAX_CARPORTLIGHT_NUM]; 	// light info,don't repeat
	int                  nFiringTime;                    		// firing time(s)
	int                  nHoldTime;                      		// hold time(s), -1 means keep,0 auto control
}NET_CARPORTLIGHT_STATUS;

// CLIENT_GetCarPortLightStatus's interface input
typedef struct tagNET_IN_GET_CARPORTLIGHT_STATUS
{
	DWORD                dwSize;                         // struct size 
	int                  nChannelId;                     // channel ID
}NET_IN_GET_CARPORTLIGHT_STATUS;

// CLIENT_GetCarPortLightStatus's interface output
typedef struct tagNET_OUT_GET_CARPORTLIGHT_STATUS
{
	DWORD                dwSize;                         // struct size 
	NET_CARPORTLIGHT_STATUS stuLightStatus;              // light status
}NET_OUT_GET_CARPORTLIGHT_STATUS;

// CLIENT_SetCarPortLightStatus's interface input
typedef struct tagNET_IN_SET_CARPORTLIGHT_STATUS
{
	DWORD                dwSize;                         // struct size 
	int                  nChannelId;
	NET_CARPORTLIGHT_STATUS stuLightStatus;              // light status
}NET_IN_SET_CARPORTLIGHT_STATUS;

// CLIENT_SetCarPortLightStatus's interface output
typedef struct tagNET_OUT_SET_CARPORTLIGHT_STATUS
{
	DWORD                dwSize;                         // struct size 
	
}NET_OUT_SET_CARPORTLIGHT_STATUS;

// Video Availability detect result
typedef struct tagNET_VIDEO_AVAILABILITY_DETECTIONRESULT
{
	DWORD                dwSize;									// struct size
	int					 nSignalDelay;								// signal delay,-1 indicates monitoring failure, unit:ms
	int                  nStreamDelay;								// stream delay,-1 indicates monitoring failure, unit:ms
	int                  nIFrameDelay;								// I frame delay,-1 indicates monitoring failure, unit:ms
}NET_VIDEO_AVAILABILITY_DETECTIONRESULT;

typedef struct tagNET_DEV_VIDEODIAGNOSIS_MULTI_INFO
{
	DWORD                					dwSize;                	// Current structure body size 
	
    NET_VIDEODIAGNOSIS_COMMON_INFO*         pstDiagnosisCommonInfo; // Video analysis general info. You need to allocate the following pointer of the structure body.
	
	BOOL                 					abDither;				// It is to stand for current analysis item is valid or not in this result.
	NET_VIDEO_DITHER_DETECTIONRESULT*       pstDither;  			// Video vibration detect
	
	BOOL                 					abStration;
	NET_VIDEO_STRIATION_DETECTIONRESULT*    pstStration;			// Video stria detect
	
	BOOL                 					abLoss;
	NET_VIDEO_LOSS_DETECTIONRESULT*         pstLoss;    			// Video loss detect 
	
	BOOL                 					abCover;
	NET_VIDEO_COVER_DETECTIONRESULT*        pstCover;   			// Camera masking detect
	
	BOOL                 					abFrozen;
	NET_VIDEO_FROZEN_DETECTIONRESULT*       pstFrozen;  			// Video freeze detect
	
	BOOL                 					abBrightness;
	NET_VIDEO_BRIGHTNESS_DETECTIONRESULT*   pstBrightness;			// Video brightness abnormal detect 
	
	BOOL                 					abContrast;
	NET_VIDEO_CONTRAST_DETECTIONRESULT*     pstContrast;			// Video contrast abnormal detect 
	
	BOOL                 					abUnbalance;
	NET_VIDEO_UNBALANCE_DETECTIONRESULT*    pstUnbalance;			// Video color cast detect
	
	BOOL                 					abNoise;
	NET_VIDEO_NOISE_DETECTIONRESULT*        pstNoise;   			// Video noise detect 
	
	BOOL                 					abBlur;
	NET_VIDEO_BLUR_DETECTIONRESULT*         pstBlur;    			// Video blur detect
	
	BOOL                 					abSceneChange;
	NET_VIDEO_SCENECHANGE_DETECTIONRESULT*  pstSceneChange;			// Video scene change detect 

    BOOL                 					abVideoDelay;
    NET_VIDEO_DELAY_DETECTIONRESUL*       	pstVideoDelay;        	// Video delay detect

    BOOL                					abPTZMoving;
    NET_PTZ_MOVING_DETECTIONRESULT*       	pstPTZMoving;         	// PTZ moving detect
    
    BOOL									abBlackAndWhite;
	NET_BLACK_WHITE_DETECTIONRESULT*	  	pstBlackAndWhite;		// black and white image detect
	
	BOOL									abDramaticChange;
	NET_DIAGNOSIS_DRAMATIC_DETECTIONRESULT* pstDramaticChange;		// dramatic change of scene detect

	BOOL									abVideoAvailability;    // whether support video availability detect
	NET_VIDEO_AVAILABILITY_DETECTIONRESULT* pstVideoAvailability;	// Video Availability detect result
}NET_VIDEODIAGNOSIS_RESULT_INFO;

// The output parameter of interface CLIENT_DoFindDiagnosisResult
typedef struct tagNET_OUT_DIAGNOSIS_INFO
{
	DWORD                dwSize;                         // Current structure body size 
	
	int                  nInputNum;                      // The amount of the NET_DEV_RESULT_VIDEODIAGNOSIS_INFO you allocate
	int                  nReturnNum;                     // Returned amount
	NET_VIDEODIAGNOSIS_RESULT_INFO*  pstDiagnosisResult; // Result data You need to allocate the pointer of the structure body
														 // apply to sizeof(NET_VIDEODIAGNOSIS_RESULT_INFO)*nInputNum
}NET_OUT_DIAGNOSIS_INFO;

///////////////////////////////// master-slave device control module////////////////////////////
///////////////////////////////// CLIENT_OperateMasterSlaveDevice /////////////////////////////////
#define        MASTERSLAVE_CMD_START                   "masterSlaveTracker.start"                   // start
#define        MASTERSLAVE_CMD_STOP                    "masterSlaveTracker.stop"                    // stop
#define        MASTERSLAVE_CMD_MANUALTRACK             "masterSlaveTracker.manualSelectObjectTrack" // manual select object
#define        MASTERSLAVE_CMD_POINTTRACK              "masterSlaveTracker.selectPointTrack"        // points tracking
#define        MASTERSLAVE_CMD_GETCALIBPOINTS          "masterSlaveTracker.getCalibratePoints"      // get calibrate points
#define        MASTERSLAVE_CMD_CALIBRATE               "masterSlaveTracker.calibrate"               // save calibrate points
#define        MASTERSLAVE_CMD_ADDCALIBPOINT           "masterSlaveTracker.addCalibratePoint"       // add calibrate points
#define        MASTERSLAVE_CMD_REMOVECALIBPOINT        "masterSlaveTracker.removeCalibratePoint"    // remove calibrate points
#define        MASTERSLAVE_CMD_MARKMAXZOOM             "masterSlaveTracker.markSceneMaxZoom"        // mark scene max zoom

// master-slave device pair points
typedef struct __NET_MS_PAIRPOINTS
{
	int                nStructSize;
    DH_POINT           stMasterPoint;    // master point,range[0,8192]
    DH_POINT           stSlavePoint;     // slave point,range[0,8192]
}NET_MS_PAIRPOINTS;
//MASTERSLAVE_CMD_START
typedef struct __NET_IN_MS_START
{
	int                nStructSize;
}NET_IN_MS_START;

//MASTERSLAVE_CMD_START
typedef struct __NET_OUT_MS_START
{
	int                nStructSize;
}NET_OUT_MS_START;

//MASTERSLAVE_CMD_STOP
typedef struct __NET_IN_MS_STOP
{
	int                nStructSize;
}NET_IN_MS_STOP;

//MASTERSLAVE_CMD_STOP
typedef struct __NET_OUT_MS_STOP
{
	int                nStructSize;
}NET_OUT_MS_STOP;

//MASTERSLAVE_CMD_MANUALTRACK
typedef struct __NET_IN_MS_MANUALTRACK
{
	int                nStructSize;
	DWORD              dwObject;          // -1 any position of the entire region, >=0 specify the object(can be obtained from the device to return to intelligent frame)
}NET_IN_MS_MANUALTRACK;

//MASTERSLAVE_CMD_MANUALTRACK
typedef struct __NET_OUT_MS_MANUALTRACK
{
	int                nStructSize;
}NET_OUT_MS_MANUALTRACK;

//MASTERSLAVE_CMD_POINTTRACK
typedef struct __NET_IN_MS_POINTTRACK
{
	int                nStructSize;
	DH_POINT           stTrackerPoint;    // Tracker point,range[0,8192]
}NET_IN_MS_POINTTRACK;

//MASTERSLAVE_CMD_POINTTRACK
typedef struct __NET_OUT_MS_POINTTRACK
{
	int                nStructSize;
}NET_OUT_MS_POINTTRACK;

//MASTERSLAVE_CMD_GETCALIBPOINTS
typedef struct __NET_IN_MS_GETCALIBPOINTS
{
	int                nStructSize;
}NET_IN_MS_GETCALIBPOINTS;

//MASTERSLAVE_CMD_GETCALIBPOINTS
typedef struct __NET_OUT_MS_GETCALIBPOINTS
{
	int                        nStructSize;
	int                        nPointsNum;                           // practicality points num
	NET_MS_PAIRPOINTS          stPairPoints[MAX_CALIBPOINTS_NUM];    // pair points
}NET_OUT_MS_GETCALIBPOINTS;

//MASTERSLAVE_CMD_CALIBRATE
typedef struct __NET_IN_MS_CALIBRATE
{
	int                nStructSize;
}NET_IN_MS_CALIBRATE;

//MASTERSLAVE_CMD_CALIBRATE
typedef struct __NET_OUT_MS_CALIBRATE
{
	int                nStructSize;      
}NET_OUT_MS_CALIBRATE;

//MASTERSLAVE_CMD_ADDCALIBPOINT
typedef struct __NET_IN_MS_ADDCALIBPOINT
{
	int                        nStructSize;
	BOOL                       bSlavePointEn;        // enable, TURE able;FASLE disable
	NET_MS_PAIRPOINTS          stPairPoints;         // master-slave camera pair point
}NET_IN_MS_ADDCALIBPOINT;

//MASTERSLAVE_CMD_ADDCALIBPOINT
typedef struct __NET_OUT_MS_ADDCALIBPOINT
{
	int                nStructSize;
	DH_POINT           stPoint;      // slave point
}NET_OUT_MS_ADDCALIBPOINT;


//MASTERSLAVE_CMD_REMOVECALIBPOINT
typedef struct __NET_IN_MS_REMOVECALIBPOINT
{
	int                nStructSize;
	DH_POINT           stPoint;      // master point
}NET_IN_MS_REMOVECALIBPOINT;

//MASTERSLAVE_CMD_REMOVECALIBPOINT
typedef struct __NET_OUT_MS_REMOVECALIBPOINT
{
	int                nStructSize;      
}NET_OUT_MS_REMOVECALIBPOINT;

//MASTERSLAVE_CMD_MARKMAXZOOM
typedef struct __NET_IN_MS_MARKMAXZOOM
{
	int                nStructSize; 
}NET_IN_MS_MARKMAXZOOM;

//MASTERSLAVE_CMD_MARKMAXZOOM
typedef struct __NET_OUT_MS_MARKMAXZOOM
{
	int                nStructSize; 
}NET_OUT_MS_MARKMAXZOOM;

///////////////////////////////// CLIENT_OperateCommDevice Interface parameters defined /////////////////////////////////
#define		COMMDEV_GET_EXTERNLDATA							"devComm.getExternalData"		//get serial external data for 3rd party general data

#define        MAX_EXTERN_DATA_LEN                2048

//COMMDEV_GET_EXTERNLDATA Input parameters
typedef struct __COMMDEV_IN_GET_EXTERNDATA
{
    DWORD        dwSize;

}COMMDEV_IN_GET_EXTERNDATA;

//COMMDEV_GET_EXTERNLDATA Output parameters
typedef struct __COMMDEV_OUT_GET_EXTERNDATA
{
	DWORD		dwSize;
	char		szGetData[MAX_EXTERN_DATA_LEN];				//External serial devices to collect data (data format based on custom projects)
}COMMDEV_OUT_GET_EXTERNDATA;


/////////////////////////////////CLIENT_OperateVideoAnalyseDevice Interface parameter /////////////////////////////////
#define     NET_SET_MODULESTATE                         "devVideoAnalyse.setModuleState"                        // Set module status
#define		NET_TEST_WITH_SCREENPOINTS					"devVideoAnalyse.testCalibrateWithScreenPoints"			// Detect depth of the field according to the coordinates on the screen. It is the actual distance between these two points. Please complete the parameter setup before you test.
#define		NET_TEST_WITH_METRICLENGTH					"devVideoAnalyse.testCalibrateWithMetricLength"		    // Detect parameter of depth of the field according to actual lenght,start point,and direction coordinates.
#define		NET_GET_INTERNALOPTIONS						"devVideoAnalyse.getInternalOptions"					// Get internal option
#define		NET_TUNE_INTERNALOPTIONS					"devVideoAnalyse.tuneInternalOptions"					// Debug internal item
#define		NET_RESET_INTERNALOPTIONS					"devVideoAnalyse.resetInternalOptions"					// Reset all debug internal item
#define     NET_SET_PTZ_PRESET_STATUS                   "devVideoAnalyse.setPtzPresetStatus"                    // get preset info

// Line type
typedef enum tagNET_EM_LINETYPE
{
	NET_EM_HORIZONTAL,
	NET_EM_VERTICAL,
}NET_EM_LINETYPE;

// PTZ preset status type
typedef enum tagEM_DH_PTZ_PRESET_STATUS
{
    EM_DH_PTZ_PRESET_STATUS_UNKNOWN,        // unknown
    EM_DH_PTZ_PRESET_STATUS_REACH,          // preset reach the point
    EM_DH_PTZ_PRESET_STATUS_UNREACH,        // preset do not reach the point yet
}EM_DH_PTZ_PRESET_STATUS;

//PTZ positioning information alarm
typedef struct
{
	int     nChannelID;             // Channel number
	int     nPTZPan;                // Horizontal movement of the head position, effective range: [0,3600]
	int     nPTZTilt;               // PTZ vertical position, the effective range: [-1800,1800]
	int     nPTZZoom;               // PTZ iris position changes, effective range: [0,128]
	BYTE    bState;                 // PTZ motion, 0 - Unknown 1 - Movement 2 - Idle
	BYTE    bAction;                // PTZ movement, 255- unknown,0 - preset ,1 - line scan, 2 - Cruise, 3 - patrol track, 4 - horizontal rotation,5 -GeneralMove,6-PatternRecord,7-WideViewScan
                                    // ,8-HeatMap,9-AbsoluteMove,10-CheckDeviceOffset,11-IntelliConfigure12-Restart
	BYTE    bFocusState;            // PTZ focus state, 0 - unknown 1 - state of motion 2 - Idle
	BYTE    bEffectiveInTimeSection; //In the period of validity of the preset state
									 //If the current is preset reported preset period of time, compared with one, otherwise 0
	int     nPtzActionID;           // Cruise ID number
	DWORD   dwPresetID;             // PTZ preset number where
	float   fFocusPosition;         // Focus position
	BYTE	bZoomState;				// ZOOM PTZ status, 0 - Unknown,1-ZOOM, 2 - Idle
	BYTE	bReserved[3];			// Alignment
	DWORD   dwSequence;             // Packet sequence number, used to verify whether the loss
	DWORD   dwUTC;                  // Corresponding UTC (1970-1-1 00:00:00) seconds.
    EM_DH_PTZ_PRESET_STATUS emPresetStatus; // preset status
	int	    nZoomValue;			    // real zoom value ,expanded 100 times
	int     reserved[244];          // Reserved field
}DH_PTZ_LOCATION_INFO;

// NET_SET_PTZ_PRESET_STATUS
typedef struct __NET_IN_PTZ_PRESET_STATUS
{
    DWORD                    dwSize;
    DH_PTZ_LOCATION_INFO     stPTZStatus;
}NET_IN_PTZ_PRESET_STATUS;

typedef struct __NET_OUT_PTZ_PRESET_STATUS
{
    DWORD    dwSize;
}NET_OUT_PTZ_PRESET_STATUS;

// NET_TEST_WITH_SCREENPOINTS
typedef struct __NET_IN_CALIBRATE_BY_POINTS
{
	DWORD               dwSize;                 // Current structure body size 
	DH_POINT            stStartPoint;           // Start point of the line 	 The point of the line is within [0,8191].
	DH_POINT            stEndPoint;             // End point 	The point of the line is within [0,8191]
	NET_EM_LINETYPE     emType;                 // Line type	em_Horizontal("Horizontal")  em_Vertical("Vertical")
}NET_IN_CALIBRATE_BY_POINTS;

typedef struct __NET_OUT_CALIBRATE_BY_POINTS
{
	DWORD               dwSize;                 // Current structure body size 	
	double              dlength;                // The actual length between these two points. Unit is meter.
}NET_OUT_CALIBRATE_BY_POINTS;

// NET_TEST_WITH_METRICLENGTH
typedef struct __NET_IN_CALIBRATE_BY_LENGTH
{
	DWORD               dwSize;                 // Current structure body size 
	double				nLength;				// The actual length between these two points. Unit is meter.
	DH_POINT			stStartPoint;			// Start point of the line	The point of the line is within [0,8191]
	DH_POINT			stDirection;			// Line direction coordinates	For vertical line ony. The point of the line is within [0,8191]
	NET_EM_LINETYPE		emType;					// Line type	em_Horizontal("Horizontal")  em_Vertical("Vertical")				
}NET_IN_CALIBRATE_BY_LENGTH;

typedef struct __NET_OUT_CALIBRATE_BY_LENGTH
{
	DWORD               dwSize;                 // Current structure body size 
	DH_POINT			stEndPoint;				// Coordinates of the end of the line on the screen. 	The point of the line is within[0,8191]	
}NET_OUT_CALIBRATE_BY_LENGTH;

typedef struct __NET_INTERNAL_OPTION
{
	DWORD               dwSize;                 // Current structure body size 
	int					nIndex;					// Item SN
	NET_ARRAY           stKey;				    // Option name. 256 bytes including'\0'. Encryption data
	int					nValue;					// Option value
	int					nMinValue;				// Min value
	int					nMaxValue;				// Max value
}NET_INTERNAL_OPTION;

// Debug internal option NET_GET_INTERNALOPTIONS
typedef struct __NET_IN_GETINTERNAL_OPTIONS
{
	DWORD               dwSize;                 // Current structure body size
}NET_IN_GETINTERNAL_OPTIONS;

typedef struct __NET_OUT_GETINTERNAL_OPTIONS
{
	DWORD               dwSize;                 // Current structure body size 
	
	int					nTotalOptionNum;		// Option amount. Max value search capability.
	int					nReturnOptionNum;		// returned actual option amount.
	NET_INTERNAL_OPTION* pstInternalOption;	    // Option list. Caller shall allocate the address.
												// apply to sizeof(NET_INTERNAL_OPTION)*nTotalOptionNum
}NET_OUT_GETINTERNAL_OPTIONS;

// NET_TUNE_INTERNALOPTIONS
typedef struct __NET_IN_TUNEINTERNAL_OPTION
{
	DWORD               dwSize;                 // Current structure body size 
	int					nOptionCount;	    	// Option amount
	NET_INTERNAL_OPTION* pstInternalOption;	    // Option list. The amount stands for the capability.
												// the space appliacation by th user, apply to sizeof(NET_INTERNAL_OPTION)*nOptionCount
}NET_IN_TUNEINTERNAL_OPTION;

typedef struct __NET_OUT_TUNEINTERNAL_OPTION
{
	DWORD               dwSize;                 // Current structure body size 
}NET_OUT_TUNEINTERNAL_OPTION;

// NET_RESET_INTERNALOPTIONS
typedef struct __NET_IN_RESETINTERNAL_OPTION
{
	DWORD               dwSize;                 // Current structure body size 
}NET_IN_RESETINTERNAL_OPTION;

typedef struct __NET_OUT_RESETINTERNAL_OPTION
{
	DWORD               dwSize;                 // Current structure body size 
}NET_OUT_RESETINTERNAL_OPTION;

// NET_SET_MODULESTATE
typedef enum tagNET_EM_MODULESTATE
{
	NET_EM_MODULESTATE_OK,
	NET_EM_MODULESTATE_PAUSE,
}NET_EM_MODULESTATE;
typedef struct __NET_IN_SETMODULESTATE
{
	DWORD				dwSize;					// Current structure body size 
	NET_EM_MODULESTATE  emState;				// 0-Normal work.1-Pause. Need to rebuild background when you switch to the normal video since it may change.
	int                 nIndex;                 // Model SN.	-1 stands for all modules.
}NET_IN_SETMODULESTATE;

typedef struct __NET_OUT_SETMODULESTATE
{
	DWORD				dwSize;					// Current structure body size
}NET_OUT_SETMODULESTATE;

/////////////////////////////////CLIENT_DeleteDevConfig Interface parameter/////////////////////////////////
/*
 * CLIENT_DeleteDevConfig Input and output parameter
 */

typedef enum tagNET_EM_CONFIGOPTION
{
	NET_EM_CONFIGOPTION_OK,
	NET_EM_CONFIGOPTION_NEEDRESTART,
	NET_EM_CONFIGOPTION_NEEDREBOOT=2,
	NET_EM_CONFIGOPTION_WRITEFILEERROR=4,
	NET_EM_CONFIGOPTION_CAPSNOTSUPPORT=8,
	NET_EM_CONFIGOPTION_VALIDATEFAILED=16,
}NET_EM_CONFIGOPTION;

typedef struct tagNET_IN_DELETECFG
{
	DWORD         dwSize;						// Structure body size
	char*         szCommand;                    // Configuration command
}NET_IN_DELETECFG;

typedef struct tagNET_OUT_DELETECFG
{
	DWORD         dwSize;                       // Structure body size
    int           nError;                       // The error code device returns
    int           nRestart;                     // Device reboot or not
	DWORD         dwOptionMask;                 // Option. Please refer to enumeration NET_EM_CONFIGOPTION
}NET_OUT_DELETECFG;

/////////////////////////////////CLIENT_GetMemberNames interface parameter/////////////////////////////////
/*
 * CLIENT_GetMemberNames Input and output parameter
 */
typedef struct tagNET_IN_MEMBERNAME
{
	DWORD         dwSize;                       // Structure body size
	char*         szCommand;                    // Configuration command
}NET_IN_MEMBERNAME;

typedef struct tagNET_OUT_MEMBERNAME
{
	DWORD         dwSize;                       // Structure body size 
	int           nError;                       // The error code device returns
    int           nRestart;                     // Device reboot or not	
	int           nTotalNameCount;              // Name amount. Fromt the capability set. Caller fill in.
	int           nRetNameCount;                // The returned actual name amount
	NET_ARRAY*    pstNames;                     // Name array. The caller apply for the memory. The amount is nTotalNameCount.
												// the space application by the user,apply to sizeof(NET_ARRAY)*nTotalNameCount
}NET_OUT_MEMBERNAME;

////////////////////////////////////video compression//////////////////////////////////////
// staff type
typedef enum tagNET_EM_STAFF_TYPE
{
	NET_EM_STAFF_TYPE_ERR,
	NET_EM_STAFF_TYPE_HORIZONTAL,                       // "Horizontal" 
	NET_EM_STAFF_TYPE_VERTICAL,                         // "Vertical" 
	NET_EM_STAFF_TYPE_ANY,                              // "Any" 
	NET_EM_STAFF_TYPE_CROSS,                            // "Cross" 
}NET_EM_STAFF_TYPE;

// region type
typedef enum tagNET_EM_CALIBRATEAREA_TYPE
{
	NET_EM_CALIBRATEAREA_TYPE_ERR,
	NET_EM_CALIBRATEAREA_TYPE_GROUD,		            // "Groud" 
	NET_EM_CALIBRATEAREA_TYPE_HORIZONTAL,	            // "Horizontal" 		
	NET_EM_CALIBRATEAREA_TYPE_VERTICAL,		            // "Vertical" 
	NET_EM_CALIBRATEAREA_TYPE_ANY,			            // "Any"
}NET_EM_CALIBRATEAREA_TYPE;

// The concentrated output data subtype
typedef enum tagNET_EM_OUTPUT_SUB_TYPE
{
	NET_EM_OUTPUT_SUB_TYPE_ERR,
	NET_EM_OUTPUT_SUB_TYPE_NORMAL,                      // Normal playback speed (the parent type is concentrated Video valid)
	NET_EM_OUTPUT_SUB_TYPE_SYNOPSIS,                    // Concentrated by the playback speed (parent type is effective when concentrated video), quick release in the absence of an object, the object appears when playing at normal speed
}NET_EM_OUTPUT_SUB_TYPE;

// staff info
typedef struct tagNET_STAFF_INFO
{
	DH_POINT	        stuStartLocation;	            // start location
	DH_POINT	        stuEndLocation;		            // end location
	float			    nLenth;				            // length(m)
	NET_EM_STAFF_TYPE	emType;			                // type
}NET_STAFF_INFO;

// calibration area,common scenario use
typedef struct tagNET_CALIBRATEAREA_INFO
{
	int				    nLinePoint;					    // horizontal line point
	DH_POINT	        stuLine[DH_MAX_POLYLINE_NUM];	// horizontal line
	float			    fLenth;						    // lenth
	DH_POLY_POINTS	    stuArea;					    // area
	int				    nStaffNum;					    // number of vertical line
	NET_STAFF_INFO	    stuStaffs[DH_MAX_STAFF_NUM];    // vertical line         
	NET_EM_CALIBRATEAREA_TYPE emType;			        // area type
}NET_CALIBRATEAREA_INFO;

typedef struct tagNET_LOCALFILE_INFO
{
	DWORD			    dwSize;
	char			    szFilePath[MAX_PATH];	        // file path
	NET_TIME			stuStartTime;					// start time(local time of device)
    NET_TIME			stuEndTime;						// end time(local time of device)
    UINT				nFileLength;					// size of file, unit: Byte
}NET_LOCALFILE_INFO;

typedef struct tagNET_REMOTEFILE_INFO
{
	DWORD			    dwSize;
	char			    szIP[MAX_PATH];	                // the remote device IP
	unsigned int	    nPort;				            // the remote device  port
	char			    szName[DH_MAX_NAME_LEN];        // the remote device  userName
	char			    szPassword[DH_MAX_NAME_LEN];    // the remote device  password
	BYTE			    byProtocolType;			        // the remote device protocol type,2-the second generation of private 3-the third generation of private
	BYTE			    byReserved[3];			        // byte alignment
	char			    szFilePath[MAX_PATH];           // file path,when byProtocolType == 3 effective.
	int				    nStartCluster;		  	        // start cluster,when byProtocolType == 2 effective.
	int				    nDriverNo;				        // driver no.when byProtocolType == 2 effective.
	NET_TIME			stuStartTime;					// start time(local time of device)use nStartCluster and nDriverNo first
	NET_TIME			stuEndTime;						// end time(local time of device)use nStartCluster and nDriverNo first
	int					nChannel;						// channel ID, use nStartCluster and nDriverNo first
	NET_STREAM_TYPE		emStreamType;					// stream type, only support main stream and Extra1/ Extra2
}NET_REMOTEFILE_INFO;

// file path info
typedef struct tagNET_FILEPATH_INFO
{
	DWORD				dwSize;
	BOOL				bFileType;			            // TRUE: local server's file; FALSE: remote device's file
	NET_LOCALFILE_INFO	stuLocalFile;		            // local file, when bFileType==TRUE effective
	NET_REMOTEFILE_INFO	stuRemoteFile;		            // remote file, when bFileType==FALSE effective
}NET_FILEPATH_INFO;

// global param info
typedef struct tagNET_GLOBAL_INFO
{
	DWORD			    dwSize;
	char			    szSceneType[DH_MAX_NAME_LEN];	// scene type,only support "Normal"
	int				    nStaffNum;						// staff num
	NET_STAFF_INFO	    stuStaffs[DH_MAX_STAFF_NUM];	// staffs
	int				    nCalibrateAreaNum;				// number of calibrate area
	NET_CALIBRATEAREA_INFO stuCalibrateArea[DH_MAX_CALIBRATEBOX_NUM]; // calibrate area(if the filed does not exist,return the entire tegion)
	int				    nJitter;		                // vidicon jitter, range[0-100],the value of static camera shake,the more powerful shake,the bigger the value.
	BOOL			    bDejitter;		                // if start to wobble
}NET_GLOBAL_INFO;

// module info
typedef struct tagNET_MODULE_INFO
{
	DWORD			    dwSize;										// size
	BYTE			    bSensitivity;								// sensitivity,range[1-10],the lower the value the sensitivity.
	BYTE			    bReserved[3];
	int				    nDetectRegionPoint;							// detect region point
	DH_POINT		    stuDetectRegion[DH_MAX_POLYGON_NUM]; 		// detect region
	int				    nExcludeRegionNum;							// number of exclude region 
	DH_POLY_POINTS	    stuExcludeRegion[DH_MAX_EXCLUDEREGION_NUM];	// exclude region
}NET_MODULE_INFO;

// object filter info
typedef struct tagNET_OBJFILTER_INFO
{
	DWORD		        dwSize;						    // size
	NET_TIME	        stuStartTime;				    // start time
	NET_TIME	        stuEndTime;					    // end time
	char		        szObjectType[DH_MAX_NAME_LEN];	// object type, support for the following:
											            // "Unknown", "Human", "Vehicle",
											            // "Fire", "Smoke", "Plate", "HumanFace", "Container", "Animal", "TrafficLight", "PastePaper", "HumanHead", "Entity"
	char		        szObjectSubType[64];		    // object sub type,support for the following:
											            // Vehicle Category:"Unknown"  "Motor" "Non-Motor" "Bus" "Bicycle" "Motorcycle" 
											            // Plate Category: "Unknown" "Normal" "Yellow" "DoubleYellow" "Police" "Armed" 
											            // "Military" "DoubleMilitary" "SAR" "Trainning" 
											            // "Personal" "Agri" "Embassy" "Moto" "Tractor" "Other"
											            // HumanFace Category:"Normal" "HideEye" "HideNose" "HideMouth" 
	DWORD		        dwRGBMainColor[DH_MAX_COLOR_NUM];	// main color,object to the person,said the upper part of the color,in bytes,is red,green,blue and diaphaneity,example:RGB value is(0,255,0),when diaphaneity = 0, the value = 0x00ff0000
	DWORD		        dwLowerBodyColor[DH_MAX_COLOR_NUM];	// object to the person,said the lower half of the color,in bytes,is red,green,blue and diaphaneity,example:RGB value is(0,255,0),when diaphaneity = 0, the value = 0x00ff0000
	int			        nMinSize;					    // min siez, m
	int			        nMaxSize;					    // max size, m
	int			        nMinSpeed;					    // min speed km/h
	int			        nMaxSpeed;					    // max speed km/h
	DWORD		        dwRGBMainColorNum;			    // object is the person,dwRGBMainColor effective number of colors
	DWORD		        dwLowerBodyColorNum;		    // object is the person, and bRGBMainColor==true,is the lower half of the effective color
	BOOL		        bRGBMainColor;				    // true-dwRGBMainColor the upper part of the color,dwLowerBodyColor the lower half of the color; false-dwRGBMainColor means main color,dwLowerBodyColor nullity
}NET_OBJFILTER_INFO;

// param of rule
typedef struct tagNET_VIDEOSYNOPSISRULE_INFO
{
	DWORD				dwSize;				            // struct size
	BYTE				byOutputType;		            // out tyope,1-snapshot;2-condensatal video;3-snapshot with video
	BYTE				byDensity;			            // density, 1-10, the more value,the density higher
	bool				bShowTime;			            // show time
	bool				bShowBox;			            // show object box
	bool				bEnableRecordResult;            // the result recoded or not
    BYTE                byTime;                         // Length after video synposis, unit is minute
    BYTE                byReserved[2];
	NET_OBJFILTER_INFO	stuFilter[MAX_OBJFILTER_NUM];   // fileter info
	DWORD				dwObjFilterNum;		            // number of filter

	// NET_OUT_QUERY_VIDEOSYNOPSIS , CFG_CMD_ANALYSERULE transfer dhconfigsdk.dll get CLIENT_ParseData
	// NET_IN_ADD_VIDEOSYNOPSIS ,CFG_CMD_ANALYSERULEtransfer  dhconfigsdk.dll get CLIENT_PacketData
	char*		        szAnalyseRuleInfo;				// JSON rule info
	int                 nBufferLen;                     // NET_OUT_QUERY_VIDEOSYNOPSIS,apply szAnalyseRuleInfo length
	BOOL				bCustomResolution;				// Custom resolution enabled, TRUE-resolution is determined by emResolution, FALSE-concentrate production based on the original video resolution video
	CAPTURE_SIZE		emResolution;					// Resolution, bCustomResolution is TRUE only valid
	BOOL				bEnableMaxUsedCPU;				// Are maximize occupy CPU resource requirements
	BOOL				bEnableSmoothBorder;			// Target is smooth border
	NET_EM_OUTPUT_SUB_TYPE emOutputSubType;             // After concentrating the output data sub-type, see NET_EM_OUTPUT_SUB_TYPE
	int					nExtractFrameRate;				// Video frame rate pumping concentrated 1-32, the value, the higher the pumping rate of the frame, the client presents the faster playback
														// This field is concentrated only in the output data sub-type (emOutputSubType) is valid NET_EM_OUTPUT_SUB_TYPE_SYNOPSIS
	//Video synposis extra info 
    int                 nSynopsisSpeed;                 // Synposis speed threshold. The level ranges from 1 to 10. 5 means only reserve the object of speed higher than 5. It is a relative unit.
                                                        // Current string is null if it is o. 
    int                 nSynopsisSize;                  // Synposis dimensions threshold. There are ten levels (1 to 10). 3 means only reserve the object of speed higher than 3. It is a relative unit.
                                                        // Current string is null if it is o. 
    BOOL                bEnableDirection;               // When it is True,  filter the object moving direction. 
                                                        // When it is False, do not filter the object moving direction. 
    DH_POINT            stuSynopsisStartLocation;       // Synopsis moving direction, start coordinates. The point coordinates [0,8192), it is valid when bEnableDirection is True. 
    DH_POINT            stuSynopsisEndLocation;         // Synopsis moving direction, stop coordinates. The point coordinates [0,8192), it is valid when bEnableDirection is True. 
}NET_VIDEOSYNOPSISRULE_INFO;

// add video synopsis input param
typedef struct tagNET_IN_ADD_VIDEOSYNOPSIS
{
	DWORD			    dwSize;			                // size
	NET_FILEPATH_INFO*	pFilePathInfo;	                // file path info
														// the space application by the user,apply to sizeof(NET_FILEPATH_INFO)*dwFileCount														// the space application by the user,apply to 

	DWORD				dwFileCount;	                // effective number of files
	NET_GLOBAL_INFO		stuGlobalInfo;	                // global info
	NET_MODULE_INFO		stuModuleInfo;	                // module info
	NET_VIDEOSYNOPSISRULE_INFO	stuRuleInfo;	        // rule info
	unsigned int		nWaitTime;		                // wait time(ms)
}NET_IN_ADD_VIDEOSYNOPSIS;

// add video synopsis output param
typedef struct tagNET_OUT_ADD_VIDEOSYNOPSIS
{
	DWORD	            dwSize;			                // size
	DWORD*	            pnTaskID;		                // TaskID array,users are assigned space.
	DWORD	            nTaskIDCount;	                // count of TaskID
}NET_OUT_ADD_VIDEOSYNOPSIS;

// pause video synopsis input param
typedef struct tagNET_IN_PRE_HANDLE_VIDEOSYNOPSIS
{
    DWORD                   dwSize;                         // The structure size
    NET_FILEPATH_INFO*      pFilePathInfo;                  // File position info. Space allocated by the user,apply to sizeof(NET_FILEPATH_INFO)*dwFileCount
    DWORD                   dwFileCount;                    // Valid file amount. 
    unsigned int            nWaitTime;                      // Waiting time out, unit is ms.
    char                    szTaskName[DH_COMMON_STRING_64];// the task name,can be empty
}NET_IN_PRE_HANDLE_VIDEOSYNOPSIS;

// Video synopsis pre-process task outputs parameters 	
typedef struct tagNET_OUT_PRE_HANDLE_VIDEOSYNOPSIS
{
    DWORD               dwSize;                             // Structure size 
    DWORD*              pnTaskID;                           // TaskID array. Space allocated by user. It is corresponding to the added task file. 0=failed to add the corresponding task. 
															// the space application by the user, apply to sizeof(DWORD)*nTaskIDCount
	DWORD               nTaskIDCount;                       // TaskID amount 
}NET_OUT_PRE_HANDLE_VIDEOSYNOPSIS;

// Perform video condensation processing on a video channel basis
typedef struct tagNET_IN_PRETASK_BYCHANNEL
{
	DWORD				dwSize;
	int					nChannelCount;						// The number of channels 
	int					nChannel[DH_PRETASK_CHANNEL];		// Send channel
	NET_TIME			stuStartTime;						// The Synopsis video start time
	NET_TIME			stuEndTime;							// The Synopsis video end time
	unsigned int		nWaitTime;							// Wait time
}NET_IN_PRETASK_BYCHANNEL;

typedef struct tagNET_OUT_PRETASK_BYCHANNEL
{
	DWORD				dwSize;
	int					nTaskCount;							// Task ID count;
	int					nRealCount;							// The real task ID count;
	DWORD*              pnTaskID;							// Pre Task ID, value is sizeof(DWORD)*nTaskCount
															// 0: Failed to create the task; >0: sucess to create the task
}NET_OUT_PRETASK_BYCHANNEL;

// Get synopsis video task progress input parameter
typedef struct tagNET_IN_GET_VIDEOSYNOPSIS_STATE
{
	DWORD				dwSize;
	unsigned int		nTaskID;							// Synopsis video task ID
	unsigned int		nWaitTime;							// Wait time
}NET_IN_GET_VIDEOSYNOPSIS_STATE;

// The current state of Synopsis video
typedef enum tagEM_VIDEOSYNOPSIS_STATE
{
	EM_VIDEOSYNOPSIS_STATE_UNKNOWN,							// Unknown
	EM_VIDEOSYNOPSIS_STATE_SUCESSED,						// Successful
	EM_VIDEOSYNOPSIS_STATE_FAILED,							// Failed
	EM_VIDEOSYNOPSIS_STATE_PRETASK,							// In the addPreTask stage
	EM_VIDEOSYNOPSIS_STATE_SYNO								// In the addSynoInfo stage
}EM_VIDEOSYNOPSIS_STATE;

// Get synopsis video task progress output parameter
typedef struct tagNET_OUT_GET_VIDEOSYNOPSIS_STATE
{
	DWORD						dwSize;
	int							nProcess;					// Unit: %, idle is -1
	EM_VIDEOSYNOPSIS_STATE		emState;					// The synopsis video task stage
}NET_OUT_GET_VIDEOSYNOPSIS_STATE;

// Start find synopsis video history input parameter
typedef struct tagNET_IN_VIDEOSYNOPSIS_STARTFIND
{
	DWORD						dwSize;
	int							nChannelCount;				// The number of channels
	int*						pnChannel;					// Video channel, value is sizeof(pnChannel)*nChannelCount;
	NET_TIME					stuStartTime;				// Start time
	NET_TIME					stuEndTime;					// End time
	unsigned int				nWaitTime;					// Wait time
}NET_IN_VIDEOSYNOPSIS_STARTFIND;

// Start find synopsis video history output parameter
typedef struct tagNET_OUT_VIDEOSYNOPSIS_STARTFIND
{
	DWORD						dwSize;
	int							nToken;						// Acquired query token
	int							nTotalCount;				// The total number of results that match this query
}NET_OUT_VIDEOSYNOPSIS_STARTFIND;

// Get historical search result information input parameter
typedef struct tagNET_IN_VIDEOSYNOPSIS_DOFIND
{
	DWORD						dwSize;
	int							nToken;						// Query token
	int							nBeginNumber;				// Check the starting serial number, start from nBeginNumber, get nCount record
	int							nCount;						// The number of results for each query
	unsigned int				nWaitTime;					// Wait time
}NET_IN_VIDEOSYNOPSIS_DOFIND;

// Get historical search result information
typedef struct tagNET_VIDEOSYNOPSIS_DOFIND_INFO
{
	int							nChannel;					// Video channel
	NET_TIME					stuStartTime;				// Original video start time
	NET_TIME					stuEndTime;					// Original video end time
	int							nDisk;						// Disk number
	int							nPartition;					// Partition number
	int							nCluster;					// Cluster number
	int							nFileLength;				// The length of time to condense the video, unit: s
	int							nFileSize;					// Synopsis video file length, need to download, unit:kB
	BOOL						bLocked;					// Whether or not to be locked
    NET_TIME					stuBeginWriteTime;			// Synopsis video file begin write time
	NET_TIME					stuEndWriteTime;			// Synopsis video file end write time
	BYTE						byReserved[976];			// Reserved
}NET_VIDEOSYNOPSIS_DOFIND_INFO;

// Get historical search result information output parameter
typedef struct tagNET_OUT_VIDEOSYNOPSIS_DOFIND
{
	DWORD							dwSize;
	int								nMaxFind;				// The maximum number of queries
	int								nRealFound;				// The actual query to the number
	NET_VIDEOSYNOPSIS_DOFIND_INFO*	pstuFindInfo;			// Query information requested by the user, value is: sizeof(NET_VIDEOSYNOPSIS_DOFIND_INFO) * nMaxFind
}NET_OUT_VIDEOSYNOPSIS_DOFIND;

// End concentration history query input parameter
typedef struct tagNET_IN_VIDEOSYNOPSIS_STOPFIND
{
	DWORD						dwSize;
	int							nToken;						// Query token
	unsigned int				nWaitTime;					// Wait time
}NET_IN_VIDEOSYNOPSIS_STOPFIND;

// End concentration history query output parameter
typedef struct tagNET_OUT_VIDEOSYNOPSIS_STOPFIND
{
	DWORD						dwSize;
}NET_OUT_VIDEOSYNOPSIS_STOPFIND;

// Input parameters when implement the video synopsis task 
typedef struct tagNET_IN_RUN_VIDEOSYNOPSIS_TASK
{
    DWORD                       dwSize;                     // Structure size 
    DWORD                       nTaskID;                    // Task ID. CLIENT_PreHandleVideoSynopsisTask output function and then return 
    NET_GLOBAL_INFO             stuGlobalInfo;              // Global info 
    NET_MODULE_INFO             stuModuleInfo;              // Module info 
    NET_VIDEOSYNOPSISRULE_INFO  stuRuleInfo;                // Rule info 
    unsigned int                nWaitTime;                  // Waiting time out. Unit is ms
}NET_IN_RUN_VIDEOSYNOPSIS_TASK;

//  Output parameters when implementing the video synopsis task 
typedef struct tagNET_OUT_RUN_VIDEOSYNOPSIS_TASK
{
    DWORD               dwSize;                             // Structure size 
    DWORD               nPlayID;                            // Playback ID,0=interface failed, otherwise input CLIENT_PlayBackBySynopsisFile to playback video
    DWORD               nTime;                              // Video synopsis time. Unit:second. 
}NET_OUT_RUN_VIDEOSYNOPSIS_TASK;

// Input parameters when parsing the video synopsis task 
typedef struct tagNET_IN_PAUSE_VIDEOSYNOPSIS
{
	DWORD	            dwSize;			                // size 
	BOOL                bPause;                         // TRUE-pause  FALSE-resume 
	DWORD*	            pnTaskID;		                // TaskID array,users are assigned space.apply to sizeof(DWORD)*nTaskIDCount
	DWORD	            nTaskIDCount;	                // count of TaskID
	DWORD	            nWaitTime;		                // wait time(ms)
}NET_IN_PAUSE_VIDEOSYNOPSIS;

//  remove video synopsis input param
typedef enum tagNET_SYNOPSIS_REMOVE_TYPE
{
    EM_SYNOPSIS_REMOVE_UNKNOW =0 , // Unknown 
    EM_SYNOPSIS_REMOVE_PRETASK   , // Pre-process task 
    EM_SYNOPSIS_REMOVE_SYNO      , // Video synopsis task 
}NET_SYNOPSIS_REMOVE_TYPE;

// Input parameters when deleting video synopsis task 
typedef struct tagNET_IN_REMOVE_VIDEOSYNOPSIS
{
	DWORD	            dwSize;			                // size
	DWORD*	            pnTaskID;		                // TaskID array,users are assigned space.apply to sizeof(DWORD)*nTaskIDCount
	DWORD	            nTaskIDCount;	                // count of TaskID
	DWORD	            nWaitTime;		                // wait time(ms)
    NET_SYNOPSIS_REMOVE_TYPE    emRemoveType;			// Task type to be deleted 
}NET_IN_REMOVE_VIDEOSYNOPSIS;

// return objece info of video synopsis
typedef struct tagNET_REAL_SYNOPSIS_OBJECT_INFO
{
	DWORD               dwSize;
	
	DWORD               dwTaskID;                       // task ID
    DH_MSG_OBJECT_EX2   stuObjectInfo;                  // Object detailed info 
}NET_REAL_SYNOPSIS_OBJECT_INFO;

typedef struct tagNET_REAL_SYNOPSIS_STATE_INFO
{
	DWORD               dwSize;
	
	DWORD               dwTaskID;                       	// task ID   
	int                 nObjectNum;                     	// number of object
	int                 nTaolProgress;                  	// progress of condensation,0~100
	char                szState[DH_MAX_SYNOPSIS_STATE_NAME];// state of condensation,"Downloading"  "Synopsising"
                                                        	// "DownloadFailed""DownloadSucceeded"
	                                                  		// "SynopsisFailed" ,"Succeeded" 
		                                                	// "DownloadPause" ,"SynopsisPause" 
	int           		nProgressOfCurrentState;        	// progress of current state,0~100
	char				szFailedCode[DH_MAX_STRING_LEN];	// Failure code, szState="SynopsisFailed"Effective
															// "OutOfMemory" Out of memory;
															// "TooMany_TargetInVideo"  Too many goals the entire video;
															// "InvalidFilePointer" File pointer is invalid;
															// "InvalidFilePath" File path is invalid;
															// "CreateDirectoryFailed"  Create a folder path fails;
															// "WriteDataFailed" Intermediate file failed to write Tube
															// "DataSizeTooLarge" Tube file is too large
															// "Detect_Nothing" Scene without moving target
															// "OpenDataFailed" Failed to open the intermediate file
															// "InvalidSynopsisBackgroud" Invalid concentrated background
															// "ColorRetrieval" Wrong color retrieve configuration
															// "UnsupportRuleType" Unsupported rule type
															// "RuleNumberExceedLimit" Number of rules overrun
															// "NoFunctionCfgInfo" But did not specify the configuration information corresponding function
															// "FunctionNumberExceedLimit" The number of feature quantity of each rule overrun
															// "PointsExceedLimit" Point line or area overrun
															// "BadFunctionType" Error function type
															// "RulePointNumber" Points rule error
															// "MaskRegionNumberExceedLimit" Shielded area overrun quantity
															// "CameraSceneSwitch" Cameras scene change
															// "TooManyTargeInFrame" Excessive number of single-frame target
															// "InalidSynopsisDesity" Concentrated density invalid
															// "ExtrackColorFeatureFailed" Failed to extract color features
															// "JpegEncodeFrameFailed" Jpeg encoder failure
															// "JpegParamRestFailed" Jpeg encoding parameters fail reset
															// "JpegDecodeFrameFailed" Jpeg decoding failure
															// "RetrieveObjectIdInvalid" Retrieving Target ID is invalid
															// "RetrieveImageInvalid" Invalid image retrieval
															// "NetworkAnomaly" DISH Network anomaly map
															// "ObjectNumberLimit" Limit the number of goals over analysis
															// "CreateChannelFailed" Create a channel failure
															// "ReadUGFileFailed" Read UG file failed
															// "GetSynopsisInfoFailed" Failed to obtain concentrated Video
															// "ObjectNumberExceedLimit" The number of targets in the scene over the limit
															// "RebuildBackgroudFailed" Background reconstruction failure
															// "NotExistMiddleFile" Intermediate file does not exist
															// "NotExistSourceFile" Original file does not exist
															// "NotDog" No dongle
															// "NotEnoughFreeDisk" Disk space is not enough
															// "StartDecodeFail" Start decoding failure
															// "DecodeTimeOut" Decoding wait timeout
															// "EncodeTimeOut" Coding wait timeout
															// "ExactTimeOut" Extract snapshots wait timeout
															// "ReadMidlleFileFail" Failed to read the intermediate file
															// "ExactPictureFail" Failed to extract pictures
    char 				szPicPath[DH_COMMON_STRING_512];	// The snap image file path get by pre-process file.  
                                                        	// Support HTTP URL means :http://www.dahuate.com/1.jpg
                                                        	// Support FTP URL means: "ftp://ftp.dahuate.com/1.jpg"
                                                        	// Server local path  
                                                        	// a)"C:/pic/1.jpg" 
                                                        	// b)"/mnt//2010/8/11/dav/15:40:50.jpg"
    int         		nMaxTime;                       	// Supported video synopsis max time. Unit is second. 
    int         		nMinTime;                       	// Supported video synopsis min time. Unit is second. 
    
    char				szVideoPath[DH_COMMON_STRING_512];	// The path of synopsis video,  it is effect when the front szState is Succeeded .
}NET_REAL_SYNOPSIS_STATE_INFO;

//callback function of synopsis video info
typedef int (CALLBACK *fVideoSynopsisObjData)(LLONG lRealLoadHandle, NET_REAL_SYNOPSIS_OBJECT_INFO* pSynopsisObjectInfo, void* pBuf, int nBufLen, LDWORD dwUser, void* pReserved);

//callback function of synopsis video state
typedef int (CALLBACK *fVideoSynopsisState)(LLONG lRealLoadHandle, NET_REAL_SYNOPSIS_STATE_INFO* pSynopsisStateInfos, int nInfoCount, LDWORD dwUser, void* pReserved);



// CLIENT_RealLoadObjectData's interface define
typedef struct tagNET_IN_REALLOAD_OBJECTDATA
{
	DWORD               dwSize;                         // size
	
	int                 nTaskIDNum;                     // number of taskID
	DWORD               *pTaskIDs;                      // material taskID, the space application by the user, apply to sizeof(DWORD)*nTaskIDNum
	BOOL                bNeedPicFile;                   // need download corresponding to the picture 
	int                 nWaitTime;                      // wait time(ms)
	fVideoSynopsisObjData cbVideoSynopsisObjData;       // callback function's pointer
	LDWORD         		dwUser;
}NET_IN_REALLOAD_OBJECTDATA;

typedef struct tagNET_OUT_REALLOAD_OBJECTDATA
{
	DWORD               dwSize;                         // size

	LLONG               lRealLoadHandle;                // return subscriptal handle
}NET_OUT_REALLOAD_OBJECTDATA;

// CLIENT_StopLoadObjectData's interface define
typedef struct tagNET_IN_STOPLOAD_OBJECTDATA
{
	DWORD               dwSize;

	int                 nTackIDNum;                     // number of tackID
	DWORD               *pTaskIDs;                      // specific taskID, the space application by the user, apply to sizeof(DWORD)*nTaskIDNum
}NET_IN_STOPLOAD_OBJECTDATA;

// CLIENT_RealLoadSynopsisState's interface define
typedef struct tagNET_IN_REALLAOD_SYNOPSISSTATE
{
	DWORD               dwSize;                         // size
	
	int                 nTaskIDNum;                     // number of taskID, 0 means attach all task
	DWORD               *pTaskIDs;                      // specific taskID,the space application by the user, apply to sizeof(DWORD)*nTaskIDNum  
	int                 nWaitTime;                      // wait time(ms)
	fVideoSynopsisState cbVideoSynopsisState;           // callback function's pointer
	LDWORD         		dwUser;
}NET_IN_REALLAOD_SYNOPSISSTATE;

typedef struct tagNET_OUT_REALLOAD_SYNOPSISSTATE
{
	DWORD               dwSize;                         // size
	
	LLONG               lRealLoadHandle;                // return subscriptal handle
}NET_OUT_REALLOAD_SYNOPSISSTATE;

// CLIENT_StopLoadSynopsisState's interface define
typedef struct tagNET_IN_STOPLOAD_SYNOPSISSTATE
{
	DWORD               dwSize;
	
	int                 nTackIDNum;                     // number of taskID
	DWORD               *pTaskIDs;                      // specific taskID, the space application by the user, apply to sizeof(DWORD)*nTaskIDNum  
}NET_IN_STOPLOAD_SYNOPSISSTATE;

// type of video synopsis's query
typedef enum tagEM_VIDEOSYNOPSIS_QUERY_TYPE
{
	EM_VIDEOSYNOPSIS_TASK,	                            // task info
	EM_VIDEOSYNOPSIS_OBJ,	                            // snapshot
}EM_VIDEOSYNOPSIS_QUERY_TYPE;

// query the task of video synopsis information
typedef struct tagNET_QUERY_VSTASK_INFO
{
	DWORD	            dwSize;			                // size
	DWORD	            dwTaskID;		                // taskID,when value = 0,query all task
}NET_QUERY_VSTASK_INFO;

// the color of sysnopsis Object, similarity value relative to a color
typedef struct tagNET_VSO_COLORSIMILAR_INFO
{
	int					nRed;							// red, 0-100, 0 means does not care about the color
	int					nYellow;						// yellow, 0-100, 0 means does not care about the color
	int					nGreen;							// green, 0-100, 0 means does not care about the color
	int					nCyan;							// cyan, 0-100, 0 means does not care about the color
	int					nBlue;							// blue, 0-100, 0 means does not care about the color
	int					nPurple;						// purple, 0-100, 0 means does not care about the color
	int					nBlack;							// black, 0-100, 0 means does not care about the color
	int					nWhite;							// white, 0-100, 0 means does not care about the color
	BYTE				byReserved[512];				// reserved
} NET_VSO_COLORSIMILAR_INFO;

// query conditions of video objects in the task information
typedef struct tagNET_QUERY_VSOBJECT_INFO
{
	DWORD			    dwSize;			                // size
	DWORD*			    pdwTaskID;                		// taskID,when value = -1,query all task
	DWORD			    dwTaskIDCount;                	// count of taskID
	DH_MSG_OBJECT	    stuObjInfo;	                	// object info,when objectID!=0,query all
	int					nSpeed;						 	// speed, unit:km/h, -1 means does not care about the speed
    int					nDirection;					 	// direction, unit:degree, [-1, 360], 0 means the direction of 12 o'clock,  -1 means does not care about the direction
    NET_TIME_EX         stuStartTime;                   // start time(local time of device)
    NET_TIME_EX         stuEndTime;                     // end time(local time of device)
	NET_VSO_COLORSIMILAR_INFO	stuColorSimilarInfo;    // the color of sysnopsis Object, similarity value relative to a color
}NET_QUERY_VSOBJECT_INFO;

//--CLIENT_QueryVideoSynopsisInfo's interface input define
typedef struct tagNET_IN_QUERY_VIDEOSYNOPSIS
{
	DWORD	            dwSize;							// size
	EM_VIDEOSYNOPSIS_QUERY_TYPE emQueryType;            // query type
	DWORD	            dwCount;						// count of query
	DWORD	            dwBeginNumber;					// begin number
	void*	            pQueryInfo;						// information query condition
											            // when emQueryType==EM_VIDEOSYNOPSIS_TASK, corresponding to NET_QUERY_VSTASK_INFO,apply to sizeof(NET_QUERY_VSTASK_INFO)*dwCount
											            // when emQueryType==EM_VIDEOSYNOPSIS_OBJ, corresponding to NET_QUERY_VSOBJECT_INFO,apply to sizeo(NET_QUERY_VSOBJECT_INFO)*dwCount

	DWORD	            dwWaitTime;						// wait time(ms)
}NET_IN_QUERY_VIDEOSYNOPSIS;

// query to the task of each synopsis video information
typedef struct tagNET_VSTASK_INFO
{
	DWORD		        dwSize;			                // size
	DWORD				dwTaskID;		                // task ID
	NET_MODULE_INFO		stuModuleInfo;                	// module info
	NET_VIDEOSYNOPSISRULE_INFO	stuRuleInfo;           	// info of task rule
	NET_GLOBAL_INFO		stuGlobalInfo;	                // global param
	NET_TIME			stuCreateTime;	                // create time
	char				szCurrState[DH_MAX_SYNOPSIS_STATE_NAME];  // current state,"Downloading" "Synopsising" 
																  // "DownloadFailed" "DownloadSucceeded" 
																  // "SynopsisFailed" "Succeeded" 
																  // "DownloadPause" "SynopsisPause" 
	char				szCreateUser[DH_MAX_NAME_LEN];	// the creator
	int					nProgressOfCurrentState;		// progress of current state [0~100]
	char				szLocalFilePath[MAX_PATH];		// local file path
	int					nObjectNum;						// number of object
	NET_FILEPATH_INFO	stuVideoSourceFilePath;			// path of video source file
	NET_FILEPATH_INFO	stuSynopsisVideoFilePath;		// path of synopsis video file
	char                szFailedCode[DH_MAX_STRING_LEN];// Concentrated video failed error code, szCurrState when "SynopsisFailed" Effective
                                                        // "OutOfMemory" Out of memory;
                                                        // "TooMany_TargetInVideo"  Too many goals the entire video;
                                                        // "InvalidFilePointer" File pointer is invalid;
                                                        // "InvalidFilePath" File path is invalid;
                                                        // "CreateDirectoryFailed"  Create a folder path fails;
                                                        // "WriteDataFailed" Intermediate file failed to write Tube
                                                        // "DataSizeTooLarge" Tube file is too large
                                                        // "Detect_Nothing" Scene without moving target
                                                        // "OpenDataFailed" Failed to open the intermediate file
                                                        // "InvalidSynopsisBackgroud" Invalid concentrated background
                                                        // "ColorRetrieval" Wrong color retrieve configuration
                                                        // "UnsupportRuleType" Unsupported rule type
                                                        // "RuleNumberExceedLimit" Number of rules overrun
                                                        // "NoFunctionCfgInfo" But did not specify the configuration information corresponding function
                                                        // "FunctionNumberExceedLimit" The number of feature quantity of each rule overrun
                                                        // "PointsExceedLimit" Point line or area overrun
                                                        // "BadFunctionType" Error function type
                                                        // "RulePointNumber" Points rule error
                                                        // "MaskRegionNumberExceedLimit" Shielded area overrun quantity
                                                        // "CameraSceneSwitch" Cameras scene change
                                                        // "TooManyTargeInFrame" Excessive number of single-frame target
                                                        // "InalidSynopsisDesity" Concentrated density invalid
                                                        // "ExtrackColorFeatureFailed" Failed to extract color features
                                                        // "JpegEncodeFrameFailed" Jpeg encoder failure
                                                        // "JpegParamRestFailed" Jpeg encoding parameters fail reset
                                                        // "JpegDecodeFrameFailed" Jpeg decoding failure
                                                        // "RetrieveObjectIdInvalid" Retrieving Target ID is invalid
                                                        // "RetrieveImageInvalid" RetrieveImageInvalid
                                                        // "NetworkAnomaly" NetworkAnomaly
                                                        // "ObjectNumberLimit" bjectNumberLimit
                                                        // "CreateChannelFailed" CreateChannelFailed
                                                        // "ReadUGFileFailed" ReadUGFileFailed
                                                        // "GetSynopsisInfoFailed" GetSynopsisInfoFailed
                                                        // "ObjectNumberExceedLimit" ObjectNumberExceedLimit
                                                        // "RebuildBackgroudFailed" RebuildBackgroudFailed
                                                        // "NotExistMiddleFile" NotExistMiddleFile
                                                        // "NotExistSourceFile" NotExistSourceFile
                                                        // "NotDog" NotDog
                                                        // "NotEnoughFreeDisk" NotEnoughFreeDisk
                                                        // "StartDecodeFail"StartDecodeFail
                                                        // "DecodeTimeOut" DecodeTimeOut
                                                        // "EncodeTimeOut" EncodeTimeOut
                                                        // "ExactTimeOut" ExactTimeOut
                                                        // "ReadMidlleFileFail" ReadMidlleFileFail
                                                        // "ExactPictureFail" ExactPictureFail
    char                        szTaskName[DH_COMMON_STRING_64];    //  the task name
}NET_VSTASK_INFO;

// each object in the synopsis video task info
typedef struct tagNET_VSOBJECT_INFO
{
	DWORD				dwSize;			                // size 
	DWORD				dwTaskID;		                // task ID
	DH_MSG_OBJECT		stuObjInfo;		                // object info, suggested use stuObjInfoEx
	NET_FILEPATH_INFO	stuFilePathInfo;                // file info
	DWORD				dwFileLength;	                // file length
	int					nDirection;						// direction, unit:degree, effect value [0, 360], -1 means does not care about the direction, 0 means the direction of 12 o'clock, 
	DH_MSG_OBJECT_EX2   stuObjInfoEx;					// extended information of object
}NET_VSOBJECT_INFO;

//--CLIENT_QueryVideoSynopsisInfo's interface output define
typedef struct tagNET_OUT_QUERY_VIDEOSYNOPSIS
{
	DWORD	            dwSize;			                // size
	DWORD	            dwTotalCount;	                // total count
	DWORD            	dwFoundCount;	                // found count
	void*	            pResult;                		// return result info
					                		            // if emQueryType==EM_VIDEOSYNOPSIS_TASK,corresponding to NET_VSTASK_INFO,apply to sizeof(NET_VSTASK_INFO)*dwMaxCount
							                            // if emQueryType==EM_VIDEOSYNOPSIS_OBJ,corresponding to NET_VSOBJECT_INFO,apply to sizeof(NET_VSOBJECT_INFO)*dwMaxCount
	DWORD	            dwMaxCount;		                // hope tp get the number
}NET_OUT_QUERY_VIDEOSYNOPSIS;

// CLIENT_FindSynopsisFile's interface define 
// query type of file
typedef enum tagNET_EM_QUERY_SYNOPSIS_FILE
{
	DH_FILE_QUERY_VIDEO,                                // normal record file info,corresponding to:NET_SYNOPSIS_QUERY_VIDEO_PARAM, return result:NET_SYNOPSISFILE_VIDEO_INFO
	DH_FILE_QUERY_SYNOPSISVIDEO,                        // synopsis video file,corresponding to:NET_QUERY_SYNOPSISVIDEO_PARAM,return result:NET_QUERY_SYNOPSISVIDEO_INFO
}NET_EM_QUERY_SYNOPSIS_FILE;

typedef struct __NET_SYNOPSIS_QUERY_VIDEO_PARAM
{
	DWORD               dwSize;
	DWORD				dwQueryMask;					// query type mask, according to from low to high,the first bit is period of time, the second is file path 
	NET_TIME			stuStartTime;					// start time
	NET_TIME			stuEndTime;						// end time
	char				szFilePath[DH_MAX_SYNOPSIS_QUERY_FILE_COUNT][MAX_PATH];	// file path
	DWORD				dwFileCount;					// file count
}NET_SYNOPSIS_QUERY_VIDEO_PARAM;

typedef struct  
{
	DWORD               dwSize;
	int                 nTaskId;                        // taskID
	DWORD               dwOutPutTypeMask;               // output type in current,the first bit is snapshot,the second bit is synopsis video 
	char                szCurrentState[DH_MAX_SYNOPSIS_STATE_NAME]; // current state
}NET_VIDEOSYNOPSIS_TASK_INFO;

// DH_FILE_QUERY_VIDEO return video file info
typedef struct
{
	DWORD               dwSize;
    unsigned int		nchannelId;						// channel ID
    char				szFilePath[MAX_PATH];		    // file path
    unsigned int		nFileLenth;					    // file length(byte),This field is discarded,please use the nFileLengthEx
    NET_TIME			stuStarttime;				    // start time 
    NET_TIME			stuEndtime;				        // end time
    unsigned int		nWorkDirSN;				        // work dir SN	
	unsigned int        nCluster;                       // cluster				
	BYTE                bHint;					        // hint
	BYTE                bDriveNo;                       // drive no.
	BYTE                bReserved[18];                  // reserved
	
	int                 nTaskInfoNum;                   // task info number
	NET_VIDEOSYNOPSIS_TASK_INFO stuTaskInfo[16];        // video synopsis task info
    char szSynopsisPicPath[DH_COMMON_STRING_512];       // The snap image file path get by pre-process file.  
    int                 nSynopsisMaxTime;               // Supported video synopsis max time. Unit is second. 
    int                 nSynopsisMinTime;               // Supported video synopsis min time. Unit is second.
	INT64               nFileLengthEx;                  // size of file extension, Support file length is greater than 4G,unit:Byte
}NET_SYNOPSISFILE_VIDEO_INFO;

// DH_FILE_QUERY_SYNOPSISVIDEO synopsis viedo file query param
typedef struct __NET_QUERY_SYNOPSISVIDEO_PARAM
{
	DWORD               dwSize;
	int                 nTaskID;                        // taskID
}NET_QUERY_SYNOPSISVIDEO_PARAM;

// DH_FILE_QUERY_SYNOPSISVIDEO query result
typedef struct __NET_QUERY_SYNOPSISVIDEO_INFO
{
	DWORD               dwSize;
    char				szFilePath[MAX_PATH];        	// file path
    unsigned int		nFileLenth;					    // file length,This field is discarded,please use the nFileLengthEx
	int                 nDurationTime;                  // duration time(s)
	INT64               nFileLengthEx;                  // length of file extension, Support file length is greater than 4G,unit:Byte
}NET_QUERY_SYNOPSISVIDEO_INFO;

// CLIENT_FindSynopsisFile's interface param
typedef struct tagNET_IN_FIND_SYNOPSISFILE
{
	DWORD               dwSize;                          
	NET_EM_QUERY_SYNOPSIS_FILE emQueryType;             // query's type
	void*               pQueryCondition;                // query's type,the space application by the user
														// if query type is DH_FILE_QUERY_VIDEO, corresponding to NET_SYNOPSIS_QUERY_VIDEO_PARAM structure, apply to sizeof(NET_SYNOPSIS_QUERY_VIDEO_PARAM)
														// if query type is DH_FILE_QUERY_SYNOPSISVIDEO, corresponding to NET_QUERY_SYNOPSISVIDEO_PARAM structure, apply to sizeof(NET_QUERY_SYNOPSISVIDEO_PARAM)
	int                 nWaitTime;                      // wait time(ms)
}NET_IN_FIND_SYNOPSISFILE;

typedef struct tagNET_OUT_FIND_SYNOPSISFILE
{
	DWORD               dwSize;
	LLONG               lFindHandle;                    // find handle         
}NET_OUT_FIND_SYNOPSISFILE;

// CLIENT_FindNextSynopsisFile's interface param
typedef struct tagNET_IN_FINDNEXT_SYNOPSISFILE
{
	DWORD               dwSize;
    int                 nFileCount;                     // count of file
	NET_EM_QUERY_SYNOPSIS_FILE emQueryType;             // query's type
	void*               pSynopsisFileInfo;              // info of file buf,the space application by the user, apply to nMaxlen
	int                 nMaxlen;                        // size of buf
	int                 nWaitTime;                      // wait time(ms)
}NET_IN_FINDNEXT_SYNOPSISFILE;

typedef struct tagNET_OUT_FINDNEXT_SYNOPSISFILE
{
	DWORD               dwSize;
	int                 nRetFileCount;                  // the actual return information artucle number,return<nFileCount(input param) corresponding period of the finished file query
}NET_OUT_FINDNEXT_SYNOPSISFILE;

// download progress's callback,nError means downloading appear error,1 - cashe is insufficient,2-data validation error,3.download failed,4,create file failed
typedef void (CALLBACK *fSynopsisFileDownLoadPosCB)(LLONG lDownLoadHandle, DWORD dwFileID, DWORD dwFileTotalSize, DWORD dwDownLoadSize, int nError, LDWORD dwUser, void* pReserved);

// CLIENT_DownLoadSynosisFile's interface param
typedef  NET_DOWNLOADFILE_INFO NET_SYNOPSIS_DOWNLOADFILE_INFO;

typedef struct tagNET_IN_DOWNLOAD_SYNOPSISFILE
{
	DWORD               dwSize;
    int                 nFileCount;                     // count of file
	NET_SYNOPSIS_DOWNLOADFILE_INFO* pFileInfos;         // file info,the space application by the user, apply to sizeof(NET_SYNOPSIS_DOWNLOADFILE_INFO)*nFileCount
	fSynopsisFileDownLoadPosCB cbPosCallBack;           // post of callback function
	LDWORD              dwUserData;                     // user's data
	int                 nWaitTime;                      // wait time(ms)
}NET_IN_DOWNLOAD_SYNOPSISFILE;

typedef struct tagNET_OUT_DOWNLOAD_SYNOPSISFILE
{
	DWORD               dwSize;
	LLONG               lDownLoadHandle;                // handle of download
}NET_OUT_DOWNLOAD_SYNOPSISFILE;

// path of file's info 
typedef struct	tagNET_SET_FILEPATH_INFO
{
	DWORD		        dwSize;
	char		        szFilePath[MAX_PATH];	        // can be a folder ,can be the file,current server only supports the dav format file
}NET_SET_FILEPATH_INFO;

// CLIENT_SetFilePathInfo()interface input param
typedef struct tagNET_IN_SET_FILEPATHINFO
{
	DWORD		        dwSize;
	DWORD		        dwCount;		                // count of added file
	void*	        	pFilePathInfo;                	// look for NET_SET_FILEPATH_INFO
													    // the space application by the user, apply to sizeof(NET_SET_FILEPATH_INFO)*dwCount
	DWORD		        dwWaitTime;		                // wait time(ms)
}NET_IN_SET_FILEPATHINFO;


// fAddFileStateCB param
typedef struct tagNET_CB_ADDFILESTATE
{
	DWORD		        dwSize;
	const char*         szFileName;                     // file name
	const char*         szState;                        // analyse file's state, "Successed" ; "Failed" ;
}NET_CB_ADDFILESTATE;

// burning device callback function, pBuf->dwSize == nBufLen
typedef void (CALLBACK *fAddFileStateCB) (LLONG lLoginID, LLONG lAttachHandle, NET_CB_ADDFILESTATE* pBuf,  int nBufLen, LDWORD dwUser);

// CLIENT_AttacAddFileState()interface input param
typedef struct tagNET_IN_ADDFILE_STATE
{
	DWORD		        dwSize;
	fAddFileStateCB     cbAttachState;                 // listenint to increase callback file state
	LDWORD              dwUser;                        // user's data
}NET_IN_ADDFILE_STATE;
typedef struct tagNET_OUT_ADDFILE_STATE
{
	DWORD		        dwSize;
}NET_OUT_ADDFILE_STATE;

///////////////////////////////////Face recognition module related structures///////////////////////////////////////
typedef struct tagNET_UID_CHAR
{
    char szUID[DH_MAX_PERSON_ID_LEN];  //UID contents 
}NET_UID_CHAR;

// CLIENT_OperateFaceRecognitionDBInterface input parameters
typedef struct __NET_IN_OPERATE_FACERECONGNITIONDB
{
	DWORD             					dwSize;
	EM_OPERATE_FACERECONGNITIONDB_TYPE  emOperateType;  	// Type of operation
	FACERECOGNITION_PERSON_INFO         stPersonInfo;   	// Personnel information

	// Picture binary data
    DWORD            					nUIDNum;			// UID amount              
    NET_UID_CHAR     					*stuUIDs;			// Person unique mark. Generated by the client if it is the first time. Different from the ID string. 
															// the space application by the user, apply to sizeof(NET_UID_CHAR)*nUIDNum
	char                				*pBuffer;			// Buffer address
	int                 				nBufferLen;			// Buffer data length
	
	BOOL			  					bUsePersonInfoEx;	// use stPersonInfoEx when bUsePersonInfoEx is true, otherwise use stPersonInfo
	FACERECOGNITION_PERSON_INFOEX		stPersonInfoEx;		// expansion of personnel information
}NET_IN_OPERATE_FACERECONGNITIONDB;

// error code, it is effective when emOperateType is NET_FACERECONGNITIONDB_DELETE_BY_UID
typedef enum tagEM_ERRORCODE_TYPE
{
    EM_ERRORCODE_TYPE_UNKNOWN = -1,               // unknown
    EM_ERRORCODE_TYPE_SUCCESS,               // success
    EM_ERRORCODE_TYPE_PERSON_NOT_EXIST,            // person not exist
    EM_ERRORCODE_TYPE_DATABASE_ERROR,             //  database error
} EM_ERRORCODE_TYPE;

// CLIENT_OperateFaceRecognitionDB port output parameter
typedef struct __NET_OUT_OPERATE_FACERECONGNITIONDB
{
    DWORD               dwSize;
	char				szUID[DH_MAX_PERSON_ID_LEN];	// Person unique mark. it is effective when emOperateType is NET_FACERECONGNITIONDB_ADD

    // the following fields are effective when emOperateType is NET_FACERECONGNITIONDB_DELETE_BY_UID
    int                nErrorCodeNum; // error code number
    EM_ERRORCODE_TYPE          emErrorCodes[MAX_ERRORCODE_NUM]; // error code
    // the uping fields are effective when emOperateType is NET_FACERECONGNITIONDB_DELETE_BY_UID
}NET_OUT_OPERATE_FACERECONGNITIONDB;

// Input param of CLIENT_BatchAppendFaceRecognition
typedef struct tagNET_IN_BATCH_APPEND_FACERECONGNITION
{
    DWORD                           dwSize;             // struct size
    UINT                            nPersonNum;         // the number of persons which are appended to the face DB
    FACERECOGNITION_PERSON_INFOEX   *pstPersonInfo;     // person infomemory is requested by userand the size is nPersonNum * sizeof(FACERECOGNITION_PERSON_INFOEX)

    // picture binary data
    char                            *pBuffer;           // picture buffer
    UINT                            nBufferLen;         // length of picture buffer
    BYTE                            bReserved[4];       // alignment
} NET_IN_BATCH_APPEND_FACERECONGNITION;

// result of batch append persons
typedef struct tagNET_BATCH_APPEND_PERSON_RESULT
{
    UINT            nUID;               // UID
    DWORD           dwErrorCode;        // error code
    BYTE            bReserved[512];     // reserved
} NET_BATCH_APPEND_PERSON_RESULT;

// output param of CLIENT_BatchAppendFaceRecognition 
typedef struct tagNET_OUT_BATCH_APPEND_FACERECONGNITION
{
    DWORD                           dwSize;                 // struct size
    UINT                            nResultNum;             // number of resultit is set by user. The value is same with the nPersonNum in ET_IN_MULTI_APPEND_FACERECONGNITION
    NET_BATCH_APPEND_PERSON_RESULT  *pstResultInfo;         // result of batch append persons
} NET_OUT_BATCH_APPEND_FACERECONGNITION;

// The query mode of searching face database by picture
typedef enum tagEM_FINDPIC_QUERY_MODE
{
    EM_FINDPIC_QUERY_UNKNOWN,               // Unknown
    EM_FINDPIC_QUERY_PASSIVE,               // Passive
    EM_FINDPIC_QUERY_ACTIVE,                // Active
} EM_FINDPIC_QUERY_MODE;

// The sort order of the result about searching face database by picture
typedef enum tagEM_FINDPIC_QUERY_ORDERED
{
	EM_FINDPIC_QUERY_BY_SIMILARITY,			// From high to low by similarity
	EM_FINDPIC_QUERY_BY_TIME_FORWARD,		// Forward by time
	EM_FINDPIC_QUERY_BY_TIME_REVERSE,		// Reverse by time
} EM_FINDPIC_QUERY_ORDERED;

typedef struct __NET_FACE_MATCH_OPTIONS
{
	DWORD               dwSize;
	unsigned int        nMatchImportant;               // Important level 1 to 10 staff, the higher the number the more important (check important level greater than or equal to this level of staff)
	EM_FACE_COMPARE_MODE emMode;                       // Face comparison mode, see EM_FACE_COMPARE_MODE
	int                 nAreaNum;                      // Face the number of regional
	EM_FACE_AREA_TYPE   szAreas[MAX_FACE_AREA_NUM];    // Regional groupings of people face is NET_FACE_COMPARE_MODE_AREA effective when emMode
	int                 nAccuracy;                     // Recognition accuracy (ranging from 1 to 10, with the value increases, the detection accuracy is improved, the detection rate of decline. Minimum value of 1 indicates the detection speed priority, the maximum is 10, said detection accuracy preferred. Temporarily valid only for face detection)
	int                 nSimilarity;                   // Similarity (must be greater than the degree of acquaintance before the report; expressed as a percentage, from 1 to 100)
	int                 nMaxCandidate;                 // Reported the largest number of candidate (based on similarity to sort candidates to take the maximum number of similarity report)
	EM_FINDPIC_QUERY_MODE emQueryMode;                 // The query mode of searching face database by picture
	EM_FINDPIC_QUERY_ORDERED emOrdered;				   // The sort order of the result about searching face database by picture
}NET_FACE_MATCH_OPTIONS;

typedef struct __NET_FACE_FILTER_CONDTION
{
	DWORD               dwSize;
	NET_TIME			stStartTime;			       // Start time
    NET_TIME			stEndTime;				       // End Time
	char                szMachineAddress[MAX_PATH];    // Place to support fuzzy matching
	int                 nRangeNum;                     // The actual number of database
	BYTE                szRange[MAX_FACE_DB_NUM];      // To query the database type, see EM_FACE_DB_TYPE
	EM_FACERECOGNITION_FACE_TYPE emFaceType;           // Face to query types, see EM_FACERECOGNITION
    int                 nGroupIdNum;                   // staff group  
    char                szGroupId[MAX_GOURP_NUM][DH_COMMON_STRING_64]; // staff group ID 
    NET_TIME            stBirthdayRangeStart;          // start birthday time
    NET_TIME            stBirthdayRangeEnd;            // end birthday time
	BYTE			    byAge[MAX_AGE_NUM];			   // Age range, When byAge[0] is 0 and byAge[1] is 0, it means query all age
	BYTE				byReserved[2];				   // Reserved
	EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE	emEmotion[MAX_EMOTION_NUM];		// Emotion
	int					nEmotionNum;				   // Emotion num
    int                 nUIDNum;                       // UID num
    char                szUIDs[64][32];                // UID list
}NET_FACE_FILTER_CONDTION;

#define MAX_SMALLPIC_NUM	32		// max number of small images


// CLIENT_StartFindFaceRecognitionInterface input parameters
typedef struct __NET_IN_STARTFIND_FACERECONGNITION
{
    DWORD               dwSize;
    BOOL                bPersonEnable;                 // Personnel information query is valid
    FACERECOGNITION_PERSON_INFO stPerson;              // Personnel information query
    NET_FACE_MATCH_OPTIONS stMatchOptions;             // Face Matching Options
    NET_FACE_FILTER_CONDTION stFilterInfo;             // Query filters
  
    // Picture binary data
    char                *pBuffer;                      // Buffer address
    int                 nBufferLen;                    // Buffer data length

    int                 nChannelID;                    // Channel ID     
    
    BOOL                bPersonExEnable;                // use stPersonInfoEx when bUsePersonInfoEx is true, otherwise use stPersonInfo
    FACERECOGNITION_PERSON_INFOEX   stPersonInfoEx;     // expansion of personnel information
    int                 nSmallPicIDNum;                 // the count of small picture ID
    int                 nSmallPicID[MAX_SMALLPIC_NUM];  // small picture ID
    EM_OBJECT_TYPE      emObjectType;                   // The type of object
}NET_IN_STARTFIND_FACERECONGNITION;

// CLIENT_StartFindFaceRecognitionInterface output parameters
typedef struct __NET_OUT_STARTFIND_FACERECONGNITION
{
	DWORD               dwSize;
	int                 nTotalCount;                   // Record number of returns that match the query criteria
	LLONG               lFindHandle;                   // Query handle
    int                 nToken;                        // The search token received 
}NET_OUT_STARTFIND_FACERECONGNITION;

// CLIENT_StartMultiFindFaceRecognition input parameters
typedef struct tagNET_IN_STARTMULTIFIND_FACERECONGNITION
{
    DWORD               dwSize;
    int*                pChannelID;                    // Channel ID
    int                 nChannelCount;                 // number of channel
    BOOL                bPersonEnable;                 // Personnel information query is valid
    FACERECOGNITION_PERSON_INFO stPerson;              // Personnel information query
    NET_FACE_MATCH_OPTIONS stMatchOptions;             // Face Matching Options
    NET_FACE_FILTER_CONDTION stFilterInfo;             // Query filters

    // Picture binary data
    char                *pBuffer;                      // Buffer address
    int                 nBufferLen;                    // Buffer data length  

    BOOL                bPersonExEnable;               // use stPersonInfoEx when bUsePersonInfoEx is true, otherwise use stPersonInfo
    FACERECOGNITION_PERSON_INFOEX   stPersonInfoEx;    // expansion of personnel information
    EM_OBJECT_TYPE      emObjectType;                  // The type of object
}NET_IN_STARTMULTIFIND_FACERECONGNITION;

// CLIENT_StartMultiFindFaceRecognition output parameters
typedef struct tagNET_OUT_STARTMULTIFIND_FACERECONGNITION
{
	DWORD               dwSize;
	int                 nTotalCount;                   // Record number of returns that match the query criteria
	LLONG               lFindHandle;                   // Query handle
	int                 nToken;                        // The search token received
}NET_OUT_STARTMULTIFIND_FACERECONGNITION;

// CLIENT_StartMultiFindFaceRecognitionRecord Corresponding Multimodal face recognition
typedef struct tagNET_IN_STARTMULTIFIND_FACERECONGNITIONRECORD 
{
    DWORD               dwSize;                         // Structure size
	
														// Search filter criteria
    NET_TIME            stStartTime;                    // start time
    NET_TIME            stEndTime;                      // closing time
    char                szMachineAddress[MAX_PATH];     // Place to support fuzzy matching     
    int                 nAlarmType;                     // To query the type of alarm, see EM_FACERECOGNITION_ALARM_TYPE
    BOOL                abPersonInfo;                   // staff info is valid or not
    FACERECOGNITION_PERSON_INFO stPersonInfo;           // staff info
    int*                pChannelID;                     // channel no.
	int					nChannelCount;					// number of channels
    int                 nGroupIdNum;                    // staff group  
    char                szGroupId[MAX_GOURP_NUM][DH_COMMON_STRING_64]; // staff group ID 
    
	BOOL                abPersonExInfo;                 // use stPersonInfoEx when bUsePersonInfoEx is true, otherwise use stPersonInfo
	FACERECOGNITION_PERSON_INFOEX	stPersonInfoEx;		// expansion of personnel information
}NET_IN_STARTMULTIFIND_FACERECONGNITIONRECORD;

// CLIENT_StartMultiFindFaceRecognitionRecord Corresponding Multimodal face recognition
typedef struct tagNET_OUT_STARTMULTIFIND_FACERECONGNITIONRECORD
{
	DWORD               dwSize;
    int                 nTotalCount;                   // Record number of returns that match the query criteria
	LLONG               lFindHandle;                   // Query handle
	int                nToken;                        // The search token received
}NET_OUT_STARTMULTIFIND_FACERECONGNITIONRECORD;

//CLIENT_DoFindFaceRecognitionRecord Inpute parameters
typedef struct tagNET_IN_DOFIND_FACERECONGNITIONRECORD
{
	DWORD               dwSize;
    int                 nTotalCount;                    // Record number of returns that match the query criteria	
	LLONG               lFindHandle;                    // Query handle 
	int					nBeginNumber;					// begin Number
}NET_IN_DOFIND_FACERECONGNITIONRECORD;

// Face Recognition data
typedef struct tagNET_DOFIND_FACERECONGNITIONRECORD_INFO
{
    BOOL                    bGlobalScenePic;                        // Does the panorama exist
    NET_PIC_INFO		    stGlobalScenePic;                       // Panoramic image file path
    DH_MSG_OBJECT           stuObject;                              // the target face object information
    NET_PIC_INFO			stObjectPic;                            // the target face file path
    int                     nCandidateNum;                          // Face Matching the current number of candidates
    CANDIDATE_INFO          stuCandidates[DH_MAX_CANDIDATE_NUM];    // Face candidates to match this informatio
    NET_CANDIDAT_PIC_PATHS_EX  stuCandidatesPic[DH_MAX_CANDIDATE_NUM]; // The current face matching candidates to the image file path
    NET_TIME                stTime;                                 // time for an alarm  
    char                    szAddress[MAX_PATH];                    // Place for an alarm
    int                     nChannelId;                             // channel no 
	BYTE					bReserved[256];							// Reserved
}NET_DOFIND_FACERECONGNITIONRECORD_INFO;

//CLIENT_DoFindFaceRecognitionRecord Out parameters
typedef struct tagNET_OUT_DOFIND_FACERECONGNITIONRECORD
{
	DWORD											dwSize;
	NET_DOFIND_FACERECONGNITIONRECORD_INFO			*stuResults;		// return date
	int												nResultNum;			// The number of memory applications for face recognition information
	int												nTotalCount;		// Actual number of returns
}NET_OUT_DOFIND_FACERECONGNITIONRECORD;

//Input parameters of interface CLIENT_DoFindFaceRecognitionRecordEx
typedef struct tagNET_IN_DOFIND_FACERECONGNITIONRECORD_EX
{
	DWORD               dwSize;
    int                 nTotalCount;                    // The count of needs to be obtained each time
	LLONG               lFindHandle;                    // Query handle
	int					nBeginNumber;					// The begin number, it means that start query record from beginNumber, and get nTotalCount records
}NET_IN_DOFIND_FACERECONGNITIONRECORD_EX;

// Face Recognition data
typedef struct tagNET_DOFIND_FACERECONGNITIONRECORD_INFO_EX
{
    BOOL                    bGlobalScenePic;                        // Dose the global scene picture exist
    NET_PIC_INFO			stGlobalScenePic;                       // The path of the global scene picture
    DH_MSG_OBJECT           stuObject;                              // The target face object information
    NET_PIC_INFO			stObjectPic;                            // The target face file path
    int                     nCandidateNum;                          // Face Matching the current number of candidates
    CANDIDATE_INFOEX        stuCandidates[DH_MAX_CANDIDATE_NUM];    // Face candidates to match this informatio
    NET_CANDIDAT_PIC_PATHS_EX  stuCandidatesPic[DH_MAX_CANDIDATE_NUM]; // The current face matching candidates to the image file path
    NET_TIME                stTime;                                 // Time for an alarm  
    char                    szAddress[MAX_PATH];                    // Place for an alarm
    int                     nChannelId;                             // Channel no 
	BYTE					bReserved[1024];						// Reserved
}NET_DOFIND_FACERECONGNITIONRECORD_INFO_EX;

//Output parameters of interface CLIENT_DoFindFaceRecognitionRecordEx
typedef struct tagNET_OUT_DOFIND_FACERECONGNITIONRECORD_EX
{
	DWORD											dwSize;
	NET_DOFIND_FACERECONGNITIONRECORD_INFO_EX		*pstResults;		// Face recongnition data returned(the memory is applied and released by user)
	int												nMaxResultNum;		// The number of memory applications for face recognition information
	int												nRetResultNum;		// Actual number of returns
}NET_OUT_DOFIND_FACERECONGNITIONRECORD_EX;

#define MAX_FIND_COUNT  20

// the format of the image returned in the query results
typedef enum tagEM_NEEDED_PIC_RETURN_TYPE
{
    EM_NEEDED_PIC_TYPE_UNKOWN,            // unknow
    EM_NEEDED_PIC_TYPE_HTTP_URL,          // http url
    EM_NEEDED_PIC_TYPE_BINARY_DATA,       // binary data
    EM_NEEDED_PIC_TYPE_HTTP_AND_BINARY,   // http url and binary data
}EM_NEEDED_PIC_RETURN_TYPE;

// CLIENT_DoFindFaceRecognition Interface input parameters
typedef struct __NET_IN_DOFIND_FACERECONGNITION
{
    DWORD               dwSize;
    LLONG               lFindHandle;                    // Query handle
    int                 nBeginNum;                      // Queries starting serial number
    int                 nCount;                         // The current number of records you want to search for
    EM_NEEDED_PIC_RETURN_TYPE	emDataType;             // the format of the image returned in the query results
}NET_IN_DOFIND_FACERECONGNITION;

// CLIENT_DoFindFaceRecognitionInterface output parameters
typedef struct __NET_OUT_FINDNEXT_FACERECONGNITION
{
    DWORD               dwSize;
    int                 nCadidateNum;                  // The actual number of candidate information structure returned
    CANDIDATE_INFO      stCadidateInfo[MAX_FIND_COUNT];// An array of candidate information

    // Picture binary data
    char                *pBuffer;                      // Buffer address
    int                 nBufferLen;                    // Buffer data length

    BOOL                bUseCandidatesEx;               // whether or not to use stuCandidatesEx
                                                        // stuCandidatesEx is effective and stuCandidates is invalid when the bUseCandidatesEx is TRUE, otherwise, on the contrary
    int                 nCadidateExNum;                 // the actual return number of stuCandidatesEx
    CANDIDATE_INFOEX    stuCandidatesEx[MAX_FIND_COUNT];// the expansion of candidate information
}NET_OUT_DOFIND_FACERECONGNITION;

// State of galsses
typedef enum tagEM_GLASSES_STATE
{
    EM_GLASSES_STATE_UNKNOWN,       // Unknown
    EM_GLASSES_STATE_NO,            // No glasses
    EM_GLASSES_STATE_WEAR,          // Wear glasses
} EM_GLASSES_STATE;

// Information of person in history database
typedef struct tagNET_HISTORY_PERSON_INFO
{
    char                		szUID[DH_MAX_PERSON_ID_LEN];                    // Personnel's unique identifier. It is generated by server for the first time, and different form ID; 
                                                                        		// And it is must be assigned value when modifying or deleting.
    EM_SEX_TYPE                 emSexType;                                      // Sex 
    UINT                        nAge;                                           // Age, 0 means unknown
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE	emEmotion;							// Emotion
    EM_GLASSES_STATE            emGlassesState;                                 // State of glasses
    EM_GLASSES_TYPE             emGlassesType;                                  // Type of glasses
    EM_RACE_TYPE                emRace;                                         // Race
    EM_EYE_STATE_TYPE			emEye;											// State of eyes
    EM_MOUTH_STATE_TYPE			emMouth;										// State of mouth
	EM_MASK_STATE_TYPE 			emMask;											// State of mask
	EM_BEARD_STATE_TYPE			emBeard;										// State of beard
	int							nAttractive;									// Attractive, -1 means invalid; 0 means unknown; recognition range:1-100; 
                                                                                // The bigger the value, the higher the attractive
    UINT                		nFacePicNum;                                    // Count of pictures
    NET_FACE_IMAGE_INFO         stuFacePicInfo[DH_MAX_PERSON_IMAGE_NUM];        // Picture information about the person
    BYTE                        bReserved[2048];					            // Reserved
} NET_HISTORY_PERSON_INFO;

// Personnel information reported actively when searching history database by picture
typedef struct tagNET_HISTORY_ACTIVE_CANDIDATE
{
    UINT                    nSimilarity;                    // Similarity
    int                     nChannelID;                     // Channel ID
    NET_HISTORY_PERSON_INFO stuHistoryPerson;               // Information of person in history database
    NET_TIME                stuTime;                        // Means that the query time staff appeared
    NET_FACE_IMAGE_INFO		stuSceneImage;					// scene image
    BYTE                    bReserved[1236];					// Reserved
} NET_HISTORY_ACTIVE_CANDIDATE;

#define MAX_CANDIDATE_NUM        50      // Max num of candidate

// Result information reported actively when searching history database by picture
typedef struct tagNET_RESULT_OF_FINDHISTORY_BYPIC
{
    UINT                            nSmallPicID;                            // Small picture ID
    UINT                            nPictureID;                             // Face picture ID
    UINT                            nCandidateNum;                          // Candidate number
    NET_HISTORY_ACTIVE_CANDIDATE    stuCandidateInfo[MAX_CANDIDATE_NUM];    // Candidate information
    BYTE                            bReserved[1024];				        // Reserved
} NET_RESULT_OF_FINDHISTORY_BYPIC;

#define MAX_FINDPERSON_RESULT_NUM       32 // Max number of result information reported actively when searching history database by picture

// Callback information about searching history database by picture
typedef struct tagNET_CB_RESULT_OF_FIND_HISTORY_BYPIC
{
    UINT                                nToken;                                         // Token
    UINT                                nProgress;                                      // Progress
    UINT                                nTotalCount;                                    // Total count of qualified persons
    int                                 nHistoryResultNum;                              // Number of result information reported actively when searching history database by picture
    NET_RESULT_OF_FINDHISTORY_BYPIC     stuHistoryResult[MAX_FINDPERSON_RESULT_NUM];    // Result information reported actively when searching history database by picture
    BYTE                                bReserved[1024];				                // Reserved
} NET_CB_RESULT_OF_FIND_HISTORY_BYPIC;

// Callback function of searching history database by picture, lAttachHandle is returned by CLIENT_AttachResultOfFindHistoryByPic
typedef void (CALLBACK *fResultOfFindHistory)(LLONG lAttachHandle, NET_CB_RESULT_OF_FIND_HISTORY_BYPIC* pstesult, const char *pBinBuf, int nBinBufLen, LDWORD dwUser);

// Input parameter of CLIENT_AttachResultOfFindHistoryByPic
typedef struct tagNET_IN_ATTACH_RESULT_FINDHISTORY_BYPIC
{
    DWORD                   dwSize;                     // Struct size
    UINT                    nToken;                     // Token, it is returned by CLIENT_StartFindFaceRecognition
    fResultOfFindHistory    cbResultOfFindHistory;      // Callback function of searching history database by picture
    LDWORD                  dwUser;                     // User data
} NET_IN_ATTACH_RESULT_FINDHISTORY_BYPIC;

// Output parameter of CLIENT_AttachResultOfFindHistoryByPic
typedef struct tagNET_OUT_ATTACH_RESULT_FINDHISTORY_BYPIC
{
    DWORD                   dwSize;                     // Struct size
} NET_OUT_ATTACH_RESULT_FINDHISTORY_BYPIC;

// Human information reported actively when searching history database by picture
typedef struct tagNET_HUMANHISTORY_CANDIDATE
{
    UINT                    nSimilarity;                    // Similarity
    int                     nChannelID;                     // ChannelID
    NET_HISTORY_HUMAN_INFO  stuHistoryHuman;                // Human info in history data base
    NET_TIME                stuTime;                        // Means that the query time staff appeared
    NET_FACE_IMAGE_INFO		stuSceneImage;					// Human scene image
    BYTE                    bReserved[748];				    // Reserved
} NET_HUMANHISTORY_CANDIDATE;

// Result information reported actively when searching human history database by picture
typedef struct tagNET_RESULT_OF_HUMANHISTORY_BYPIC
{
    UINT                            nSmallPicID;                            // Small picture ID
    UINT                            nPictureID;                             // Face picture ID
    NET_HUMANHISTORY_CANDIDATE      stuCandidateInfo[50];                   // Human candidate info
    UINT                            nCandidateNum;                          // Human candidate number
    BYTE                            bReserved[1028];				        // Reserved
} NET_RESULT_OF_HUMANHISTORY_BYPIC;

// Callback information about searching human history database by picture
typedef struct tagNET_CB_RESULT_OF_HUMAN_HISTORY_BYPIC
{
    UINT                                nToken;                                         // Token
    UINT                                nProgress;                                      // Process
    UINT                                nTotalCount;                                    // Total count of qualified humans
    int                                 nHistoryResultNum;                              // Number of result information reported actively when searching human history database by picture
    NET_RESULT_OF_HUMANHISTORY_BYPIC    stuHistoryResult[32];                           // Result information reported actively when searching human history database by picture
    BYTE                                bReserved[1024];				                // Reserved
} NET_CB_RESULT_OF_HUMAN_HISTORY_BYPIC;

// Callback function of searching human history database by picture, lAttachHandle is returned by CLIENT_AttachResultOfHumanHistoryByPic
typedef void (CALLBACK *fResultOfHumanHistory)(LLONG lAttachHandle, NET_CB_RESULT_OF_HUMAN_HISTORY_BYPIC* pstesult, const char *pBinBuf, int nBinBufLen, LDWORD dwUser);

// Input param of CLIENT_AttachResultOfHumanHistoryByPic
typedef struct tagNET_IN_ATTACH_RESULT_HUMAN_HISTORY_BYPIC
{
    DWORD                   dwSize;                     // Struct size
    UINT                    nToken;                     // Token, it is returned by CLIENT_StartFindFaceRecognition
    fResultOfHumanHistory   cbResultOfHumanHistory;     // Callback function of searching human history database by picture
    LDWORD                  dwUser;                     // User data
} NET_IN_ATTACH_RESULT_HUMAN_HISTORY_BYPIC;

// Output param of CLIENT_AttachResultOfHumanHistoryByPic
typedef struct tagNET_OUT_ATTACH_RESULT_HUMAN_HISTORY_BYPIC
{
    DWORD                   dwSize;                     // Struct size
} NET_OUT_ATTACH_RESULT_HUMAN_HISTORY_BYPIC;

// CLIENT_DetectFaceInterface input parameters
typedef struct __NET_IN_DETECT_FACE
{
	DWORD               dwSize; 
	DH_PIC_INFO         stPicInfo;                     // Big picture information

	// Picture binary data
	char                *pBuffer;                      // Buffer address
	int                 nBufferLen;                    // Buffer data length
}NET_IN_DETECT_FACE;

// CLIENT_DetectFaceInterface output parameters
typedef struct __NET_OUT_DETECT_FACE
{
	DWORD               dwSize; 
	DH_PIC_INFO         *pPicInfo;                     // The detected face image information from the user space applications, apply to sizeof(DH_PIC_INFO)*nMaxPicNum
	int                 nMaxPicNum;                    // The maximum number of face image information
	int                 nRetPicNum;                    // The actual number of returning faces pictures
	
	// Picture binary data
	char                *pBuffer;                      // Buffer address, the user application space to store the detected face image data
	int                 nBufferLen;                    // Buffer data length
}NET_OUT_DETECT_FACE;

// staff group operation enumeration
typedef enum tagEM_OPERATE_FACERECONGNITION_GROUP_TYPE
{
  NET_FACERECONGNITION_GROUP_UNKOWN,
  NET_FACERECONGNITION_GROUP_ADD,           // add staff group info 
  NET_FACERECONGNITION_GROUP_MODIFY,         // modify staff group info  
  NET_FACERECONGNITION_GROUP_DELETE,         // delete staff group info 
}EM_OPERATE_FACERECONGNITION_GROUP_TYPE;

// staff group info 
typedef struct tagNET_FACERECONGNITION_GROUP_INFO
{
    DWORD       				dwSize;
	EM_FACE_DB_TYPE   			emFaceDBType;         					// staff group type ,  see  EM_FACE_DB_TYPE
	char        				szGroupId[DH_COMMON_STRING_64];			// staff group ID, SN(cannot modify, invalid when adding operation)
	char        				szGroupName[DH_COMMON_STRING_128]; 		// staff operation name 
	char        				szGroupRemarks[DH_COMMON_STRING_256]; 	// staff group note info 
	int         				nGroupSize;          					// current group staff number
	int		  					nRetSimilarityCount;					// rect similarity count
	int		  					nSimilarity[MAX_SIMILARITY_COUNT];		// library similarity threshold
	int		  					nRetChnCount; 							// rect channel count
	int		  					nChannel[DH_MAX_CAMERA_CHANNEL_NUM];	// the list of channels
	UINT						nFeatureState[MAX_FEATURESTATE_NUM];    // feature state of the group:
																	    // [0]-the number of people ready to model, but no guarantee of sucess
																	    // [1]-the number of people who failed to model, need to change the picture
																	    // [2]-the number of people who success to model, the data can be used for face recognition
																	    // [3]-once modeling was successful, but became unusable after upgrading, need to abstract
	EM_REGISTER_DB_TYPE 		emRegisterDbType;						// type of register face DB
}NET_FACERECONGNITION_GROUP_INFO;

// add staff group info 
typedef struct tagNET_ADD_FACERECONGNITION_GROUP_INFO
{
  DWORD        dwSize;
  NET_FACERECONGNITION_GROUP_INFO stuGroupInfo;   // staff group info 
}NET_ADD_FACERECONGNITION_GROUP_INFO;

// delete staff group info 
typedef struct tagNET_DELETE_FACERECONGNITION_GROUP_INFO
{
  DWORD        dwSize;
  char         szGroupId[DH_COMMON_STRING_64];	// staff group ID, SN staff
}NET_DELETE_FACERECONGNITION_GROUP_INFO;

// modify staff group info 
typedef struct tagNET_MODIFY_FACERECONGNITION_GROUP_INFO
{
  DWORD        dwSize;
  NET_FACERECONGNITION_GROUP_INFO stuGroupInfo;   // staff group info 
}NET_MODIFY_FACERECONGNITION_GROUP_INFO;

// CLIENT_OperateFaceRecognitionGroup port input parameter
typedef struct tagNET_IN_OPERATE_FACERECONGNITION_GROUP
{
  DWORD        dwSize;
  EM_OPERATE_FACERECONGNITION_GROUP_TYPE emOperateType; // operation type, the space application by the user,please refer to the structure of operate type 
														// if operate type is NET_FACERECONGNITION_GROUP_ADD,corresponding to NET_ADD_FACERECONGNITION_GROUP_INFO
														// if operate type is NET_FACERECONGNITION_GROUP_MODIFY,corresponding to NET_MODIFY_FACERECONGNITION_GROUP_INFO
														// if operate type is NET_FACERECONGNITION_GROUP_DELETE,corresponding to NET_DELETE_FACERECONGNITION_GROUP_INFO
  void        *pOPerateInfo;         					// operation info 
}NET_IN_OPERATE_FACERECONGNITION_GROUP;  

// CLIENT_OperateFaceRecognitionGroup port output parameter
typedef struct tagNET_OUT_OPERATE_FACERECONGNITION_GROUP
{
  DWORD       dwSize;
  char        szGroupId[DH_COMMON_STRING_64]; // new record staff group ID, SN staff
}NET_OUT_OPERATE_FACERECONGNITION_GROUP;  

// max num of get face recognition server person type
#define MAX_FACE_RECOGNITION_SERVER_PERSON_TYPE		64

// CLIENT_GetFaceRecognitionPersonType input parameter
typedef struct tagNET_IN_GET_FACERECOGNITION_PERSON_TYPE
{
    DWORD               dwSize;				// struct size
} NET_IN_GET_FACERECOGNITION_PERSON_TYPE;   

// CLIENT_GetFaceRecognitionPersonType output parameter
typedef struct tagNET_OUT_GET_FACERECOGNITION_PERSON_TYPE
{
    DWORD               dwSize;																		// struct size
    char                szPersonType[MAX_FACE_RECOGNITION_SERVER_PERSON_TYPE][DH_COMMON_STRING_16];	// person type
	int					nPersonTypeNum;																// number of person type
	BYTE                byDefault[DH_COMMON_STRING_16];												// person type, see EM_PERSON_TYPE
	int					nDefaultNum;																// return person type NumBer																	// Personnel types, see EM_PERSON_TYPE
} NET_OUT_GET_FACERECOGNITION_PERSON_TYPE; 

// CLIENT_GetDevCaps (NET_FACERECOGNITIONSE_CAPS) input parameter
typedef struct tagNET_IN_FACERECOGNITIONSERVER_CAPSBILITYQUERY
{
    DWORD               dwSize;				// struct size
} NET_IN_FACERECOGNITIONSERVER_CAPSBILITYQUERY;

// Face Box color caps
typedef struct tagNET_FACEBOXCOLOR_CAPS
{
	BOOL				bSupport;				// whether support Face box color change
	NET_COLOR_RGBA		stuDefaultColor;		// Default color
	BYTE				byReserved[1024];		// Reserved
}NET_FACEBOXCOLOR_CAPS;

// Is it supported to search by pictures
typedef enum tagEM_SUPPORT_SEARCH_BY_PIC
{
    EM_SUPPORT_SEARCH_BY_PIC_UNKNOWN,       // Unknown, IVSS, NVR, DVR are very likely to support search by picture, and ipc-fr is not support search by picture.
    EM_SUPPORT_SEARCH_BY_PIC_UNSUPPORT,     // Unsuppoer
    EM_SUPPORT_SEARCH_BY_PIC_SUPPORT,       // Support
} EM_SUPPORT_SEARCH_BY_PIC;

// CLIENT_GetDevCaps (NET_FACERECOGNITIONSE_CAPS) output parameter
typedef struct tagNET_OUT_FACERECOGNITIONSERVER_CAPSBILITYQUERY
{
    DWORD                       dwSize;                 // struct size
    BOOL                        bmultiFind;             // support multi channel
    UINT                        nmaxFaceType;           // Maximum number of face face types supported
    NET_FACEBOXCOLOR_CAPS       stuFaceBoxColor;        // Face Box color caps
    BOOL                        bAsynPush;              // Whether to support push data which is returned by searching face database by picture
    UINT                        nMaxGroupNum;           // Max group number, 0 means invalid
    UINT                        nMaxPersonNum;          // Max person number, 0 means invalid
    UINT                        nMultiAppendPicLength;  // The size of each image recevied about milti appen, unit:KB
    EM_SUPPORT_SEARCH_BY_PIC    emSupportSearchByPic;   // Is it supported to search by pictures
    DWORD                       dwSearchTypeMask;       // Object type about search by pictures, it is effective when emSupportSearchByPic is EM_SUPPORT_SEARCH_BY_PIC_SUPPORT
                                                        // bit0:face, bit1:human, bit2:traffiv,  bit3:nomotor
    UINT                        nSinglePicMaxLength;    // single picture max length, uint:KB
} NET_OUT_FACERECOGNITIONSERVER_CAPSBILITYQUERY;  

// operate face recognition person type
typedef enum tagEM_OPERATE_FACERECOGNITION_PERSON_TYPE
{
    NET_PERSON_TYPE_UNKOWN,				// unknown
	NET_PERSON_TYPE_ADD,				// add face recongnition person type
	NET_PERSON_TYPE_MODIFY,				// modify face recongnition person type
	NET_PERSON_TYPE_DELETE,				// delete face recongnition person type
} EM_OPERATE_FACERECOGNITION_PERSON_TYPE;

// add face recongnition person type
typedef struct tagNET_ADD_FACERECOGNITION_PERSON_TYPE_INFO
{
    DWORD               dwSize;									// struct size
	char				szType[DH_COMMON_STRING_16];			// person type
} NET_ADD_FACERECOGNITION_PERSON_TYPE_INFO;   

// modify face recongnition person type
typedef struct tagNET_MODIFY_FACERECOGNITION_PERSON_TYPE_INFO
{
    DWORD               dwSize;									// struct size
	char				szType[DH_COMMON_STRING_16];			// person type
	char				szNewType[DH_COMMON_STRING_16];			// new person type
} NET_MODIFY_FACERECOGNITION_PERSON_TYPE_INFO;   

// delete face recongnition person type
typedef struct tagNET_DELETE_FACERECOGNITION_PERSON_TYPE_INFO
{
    DWORD               dwSize;									// struct size
	char				szType[DH_COMMON_STRING_16];			// person type
} NET_DELETE_FACERECOGNITION_PERSON_TYPE_INFO;   

// CLIENT_OperateFaceRecognitionPersonType input parameter
typedef struct tagNET_IN_OPERATE_FACERECOGNITION_PERSON_TYPE
{
    DWORD											dwSize;			// struct size
    EM_OPERATE_FACERECOGNITION_PERSON_TYPE			emOperateType;	// operate type
    void											*pOPerateInfo;	// the space application by the user,please refer to the structure of operate type 
																	// if operate type is NET_PERSON_TYPE_ADD,corresponding to NET_ADD_FACERECONGNITION_PERSON_TYPE_INFO
																	// if operate type is NET_PERSON_TYPE_MODIFY,corresponding to NET_MODIFY_FACERECONGNITION_PERSON_TYPE_INFO
																	// if operate type is NET_PERSON_TYPE_DELETE,corresponding to NET_DELETE_FACERECONGNITION_PERSON_TYPE_INFO
} NET_IN_OPERATE_FACERECOGNITION_PERSON_TYPE;   

// CLIENT_OperateFaceRecognitionPersonType output parameter (when delete face recongnition person type is efficacious)
typedef struct tagNET_OUT_OPERATE_FACERECOGNITION_PERSON_TYPE
{
    DWORD               dwSize;										// struct size
    char                szFailedCode[DH_COMMON_STRING_16];			// failed code
} NET_OUT_OPERATE_FACERECOGNITION_PERSON_TYPE;   

// CLIENT_FindGroupInfo port input parameter
typedef struct tagNET_IN_FIND_GROUP_INFO  
{
  DWORD       dwSize;
  char        szGroupId[DH_COMMON_STRING_64];// staff ID, SN staff, as null means search all staff group info 
}NET_IN_FIND_GROUP_INFO;

// CLIENT_FindGroupInfo port output parameter
typedef struct tagNET_OUT_FIND_GROUP_INFO  
{
  DWORD       dwSize;
  NET_FACERECONGNITION_GROUP_INFO *pGroupInfos;   // staff group info , apply space by user, apply to sizeof(NET_FACERECONGNITION_GROUP_INFO)*nMaxGroupNum
  int         nMaxGroupNum;         			  // current applied group size
  int         nRetGroupNum;         			  // device returned staff group number 
}NET_OUT_FIND_GROUP_INFO;


// CLIENT_SetGroupInfoForChannel port input parameter
typedef struct tagNET_IN_SET_GROUPINFO_FOR_CHANNEL
{
  DWORD       dwSize;
  int         nChannelID;         							// channel no.
  int         nGroupIdNum;          						// staff group  
  char        szGroupId[MAX_GOURP_NUM][DH_COMMON_STRING_64];// staff group ID, [""] means that the video channels does not face the surveillance group, face recognition for face detection degradation  
  int		  nSimilaryNum; 				  				// the number of similary, same as nGroupIdNum
  int		  nSimilary[MAX_GOURP_NUM]; 	  				// the similary value, 0-100
}NET_IN_SET_GROUPINFO_FOR_CHANNEL;
// CLIENT_SetGroupInfoForChannel port output parameter
typedef struct tagNET_OUT_SET_GROUPINFO_FOR_CHANNEL
{
  DWORD        dwSize;
}NET_OUT_SET_GROUPINFO_FOR_CHANNEL;

// CLIENT_GetGroupInfoForChannel port input parameter
typedef struct tagNET_IN_GET_GROUPINFO_FOR_CHANNEL
{
    DWORD              dwSize;
    int                nChannelID;                    // channel no.
}NET_IN_GET_GROUPINFO_FOR_CHANNEL;

// CLIENT_GetGroupInfoForChannel port output parameter
typedef struct tagNET_OUT_GET_GROUPINFO_FOR_CHANNEL
{
    DWORD               dwSize;
	int                 nGroupIdNum;                    // staff group number  
    char                szGroupId[MAX_GOURP_NUM][DH_COMMON_STRING_64]; // staff group ID 
    int					nSimilaryNum;					// the number of similary, same as nGroupIdNum
    int					nSimilary[MAX_GOURP_NUM];		// the similary value, 0-100
}NET_OUT_GET_GROUPINFO_FOR_CHANNEL;

typedef struct tagNET_CB_FACE_FIND_STATE
{
    DWORD               dwSize;     
    int                 nToken;         //Video synopsis task database main key ID 
    int                 nProgress;      //Normal value: 0-100. 1=Searched token does not exist (When subscribe a search that does not exist or already finished)
    int                 nCurrentCount;  //The human face amount that match current criteria
}NET_CB_FACE_FIND_STATE;
typedef void (CALLBACK *fFaceFindState)(LLONG lLoginID, LLONG lAttachHandle, NET_CB_FACE_FIND_STATE* pstStates, int nStateNum, LDWORD dwUser);

//CLIENT_AttachFaceFindState interface parameter in
typedef struct tagNET_IN_FACE_FIND_STATE
{
    DWORD           dwSize;             //Structure size. Must fill in. 
    int             nTokenNum;          //Search token. 0=subscribe all searched tasks.
    int            *nTokens;            //Search toke,the space application by the user, apply to sizeof(int)*nTokenNum
    fFaceFindState  cbFaceFindState;    //Call function 
    LDWORD          dwUser;             //User data 
}NET_IN_FACE_FIND_STATE;
// CLIENT_AttachFaceFindState interface parameter in
 typedef struct  tagNET_OUT_FACE_FIND_STATE
 {
    DWORD           dwSize;
 }NET_OUT_FACE_FIND_STATE;
// CLIENT_FaceRecognitionSetSearchImageInfo 
typedef struct tagNET_IN_FACE_RECOGNITION_SET_SEARCH_IMAGE_INFO
{
    DWORD               dwSize;
    int                 nChannel;                           // Channel ID
    char                szFilePath[DH_COMMON_STRING_256];   // File path
}NET_IN_FACE_RECOGNITION_SET_SEARCH_IMAGE_INFO;
// CLIENT_FaceRecognitionSetSearchImageInfo 
typedef struct tagNET_OUT_FACE_RECOGNITION_SET_SEARCH_IMAGE_INFO
{
    DWORD                dwSize;
}NET_OUT_FACE_RECOGNITION_SET_SEARCH_IMAGE_INFO;

// info of disposition channel
typedef struct tagNET_DISPOSITION_CHANNEL_INFO
{
	int					nChannelID;			// channel ID
	int					nSimilary;			// similary, 0-100
	BYTE				bReserved[256];		// Reserved
} NET_DISPOSITION_CHANNEL_INFO;

// input parameter of CLIENT_FaceRecognitionPutDisposition
typedef struct tagNET_IN_FACE_RECOGNITION_PUT_DISPOSITION_INFO
{
	DWORD               			dwSize;
	char                			szGroupId[DH_COMMON_STRING_64]; 					// group ID
	int								nDispositionChnNum;									// count of disposition channels
	NET_DISPOSITION_CHANNEL_INFO	stuDispositionChnInfo[DH_MAX_CAMERA_CHANNEL_NUM];	// info of disposition channels
} NET_IN_FACE_RECOGNITION_PUT_DISPOSITION_INFO;

// output parameter of CLIENT_FaceRecognitionPutDisposition
typedef struct tagNET_OUT_FACE_RECOGNITION_PUT_DISPOSITION_INFO
{
	DWORD               dwSize;
	int					nReportCnt;							// the result count
	BOOL				bReport[DH_MAX_CAMERA_CHANNEL_NUM];	// the result, TRUE-success, FALSE-failed
} NET_OUT_FACE_RECOGNITION_PUT_DISPOSITION_INFO;

// input parameter of CLIENT_FaceRecognitionDelDisposition
typedef struct tagNET_IN_FACE_RECOGNITION_DEL_DISPOSITION_INFO
{
	DWORD               			dwSize;											// the size of this struct
	char                			szGroupId[DH_COMMON_STRING_64]; 				// group ID
	int								nDispositionChnNum;								// the count of disposition channels
	int								nDispositionChn[DH_MAX_CAMERA_CHANNEL_NUM];		// the list of disposition channels
} NET_IN_FACE_RECOGNITION_DEL_DISPOSITION_INFO;

// output parameter of CLIENT_FaceRecognitionDelDisposition
typedef struct tagNET_OUT_FACE_RECOGNITION_DEL_DISPOSITION_INFO
{
	DWORD               dwSize;								// the size of this struct
	int					nReportCnt;							// the result count
	BOOL				bReport[DH_MAX_CAMERA_CHANNEL_NUM];	// the result, TRUE-success, FALSE-falied
} NET_OUT_FACE_RECOGNITION_DEL_DISPOSITION_INFO;

#define MAX_BIG_PIC_NUM     50      // max number of large images
#define MAX_TOKEN_NUM       128     // max number of token

// large image info (the function of detect small image from large image)
typedef struct tagNET_DETECT_BIG_PIC_INFO
{
    int             nPicID;                                     // large image ID
    DWORD           dwOffSet;                                   // the offset position of the large image in the binary data, unit:bytes
    DWORD           dwFileLenth;                                // the length of the file, unit:bytes
    DWORD           dwWidth;                                    // the width of this image, unit:pixel
    DWORD           dwHeight;                                   // the height of this image, unit:pixel
    int             nDetectRegionNum;                           // Points number of detect region
    NET_POINT       stuDetectRegion[DH_MAX_DETECT_REGION_NUM];  // Detect region
    BYTE            bReserved[44];                              // Reserved
}NET_DETECT_BIG_PIC_INFO;

// the input parameter of interface CLIENT_FaceRecognitionDetectMultiFace
typedef struct tagNET_IN_FACE_RECOGNITION_DETECT_MULTI_FACE_INFO
{
    DWORD                       dwSize;                         // the size of this struct
    int                         nBigPicNum;                     // the number of large image
    NET_DETECT_BIG_PIC_INFO     stuBigPicInfo[MAX_BIG_PIC_NUM]; // the info of large image

    // the binary data of image
    char                        *pBuffer;                       // the buffer of the image
    int                         nBufferLen;                     // the length of th buffer
    EM_OBJECT_TYPE              emDetectObjType;                // Object type
} NET_IN_FACE_RECOGNITION_DETECT_MULTI_FACE_INFO;

// the output parameter of interface CLIENT_FaceRecognitionDetectMultiFace
typedef struct tagNET_OUT_FACE_RECOGNITION_DETECT_MULTI_FACE_INFO
{
    DWORD                       dwSize;                         // the size of this struct
} NET_OUT_FACE_RECOGNITION_DETECT_MULTI_FACE_INFO;

// the small image info in the large image
typedef struct tagNET_SMALL_PIC_INFO
{
    int                         nSmallPicId;                // small image ID
    NET_RECT                    stuRect;                    // the postion of the small image in the large image
    EM_OBJECT_TYPE              emDetectObjType;            // bject type
    BYTE                        bReserved[124];             // Reserved
} NET_SMALL_PIC_INFO;

// Error code of multi detect in scene image
typedef enum tagEM_MULTIFACE_DETECT_ERRCODE
{
    EM_MULTIFACE_DETECT_UNKNOWN     = -1,       // Unknown
    EM_MULTIFACE_DETECT_SUCCESS,                // Success
    EM_MULTIFACE_DETECT_DECODE_FAIL,            // Decode fail
    EM_MULTIFACE_DETECT_NO_OBJECT,              // No effect object
} EM_MULTIFACE_DETECT_ERRCODE;

// the result of detection small image from the large image
typedef struct tagNET_IMAGE_RELATION
{
    int                         nBigPicId;                          // large image ID
    int                         nSmallPicNum;                       // the number of small image in the large image
    NET_SMALL_PIC_INFO          stuSmallPicInfo[MAX_SMALLPIC_NUM];  // the info of small image in the large image
    EM_MULTIFACE_DETECT_ERRCODE emDetectErrCode;                    // Error code of multi detect in scene image
    BYTE                        bReserved[124];                     // Reserved
} NET_IMAGE_RELATION;

//  the callback struct of detection small image from the large image
typedef struct tagNET_CB_MULTIFACE_DETECT_STATE
{
    int                         nProgress;                      // the progress of detection
    NET_IMAGE_RELATION          stuImageRelation;               // the result of detection small image from the large image
    BYTE                        byReserved[512];                // Reserved
} NET_CB_MULTIFACE_DETECT_STATE;

// the callback function of detection small image form the large image
typedef void (CALLBACK *fMultiFaceDetectState)(LLONG lAttachHandle, NET_CB_MULTIFACE_DETECT_STATE *pstStates, LDWORD dwUser);

// the input parameter of interface CLIENT_AttachDetectMultiFaceState
typedef struct tagNET_IN_MULTIFACE_DETECT_STATE
{
    DWORD                       dwSize;                         // the size of this struct
    BYTE                        bReserved[4];                   // for byte alignment
    fMultiFaceDetectState       cbMultiFaceDetectState;         // callback function
    LDWORD                      dwUser;                         // user data
} NET_IN_MULTIFACE_DETECT_STATE;

// the output parameter of interface CLIENT_AttachDetectMultiFaceState
typedef struct tagNET_OUT_MULTIFACE_DETECT_STATE
{
    DWORD                       dwSize;                         // the size of this struct
} NET_OUT_MULTIFACE_DETECT_STATE;

// information about remodeling person
typedef struct tagNET_REABSTRACT_PERSON_INFO
{
	char                		szUID[DH_MAX_PERSON_ID_LEN];   // person unique ID
	BYTE						bReserved[1024];	
} NET_REABSTRACT_PERSON_INFO;

// the input parameter of interface CLIENT_FaceRecognitionReAbstract
typedef struct tagNET_IN_FACE_RECOGNITION_REABSTRACT_INFO
{
	DWORD						dwSize;							// the size of this struct
	int							nPersonNum;						// the count of remodeling persons
	NET_REABSTRACT_PERSON_INFO	*pstReAbstractPersonInfo;		// information about remodeling person
} NET_IN_FACE_RECOGNITION_REABSTRACT_INFO;

// the output parameter of interface CLIENT_FaceRecognitionReAbstract
typedef struct tagNET_OUT_FACE_RECOGNITION_REABSTRACT_INFO
{
	DWORD						dwSize;							// the size of this struct
} NET_OUT_FACE_RECOGNITION_REABSTRACT_INFO;

// the input parameter of interface CLIENT_FaceRecognitionGroupReAbstract
typedef struct tagNET_IN_FACE_RECOGNITION_GROUP_REABSTRACT_INFO
{
	DWORD						dwSize;											// the size of this struct
	int							nGroupNum;										// the count of the groups
	char						szGroupId[MAX_GOURP_NUM][DH_COMMON_STRING_64];	// group ID
} NET_IN_FACE_RECOGNITION_GROUP_REABSTRACT_INFO;

// the output parameter of interface CLIENT_FaceRecognitionGroupReAbstract
typedef struct tagNET_OUT_FACE_RECOGNITION_GROUP_REABSTRACT_INFO
{
	DWORD						dwSize;							// the size of this struct
	UINT						nToken;							// the token of remodelingwich can be used to stop remodeling
} NET_OUT_FACE_RECOGNITION_GROUP_REABSTRACT_INFO;

// the input parameter of interface CLIENT_FaceRecognitionStopGroupReAbstract
typedef struct tagNET_IN_FACE_RECOGNITION_STOP_GROUP_REABSTRACT_INFO
{
	DWORD						dwSize;							// the size of this struct
	UINT						nToken;							// the token of remodeling
} NET_IN_FACE_RECOGNITION_STOP_GROUP_REABSTRACT_INFO;

// the output parameter of interface CLIENT_FaceRecognitionStopGroupReAbstract
typedef struct tagNET_OUT_FACE_RECOGNITION_STOP_GROUP_REABSTRACT_INFO
{
	DWORD						dwSize;							// the size of this struct
} NET_OUT_FACE_RECOGNITION_STOP_GROUP_REABSTRACT_INFO;

// the input parameter of interface CLIENT_GetFaceParam
typedef struct tagNET_IN_GET_FACE_PARAM
{
    DWORD                       dwSize;                         // the size of this struct
    int                         nChannel;                       // channel id
} NET_IN_GET_FACE_PARAM;

// the output parameter of interface CLIENT_GetFaceParam
typedef struct tagNET_OUT_GET_FACE_PARAM
{
    DWORD                       dwSize;                         // the size of this struct
    int                         nRegMinQuality;                 // picture quality threshold, 1-100
    UINT                        nMinFaceSize;                   // min face size, Default 0 means no validity
    unsigned short              nConfidence;                    // confidence, 1-100, Default 0 means no validity
    unsigned short              nAlignScore;                    // face Angle Filtration in storage, aligned score, 1-100, Default 0 means no validity    
    short                       nRoll;                          // face Angle Filtration in storage, rool, -90~90, Default 0 means no validity
    short                       nPitch;                         // face Angle Filtration in storage, pitch, -90~90, Default 0 means no validity
    short                       nYaw;                           // face Angle Filtration in storage, yaw, -90~90, Default 0 means no validity
    BYTE                        reserved[2];                    // reserved
} NET_OUT_GET_FACE_PARAM;

// the input parameter of interface CLIENT_SetFaceParam
typedef struct tagNET_IN_SET_FACE_PARAM
{
    DWORD                       dwSize;                         // the size of this struct
    int                         nChannel;                       // channel
    int                         nRegMinQuality;                 // picture quality threshold, 1-100
    UINT                        nMinFaceSize;                   // min face size, Default 0 means no validity
    unsigned short              nConfidence;                    // confidence, 1-100, Default 0 means no validity
    unsigned short              nAlignScore;                    // face Angle Filtration in storage, aligned score, 1-100, Default 0 means no validity
    short                       nRoll;                          // face Angle Filtration in storage, rool, -90~90, Default 0 means no validity
    short                       nPitch;                         // face Angle Filtration in storage, pitch, -90~90, Default 0 means no validity
    short                       nYaw;                           // face Angle Filtration in storage, yaw, -90~90, Default 0 means no validity
    BYTE                        reserved[6];                    // reserved
} NET_IN_SET_FACE_PARAM;

// the output parameter of interface  CLIENT_SetFaceParam
typedef struct tagNET_OUT_SET_FACE_PARAM
{
    DWORD                       dwSize;                         // the size of this struct
} NET_OUT_SET_FACE_PARAM;

//////////////////////////////// burn the upload////////////////////////////////
// fBurnCheckCallBack Parameter
typedef struct tagNET_CB_BURN_CHECK_STATE
{
	DWORD		        dwSize;
	const char*         szType;							// Message Type
														// "Checking": Check in
														// "CheckResult": CheckResult
	BOOL				bCheckResult;					// Calibration results for "CheckResult", TRUE-success, FALSE-failure
	BYTE				byProgress;						// Calibration schedule for "Checking", the percentage of 0 to 100
	BYTE				reserved[3];
} NET_CB_BURN_CHECK_STATE;

// Burn verification callback function prototype, lAttachHandle return value is CLIENT_AttachBurnCheckState
typedef void (CALLBACK *fBurnCheckCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_CB_BURN_CHECK_STATE* pstState, void* reserved, LDWORD dwUser);

// CLIENT_AttachBurnCheckState Input parameter interface (monitor burn parity status)
typedef struct tagNET_IN_ATTACH_BURN_CHECK 
{
	DWORD				dwSize;
	fBurnCheckCallBack  cbBurnCheck;					// Burn verification callback
	LDWORD              dwUser;							// User data
} NET_IN_ATTACH_BURN_CHECK;

// CLIENT_AttachBurnCheckState Output parameters of the interface (listening burning parity status)
typedef struct tagNET_OUT_ATTACH_BURN_CHECK
{
    DWORD            dwSize;
} NET_OUT_ATTACH_BURN_CHECK;

///////////////////////////////// logical device /////////////////////////////////

typedef struct tagNET_CB_CAMERASTATE
{
	DWORD		        dwSize;
	int                 nChannel;             // channel
	CONNECT_STATE       emConnectState;       // state of connect
}NET_CB_CAMERASTATE;

// CLIENT_AttachCameraState()callback function, pBuf->dwSize == nBufLen
typedef void (CALLBACK *fCameraStateCallBack) (LLONG lLoginID, LLONG lAttachHandle, const NET_CB_CAMERASTATE *pBuf, int nBufLen, LDWORD dwUser);

// CLIENT_AttachCameraState()input param
typedef struct tagNET_IN_CAMERASTATE
{
	DWORD		        dwSize;
	int *               pChannels;             // observation of the channel, if the value = -1,is boservate all channel
											   // the space application by the user,apply to  sizeof(int)*nChannels
	int                 nChannels;             // length of pChannels pointer
    fCameraStateCallBack cbCamera;             // state of callback function
	LDWORD				dwUser;                // user's data
}NET_IN_CAMERASTATE;
typedef struct tagNET_OUT_CAMERASTATE
{
	DWORD		        dwSize;
	int                 nObjectID;              // Object ID,each ID represent a unique object
}NET_OUT_CAMERASTATE;

////////////////////////////////Special version/////////////////////////////////

// Activate device to snapshot overlay card number information 
typedef struct __NET_SNAP_COMMANDINFO 
{
	char				szCardInfo[16];			// Card information
	char				reserved[64];			// Reserved 
} NET_SNAP_COMMANDINFO, LPNET_SNAP_COMMANDINFO;

typedef struct
{
	int					nChannelNum;			// Channel number 
	char				szUseType[32];			// Channel type 
	DWORD				dwStreamSize;			// Stream size(Unit:kb/s)
	char				reserved[32];			// Reserved 
} DHDEV_USE_CHANNEL_STATE;

typedef struct 
{
	char				szUserName[32];			// User name 
	char				szUserGroup[32];		// User group 
	NET_TIME			time;					// Log in time
	int					nOpenedChannelNum;		// Enabled channel amount 
	DHDEV_USE_CHANNEL_STATE	channelInfo[DH_MAX_CHANNUM];
	char                szIpAddress[DH_MAX_IPADDR_LEN_EX];  // ip
    char                reserved[24];
} DHDEV_USER_NET_INFO;

// Network running status information 
typedef	struct 
{
	int					nUserCount;				// User amount
	DHDEV_USER_NET_INFO	stuUserInfo[32];
	char				reserved[256];
}DHDEV_TOTAL_NET_STATE;

typedef struct
{
    char                szIpAddress[DH_MAX_IPADDR_LEN];  // ip
	char                szUserGroup[32];                 // User Group
	char                szUserName[32];                  // User Name
	char                reserved[64];
}DHDEV_USER_REJECT_INFO;

// Reject User
typedef struct
{ 
	int                       nUserCount;				// User Account
	DHDEV_USER_REJECT_INFO    stuUserInfo[10];     
	char				      reserved[256];
}DHDEV_REJECT_USER;

typedef struct
{
	char                szIpAddress[DH_MAX_IPADDR_LEN];  // ip
	char                szUserGroup[32];                 // User Group
	char                szUserName[32];                  // User Name
	int                 nForbiddenTime;                  // Forbidden Time
	char                reserved[64];
}DHDEV_USER_SHIELD_INFO;

// Shield User
typedef struct
{ 
	int                       nUserCount;          // User Account
	DHDEV_USER_SHIELD_INFO    stuUserInfo[10];     
	char				      reserved[256];
}DHDEV_SHIELD_USER;

// longitude latitude
typedef struct
{//  longitude first,then latitude
	char                chPreLogi;        // preflag of longitude:N(north),S(south),W(west),E(east)
	char                chPreLati;        // preflag of latitude:N(north),S(south),W(west),E(east)
	BYTE                reserved[6];      // 
	double              dbLongitude;      // longitude
	double              dbLatitude;       // latitude
}DHDEV_LONGI_LATI;

// NAVIGATION OR SMS
typedef struct
{
	char                szPhoneNum[DH_MAX_PHONE_NO_LEN];    // phone no
	NET_TIME            stMsgTime;                          // time of sending message
	char                szMsgType[DH_MAX_MSGTYPE_LEN];      // type:Navigation message-Navigation,short message--SMS
	char                szSmsContext[DH_MAX_MSG_LEN];       // message to send

	DHDEV_LONGI_LATI    stLogiLati;                         // longitude
	unsigned int        uFlag;                              // 01:marking true longitude
	char                szNavigationType[16];               // TNC,TXZ
	char                szAddress[32];                      // address
	char                szNavigationMode[32];               // mode
	DHDEV_LONGI_LATI    stPassLogiLati[5];                  // passing
	DHDEV_LONGI_LATI    stNoPassLogiLati[5];                // no passing
	BYTE				reserved[256];
}DHDEV_NAVIGATION_SMSS;

// Image watermark setup 
typedef struct __DHDEV_WATERMAKE_CFG 
{
	DWORD				dwSize;
	int					nEnable;				// Enable 
	int					nStream;				// Bit stream(1~n)0- All bit streams
	int					nKey;					// Data type(1- text,2- image )
	char				szLetterData[DH_MAX_WATERMAKE_LETTER];	// text
	char				szData[DH_MAX_WATERMAKE_DATA]; 			// Image data
	BYTE				bReserved[512];			// Reserved
} DHDEV_WATERMAKE_CFG;

// Storage position set structure.  Each channel set separately.Each channel can set several storage types including local,portableand remote storage.
typedef struct 
{
	DWORD				dwSize;
	DWORD				dwLocalMask;			// Local storage mask. Use bit to represent.
												// The first bit:system pre-record. The second bit:scheduled record. The third bit:motion detection record.
												// The fourth bit:alarm record. The fifth bit:card record. The sixth bit:manual record.
	DWORD				dwMobileMask;			// Moving storage mask. Storage mask such as local storage mask.
	int					RemoteType;				// Remote storage type 0: Ftp  1: Smb 
	DWORD				dwRemoteMask;			// Remote storage mask.  Storage mask such as local storage mask.
	DWORD				dwRemoteSecondSelLocal;	// Local storage mask when remote is abnormal
	DWORD				dwRemoteSecondSelMobile;// Moving storage mask when remote is abnormal.
	char				SubRemotePath[MAX_PATH_STOR]; // Remote path. Its length is 240
	DWORD				dwFunctionMask;			// Function shield bit. Use bit to represent bit0 = 1:Shield sanpshot event activate storage position function.
	DWORD				dwAutoSyncMask;			// If synchronous mask; after remote storage network recovery, the local storage data will automatically synchronized to the remote storage.
	BYTE				bAutoSyncRange;			// the time for synchronous from the network synchronous time. In hour. 0:all data  1:data in one hour n:data in n hours
	char				reserved[119];
} DH_STORAGE_STATION_CFG;

#define MAX_ALARM_DECODER_NUM 16
typedef struct  
{
	DWORD				dwAlarmDecoder;			// Now it supports max 8 alarm input ports. Reserved 8 bits for future development.
	BYTE				bDecoderIndex;			// It means it is from which alarm decoder.
	BYTE				bReserved[3];
} ALARM_DECODER;

// Alarm decoder alarm 
typedef struct
{
	int					nAlarmDecoderNum;
	ALARM_DECODER		stuAlarmDecoder[MAX_ALARM_DECODER_NUM];
	BYTE				bReserved[32];
} ALARM_DECODER_ALARM;

//DSP alarm
typedef struct  
{
	BOOL				bError;			//0,DSP normal 1,DSP abnormal
	DWORD				dwErrorMask;	//Bit shows,Nor 0 shows havening this error,0 shows no.(Now alarm has only 1 bit valid)
										//bit		DSP alarm
										//1			DSP downloading failure 
										//2			DSP error
										//3			Format not correct 
										//4			Resolution not support
										//5			Data format not support
										//6			Can't find I frame
	DWORD               dwDecChnnelMask;//Bit shows,alarm decoding channel number,dwErrorMask is DSP fault,incorrect format,incorrect resolution,data format not support
	DWORD               dwDecChnnelMask1;//Bit shows,33-64 is alarm of decoding channel, dwErrorMask is DSP mistake,format is wrong, effective when not support resolution or data format
	BYTE				bReserved[24];
} DSP_ALARM;

// Fiber-optic alarm
typedef struct  
{
	int		nFDDINum;
	BYTE	bAlarm[256];
} ALARM_FDDI_ALARM;

#define ALARM_PTZ_LOCATION_INFO DH_PTZ_LOCATION_INFO

// New audio detection alarm setup 
typedef struct
{
	BOOL				bEnable;				// Enable alarm input 
	int					Volume_min;				// Min volume
	int					Volume_max;				// Max volume
	char				reserved[128];	
	DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT];	
	DH_MSG_HANDLE		struHandle;				// Process way 
} DH_AUDIO_DETECT_INFO;

typedef struct  
{
	DWORD				dwSize;
	int					AlarmNum;
	DH_AUDIO_DETECT_INFO AudioDetectAlarm[DH_MAX_AUDIO_IN_NUM];
	char				reserved[256];
} DH_AUDIO_DETECT_CFG;

typedef struct
{
	BOOL				bTourEnable;			// Enable tour
	int					nTourPeriod;			// Tour interval. Unit is second. The value ranges from 5 to 300 
	DWORD				dwChannelMask;			// Tour channel. Use mas bit to represent.
	char				reserved[64];
}DH_VIDEOGROUP_CFG;

// Local matrix control strategy setup 
typedef struct
{
	DWORD				dwSize;
	int					nMatrixNum;				// Matrix amount(Read only )
	DH_VIDEOGROUP_CFG	struVideoGroup[DH_MATRIX_MAXOUT];
	char				reserved[32];
} DHDEV_VIDEO_MATRIX_CFG;   

// WEB path setup 
typedef struct 
{
	DWORD				dwSize;
	BOOL				bSnapEnable;					// Snapshot or not
	int					iSnapInterval;					// Snapshot interval
	char				szHostIp[DH_MAX_IPADDR_LEN];	// HTTP host IP
	WORD				wHostPort;
	int					iMsgInterval;					// Message sending out interval
	char				szUrlState[DH_MAX_URL_LEN];		// Status message upload URL
	char				szUrlImage[DH_MAX_URL_LEN];		// Image upload Url
	char				szDevId[DH_MAX_DEV_ID_LEN];		// Device web serial number
	BYTE				byReserved[2];
} DHDEV_URL_CFG;

// OEM search 
typedef struct  
{
	char				szVendor[DH_MAX_STRING_LEN];
	char				szType[DH_MAX_STRING_LEN];
	char				reserved[128];
} DHDEV_OEM_INFO;


//Video OSD
typedef struct 
{ 
	DWORD	rgbaFrontground;		// Object front view. Use bit to represent:red,green, blue and transparency.
	DWORD	rgbaBackground;			// Object background. Use bit to represent:red,green, blue and transparency
	RECT	rcRelativePos;			// Position. The proportion of border distance and whole length *8191
	BOOL	bPreviewBlend;			// Enable preview overlay	
	BOOL	bEncodeBlend;			// Enable encode overlay
	BYTE    bReserved[4];           // Reserved 
} DH_DVR_VIDEO_WIDGET;

typedef struct 
{
	DH_DVR_VIDEO_WIDGET	StOSD_POS; 								// OSD position and background color.
	char 				SzOSD_Name[DH_VIDEO_OSD_NAME_NUM]; 		// OSD name 
}DH_DVR_VIDEOITEM;
 
// OSD information in each channel
typedef struct 
{
	DWORD 				dwSize;
	DH_DVR_VIDEOITEM 	StOSDTitleOpt [DH_VIDEO_CUSTOM_OSD_NUM];// Each channel OSD information
	BYTE    			bReserved[16];							// Reserved
} DH_DVR_VIDEOOSD_CFG;

// CDMA/GPRS Configuration
// Time structure															    
typedef struct 
{
	BYTE				bEnable;					// Time period enable,1 shows this time period valid,0 shows invalid.
	BYTE				bBeginHour;
	BYTE				bBeginMin;
	BYTE				bBeginSec;
	BYTE				bEndHour;
	BYTE				bEndMin;
	BYTE				bEndSec;
	BYTE    			bReserved;					//Reserved
} DH_3G_TIMESECT, *LPDH_3G_TIMESECT;

typedef struct 
{
	DWORD 				dwSize;
	BOOL				bEnable;					// Wireless module enable
	DWORD               dwTypeMask;                 // Network type mask;Use bit to represent,The first bit:Automatic selection
													// The second bit:TD-SCDMA network;The third bit:WCDMA network;
													// The fourth bit:CDMA 1.x network;The fifth bit:GPRS network;The sixth bit:EVDO network
													// The seventh bit:EVDO network;The eighth bit:WIFI network;
	DWORD               dwNetType;                  // Types of wireless networks,EM_GPRSCDMA_NETWORK_TYPE
	char				szAPN[128];					// Access Point Name
	char				szDialNum[128];				// Dial-up number
	char				szUserName[128];			// Dial-up user name
	char				szPWD[128];					// Dial-up Password
	
	/* Read-only part */
	BOOL				iAccessStat;				// Wireless network registration status
    char				szDevIP[16];				// dial-up IP of Front-end equipment  
	char				szSubNetMask [16];			// Dial-up mask of Front-end equipment
	char				szGateWay[16];				// Dial-up Gateway of Front-end equipment

	int                 iKeepLive;					// Keep-alive time
	DH_3G_TIMESECT		stSect[DH_N_WEEKS][DH_N_TSECT];// 3G dial period,valid time period,start dialing;beyond this period,shut the dial.
	BYTE                byActivate;                 // Whether need to be active by voice or message
	
	BYTE                bySimStat;                  // SIM(UIM) State: 1, 0 (read-only data) be occupied the 1 byte
	char                szIdentify[128];            // identify mode
	bool                bPPPEnable;                 // PPP Dial-up,0- cut down ppp connect,1-ppp dial-up
	BYTE                bPPPState;                  // PPP Dial-up statr(real only),see EM_MOBILE_PPP_STATE
	BYTE                bNetCardState;              // net card state(read only),see EM_3GMOBILE_STATE
	char				szPhyCardNo[32];			// physics card no.
	char				Reserved[4];				// reserved
	BYTE				byPinShow;					// PIN show or not(read only), 0-don't support 1-show, 2-don't show
	BYTE				byPinEnable;				// PIN setting enable(read only), 0-disable, 1-enable
	BYTE				byPinCount;					// the rest of pin setting number(read only), 0~3
	//-------------------------------the following fields in setting up effective after dwSize------------------------------------
	char				szPinNo[16];				// value of PIN, a combination of letters or numbers
} DHDEV_CDMAGPRS_CFG;

// The length of the video package configuration
typedef struct  
{
	DWORD 				dwSize;
	int					nType;						// 0:by time,1:by size
	int					nValue;						// nType = 0:(minutes),nType = 1:(KB)
	char				Reserved[128];				// Reserved
} DHDEV_RECORD_PACKET_CFG;

// (Directional)register the server information
typedef struct __DEV_AUTOREGISTER_INFO 
{
	LONG			lConnectionID;					// Connection ID
	char			szServerIp[DH_MAX_IPADDR_LEN];	// Server IP
	int				nPort;							// Port:0- 65535
	int             nState;                         // Server status:0-Registration failure;1-Registration success; 2-Connection failed
	char			reserved[16];
} DEV_AUTOREGISTER_INFO;

typedef struct __DEV_SERVER_AUTOREGISTER 
{
	DWORD					dwSize;
	int						nRegisterSeverCount;									// Number of registered servers
	DEV_AUTOREGISTER_INFO	stuDevRegisterSeverInfo[DH_CONTROL_AUTO_REGISTER_NUM];	// Server information
	char					reserved[256];
} DEV_SERVER_AUTOREGISTER, *LPDEV_SERVER_AUTOREGISTER;

// Upload burning annex
typedef struct
{
	DWORD				dwSize;		
	char				szSourFile[MAX_PATH_STOR];	// Source file path
	int					nFileSize;					// Source file size,If less than or equal to 0, sdk to calculate file size.
	char				szBurnFile[MAX_PATH_STOR];	// After burning the file name
	BYTE				bReserved[64];
} DHDEV_BURNFILE_TRANS_CFG;

// Update file upload
typedef struct
{
	char                 szFile[MAX_PATH_STOR];      // Update file path
	int                  nFileSize;                  // Update file size  
	BYTE                 byChannelId;                // Channel No.
	BYTE                 byManufactryType;           // Manufacturer type    Please refer to EM_IPC_TYPE
	
	BYTE                 byReserved[126];            // Reserved      
}DHDEV_UPGRADE_FILE_INFO;

// upload black-white list
typedef struct  
{
	char                 szFile[MAX_PATH_STOR];     // path of file
	int                  nFileSize;                 // size of upgrade file
	BYTE                 byFileType;                // type of file.0-black list,1-white list 
	BYTE                 byAction;                  // action,0-overload,1-additional

	BYTE                 byReserved[126];           // reserved
}DHDEV_BLACKWHITE_LIST_INFO;

// download black-white list
typedef struct
{
	char                 szFile[MAX_PATH_STOR];     // path of file
	BYTE                 byFileType;                // type of file,0-black list,1-white of list
	BYTE                 byReserved[127];           // reserved
}DHDEV_LOAD_BLACKWHITE_LIST_INFO;
// Zhengzhou EC_U video data overlay enabling configuration
typedef struct 
{
	BOOL				bEnable;					// Enable
	int					nPort;						// Port
	BYTE				bReserved[64];
}DHDEV_OSD_ENABLE_CFG;

// about vehicle configuration
typedef struct	
{
	BOOL				bAutoBootEnable;				//auto boot enable
	DWORD				dwAutoBootTime;					//auto boot time, Unit is second. The value ranges from 0 to 82800.
	BOOL				bAutoShutDownEnable;			//auto shut down enable
	DWORD				dwAutoShutDownTime;				//auto shut down time ,  Unit is second. The value ranges from 0 to 82800.
	DWORD				dwShutDownDelayTime;			//shut down delay time, Unit is second.
	BYTE				bEventNoDisk;					//1,(Ignore); 2,(Reboot)
	BYTE				bWifiEnable;					//If support car wifi module.
	BYTE				bUpperSpeedEnable;				//if use over speed verdict
	BYTE				bLowerSpeedEnable;				//if use low speed verdict
	DWORD				dwUpperSpeedValue;				//Over speed area(1,1000).km/hour.
	DWORD               dwLowerSpeedValue;              //Low speed area(1,1000).km/hour.
    DWORD               dwUpperSpeedDelayTime;          //Upper Speed Delay Time
	DWORD               dwLowerSpeedDelayTime;          //Lower Speed Delay Time
	DWORD               dwAlarmMaskEnable;              //Search/set OSD alarm information enable, every bit present one external alarm channel, 0:close;1:open
	BOOL                bSpeedOverAlarmRecordEnable;    //Over Speed Alarm Record Enable
	BOOL                bSpeedLowAlarmRecordEnable;     //Low Speed Alarm Record Enable
	BYTE				bReserved[480];					//reserved byte.
} DHDEV_ABOUT_VEHICLE_CFG;

// atm: query overlay ability information
typedef struct  
{
	DWORD				dwDataSource;					//1:Network, 2:Comm, 3:Network&Comm
	char				szProtocol[32][33];				//protocol name
	BYTE				bReserved[256];
} DHDEV_ATM_OVERLAY_GENERAL;
 
// atm: overlay configuration
typedef struct 
{
	DWORD				dwDataSource;					// 1:Network, 2:Comm
	char				szProtocol[33];					// protocol name, from DHDEV_ATM_OVERLAY_GENERAL
	BYTE				bReserved_1[3];
	DWORD				dwChannelMask;					// channel mask
	BYTE				bMode;							// 1:Preview, 2:Encode, 3:Preview&Encode
	BYTE				bLocation;						// 1:LeftTop, 2:LeftBottom, 3:RightTop, 4:RightBottom
	BYTE                bReserved_3[2];
	int                 nLatchTime;                     // display latch time on overlay, instruct the video's close latch time, 0~65535
	BYTE                bReserved_4[3];
	BYTE                bRecordSrcKeyNum;               // key number
	int                 nRecordSrcKey[32];              // key of channels 
	BYTE				bReserved_2[120];
} DHDEV_ATM_OVERLAY_CONFIG;

// atm:overlay set configuration
typedef struct 
{
	DWORD               dwSize;                         // size
	DWORD				dwDataSource;					// 1:Net, 2:Com, 3:Com422
	char				szProtocol[33];					// protocol name
	BYTE				bReserved_1[3];
	DWORD				dwChannelMask[8];				// overlay channel,the mask means: dwChannelMask[0] is channel 1,so on
	BYTE				bMode;							// 1:Preview(preview), 2:Encode(encode), 3:Preview&Encode(preview and encode)
	BYTE				bLocation;						// 1:LeftTop, 2:LeftBottom , 3:RightTop , 4:RightBottom 
	BYTE                bReserved_3[2];           
	int                 nLatchTime;                     // latch time,0~65535s
	BYTE                bReserved_4[3];
	BYTE                bRecordSrcKeyNum;               // number of key word
	int                 nRecordSrcKey[256];             // key word
} DHDEV_ATM_OVERLAY_CONFIG_EX;

// radar configuration - car speed
typedef struct tagNET_RADAR_CARSPEED_INFO
{
    int                 nTriggerLower;                  // lowerbound of trigger value  range 1~255km/h
    int                 nTriggerUpper;                  // upperbound of trigger value  range 1~255km/h
    int                 nLimitLower;                    // lowerbound of limit value    range 5~255km/h
    int                 nLimitUpper;                    // upperbound of limit value    range 5~255km/h
} NET_RADAR_CARSPEED_INFO;

// dahua radar configuration
typedef struct tagDEV_DAHUA_RADAR_CONFIG
{
    int							nAngle;                         // Angle, useful when correcting speed error from radar sensor installation angle. Unit: degree, range: 0~45
    BOOL						bLowSpeed;                      // whether or not enable lowerbounds. if TRUE, the lowerbounds in NET_RADAR_CARSPEED_INFO are valid
    BOOL						bSpeedForSize;                  // whether or not discriminate different car size, if FALSE, only small car speed config (stuSmallCarSpeed) is valid
    NET_RADAR_CARSPEED_INFO	    stuSmallCarSpeed;               // small car speed, if bSpeedForSize is TRUE, nTriggerLower member is ALSO lowerbounds for medium car and large car
    NET_RADAR_CARSPEED_INFO     stuMediumCarSpeed;              // medium car speed, valid only if bSpeedForSize is TRUE, but nTriggerLower member is ALWAYS invalid.
    NET_RADAR_CARSPEED_INFO		stuBigCarSpeed;                 // large car speed, valid only if bSpeedForSize is TRUE, but nTriggerLower member is ALWAYS invalid.
    char						szName[256];                    // device installation address
    int							nSensitivity;                   // Sensitivity, range: 0~5, 0 is most sensitive
    int							nDetectMode;                    // Detect Mode, values: -1  nonsense, 0 approaching in front, 1 leaving in front, 2 approaching behind, 3 leaving behind, 4 in front (approaching or leaving), 5 behind (approaching or leaving)
	BYTE						bReserved[1024];
} DEV_DAHUA_RADAR_CONFIG;

// single radar configuration 
typedef struct tagDEV_RADAR_CONFIG
{
	DWORD							dwSize;
	BOOL							bEnable;                          		// whether to enable function
	int								nPort;							  		// serial port number
	DH_COMM_PROP					stuCommAttr;							// serial port attribute
	int								nAddress;								// device's address;if multiple devices are hung on the serial port,they are distinguished by addresses.
	int								nPreSpeedWait;							// waiting time in the case of speed first
	int								nDelaySpeedWait;						// waiting time in the case of speed later,  range (1 -- 5000ms)
	BOOL							bDahuaRadarEnable;						// if enable dahua radar configuration, range (1 -- 5000ms)
	DEV_DAHUA_RADAR_CONFIG			stuDhRadarConfig;						// Dahua radar parameter configuration
}DEV_RADAR_CONFIG;



#define DH_MAX_BACKUPDEV_NUM			16
#define DH_MAX_BACKUP_NAME				32

// backup device list
typedef struct 
{
	int					nBackupDevNum;												// number of backup devices
	char				szBackupDevNames[DH_MAX_BACKUPDEV_NUM][DH_MAX_BACKUP_NAME]; // backup device name
} DHDEV_BACKUP_LIST, *LPDHDEV_BACKUP_LIST;

// backup device type
typedef enum __BACKUP_TYPE
{
	BT_DHFS = 0,							// dvr file system
	BT_DISK,								// floating disk
	BT_CDRW									// CD
} DHDEV_BACKUP_TYPE;	

// backup device interface
typedef enum __BACKUP_BUS
{
	BB_USB = 0,								// usb
	BB_1394,								// 1394
	BB_IDE,									// ide
	BB_ESATA,								// esata
} DHDEV_BACKUP_BUS;	

typedef struct 
{
	char				szName[32];						// name
	BYTE				byType;							// see BACKUP_TYPE
	BYTE				byBus;							// see BACKUP_BUS
	UINT				nCapability;					// total capability(kBytes)
	UINT				nRemain;						// remain capability(kBytes)
	char				szDirectory[128];				// Remote Directory
} DHDEV_BACKUP_INFO, *LPDHDEV_BACKUP_INFO;

typedef struct 
{
	char				szName[32];						// name 
	UINT				nCapability;					// total capability(kBytes)
	UINT				nRemain;						// remain capability(kBytes)
} DHDEV_BACKUP_FEEDBACK, *LPDHDEV_BACKUP_FEEDBACK;

#define  DH_MAX_BACKUPRECORD_NUM 1024

typedef struct  
{
	char				szDeviceName[DH_MAX_BACKUP_NAME];			//name
	int					nRecordNum;									//number of records
	NET_RECORDFILE_INFO	stuRecordInfo[DH_MAX_BACKUPRECORD_NUM];		//record information
} BACKUP_RECORD, *LPBACKUP_RECORD;

// multiplay input param
typedef struct
{
	int                 iChannelID;      // channel id
	DH_RealPlayType     realplayType;    // real play type
	char                reserve[32];
}DHDEV_IN_MULTIPLAY_PARAM;

// multiplay output param
typedef struct
{
	int                 iChannelID;      // channel id
	LLONG                lRealHandle;    // real play handle
	char                reserve[32];
}DHDEV_OUT_MULTIPLAY_PARAM;
/////////////////////////////////Embedded platform/////////////////////////////////

// Platform embedded setup - U China Network Communication(CNC)
typedef struct
{
    BOOL				bChnEn;
    char				szChnId[DH_INTERVIDEO_UCOM_CHANID];
} DH_INTERVIDEO_UCOM_CHN_CFG;

typedef struct
{
	DWORD				dwSize;
	BOOL				bFuncEnable;			// Enable connection
	BOOL				bAliveEnable;			// Enable alive
	DWORD				dwAlivePeriod;			// Alive period. Unit is second. The value ranges from 0 to 3600.
	char				szServerIp[DH_MAX_IPADDR_LEN];			// CMS IP
	WORD				wServerPort;							// CMS Port
    char				szRegPwd[DH_INTERVIDEO_UCOM_REGPSW];	// Registration password 
	char				szDeviceId[DH_INTERVIDEO_UCOM_DEVID];	// Device id
	char				szUserName[DH_INTERVIDEO_UCOM_USERNAME];
	char				szPassWord[DH_INTERVIDEO_UCOM_USERPSW];
    DH_INTERVIDEO_UCOM_CHN_CFG  struChnInfo[DH_MAX_CHANNUM];	// Channel id,en
} DHDEV_INTERVIDEO_UCOM_CFG;

//  Platform embedded setup - Alcatel
typedef struct
{
	DWORD				dwSize;
    unsigned short		usCompanyID[2];			// Company ID,Value. the different three party service company. Now use the first array considering the four bytes in line.
    char				szDeviceNO[32];			// Strings including '\0' are 32 bytes.
    char				szVSName[32];			// Front-end device name. Strings including '\0' are 16 bytes.
    char				szVapPath[32];			// VAP path
    unsigned short		usTcpPort;				// TCP port,value:value ranges from 1 to 65535 
    unsigned short		usUdpPort;				// UDP port,Value:Value ranges from 1 to 65535
    bool				bCsEnable[4];			// Enable central server symbol. Value:true=enable,false=disable.Now only use the first array considering the four bytes in line.
    char				szCsIP[16];				// Central server IP address.Strings including '\0' are 16 bytes.
    unsigned short		usCsPort[2];			// Central server port. Value ranges from 1 to 65535.Now only use the first array considering the four bytes in line.
    bool				bHsEnable[4];			// Enable pulse server symbol. Value:true-enable,false=disable.Now only use the first array considering the four bytes in line.
    char				szHsIP[16];				// Pulse server IP address. Strings including '\0' are 16 bytes.
    unsigned short		usHsPort[2];			// Pulse server port. Value ranges from 1 to 65535.Now only use the first array considering the four bytes in line
    int					iHsIntervalTime;		// Pulse server interval. Value(unit is second)
    bool				bRsEnable[4];			// Enable registration server symbol. Value:,true=enable,false=disable.Now only use the first array considering the four bytes in line. 
    char				szRsIP[16];				// Registration server IP address. Strings including '\0' are 16 bytes.
    unsigned short		usRsPort[2];			// Registration server port. Value. The value ranges from 1 to 65535.Now use the first array considering the four bytes in line
    int					iRsAgedTime;			// Registration server valid duration. Value(unit is hour)
    char				szAuthorizeServerIp[16];// IP Authorization server IP
    unsigned short		usAuthorizePort[2];		// Authorization server port. Now only use the first array considering the four bytes in line
    char				szAuthorizeUsername[32];// Authorization server account
    char				szAuthorizePassword[36];// Authorization server password
    
    char				szIpACS[16];			// ACS( auto registration server) IP
    unsigned short		usPortACS[2];			// ACS Port,Now only use the first array considering the four bytes in line. 
    char				szUsernameACS[32];		// ACS user name
    char				szPasswordACS[36];		// ACS password
    bool				bVideoMonitorEnabled[4];// DVS regularly uploads front-end video monitor message or not.Value:true=enable,false=disable
    int					iVideoMonitorInterval;	// Upload interval(minute)
    
    char				szCoordinateGPS[64];	// GPS coordinates
    char				szPosition[32];			// Device position
    char				szConnPass[36];			// Device connection bit 
} DHDEV_INTERVIDEO_BELL_CFG;

//  Platform embedded setup - ZTE Netview
typedef struct  
{
	DWORD				dwSize;
	unsigned short		nSevPort;								// Server port. Value. The value ranges from 1 to 65535
    char				szSevIp[DH_INTERVIDEO_NSS_IP];			// Server IP address,string,including '\0' end symbol, there are total 32byte.
    char				szDevSerial[DH_INTERVIDEO_NSS_SERIAL];	// Front-end device serial number, string including '\0' end symbol, there are total 32byte.
    char				szUserName[DH_INTERVIDEO_NSS_USER];
    char				szPwd[DH_INTERVIDEO_NSS_PWD];
} DHDEV_INTERVIDEO_NSS_CFG;

// Platform embedded setup - AMP
typedef struct  
{
	char               szDevSerial[DH_INTERVIDEO_AMP_DEVICESERIAL];                  // Front Device Serial num(encoder serial num), read only	
	char               szDevName[DH_INTERVIDEO_AMP_DEVICENAME];                      // Front Device Name(encoder name), read only
	char               szRegUserName[DH_INTERVIDEO_AMP_USER];                        // Server Name
	char               szRegPwd[DH_INTERVIDEO_AMP_PWD];                              // Server Password
	BYTE			   bReserved[128];
} DHDEV_INTERVIDEO_AMP_CFG;  
////////////////////////////////HDVR special use//////////////////////////////////

// Alarm relay structure
typedef struct 
{
	/* Message triggered methods,multiple methods,including
	 * 0x00000001 - alarm upload
	 * 0x00000002 - triggering recording
	 * 0x00000004 - PTZ movement
	 * 0x00000008 - sending email
	 * 0x00000010 - local tour
	 * 0x00000020 - local tips
	 * 0x00000040 - alarm output
	 * 0x00000080 - ftp upload
	 * 0x00000100 - buzzer
	 * 0x00000200 - voice tips 
	 * 0x00000400 - snapshot
	*/

	/* Current alarm supporting methods, shown by bit mask */
	DWORD				dwActionMask;

	/* Triggering action,shown by bit mask,concrete action parameter is shows in the configuration */
	DWORD				dwActionFlag;
	
	/* Triggering alarm output channel,1 means triggering this output */ 
	BYTE				byRelAlarmOut[DH_MAX_ALARMOUT_NUM_EX];
	DWORD				dwDuration;				/* Alarm lasting period */

	/* Triggering recording */
	BYTE				byRecordChannel[DH_MAX_VIDEO_IN_NUM_EX]; /* Record channel triggered by alarm,1 means triggering this channel */
	DWORD				dwRecLatch;				/* Recording period */

	/* Snapshot channel */
	BYTE				bySnap[DH_MAX_VIDEO_IN_NUM_EX];
	/* Tour channel */
	BYTE				byTour[DH_MAX_VIDEO_IN_NUM_EX];

	/* PTZ movement */
	DH_PTZ_LINK			struPtzLink[DH_MAX_VIDEO_IN_NUM_EX];
	DWORD				dwEventLatch;			/* Event delay time, s for unit,range is 0~15,default is 0 */
	/* Alarm trigerring wireless output,alarm output,1 for trigerring output */ 
	BYTE				byRelWIAlarmOut[DH_MAX_ALARMOUT_NUM_EX];
	BYTE				bMessageToNet;
	BYTE                bMMSEn;                /*Message triggering alarm enabling*/
	BYTE                bySnapshotTimes;       /* the number of sheets of drawings */
	BYTE				bMatrixEn;				/*!< Matrix output enable */
	DWORD				dwMatrix;				/*!< Matrix mask */			
	BYTE				bLog;					/*!< Log enable,only used in WTN motion detection */
	BYTE				bSnapshotPeriod;		/*!<Snapshot frame interval. System can snapshot regularly at the interval you specify here. The snapshot amount in a period of time also has relationship with the snapshot frame rate. 0 means there is no interval, system just snapshot continuously.*/
	BYTE				byTour2[DH_MAX_VIDEO_IN_NUM_EX];/* Tour channel 32-63*/
	BYTE                byEmailType;             /*<0,picture,1,record>*/
	BYTE                byEmailMaxLength;        /*<max record length,unit:MB>*/
	BYTE                byEmailMaxTime;          /*<max time length, unit:second>*/
	BYTE				byReserved[475];   
} DH_MSG_HANDLE_EX;

// External alarm expansion
typedef struct
{
	BYTE				byAlarmType;			// Alarm type,0:normal closed,1:normal open
	BYTE				byAlarmEn;				// Alarm enable
	BYTE				byReserved[2];						
	DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT]; //NSP
	DH_MSG_HANDLE_EX	struHandle;				// Handle method
} DH_ALARMIN_CFG_EX, *LPDHDEV_ALARMIN_CFG_EX; 

// Motion detection alarm
typedef struct 
{
	BYTE				byMotionEn;				// Motion detection alarm enabling
	BYTE				byReserved;
	WORD				wSenseLevel;			// Sensitivity
	WORD				wMotionRow;				// Motion detection area rows
	WORD				wMotionCol;				// Motion detection area lines
	BYTE				byDetected[DH_MOTION_ROW][DH_MOTION_COL]; // Motion detection area,most 32*32
	DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT];		  // NSP
	DH_MSG_HANDLE_EX	struHandle;				//Handle method
} DH_MOTION_DETECT_CFG_EX;

// fire alarm
typedef struct
{
	BOOL                byFireEn;              // enable
	DH_MSG_HANDLE_EX    struHandle;            // handler
	BYTE                byReserved[128];
}DHDEV_FIRE_ALARM_CFG;

// Static detection alarm

typedef struct 
{
	BYTE				byStaticEn;				// Static detection alarm enabling
	BYTE				byLatch;                // detect delay (old struct)
	WORD				wSenseLevel;			// Sensitivity
	WORD				wStaticRow;				// Static detection area rows
	WORD				wStaticCol;				// Static detection area lines
	BYTE				byDetected[DH_STATIC_ROW][DH_STATIC_COL]; // Static detection area,most 32*32
	DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT];	//NSP
	DH_MSG_HANDLE_EX	struHandle;				//Handle method
	int                 nLatch;                 // detect delay (new struct)
	BYTE                bReserved[64];          // reserved
} DH_STATIC_DETECT_CFG_EX;

// ACC power off configuration
typedef struct _DHDEV_ACC_POWEROFF_CFG
{
	BOOL                bEnable;               // ACC power off configuration enable
	int                 nDelayTime;            // ACC power off delay time(m)
	DH_MSG_HANDLE_EX    struHandle;            // handle method
	BYTE                Reserved[128];         // reserved
}DHDEV_ACC_POWEROFF_CFG;

// explosion proof alarm configuration
typedef struct _DHDEV_EXPLOSION_PROOF_CFG
{
	BOOL                bEnable;               // explosion proof alarm configuration enable
	DH_MSG_HANDLE_EX    struHandle;            // handle method
	BYTE                Reserved[128];         // reserved
}DHDEV_EXPLOSION_PROOF_CFG;

// Raid evnet config
typedef struct _DHDEV_RAID_EVENT_CFG
{
	BOOL                bEnable;               // enable
	DH_MSG_HANDLE_EX    struHandle;            // handle
	BYTE                Reserved[128];         // 
}DHDEV_RAID_EVENT_CFG;

// Video loss alarm
typedef struct
{
	BYTE				byAlarmEn;				// Video loss alarm enabling
	BYTE				byReserved[3];
	DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT];	//NSP
	DH_MSG_HANDLE_EX	struHandle;				// Handle method
} DH_VIDEO_LOST_CFG_EX;

// Camera masking alarm
typedef struct
{
	BYTE				byBlindEnable;			// Enable
	BYTE				byBlindLevel;			// Sensitivity 1-6
	BYTE				byReserved[2];
	DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT];	//NSP
	DH_MSG_HANDLE_EX	struHandle;				// Handle method
} DH_BLIND_CFG_EX;

// HDD info(alarm)
typedef struct 
{
	BYTE				byNoDiskEn;				// No HDD alarm
	BYTE				byReserved_1[3];
	DH_TSECT			stNDSect[DH_N_WEEKS][DH_N_REC_TSECT]; //NSP
	DH_MSG_HANDLE_EX	struNDHandle;			// Handle method
	
	BYTE				byLowCapEn;				// Low capacity alarm
	BYTE				byLowerLimit;			// Lower limit,0-99
	BYTE				byReserved_2[2];
	DH_TSECT			stLCSect[DH_N_WEEKS][DH_N_REC_TSECT]; //NSP
	DH_MSG_HANDLE_EX	struLCHandle;			// Handle method
	
	BYTE				byDiskErrEn;			// HDD error alarm
	BYTE				bDiskNum;
	BYTE				byReserved_3[2];
	DH_TSECT			stEDSect[DH_N_WEEKS][DH_N_REC_TSECT]; //NSP
	DH_MSG_HANDLE_EX	struEDHandle;			// Handle method
} DH_DISK_ALARM_CFG_EX;

typedef struct
{
	BYTE				byEnable;
	BYTE				byReserved[3];
	DH_MSG_HANDLE_EX	struHandle;
} DH_NETBROKEN_ALARM_CFG_EX;

// Front encoder configuration parameter
typedef struct __DEV_ENCODER_CFG 
{
	int					nChannels;				// Digital channel number
	DEV_ENCODER_INFO	stuDevInfo[32];			// Digital channel info
	BYTE				byHDAbility;			// The max high definition video amount the digital channel supported. (0 means it does not support high definition setup.)
												// If it supports high definition setup, the high definition channel ranges from 0 to N-1. If your high definition channel number is more than N, the save operation may fail. 
	BYTE				bTVAdjust;				// TV adjust. 0:not support, 1:support.
	BYTE				bDecodeTour;			// Decode tour. 0:not support, greater than zero: it means the maximal number supported.
	BYTE				bRemotePTZCtl;			// Remote PTZ control. 0:not support, 1:support.
	char				reserved[12];
} DEV_ENCODER_CFG, *LPDEV_ENCODER_CFG;

// front end access configuratiion parameter expansion
typedef struct __DEV_ENCODER_CFG_EX 
{
	int					nChannels;				// number of channel
	DEV_ENCODER_INFO	stuDevInfo[128];	    // the front end of the every digital channel encoder information
	BYTE				byHDAbility;			// maximum number of hd video(0 means not support)

	BYTE				bTVAdjust;				// support TV adjust,0:not support,1:support.
	BYTE				bDecodeTour;			// support tour or not, 0:not support, >0:the current number of device support
	BYTE				bRemotePTZCtl;			// support remote PTZ control
	char				reserved[256];
} DEV_ENCODER_CFG_EX, *LPDEV_ENCODER_CFG_EX;

// front end access configuratiion parameter expansion
typedef struct __DEV_ENCODER_CFG_EX2
{
	int                 nChannels;                  // number of channel
	int					nDevInfoMaxNum;				// The maximum number of applications for digital channels
	DEV_ENCODER_INFO    *pstuDevInfo;				// The font-end encoder information of each digital channelthe size is: sizeof(DEV_ENCODER_INFO)*nDevInfoMaxNum;
	BYTE                byHDAbility;                // maximum number of hd video(0 means not support)
	BYTE                bTVAdjust;                  // support TV adjust,0:not support,1:support.
	BYTE                bDecodeTour;                // support tour or not, 0:not support, >0:the current number of device support
	BYTE                bRemotePTZCtl;              // support remote PTZ control
	char                reserved[256];
} DEV_ENCODER_CFG_EX2, *LPDEV_ENCODER_CFG_EX2;

// Controller
typedef struct tagDHCONFIG_CONTROLER{
	DH_COMM_PROP        struComm;	                     // Com attribution
	BYTE                bLightGroup[DH_MAX_LIGHT_NUM];   // Controlled light group,light number start from 1,such as[1,3,8,0...0]present control light number 1,3,8 light
	BYTE	            bDeviceAddr;	                 // Controller address
	BYTE                bComPortType;                    // Com Type 0:485 COM, 1:232 COM
	BYTE                bReserved[6];		             // Reserved
} DH_CONFIG_CONTROLER;

// Light control config
typedef struct __DHDEV_LIGHTCONTROL_CFG
{
	DH_CONFIG_CONTROLER    struControlers[DH_MAX_CONTROLER_NUM]; // Control config
	BYTE                   bControlerNum;                        // Effective controller number
	BYTE                   bReserved[1023];                      // Reserved
} DHDEV_LIGHTCONTROL_CFG, *LPDHDEV_LIGHTCONTROL_CFG;

// 3G Flow info config
typedef struct
{
	int                 nStrategy;       // strategy, 0: charged by flow every month 1:charged by time every month
	int                 nUpLimit;        // up limit, by flow: MB, by time: h
	int                 nreserved[22];   // reserved
}DHDEV_3GFLOW_INFO_CFG;

// IPv6 config
typedef struct 
{
	char               szLinkAddr[44];	 // link address: string length = 44;(every host has an exclusive link address, read only)
	char               szHostIP[40]; 	 // host IP
	DWORD              dwPreFix;		 // net prefix, 1-128
	char               szGateWay[40];	 // gateway
	BOOL               bAutoGet;		 // enable of auto get ip 
	char               szPrimaryDns[40]; // primary DNS
	char               szSecondDns[40];	 // second DNS
    char               cReserved[256];   // reserved
}DHDEV_IPV6_CFG;

//Emergency storage configuration
typedef struct __DEV_URGENCY_RECORD_CFG
{
	DWORD dwSize;           // Structure body size
	BOOL bEnable;           // Enable or not. 1=enable.0=disable
	UINT nMaxRecordTime;    // Max record time. Unit is second.
	char szClientMac[64];	// Client ID, if set mac address manual, please take out ':';if not set this item, sdk will use default netcard mac address
							// (notice: if set mac address manual and different with  default netcard mac address, you will cannot get this configuration again until reset default)
}DHDEV_URGENCY_RECORD_CFG;

// Lift running parameter configuration
typedef struct __DEV_ELEVATOR_ATTRI_CFG
{
	DWORD  dwSize;           //Structure body size
	UINT   nMAXFloorNum;     //Max floor. Min is 2.
	UINT   nFloorDelayTime;  //Stay verification time ranges from 5-60. It regards as stop current floor if keep this time period.
	UINT   nIntervalTime;    //The max time for the lift to go up/down a floor. It regars the lift is malfunction if the time is out of the threshold. The lift stopsa between two floors.
}DHDEV_ELEVATOR_ATTRI_CFG;

// Virtual camera status search
typedef struct tagDHDEV_VIRTUALCAMERA_STATE_INFO
{
	DWORD              nStructSize;                  // Structure body size
	int                nChannelID;                   // Channel No.
	CONNECT_STATE      emConnectState;               // Connection status
	UINT               uiPOEPort;                    // The PoE port the virtual camera connected to. 0=It is not a PoE connection.
	char               szDeviceName[64];             // Device name
	char               szDeviceType[128];            // Device type
	char               szSystemType[128];            // system type
	char               szSerialNo[DH_SERIALNO_LEN];  // serial no
	int                nVideoInput;                  // video input number
	int                nAudioInput;                  // audio input number
	int                nAlarmOutput;                 // alarm output number
}DHDEV_VIRTUALCAMERA_STATE_INFO;

// Device working video/loop mode status info and etc search 
typedef struct tagDHDEV_TRAFFICWORKSTATE_INFO
{
	DWORD                nStructSize;      // Structure body size
	int                  nChannelID;       // Channel No.
	DH_TRAFFIC_SNAP_MODE emSnapMode;       // Snap mode
}DHDEV_TRAFFICWORKSTATE_INFO;

typedef enum tagEM_NET_DEFENCE_AREA_TYPE
{
    EM_NET_DEFENCE_AREA_TYPE_UNKNOW,                    // unknown
    EM_NET_DEFENCE_AREA_TYPE_INTIME,                    // realtime protection area  
    EM_NET_DEFENCE_AREA_TYPE_DELAY,                     // delay protection area
    EM_NET_DEFENCE_AREA_TYPE_FULLDAY,                   // 24h protection area
    EM_NET_DEFENCE_AREA_TYPE_Follow,                    // follow Protection area
    EM_NET_DEFENCE_AREA_TYPE_MEDICAL,                   // medical protection area
    EM_NET_DEFENCE_AREA_TYPE_PANIC,                     // panic Protection area
    EM_NET_DEFENCE_AREA_TYPE_FIRE,                      // fire Protection area
    EM_NET_DEFENCE_AREA_TYPE_FULLDAYSOUND,              // 24h sound Protection area
    EM_NET_DEFENCE_AREA_TYPE_FULLDATSLIENT,             // 24h slient Protection area
    EM_NET_DEFENCE_AREA_TYPE_ENTRANCE1,                 // entrance Protection area 1 
    EM_NET_DEFENCE_AREA_TYPE_ENTRANCE2,                 // entrance Protection area 2
    EM_NET_DEFENCE_AREA_TYPE_INSIDE,                    // inside Protection area
    EM_NET_DEFENCE_AREA_TYPE_OUTSIDE,                   // outside Protection area
    EN_NET_DEFENCE_AREA_TYPE_PEOPLEDETECT,              // people detect Protection area
} EM_NET_DEFENCE_AREA_TYPE;


// Local Alarm Event (DH_ALARM_ALARM_EX Update
typedef struct tagALARM_ALARM_INFO_EX2
{
    DWORD		                     dwSize;
    int			                     nChannelID;            // Channel ID
    int			                     nAction;				// 0=Start 1=Stop 
    NET_TIME	                     stuTime;				// Alarm Event Begin Time
    NET_SENSE_METHOD                 emSenseType;		    // The Sensor's Type
    DH_MSG_HANDLE_EX                 stuEventHandler;       // Handle method
    EM_NET_DEFENCE_AREA_TYPE         emDefenceAreaType;     // protection area type, refer to EM_NET_DEFENCE_AREA_TYPE 	
    UINT 							 nEventID;				// event id
    char                             szName[DH_COMMON_STRING_32];  // Channel Name
    int                              nCount;               	// evnet count
	NET_GPS_STATUS_INFO				 stuGPS;				// GPS information
	char							 szUserID[32];			// User ID logged in at local alarm
	char							 szUserName[128];		// User name logged in at local alarm
    char                             szSN[32];              // Device serial number
	BYTE                			 byReserved[832];       // Reserved 
}ALARM_ALARM_INFO_EX2;

// Event of IPC used by DVR/NVR(corresponding to EVENT_IVS_ALARM_IPC)
typedef struct tagDEV_EVENT_ALARM_IPC_INFO
{
    int                 			nChannelID;             // channel
    char                			szName[128];           	// event name
    char                			bReserved1[4];          // alignment
    double              			PTS;                    // Timestamp (in milliseconds)
    NET_TIME_EX         			UTC;                    // Time for the event occurred 
    int                 			nEventID;               // Event ID
    int                             nAction;                // Event action, 0: start, 1: stop
	BYTE                			byReserved[1024];       // Reserved 
} DEV_EVENT_ALARM_IPC_INFO;

/////////////////////////////////ITS picture subscription interface parameter/////////////////////////////////
typedef struct RESERVED_DATA_INTEL_BOX
{
	DWORD  dwEventCount;	 //Event count
	DWORD* dwPtrEventType;	 //Point to continuous value of event type, user should request and fr,apply to sizeof(DWORD)*dwEventCount
    DWORD  dwInternalTime;   //picture upload interval time, unit:second
	BYTE   bReserved[1020];	 //Reserved
}ReservedDataIntelBox;

#define RESERVED_TYPE_FOR_INTEL_BOX 0x00000001
typedef struct RESERVED_PARA
{
	DWORD 	dwType;	//pData's type
					//when [dwType] is RESERVED_TYPE_FOR_INTEL_BOX, pData is address of type ReservedDataIntelBox					
					//when [dwType] is ...,[pData] is ...
	void*	pData;	//data,the space application by the user, please refer to corresponding structure of pData's type
}ReservedPara;

#define RESERVED_TYPE_FOR_PATH  0x00000100
// picture path type
typedef enum tagNET_PICTURE_PATH_TYPE
{
    NET_PATH_LOCAL_PATH     ,   // writing path for loacl disk or sd card
    NET_PATH_FTP_PATH       ,   // ftp path
    NET_PATH_VIDEO_PATH     ,   // ftp path for assocated video
}NET_PICTURE_PATH_TYPE;

#define MAX_PIC_PATH_NUM        16
typedef struct tagNET_RESERVED_PATH
{
    int                     nMaxPathNum;                        //picture path count, device will use default path if 0
    NET_PICTURE_PATH_TYPE   emPictruePaths[MAX_PIC_PATH_NUM];   //picture path type
}NET_RESERVED_PATH;

#define RESERVED_TYPE_FOR_COMMON   0x00000010
//Offline parameter
typedef struct tagNET_OFFLINE_PARAM
{
	char					szClientID[20];			// Client id
	BYTE					byReserved[108];		// Reserved
}NET_OFFLINE_PARAM;

typedef struct tagNET_RESERVED_COMMON
{
	DWORD            		dwStructSize;
	ReservedDataIntelBox* 	pIntelBox;    			// include RESERVED_TYPE_FOR_INTEL_BOX
	DWORD            		dwSnapFlagMask;			// snap flags(by bit),0bit:"*",1bit:"Timing",2bit:"Manual",3bit:"Marked",4bit:"Event",5bit:"Mosaic",6bit:"Cutout"
	NET_OFFLINE_PARAM*		pstuOfflineParam;		// Offline parameter
	NET_RESERVED_PATH*		pstuPath;				// include RESERVED_TYPE_FOR_PATH
}NET_RESERVED_COMMON;

/////////////////////////////////Intelligent speed dome control interface parameter/////////////////////////////////
// Scene structure info
typedef struct 
{
	DWORD       dwSize;
	int         nScene;			//Scene SN
}DHDEV_INTELLI_SCENE_INFO;

// Scene margin limit position info
typedef struct 
{
	DWORD       dwSize;
	int         nScene;			//Scene SN
	int         nType;			//0:Top margin limit;1:Bottom margin limit;2:Left margin;3:Right margin
}DHDEV_INTELLI_SCENELIMIT_INFO;

// Manually track object structure body info
typedef struct
{
	DWORD       dwSize;
	int         nObjectID;		// Object ID -1 = Set the intelligent frame upload the position of any object out of the frame in the Web >=0: select the intelligent frame to send the object in the frame. 
	RECT        stuBound;		// Rectangle range. The coordinates of the point is within [0,8192].
}DHDEV_INTELLI_TRACKOBJECT_INFO;

typedef enum __TRACKCONTROL_TYPE
{
	DH_TRACK_MARKSCENE,				// Specified scene. Corresponding to the structure body of the DHDEV_INTELLI_SCENE_INFO
		DH_TRACK_GOTOSCENE,			// Go to scene. Corresponding to the structure body of the DHDEV_INTELLI_SCENE_INFO
		DH_TRACK_MARKSCENELIMIT,	// The margin limit position of the specified scene. Corresponding to the structure body of the DHDEV_INTELLI_SCENELIMIT_INFO
		DH_TRACK_GOTOSCENELIMIT,	// Go to the marin limit position of the scene. Corresponding to the structure body of the DHDEV_INTELLI_SCENELIMIT_INFO
		DH_TRACK_MARKSCENEMAXZOOM,	// The max track rate in the specified scene. Corresponding to the structure body of the DHDEV_INTELLI_SCENE_INFO
		DH_TRACK_OBJECT,			// The tracking object in the selected scene. Corresponding to the structure body of the DHDEV_INTELLI_TRACKOBJECT_INFO
		DH_TRACK_START,				// Begin intelligent track. No need to specify parameter information.
		DH_TRACK_STOP,				// Stop intelligent track. No need to specify parameter information.
		DH_TRACK_TYPE_NUM,
}DH_TRACKCONTROL_TYPE;

//Intelligent speed dome control input parameter
typedef struct tagNET_IN_CONTROL_INTELLITRACKER
{
    DWORD       dwSize;
    int         nChannelID;            // Channel ID
    DH_TRACKCONTROL_TYPE emCtrlType;   // Control type
    void*       pCtrlInfo;             // The corresponding inform structure pointer of the control type. Please refer to DH_TRACKCONTROL_TYPE for definition.the space application by the user.
    int         nMaxLen;               // Structure body size of the control information
	int         nWaittime;             // Wait time out time
}NET_IN_CONTROL_INTELLITRACKER;

//Intelligent speed dome control output parameter
typedef struct tagNET_OUT_CONTROL_INTELLITRACKER
{
    DWORD       dwSize;
}NET_OUT_CONTROL_INTELLITRACKER;

/////////////////////////////////Video Analysis Interface Parameters//////////////////////////////
#define MAX_TEMPLATEIMAGE_NUM               32                      // Limitation of valid images quantities.
 
//Get the inputs of video analyses target
 typedef struct tagNET_IN_VIDEOANALYSE_GETTEMPLATEIMAGE
{
    DWORD               dwSize;
    int                 nChannelID;                                 // channel ID
	char                szRule[DH_COMMON_STRING_128];               // The correspondence rule of template image
 }NET_IN_VIDEOANALYSE_GETTEMPLATEIMAGE;

//Get the outputs of video analyses target
typedef struct tagNET_OUT_VIDEOANALYSE_GETTEMPLATEIMAGE
{
    DWORD               dwSize;
    unsigned int        nImageNum;                                  // The number of valid images
    DH_PIC_INFO_EX2     stuImage[MAX_TEMPLATEIMAGE_NUM];            // Image information
	char*               pBuffer;                                    // The pointer of image buffer, applied by users
    int                 nBufLen;                                    // The size of image buffer, filled in by users
	int                 nRetLen;                                    // Get the length of the image data, no need to fill in by user, which can be used to decide whether the buffer is enough.
 
}NET_OUT_VIDEOANALYSE_GETTEMPLATEIMAGE;

//Setup the input parameters of video analyses target
typedef struct tagNET_IN_VIDEOANALYSE_SETTEMPLATEIMAGE
{
    DWORD               dwSize;
    int                 nChannelID;                                 // Channel ID
    char                szRule[DH_COMMON_STRING_128];               // The correspondence rule of template image
    unsigned int        nImageNum;                                  // The number of valid images

    DH_PIC_INFO_EX2     stuImage[MAX_TEMPLATEIMAGE_NUM];            // Image information
	char*               pBuffer;                                    // The pointer of image buffer, the space application by the user,applt to nBufLen
    int                 nBufLen;                                    // Image buffer size
}NET_IN_VIDEOANALYSE_SETTEMPLATEIMAGE;

//Setup the output parameters of video analyses target
typedef struct tagNET_OUT_VIDEOANALYSE_SETTEMPLATEIMAGE
{
    DWORD       dwSize;
}NET_OUT_VIDEOANALYSE_SETTEMPLATEIMAGE;

/////////////////////////////////Abandoned Type/////////////////////////////////

// Search device working status channel information. Corresponding interfaces have been abandoned. Do not user.
typedef struct
{
	BYTE				byRecordStatic;			// Channel is recording or not. ;0: does not record,1: manual record,2:auto record  
	BYTE				bySignalStatic;			// Connected signal status ;0:normal,1:signal loss  
	BYTE				byHardwareStatic;		// Channel hardware status;0:normal ,1:abnormal such as DSP is down , 
	char				reserve;
	DWORD				dwBitRate;				// Actual bit rate
	DWORD				dwLinkNum;				// The client-end connected amount 
	DWORD				dwClientIP[DH_MAX_LINK];// Client-end IP address 
} NET_DEV_CHANNELSTATE, *LPNET_DEV_CHANNELSTATE;

// Search device working status. The corresponding interfaces have been abandoned. Please do not use
typedef struct
{
	DWORD				dwDeviceStatic;						// Device status;0x00:normal ,0x01:CPU occupation is too high ,0x02:hardware error 
	NET_DEV_DISKSTATE	stHardDiskStatic[DH_MAX_DISKNUM]; 
	NET_DEV_CHANNELSTATE stChanStatic[DH_MAX_CHANNUM];		// Channel status
	BYTE				byAlarmInStatic[DH_MAX_ALARMIN];	// Alarm port status;0:no alarm,1: alarm
	BYTE				byAlarmOutStatic[DH_MAX_ALARMOUT]; 	// Alarm output port status;0:no alarm,1:alarm  
	DWORD				dwLocalDisplay;						// Local display status  ;0:normal,1:abnormal 
} NET_DEV_WORKSTATE, *LPNET_DEV_WORKSTATE;

// Protocol information
typedef struct 
{
	char				protocolname[12];		// Protocol name
	unsigned int		baudbase;				// Baud rate
	unsigned char		databits;				// Data bit
	unsigned char		stopbits;				// Stop bit
	unsigned char		parity;					// Pairty bit 
	unsigned char		reserve;
} PROTOCOL_INFO, *LPPROTOCOL_INFO;

// Audio talk parameter setup
typedef struct 
{
	// Audio input parameter
	BYTE				byInFormatTag;			// Encode type such as PCM
	BYTE				byInChannels;			// Track amount
	WORD				wInBitsPerSample;		// Sampling depth 				
	DWORD				dwInSamplesPerSec;		// Sampling rate 

	// Audio output parameter
	BYTE				byOutFormatTag;			// Encode type such as PCM
	BYTE				byOutChannels;			// Track amount
	WORD				wOutBitsPerSample;		// Sampling depth 		
	DWORD				dwOutSamplesPerSec;		// Sampling rate
} DHDEV_TALK_CFG, *LPDHDEV_TALK_CFG;

/////////////////////////////////// Matrix ///////////////////////////////////////

#define DH_MATRIX_INTERFACE_LEN		16		// Signal interface name length
#define DH_MATRIX_MAX_CARDS			128		// Matrix sub card max amount
#define DH_SPLIT_PIP_BASE			1000	// The basic value of the PIP split mode
#define	DH_MAX_SPLIT_MODE_NUM		64		// Max split matrix amount
#define DH_MATRIX_MAX_CHANNEL_IN	1500	// Matrix max input channel amount
#define DH_MATRIX_MAX_CHANNEL_OUT	256		// Matrix max output channel amount
#define DH_DEVICE_NAME_LEN			64		// Device name length
#define DH_MAX_CPU_NUM				16		// Max CPU amount
#define DH_MAX_FAN_NUM				16		// Max fan amount
#define DH_MAX_POWER_NUM			16		// Max power amount
#define DH_MAX_BATTERY_NUM          16      // Max battery quantity
#define DH_MAX_TEMPERATURE_NUM      256		// Max temperature sensor amount 
#define DH_MAX_ISCSI_NAME_LEN		128		// ISCSI Name length
#define DH_VERSION_LEN				64		// Version info length
#define DH_MAX_STORAGE_PARTITION_NUM 32		//  Storage partition max number
#define DH_STORAGE_MOUNT_LEN		64		// Mount length
#define DH_STORAGE_FILE_SYSTEM_LEN	16		// File system name length
#define DH_MAX_MEMBER_PER_RAID		32		// RAID max members
#define DH_DEV_ID_LEN_EX			128		// Device ID max length
#define DH_MAX_BLOCK_NUM			32		// max number of block
#define DH_MAX_SPLIT_WINDOW			128		// max number of split window
#define DH_FILE_TYPE_LEN			64		// length of file type
#define DH_DEV_ID_LEN				128		// length of device ID
#define DH_DEV_NAME_LEN				128		// max length of device name  
#define DH_TSCHE_DAY_NUM			8		// schedule the first dimension size, means days
#define DH_TSCHE_SEC_NUM			6		// schedule the second dimension size, means time
#define    DH_SPLIT_INPUT_NUM       256     // Judicial device level 2 switch level 1 split supported input channel

#define DH_DEVICE_ID_LOCAL		"Local"		// local device ID
#define DH_DEVICE_ID_REMOTE		"Remote"	// remote device ID
#define DH_DEVICE_ID_UNIQUE		"Unique"	// unique ID

// Split mode
typedef enum tagDH_SPLIT_MODE
{
	DH_SPLIT_1 = 1,							// 1-window
	DH_SPLIT_2 = 2, 						// 2-window
	DH_SPLIT_4 = 4, 						// 4-window
	DH_SPLIT_6 = 6, 						// 6-window
	DH_SPLIT_8 = 8, 						// 8-window
	DH_SPLIT_9 = 9, 						// 9-window
	DH_SPLIT_12 = 12, 						// 12-window
	DH_SPLIT_16 = 16, 						// 16-window
	DH_SPLIT_20 = 20, 						// 20-window
	DH_SPLIT_25 = 25, 						// 25-window
	DH_SPLIT_36 = 36, 						// 36-window
	DH_SPLIT_64 = 64, 						// 64-window
	DH_SPLIT_144 = 144, 					// 144-window
	DH_PIP_1 = DH_SPLIT_PIP_BASE + 1,		// PIP mode.1-full screen+1-small window
	DH_PIP_3 = DH_SPLIT_PIP_BASE + 3,		// PIP mode.1-full screen+3-small window
	DH_SPLIT_FREE = DH_SPLIT_PIP_BASE * 2,	// free open window mode,are free to create,close, window position related to the z axis
	DH_COMPOSITE_SPLIT_1 = DH_SPLIT_PIP_BASE * 3 + 1,	// integration of a split screen
	DH_COMPOSITE_SPLIT_4 = DH_SPLIT_PIP_BASE * 3 + 4,	// fusion of four split screen
	DH_SPLIT_3  = 10,                                // 3-window
	DH_SPLIT_3B = 11,								 // 3-window(bottom) 	
} DH_SPLIT_MODE;

#define DH_PROTOCOL_DAHUA2 DH_PROTOCOL_PRIVATE2
#define DH_PROTOCOL_DAHUA3 DH_PROTOCOL_PRIVATE3

// Device protocol type
typedef enum tagDH_DEVICE_PROTOCOL
{
	DH_PROTOCOL_PRIVATE2,					// private 2nd protocol
	DH_PROTOCOL_PRIVATE3,					// private 3rd protocol
	DH_PROTOCOL_ONVIF,						// Onvif	
	DH_PROTOCOL_VNC,						// virtual network computer
    DH_PROTOCOL_TS,                         // Standard TS
    DH_PROTOCOL_ECLOUD,                     // ECloud
    
	DH_PROTOCOL_PRIVATE = 100,              // private protocol of private        
	DH_PROTOCOL_AEBELL,                     // aebell
	DH_PROTOCOL_PANASONIC,                  // panasonic       
	DH_PROTOCOL_SONY,                       // sony   
	DH_PROTOCOL_DYNACOLOR,                  // Dynacolor        
	DH_PROTOCOL_TCWS,						// tcsw        
	DH_PROTOCOL_SAMSUNG,                    // sansung        
	DH_PROTOCOL_YOKO,                       // YOKO        
	DH_PROTOCOL_AXIS,                       // axis        
	DH_PROTOCOL_SANYO,						// sanyo       		
	DH_PROTOCOL_BOSH,						// Bosch		
	DH_PROTOCOL_PECLO,						// Peclo		
	DH_PROTOCOL_PROVIDEO,					// Provideo		
	DH_PROTOCOL_ACTI,						// ACTi		
	DH_PROTOCOL_VIVOTEK,					// Vivotek		
	DH_PROTOCOL_ARECONT,					// Arecont        
	DH_PROTOCOL_PRIVATEEH,			        // PrivateEH	        
	DH_PROTOCOL_IMATEK,					    // IMatek        
	DH_PROTOCOL_SHANY,                      // Shany        
	DH_PROTOCOL_VIDEOTREC,                  // videotrec        
	DH_PROTOCOL_URA,						// Ura        
	DH_PROTOCOL_BITICINO,                   // Bticino         
	DH_PROTOCOL_ONVIF2,                     // Onvif's protocol type, same to DH_PROTOCOL_ONVIF    
	DH_PROTOCOL_SHEPHERD,                   // shepherd        
	DH_PROTOCOL_YAAN,                       // yaan      
	DH_PROTOCOL_AIRPOINT,					// Airpop        
	DH_PROTOCOL_TYCO,                       // TYCO        
	DH_PROTOCOL_XUNMEI,                     // xunmei      
	DH_PROTOCOL_HIKVISION,                  // hikvision        
	DH_PROTOCOL_LG,                         // LG        
	DH_PROTOCOL_AOQIMAN,					// aoqiman       
	DH_PROTOCOL_BAOKANG,                    // baokang            
	DH_PROTOCOL_WATCHNET,                   // Watchnet        
	DH_PROTOCOL_XVISION,                    // Xvision        
	DH_PROTOCOL_FUSITSU,                    // fusitsu        
	DH_PROTOCOL_CANON,						// Canon		
	DH_PROTOCOL_GE,							// GE		
	DH_PROTOCOL_Basler,						// basler		
	DH_PROTOCOL_Patro,						// patro	    
	DH_PROTOCOL_CPKNC,						// CPPLUS K series		
	DH_PROTOCOL_CPRNC,						// CPPLUS R series		
	DH_PROTOCOL_CPUNC,						// CPPLUS U series		
	DH_PROTOCOL_CPPLUS,						// CPPLUS IPC		
	DH_PROTOCOL_XunmeiS,					// xunmeis,protocal is Onvif		
	DH_PROTOCOL_GDDW,						// GDDW		
	DH_PROTOCOL_PSIA,                       // PSIA        
	DH_PROTOCOL_GB2818,                     // GB2818	        
	DH_PROTOCOL_GDYX,                       // GDYX        
	DH_PROTOCOL_OTHER,                      // others   
} DH_DEVICE_PROTOCOL;

// Split mode info
typedef struct tagDH_SPLIT_MODE_INFO
{
	DWORD				dwSize;
	DH_SPLIT_MODE		emSplitMode;			// Split mode
	int					nGroupID;				// Group SN
    DWORD               dwDisplayType;          // display type, seeDH_SPLIT_DISPLAY_TYPE, under each mode in note , displayed content depends on "PicInPic", each mode displayed content by NVD old rule, as depending on DisChntext, . Compatible, no this item, default is normal display type as"General", 
} DH_SPLIT_MODE_INFO;

// Split capability
typedef struct tagDH_SPLIT_CAPS 
{
	DWORD				dwSize;
	int					nModeCount;				// The split amount supported
	DH_SPLIT_MODE		emSplitMode[DH_MAX_SPLIT_MODE_NUM];	// The split mode supported
	int				    nMaxSourceCount;		// Max display source allocation amount
	int					nFreeWindowCount;		// count of free window support
	BOOL				bCollectionSupported;	// support collection
    DWORD               dwDisplayType;                          // mask means multiple display types, see DH_SPLIT_DISPLAY_TYPE, under each mode in note , displayed content depends on "PicInPic", each mode displayed content by NVD old rule, as depending on DisChntext, Compatible, no this item, default is normal display type as"General", 
    int                 nPIPModeCount;                          // PIP support split mode quantity
    DH_SPLIT_MODE       emPIPSplitMode[DH_MAX_SPLIT_MODE_NUM];  // PIP supported split mode
    int                 nInputChannels[DH_SPLIT_INPUT_NUM];     // supported input channel
    int                 nInputChannelCount;                     // supported input channel quantity, 0 means no input channel limit
    int                 nBootModeCount;                         // enable split mode quantity
    DH_SPLIT_MODE       emBootMode[DH_MAX_SPLIT_MODE_NUM];      // support enable default video split mode
} DH_SPLIT_CAPS;

// even the authentication information
typedef struct tagDH_CASCADE_AUTHENTICATOR
{
	DWORD				dwSize;
	char				szUser[DH_NEW_USER_NAME_LENGTH];		// user name
	char				szPwd[DH_NEW_USER_PSW_LENGTH];			// passwd
	char				szSerialNo[DH_SERIALNO_LEN];			// serial no.
} DH_CASCADE_AUTHENTICATOR;

typedef enum tagEM_SRC_PUSHSTREAM_TYPE
{   
    EM_SRC_PUSHSTREAM_AUTO,        // device automatic recognition according to bit stream head, default
    EM_SRC_PUSHSTREAM_HIKVISION,   // Hikvision private bit stream
    EM_SRC_PUSHSTREAM_PS,          // PS
    EM_SRC_PUSHSTREAM_TS,          // TS
    EM_SRC_PUSHSTREAM_SVAC,        // SVAC
}EM_SRC_PUSHSTREAM_TYPE;


// Encrypt level
typedef enum tagEM_ENCRYPT_LEVEL
{
    EM_ENCRYPT_LEVEL_UNKNOWN,		    // Unknown
    EM_ENCRYPT_LEVEL_NONE,		        // Not encrypt
    EM_ENCRYPT_LEVEL_IFRAME256,		    // Encrypt 256 byte in Iframe
    EM_ENCRYPT_LEVEL_IFRAME_WHOLE,		// Encrypt the whole Iframe
    EM_ENCRYPT_LEVEL_IAXFRAME,		    // Encrypt the I frame , audio frame and other auxiliary frame
}EM_ENCRYPT_LEVEL;

// The type of stream encrypt algorithm
typedef enum tagEM_ENCRYPT_ALGORITHM_TYPE
{
    EM_ENCRYPT_ALGORITHM_UNKNOWN,		    // Unknown
    EM_ENCRYPT_ALGORITHM_AES,		        // AES
    EM_ENCRYPT_ALGORITHM_DES,		        // DES
    EM_ENCRYPT_ALGORITHM_3DES,		        // 3DES
}EM_ENCRYPT_ALGORITHM_TYPE;

// The type of exchange key
typedef enum tagEM_KEY_EXCHANGE_TYPE
{
    EM_KEY_EXCHANGE_UNKNOWN,            // Unknown
    EM_KEY_EXCHANGE_MIKEY,              // Mikey key
    EM_KEY_EXCHANGE_PSK,                // share key
    EM_KEY_EXCHANGE_PK,                 // public key
    EM_KEY_EXCHANGE_DH,                 // hoffman key 
}EM_KEY_EXCHANGE_TYPE;

// The encrypt of stream info
typedef struct tagNET_SOURCE_STREAM_ENCRYPT
{
    EM_ENCRYPT_LEVEL            emEncryptLevel;         // Encrypt level
    EM_ENCRYPT_ALGORITHM_TYPE   emAlgorithm;            // The type of stream encrypt algorithm
    EM_KEY_EXCHANGE_TYPE        emExchange;             // The type of exchange key
    BOOL                        bUnvarnished;           // MTS using scene,true is interacting with MIKEY and than donot encrypt data
    char                        szPSK[1032];            // key
    BYTE                        byReserved[1024];       // Revered
}NET_SOURCE_STREAM_ENCRYPT;

// Display source
typedef struct tagDH_SPLIT_SOURCE
{
	DWORD				dwSize;
	BOOL			    bEnable;						    // Enable
	char			    szIp[DH_MAX_IPADDR_LEN];		    // IP, null means there is no setup.
	char			    szUser[DH_USER_NAME_LENGTH];	    // User name
	char			    szPwd[DH_USER_PSW_LENGTH];	    	// Password
	int			    	nPort;							    // Port
	int				    nChannelID;						    // Channel No.
	int				    nStreamType;					    // Video bit stream. -1-auto, 0-main stream, 1-extra stream 1, 2-extra stream 2, 3-extra stream 3
	int				    nDefinition;					    // Definition, 0-standard definition, 1-high definition
	DH_DEVICE_PROTOCOL  emProtocol;							// Protocol type
	char			    szDevName[DH_DEVICE_NAME_LEN];		// Device name
	int					nVideoChannel;						// Video input channel amount
	int					nAudioChannel;						// Audio input channel amount
	// For decoder only
	BOOL				bDecoder;							// Decoder or not.
	BYTE				byConnType;							// 0:TCP;1:UDP;2:multicast
	BYTE				byWorkMode;							// 0:connect directly; 1:transfer 
	WORD				wListenPort;						// isten port, valid with transfer; when byConnType is multicast, it is multiport
	char				szDevIpEx[DH_MAX_IPADDR_OR_DOMAIN_LEN];// szDevIp extension, front DVR Ip address (enter domain name)
	BYTE				bySnapMode;                         //  snapshot mode (valid when nStreamType==4) 0: request for single frame, 1: sechdule sending request
	BYTE				byManuFactory;						// Target device manufacturer. Refer to EM_IPC_TYPE for detailed information.
	BYTE				byDeviceType;                       //  target device type, 0:IPC
	BYTE				byDecodePolicy;                     // target device decode policy, 0:compatible with previous  
															// 1:real time level high 2: real time level medium
															// 3: real time level low 4: default level 
															// 5: fluency level high 6: fluency level medium
															// 7: fluency level low
	DWORD				dwHttpPort;                         // Http port number, 0-65535
	DWORD				dwRtspPort;                         // Rtsp port number, 0-65535
	char				szChnName[DH_DEVICE_NAME_LEN];		// Remote channel name, modifiable only when name read is not vacant
	char				szMcastIP[DH_MAX_IPADDR_LEN];       // Multicast IP address. Valid only when byConnType is multicast
	char				szDeviceID[DH_DEV_ID_LEN_EX];		// device ID, ""-null, "Local"  "Remote"
	BOOL				bRemoteChannel;						// is remote channel or not(read only)
	unsigned int		nRemoteChannelID;					// remote channel ID (read only), effective when bRemoteChannel=TRUE
	char				szDevClass[DH_DEV_TYPE_LEN];		// type of device, such as IPC, DVR, NVR and so on
	char				szDevType[DH_DEV_TYPE_LEN];			// device specific type, such as IPC-HF3300
	char				szMainStreamUrl[MAX_PATH];			// main stream url, effective when byManuFactory =D H_IPC_OTHER
	char				szExtraStreamUrl[MAX_PATH];			// extra stream url, effective when byManuFactory =D H_IPC_OTHER
	int					nUniqueChannel;						// unique channel ID, read only
	DH_CASCADE_AUTHENTICATOR stuCascadeAuth;				// ssascade authemyication, effective when device ID = "Local/Cascade/SerialNo",  SerialNo is device seral no.
    int                 nHint;                              // 0-normal video source, 1- alarm video source
    int                 nOptionalMainUrlCount;              // back main stream address quantity
    char                szOptionalMainUrls[DH_MAX_OPTIONAL_URL_NUM][MAX_PATH]; // backup main stream address list
    int                 nOptionalExtraUrlCount;             // backup sub stream address quantity
    char                szOptionalExtraUrls[DH_MAX_OPTIONAL_URL_NUM][MAX_PATH]; // backup sub stream address list
    //--------------------------------------------------------------------------------------
    //protocol follow-up add field
    int                 nInterval;                          // tour time intertval	unit:second
    char                szUserEx[DH_NEW_USER_NAME_LENGTH];  // user name
    char                szPwdEx[DH_NEW_USER_PSW_LENGTH];    // password
    EM_SRC_PUSHSTREAM_TYPE  emPushStream;                   // type of pushstream,effective when byConnType is TCP-Push or UDP-Push 
	NET_RECT			stuSRect;							// video source region,valid when szDeviceID is not null,if rect is (0,0,0,0),it means valid data,device use default value(0,0,8192,8192)
    NET_SOURCE_STREAM_ENCRYPT stuSourceStreamEncrypt;       // The encrypt of stream info
    char                szSerialNo[DH_SERIALNO_LEN];        // Serial number of device.When connect protocol is EClould ,this parameter is required
} DH_SPLIT_SOURCE;

// Video output capability set
typedef struct tagDH_VIDEO_OUT_CAPS 
{
	DWORD				dwSize;
	BOOL				bColor;							// Support color output setup or not
	BOOL				bMargin;						// Support margin setup or not
	int					nLayers;						// The max layers supported at the same time
	BOOL				bPowerMode;						// Support power control or not.
	int					bSplitMode;						// The video split mode supported. 0-1-window. 1-'#' mode(inclduing 1-window).2-Any mode
    unsigned int        nBackground;                    // support background mode, by bit, 0-color, 1-picture
    BOOL                bBindOutput;                    // If support output screen resoluton binding setup
    BOOL                bAudioSupport;                  // Support audio output or not
    DWORD               dwAudioMode;                    // The support audio mode, by bit, bit0-main controller output, bit1-daughter card output
} DH_VIDEO_OUT_CAPS;

// Color BCSH
typedef struct tagDH_COLOR_BCSH 
{
	int					nBirghtness;					// Brightness
	int					nContrast;						// Contrast
	int			        nSaturation;					// Saturation
	int					nHue;						    // Hue
} DH_COLOR_BCSH;

// Dimensions
typedef struct tagDH_SIZE 
{
	int					nWidth;							// Width
	int					nHeight;						// Height
} DH_SIZE;

// mode of hot plug
typedef struct tagDH_HOT_PLUG_MODE
{
	DWORD				dwSize;
	int					nMode;							// mode of hot plug, 0-hot plug, 1-force output mode
} DH_HOT_PLUG_MODE;
// Video output option 
typedef struct tagDH_VIDEO_OUT_OPT
{
	DWORD				dwSize;
	DH_RECT*			pstuMargin;						// Margin range
	DH_COLOR_BCSH*		pstuColor;						// Output color
	DH_COLOR_RGBA*		pstuBackground;					// Background color
	DH_SIZE*			pstuSize;						// Output dimensions
	DH_HOT_PLUG_MODE*	pstuHotPlugMode;				// mode of hot plug
} DH_VIDEO_OUT_OPT;

#define NET_VIDEOANALYSE_SCENES (32)
#define NET_VIDEOANALYSE_RULES (64)
// intelligent analysis
typedef struct tagNET_PD_VIDEOANALYSE
{
    BOOL                bSupport;                   // whether supported 
    char                szSupportScenes[NET_VIDEOANALYSE_SCENES][DH_COMMON_STRING_64];   // supported scenes name
    char                SupportRules[NET_VIDEOANALYSE_RULES][DH_COMMON_STRING_64];       // supported rules name
} NET_PD_VIDEOANALYSE;

// audio channel type
typedef enum tagEM_AUDIO_CHANNEL_TYPE
{
	EM_AUDIO_CHANNEL_SINGLE,		// single
	EM_AUDIO_CHANNEL_DOUBLE,		// double
}EM_AUDIO_CHANNEL_TYPE;

// WIFI scan and config support version type
typedef enum tagEM_WLAN_SCAN_AND_CONFIG_TYPE
{
    EM_WLAN_SCAN_AND_CONFIG_UNKNOWN,    // Unknown
    EM_WLAN_SCAN_AND_CONFIG_V2,         // version 2
    EM_WLAN_SCAN_AND_CONFIG_V3,         // version 3
}EM_WLAN_SCAN_AND_CONFIG_TYPE;

// product definition
typedef struct tagDH_PRODUCTION_DEFNITION
{
	DWORD				dwSize;
	int					nVideoInChannel;				// Video input channel amount
	int					nVideoOutChannel;				// Video output channel amount
	int					nRemoteDecChannel;				// Remote decode channel amount
	char				szDevType[DH_DEV_TYPE_LEN];		// Device type
	char				szVendor[DH_MAX_NAME_LEN];		// OEM customer
	int					nOEMVersion;					// OEM version
	int					nMajorVerion;					// Main version No.
	int					nMinorVersion;					// SUb version No.
	int					nRevision;						// Revision version
	char				szWebVerion[DH_MAX_NAME_LEN];	// Web version
	char				szDefLanguage[DH_MAX_NAME_LEN];	// Default setup
	NET_TIME			stuBuildDateTime;				// Release time. Unit is second.
	int					nAudioInChannel;				// Audio input channel amount
	int					nAudioOutChannel;				// Audio output channel amount
	BOOL				bGeneralRecord;					// Support schedule storage or not.
	BOOL				bLocalStore;					// Support local storage or not.
	BOOL				bRemoteStore;					// Support network storage or not.
	BOOL				bLocalurgentStore;				// Support emergency local storage or not.
	BOOL				bRealtimeCompress;				// Support real-time compression storage or not.
	DWORD				dwVideoStandards;				// The video format supported. bit0-PAL, bit1-NTSC
	int					nDefVideoStandard;				// Default video format, 0-PAL, 1-NTSC
	int					nMaxExtraStream;				// Max extra stream channel amount
	int					nRemoteRecordChannel;			// Remote record channel amount
	int					nRemoteSnapChannel;				// Remote snap channel amount
	int					nRemoteVideoAnalyseChannel;		// Remote video analysis channel amount
	int					nRemoteTransmitChannel;			// Remote real-time stream transmit max channel amount
	int					nRemoteTransmitFileChannel;		// Remote transmit file channel amount
	int					nStreamTransmitChannel;			// Max network transmit channel amount
	int					nStreamReadChannel;				// Max read file channel amount
	int					nMaxStreamSendBitrate;			// Max bit stream network send capability, kbps
	int					nMaxStreamRecvBitrate;			// Max bit stream network interface capability, kbps
	BOOL				bCompressOldFile;				// Old compression file or not. Delete P frame and save I frame.
	BOOL				bRaid;							// Support RAID or not.
	int					nMaxPreRecordTime;				// Max pre-record time.Unit is second.
	BOOL				bPtzAlarm;						// Support PTZ alarm or not.
	BOOL				bPtz;							// Support PTZ or not.
	BOOL				bATM;							// Support corresponding function of the ATM or not.
	BOOL				b3G;							// Support 3G module or not.
	BOOL				bNumericKey;					// With number button or not.
	BOOL				bShiftKey;						// With Shift button or not.
	BOOL				bCorrectKeyMap;					// Number character map sheet is right or not.
	BOOL				bNewATM;						// The new 2nd ATM front panel.
	BOOL				bDecoder;						// Decoder or not
	DEV_DECODER_INFO	stuDecoderInfo;					// Decoder info. Valid when bDecoder=true.bDecoder=true
	int					nVideoOutputCompositeChannels;	// integration ceiling screen output channel
	BOOL                bSupportedWPS;                  // support WPS or not
	int					nVGAVideoOutputChannels;		// VGA video output channel number
	int					nTVVideoOutputChannels;			// TV video output channel number
	int					nMaxRemoteInputChannels;		// max number of remote channels
	int					nMaxMatrixInputChannels;		// max number of matrix channels
	int                 nMaxRoadWays;                   // max counts of road ways 1~6
	int                 nMaxParkingSpaceScreen;         // max counts of screen when docking with the camera 0~20

	int					nPtzHorizontalAngleMin;			// PTZ'horizontal minimum Angle, [0-360]
	int					nPtzHorizontalAngleMax;			// PTZ'horizontal maximum Angle, [0-360]
	int					nPtzVerticalAngleMin;			// PTZ'vertical  minimum Angle, [-90,90]
	int					nPtzVerticalAngleMax;			// PTZ'vertical  maximum Angle, [-90,90]
	BOOL				bPtzFunctionMenu;				// Whether to support PTZ's function menu 
	BOOL				bLightingControl;				// Whether to support lighting control 
	DWORD				dwLightingControlMode;			// Manual lighting control mode,bitwise,see NET_LIGHTING_CTRL_ON_OFF
	int					nNearLightNumber;				// dipped headlight group number, 0 means no support 
	int					nFarLightNumber;				// High beam group number, 0 means no support
	BOOL				bFocus;							// Whether to support control focus 
	BOOL				bIris;							// Whether to support control aperture 
	char				szPtzProtocolList[DH_COMMON_STRING_1024];	// PTZ support agreement list, can be more, each with '; 'delimited 
	BOOL				bRainBrushControl;				// Whether to support wiper control 
	int					nBrushNumber;					// Number of wiper, 0 means no support
	int					nLowerMatrixInputChannels[DH_MAX_LOWER_MITRIX_NUM];		// inferior video matrix input channel, the subscript corresponding matrix number 
	int					nLowerMatrixOutputChannels[DH_MAX_LOWER_MITRIX_NUM];	// inferior video matrix output channel, the subscript corresponding matrix number 
    BOOL                bSupportVideoAnalyse;           // support intelligent analuysis or not
    BOOL                bSupportIntelliTracker;         // support intelligen tracking or not
    DWORD               nSupportBreaking;               // device supported violation type mask(by bit Get )
                                                        // 0-run the red light 1-cross line  2-retrogradation  3-under speed 4-over speed 5-car in lane 6-yellow plate in lane 7-violation driving, left, right, u-turn, 
                                                        // 8-violation enter waiting zone 9-illegal parking 10-Traffic jam 11-driving not by lane 12-illegal lane change 13-cross yellow line 14-should driving
                                                        // 15-manual snapshot 16-illegal retention 17-crosswalk pedestration first 18-over flow 19-under flow 20-illegal in lane 21-illegal back car
                                                        // 22-cross stop line 23-run yellow light 24-yellow grid line parking 25-car in parking 26-car not in parking 27-car in parking cross line  28-limited plate
                                                        // 29-no pass 30-unfasten seat belt 31-drvier smoking
    DWORD               nSupportBreaking1;              // 0-driver call 1-trafic-pedestrian redlight running 2-Traffic Jam Forbid Into 3-Pass Not In Order
    NET_PD_VIDEOANALYSE stuVideoAnalyse;                // IVS
    BOOL                bTalkTransfer;                  // support talk-transfer or not
    BOOL				bCameraAttribute;				// support video in options or not
    BOOL				bPTZFunctionViaApp;				// support PTZ function or not
	BOOL				bAudioProperties;				// support audio properties or not
	BOOL				bIsCameraIDOsd;					// support camera id osd or not
	BOOL				bIsPlaceOsd;					// support place osd or not

	unsigned int		nMaxGeographyTitleLine;			// the max geography title line
	EM_AUDIO_CHANNEL_TYPE emAudioChannel;				// the audio channel type
	char				szVendorAbbr[DH_COMMON_STRING_32];		// Vendor abbreviation
	char				szTypeVersion[DH_COMMON_STRING_32];		// Software release type
	BOOL				bIsVideoNexus;							// Is video nexus or not
    EM_WLAN_SCAN_AND_CONFIG_TYPE    emWlanScanAndConfig;        // WIFI scan and config support version type
    BOOL                bSupportLensMasking;                    // IPC support camera adjustment to negative angle for structural occlusion
} DH_PRODUCTION_DEFNITION;

// Manual lighting control mode 
#define NET_LIGHTING_CTRL_ON_OFF				0x01	// Direct switch mode 
#define NET_LIGHTING_CTRL_ADJUST_BRIGHTNESS		0x02	// Manually adjust brightness mode 
#define NET_LIGHTING_CTRL_ZOOM_PRIO				0x04	// Ratio prefer 


// Matrix sub card type. Various setups.
#define DH_MATRIX_CARD_MAIN				0x10000000		// main card
#define DH_MATRIX_CARD_INPUT			0x00000001		// input card 
#define DH_MATRIX_CARD_OUTPUT			0x00000002		// output card
#define DH_MATRIX_CARD_ENCODE			0x00000004		// encode card
#define DH_MATRIX_CARD_DECODE			0x00000008		// decode card
#define DH_MATRIX_CARD_CASCADE			0x00000010		// cascade card
#define DH_MATRIX_CARD_INTELLIGENT		0x00000020		// intelligent card
#define DH_MATRIX_CARD_ALARM            0x00000040      // alarm card 
#define DH_MATRIX_CARD_RAID             0x00000080      // Hdd Raid Card
#define DH_MATRIX_CARD_NET_DECODE       0x00000100      // net decode card

// Matrix sub card info
typedef struct tagDH_MATRIX_CARD
{
	DWORD				dwSize;
	BOOL				bEnable;					// Valid or not
	DWORD				dwCardType;					// Sub card type
	char		    	szInterface[DH_MATRIX_INTERFACE_LEN];	// Sub card interface type, "CVBS", "VGA", "DVI", "BT656","BT1120", "Fiber","HD-SDI", "HDCVI","HDMI","Dual-Link","3G-SDI", "RJ45"...
	char		    	szAddress[DH_MAX_IPADDR_OR_DOMAIN_LEN];	// Device IP or domain name. The sub card that has no network connection can be null.
	int			    	nPort;						// Port No. The sub card that has no network connection can be 0.
	int					nDefinition;				// Definition. 0=standard definition. 1=High definition
	int					nVideoInChn;				// Video input channel amount
	int					nAudioInChn;				// Audio input channel amount
	int					nVideoOutChn;				// Video output channel amount
	int				    nAudioOutChn;				// Audio output channel amount
	int			    	nVideoEncChn;				// Video encode channel amount
	int				    nAudioEncChn;				// Audio encode channel amount
	int			    	nVideoDecChn;				// Video decode channel amount
	int			    	nAudioDecChn;				// Audio decode channel amount
	int					nStauts;					// Status: 0-OK, 1-no respond, 2-network disconnection, 3-conflict, 4-upgrading now
	int					nCommPorts;					// COM amount
	int					nVideoInChnMin;				// Video input channel min value
	int					nVideoInChnMax;				// Video input channel max value
	int					nAudioInChnMin;				// Audio input channel min value
	int					nAudioInChnMax;				// Audio input channel max value
	int					nVideoOutChnMin;			// Video output channel min value
	int					nVideoOutChnMax;			// Video output channel max value
	int					nAudioOutChnMin;			// Audio output channel min value
	int					nAudioOutChnMax;			// Audio output channel max value	
	int					nVideoEncChnMin;			// Video encode channel min value
	int					nVideoEncChnMax;			// Video encode channel max value
	int					nAudioEncChnMin;			// Audio encode channel min value
	int					nAudioEncChnMax;			// Audio encode channel max value
	int					nVideoDecChnMin;			// Video decode channel min value
	int					nVideoDecChnMax;			// Video decode channel max value
	int					nAudioDecChnMin;			// Audio decode channel min value
	int					nAudioDecChnMax;			// Audio decode channel max value
	int					nCascadeChannels;			// number of cascade channel
	int					nCascadeChannelBitrate;		// cascade channel bitrate (Mbps)
	int					nAlarmInChnCount;			// Alarm input channel number 
	int					nAlarmInChnMin;				// Alarm input channel number minimum value 
	int					nAlarmInChnMax;				// Alarm input channel number maximum value 
	int					nAlarmOutChnCount;			// Alarm output channel number 
	int					nAlarmOutChnMin;			// Alarm output channel number minimum value
	int					nAlarmOutChnMax;			// Alarm output channel number maximum value
	int					nVideoAnalyseChnCount;		// Intelligent analysis of channel number 
	int					nVideoAnalyseChnMin;		// Intelligent analysis of channel number minimum value 
	int					nVideoAnalyseChnMax;		// Intelligent analysis of channel number maximum value
	int					nCommPortMin;				// minimum value of serial port number  
	int					nCommPortMax;				// maximum value of serial port number
    char                szVersion[DH_COMMON_STRING_32];         // Version info
    NET_TIME            stuBuildTime;                           // compile time
    char                szBIOSVersion[DH_COMMON_STRING_64];     // BIOS Version
    char				szMAC[DH_MACADDR_LEN];					// MAC address
} DH_MATRIX_CARD;

// Matrix sub card list
typedef struct tagDH_MATRIX_CARD_LIST 
{
	DWORD				dwSize;
	int					nCount;							// sub card  amount
	DH_MATRIX_CARD		stuCards[DH_MATRIX_MAX_CARDS];	// Sub card list 
} DH_MATRIX_CARD_LIST;

// Video output window
typedef struct tagDH_VIDEO_OUT_WINDOW
{
	DWORD				dwSize;
	int					nBackboardID;				// Backboard ID
	int					nScreenID;					// Screen ID
	int					nWindowID;					// Window ID
} DH_VIDEO_OUT_WINDOW;

// Set Backup up information, input parameter
typedef struct tagNET_IN_SETBACKUP_SOURCES_INFO
{
	DWORD				dwSize;
	int					nSetSourcesNum;				// 	Set Backup up num
	DH_SPLIT_SOURCE	*	pSource;					//  Video Sources(Memory is released by the user)
} NET_IN_SETBACKUP_SOURCES_INFO;

// Set Backup up information,inout parameter 
typedef struct tagNET_OUT_SETBACKUP_SOURCES_INFO
{
	DWORD				dwSize;
} NET_OUT_SETBACKUP_SOURCES_INFO;

// CLIENT_GetISCSITargets
typedef struct tagDH_IN_ISCSI_TARGETS 
{
	DWORD				dwSize;
	const char*			pszAddress;					// Server address
	int					nPort;						// port
	const char*			pszUser;					// Username
	const char*			pszPwd;						// Password
} DH_IN_ISCSI_TARGETS;

// ISCSI Target Info
typedef struct tagDH_ISCSI_TARGET 
{
	DWORD				dwSize;
	char				szName[DH_MAX_ISCSI_NAME_LEN];	// Name
	char				szAddress[DH_MAX_IPADDR_OR_DOMAIN_LEN];	// service address
	char				szUser[DH_NEW_USER_NAME_LENGTH];// user name
	int					nPort;							// port
	UINT				nStatus;						// status, 0- unknow, 1-connected, 2-un connected, 3-connect failed, 4-authentication failed, 5-connect time out	
} DH_ISCSI_TARGET;

// CLIENT_GetISCSITargets Interface output parameter
typedef struct tagDH_OUT_ISCSI_TARGETS
{
	DWORD				dwSize;
	DH_ISCSI_TARGET*	pstuTargets;				// iscsi array, the space application by the user, applt to sizeof(DH_ISCSI_TARGET)*nMaxCount
	int					nMaxCount;					// iscsi group size
	int					nRetCount;					// Received iscSi amount
} DH_OUT_ISCSI_TARGETS;

typedef enum tagDH_BITMAP_ACCURACY
{
    BA_DAY ,            //day 
    BA_HOUR ,           //day
    BA_5MIN ,           //5 miuntes
}DH_BITMAP_ACCURACY;

#define DH_MAX_BITMAPS        256                        // Bitmap bytes, DH_MAX_BITMAPS*8-bit
#define DH_MAX_CHN_NUM        256                        // The maximum channel number 
//CLIENT_GetBitmap Interface input parameters 
typedef struct tagDH_IN_BITMAP
{
    DWORD               dwSize;
    NET_TIME            stuStartTime;                   // start time, accurate to seconds 
    NET_TIME            stuEndTime;                     // Over time, accurate to seconds 
    int                 nChnList[DH_MAX_CHN_NUM];       // [1, ..., 10]	Channel number list ,-1 means all channels ,0 means channels end
    DH_BITMAP_ACCURACY  emAccuracy;                     // Precision of the bitmap     
}DH_IN_BITMAP;

typedef struct tagDH_BITMAP_INFO
{
    DWORD               dwSize;
    int                 nChnID;                         //Channel number, Channel number is 0, means the end of the list 
    BYTE                bBitmap[DH_MAX_BITMAPS];        //Bitmap (each bit means a query scale, from low to high filling) 
                                                        //support DH_MAX_BITMAPS * 8 scale
    int                 nBitNum;                        //the digits of bitmap 
}DH_BITMAP_INFO;

//CLIENT_GetBitmap  Interface output parameters 
typedef struct tagDH_OUT_BITMAP
{
    DWORD               dwSize;
    DH_BITMAP_INFO      *pstBitmapInfos;     // the space application by the user,apply to sizeof(DH_BITMAP_INFO)*nMaxBitmapInfo 
    int                 nGetBitmapInfo;
    int                 nMaxBitmapInfo;    
}DH_OUT_BITMAP;

// Storage device name
typedef struct tagDH_STORAGE_DEVICE_NAME 
{
	DWORD				dwSize;
	char				szName[DH_STORAGE_NAME_LEN];
} DH_STORAGE_DEVICE_NAME;

// RAID state
#define DH_RAID_STATE_ACTIVE		0x00000001
#define DH_RAID_STATE_INACTIVE		0x00000002
#define DH_RAID_STATE_CLEAN			0x00000004
#define DH_RAID_STATE_FAILED		0x00000008
#define DH_RAID_STATE_DEGRADED		0x00000010
#define DH_RAID_STATE_RECOVERING	0x00000020
#define DH_RAID_STATE_RESYNCING		0x00000040
#define DH_RAID_STATE_RESHAPING		0x00000080
#define DH_RAID_STATE_CHECKING		0x00000100
#define DH_RAID_STATE_NOTSTARTED	0x00000200

// RAID member info
typedef struct tagNET_RAID_MEMBER_INFO 
{
    DWORD               dwSize;
    DWORD               dwID;                                       // disk no., may use to describe disk cabinet slot
    BOOL                bSpare;                                     // partial hot device, true-partial hot device, false-RAID sub disk
} NET_RAID_MEMBER_INFO;

// RAID Info
typedef struct tagDH_STORAGE_RAID
{
	DWORD				dwSize;
	int					nLevel;										// level
	int					nState;										// RAID state combinationDH_RAID_STATE_ACTIVE | DH_RAID_STATE_DEGRADED
	int					nMemberNum;									// member amount
	char				szMembers[DH_MAX_MEMBER_PER_RAID][DH_STORAGE_NAME_LEN];	// RAID member
    float               fRecoverPercent;                            // Sync percentage, 0~100, RAID status has"Recovering" or "Resyncing" valid
    float               fRecoverMBps;                               // Sync speed, unit MBps, RAID status has"Recovering" or "Resyncing" valid
    float               fRecoverTimeRemain;                         // Sync remaining time, unit minute, RAID status has "Recovering" or "Resyncing" valid
    NET_RAID_MEMBER_INFO stuMemberInfos[DH_MAX_MEMBER_PER_RAID];    // RAID member info
	int                 nRaidDevices;                               // The number of RAID device
    int                 nTotalDevices;                              // The total count of RAID device
	int                 nActiveDevices;                             // The number of active device
	int                 nWorkingDevices;                            // The number of working device
	int                 nFailedDevices;                             // The number of failed device
	int                 nSpareDevices;                              // The number of hot-spare device
	char                szAliasName[DH_COMMON_STRING_24];           // Alias Name,UTF-8 code
} DH_STORAGE_RAID;

// Storage partition info
typedef struct tagDH_STORAGE_PARTITION
{
	DWORD				dwSize;
	char				szName[DH_STORAGE_NAME_LEN];				// Name
	INT64				nTotalSpace;   							    // Total space(MB) 
	INT64				nFreeSpace;								    // free space(MB)
	char				szMountOn[DH_STORAGE_MOUNT_LEN];			// Mount point
	char				szFileSystem[DH_STORAGE_FILE_SYSTEM_LEN];	// File system
	int					nStatus;									// partition state, 0-LV not available, 1-LV available
} DH_STORAGE_PARTITION;

// storage tank info
typedef struct tagDH_STORAGE_TANK 
{
	DWORD				dwSize;
	int					nLevel;										// level, the host is 0 level
	int					nTankNo;									// extend port number from 0
    int                 nSlot;                                      // Corresponding cabinet board card no., start from 0
} DH_STORAGE_TANK;

// storage device status
#define NET_STORAGE_DEV_OFFLINE                 0                   // physical disk offline status
#define NET_STORAGE_DEV_RUNNING                 1                   // physicali disk running ststus
#define NET_STORAGE_DEV_ACTIVE                  2                   // RAID activity
#define NET_STORAGE_DEV_SYNC                    3                   // RAID sync
#define NET_STORAGE_DEV_SPARE                   4                   // RAID hotdevice(partial)
#define NET_STORAGE_DEV_FAULTY                  5                   // RAID invalid
#define NET_STORAGE_DEV_REBUILDING              6                   // RAID re-build
#define NET_STORAGE_DEV_REMOVED                 7                   // RAID remove
#define NET_STORAGE_DEV_WRITE_ERROR             8                   // RAID error
#define NET_STORAGE_DEV_WANT_REPLACEMENT        9                   // RAID need to be replaced
#define NET_STORAGE_DEV_REPLACEMENT             10                  // RAID is replacement
#define NET_STORAGE_DEV_GLOBAL_SPARE            11                  // Global hotdevice
#define NET_STORAGE_DEV_ERROR                   12                  // Error, partial available
#define NET_STORAGE_DEV_RAIDSUB                 13                  // The disk is single, originally is Raid sub disk, may auto add Raid after reboot
#define NET_STORAGE_DEV_FATAL                   14                  // Fatal,all is error
#define NET_STORAGE_DEV_SNAPSHOT_PARENT         15                  // Snapshot Parent
#define NET_STORAGE_DEV_SNAPSHOT_CHILD          16                  // Snapshot Child
#define NET_STORAGE_DEV_VOLUMECLONE_PARENT      17                  // Volume clone parent
#define NET_STORAGE_DEV_VOLUMECLONE_CHILD      18                  // Volume clone child

// hard disk power mode
typedef enum tagEM_STORAGE_DISK_POWERMODE
{
	EM_STORAGE_DISK_POWERMODE_UNKNOWN,                                  // UNKnown
	EM_STORAGE_DISK_POWERMODE_NONE,                                     // none
	EM_STORAGE_DISK_POWERMODE_ACTIVE,                                   // Active
	EM_STORAGE_DISK_POWERMODE_STANDBY,                                  // StandBy
	EM_STORAGE_DISK_POWERMODE_IDLE,                                     // Idle
}EM_STORAGE_DISK_POWERMODE;

// pre disk check(EVS)
typedef enum tagEM_STORAGE_DISK_PREDISKCHECK
{
	EM_STORAGE_DISK_PREDISKCHECK_UNKNOWN,                               // UnKnown
	EM_STORAGE_DISK_PREDISKCHECK_GOOD,                                  // good,read rate up to 120,,smart have a little error,other noerror.
	EM_STORAGE_DISK_PREDISKCHECK_WARN,                                  // warn,cmd have a little error,smart have error
	EM_STORAGE_DISK_PREDISKCHECK_ERROR,                                 // error,cmd have error,smart have error.have bad sector
	EM_STORAGE_DISK_PREDISKCHECK_WILLFAIL,                              // willfail,hard disk rate lower than 64M.cmd have error,smart have error.have bad sector
	EM_STORAGE_DISK_PREDISKCHECK_FAIL,                                  // hard disk return fail
	EM_STORAGE_DISK_PREDISKCHECK_NONE,                                  // none
	EM_STORAGE_DISK_PREDISKCHECK_BECHECK,                               // checking
	EM_STORAGE_DISK_PREDISKCHECK_CHECKFAIL,                             // check fail
}EM_STORAGE_DISK_PREDISKCHECK;

// Storage device info
typedef struct tagDH_STORAGE_DEVICE 
{
	DWORD				dwSize;
	char				szName[DH_STORAGE_NAME_LEN];				// name
	INT64				nTotalSpace;								// Total space, byte 
	INT64				nFreeSpace;									// free space, byte 
	BYTE				byMedia;									// Media, 0-DISK, 1-CDROM, 2-FLASH medium,  
	BYTE				byBUS;										// BUS, 0-ATA, 1-SATA, 2-USB, 3-SDIO, 4-SCSI main line 0-ATA, 1-SATA, 2-USB, 3-SDIO, 4-SCSI
	BYTE				byVolume;									// volume type, 0-physics, 1-Raid, 2- VG virtual 3-ISCSI, 4-Invidual Physical Volume, 5-VolumeGroup, 6-NAS ( FTP, SAMBA, NFS), 7-Invidual Raid Volume
	BYTE				byState;									// Physics disk state, 0-physics disk offline state 1-physics disk  2- RAID activity 3- RAID sync 4-RAID hotspare 5-RAID invalidation 6- RAID re-creation  7- RAID delete
	int					nPhysicNo;									// storage interface of devices of same type logic number
	int					nLogicNo;									// storage interface of devices of same type physics number
	char				szParent[DH_STORAGE_NAME_LEN];				// superior storage group name
	char				szModule[DH_STORAGE_NAME_LEN];				// device module
	char				szSerial[DH_SERIALNO_LEN];					// device serial number
	char				szFirmware[DH_VERSION_LEN];					// Firmware version
	int					nPartitionNum;								// partition number
	DH_STORAGE_PARTITION stuPartitions[DH_MAX_STORAGE_PARTITION_NUM];// partition info
	DH_STORAGE_RAID		stuRaid;									// Raid info, for RAID use only(byVolume == 1) 
	DH_ISCSI_TARGET		stuISCSI;									// Iscsi info, for iscsi use only (byVolume == 2)
	BOOL				abTank;										// tank enable
	DH_STORAGE_TANK		stuTank;									// tank info, effective when abTank = TRUE

    EM_STORAGE_DISK_POWERMODE           emPowerMode;                // hard disk power mode
	EM_STORAGE_DISK_PREDISKCHECK        emPreDiskCheck;             // pre disk check(EVS)
} DH_STORAGE_DEVICE; 

// OSD channel info
typedef struct tagNET_SPLIT_OSD 
{
    DWORD               dwSize;
    BOOL                bEnable;                    // enable
    DH_COLOR_RGBA       stuFrontColor;              // The foreground color 
    DH_COLOR_RGBA       stuBackColor;               // The background color 
    DH_RECT             stuFrontRect;               // Foreground area 
    DH_RECT             stuBackRect;                // Background region 
    BOOL                bRoll;                      // Whether the scroll display, applies to the text only 
    BYTE                byRollMode;                 // Scroll mode, applies only to text, 0 -from left to right,1-from right to left,2-from top to bottom,3-from bottom to top
    BYTE                byRoolSpeed;                // Rolling speed, applies to text  only , 0 ~ 4, the greater the value the faster the scrolling 
    BYTE                byFontSize;                 // The font size, applies to the text only  
    BYTE                byTextAlign;                // Alignment, 0 - left, 1 - centered, 2 - right 
    BYTE                byType;                     // OSD type, 0 - text, 1 - icon,  2 - Time
    BYTE                Reserved[3];                // retain byte
    char                szContent[MAX_PATH];        // OSD content
													// if the type is icon, the content is the name of the icon 
													// if the type is Time, content is the free combination with "Date","Week","Time","\n"
													// For example:Non-peer display,this field must be filled with "Date\nTime",then screem will show
													// 2018423
													// 16:49:15
													// Peers show,this field must be filled with"DateTime":
													// 201842316:49:15
    float               fPitch;                     // field interval, 0.0 ~ 5.0
    char                szFontType[DH_COMMON_STRING_64]; // font type 
} NET_SPLIT_OSD;

// CLIENT_GetSplitOSD's interface input param(get split window input OSD info)
typedef struct tagDH_IN_SPLIT_GET_OSD
{
	DWORD					dwSize;
	int						nChannel;				// channel no.
	int						nWindow;				// window no.
} DH_IN_SPLIT_GET_OSD;

// CLIENT_GetSplitOSD's interface input param(get split window output OSD info)
typedef struct tagDH_OUT_SPLIT_GET_OSD
{
	DWORD					dwSize;
    int                 nOSDNum;                            // OSD number
    NET_SPLIT_OSD       stuOSD[DH_VIDEO_CUSTOM_OSD_NUM];    // OSD information
} DH_OUT_SPLIT_GET_OSD;

// CLIENT_SetSplitOSD's interface input param(setting split window input OSD info)
typedef struct tagDH_IN_SPLIT_SET_OSD
{
	DWORD					dwSize;
	int						nChannel;							// channel no.
	int						nWindow;							// window no.
    int                 	nOSDNum;                            // OSD number
    NET_SPLIT_OSD       	stuOSD[DH_VIDEO_CUSTOM_OSD_NUM];    // OSD information
} DH_IN_SPLIT_SET_OSD;

// CLIENT_SetSplitOSD's interface input param(setting split window output OSD info)
typedef struct tagDH_OUT_SPLIT_SET_OSD
{
	DWORD					dwSize;
} DH_OUT_SPLIT_SET_OSD;

// CLIENT_GetSplitOSDEx's interface input param(get split window input OSD info)
typedef struct tagNET_IN_SPLIT_GET_OSD_EX
{
	DWORD					dwSize;					// the size of this struct
	int						nChannel;				// channel no.
	int						nWindow;				// window no.
} NET_IN_SPLIT_GET_OSD_EX;

// CLIENT_GetSplitOSDEx's interface input param(get split window output OSD info)
typedef struct tagNET_OUT_SPLIT_GET_OSD_EX
{
	DWORD				dwSize;									// the size of this struct
    int                 nOSDNum;                            	// OSD number
    NET_SPLIT_OSD       stuOSD[DH_VIDEO_CUSTOM_OSD_NUM_EX];   	// OSD information
} NET_OUT_SPLIT_GET_OSD_EX;


// CLIENT_SetSplitOSDEx's interface input param(setting split window input OSD info)
typedef struct tagNET_IN_SPLIT_SET_OSD_EX
{
	DWORD               dwSize;									// the size of this struct
    int                 nChannel;                           	// channel no.
    int                 nWindow;                            	// window no.
    int                 nOSDNum;                            	// OSD number
    NET_SPLIT_OSD       stuOSD[DH_VIDEO_CUSTOM_OSD_NUM_EX];		// OSD information
}NET_IN_SPLIT_SET_OSD_EX;

// CLIENT_SetSplitOSDEx's interface input param(setting split window output OSD info)
typedef struct tagNET_OUT_SPLIT_SET_OSD_EX
{
    DWORD               dwSize;			// the size of this struct
} NET_OUT_SPLIT_SET_OSD_EX;


// Video output control method 
typedef enum
{
    EM_VIDEO_OUT_CTRL_CHANNEL,              // Logical channel number control mode,effective for physical screen and splicing screen 
    EM_VIDEO_OUT_CTRL_COMPOSITE_ID,         // Splice screen ID control mode, applies to splice screen only  
} EM_VIDEO_OUT_CTRL_TYPE;

// CLIENT_SetSplitSourceEx  The input parameters of the interface 
typedef struct tagNET_IN_SET_SPLIT_SOURCE 
{
    DWORD                   dwSize;
    EM_VIDEO_OUT_CTRL_TYPE  emCtrlType;         // Video output control method 
    int                     nChannel;           // Video output logical channel number,when the emCtrlType is EM_VIDEO_OUT_CTRL_CHANNEL effective
    const char*             pszCompositeID;     // Splicing screen ID, when the emCtrlType is EM_VIDEO_OUT_CTRL_CHANNEL effective
    int                     nWindow;            // winder number, -1 means all windows of the current segmentation mode 
    DH_SPLIT_SOURCE*        pstuSources;        // Video source information, when nWindow=-1, Video source is an array, and the number and the window number
												// the space application by the user,applt to sizeof(DH_SPLIT_SOURCE)*nSourceCount
	int                     nSourceCount;       // Video source number 
} NET_IN_SET_SPLIT_SOURCE;

// Set the return result of video source  
typedef struct tagNET_SET_SPLIT_SOURCE_RESULT 
{
    DWORD                   dwSize;
    int                     nPushPort;          // Monitor Port Number of Push Flow Pattern Equipment 
} NET_SET_SPLIT_SOURCE_RESULT;

// CLIENT_SetSplitSourceEx output parameters of the interface 
typedef struct tagNET_OUT_SET_SPLIT_SOURCE
{
    DWORD                   dwSize;
    NET_SET_SPLIT_SOURCE_RESULT* pstuResults;   // returned value after successful setting , corresponding the window array in NET_IN_SET_SPLIT_SOURCE, user allocates memory , apply to sizeof(NET_SET_SPLIT_SOURCE_RESULT)*nMaxResultCount,If don't need can be NULL 
    int                     nMaxResultCount;    // The size of the pstuResults array
    int                     nRetCount;          // The Number Of Return
} NET_OUT_SET_SPLIT_SOURCE;

// CLIENT_SplitExchangeSource's interface input param
typedef struct tagNET_IN_SPLIT_EXCHANGE_SOURCE
{
	DWORD					dwSize;				
	int						nChannel;			// channel ID, enabled when pszCompositeID is null
    const char*				pszCompositeID;     // multi-screen display ID
	int						nWindowID1;			// Window1's ID
	int						nWindowID2;			// Window2's ID
}NET_IN_SPLIT_EXCHANGE_SOURCE;

// CLIENT_SplitExchangeSource's interface output param
typedef struct tagNET_OUT_SPLIT_EXCHANGE_SOURCE
{
	DWORD					dwSize;		
}NET_OUT_SPLIT_EXCHANGE_SOURCE;


//volume type enumeration
typedef enum tagNET_VOLUME_TYPE
{
    VOLUME_TYPE_ALL = 0      ,      //all volume
    VOLUME_TYPE_PHYSICAL     ,      //physical volume
    VOLUME_TYPE_RAID         ,      //Raid volume
    VOLUME_TYPE_VOLUME_GROUP ,      //VG virtual volume
    VOLUME_TYPE_ISCSI        ,      //iSCSI volume
    VOLUME_TYPE_INVIDUAL_PHY ,      //independent physical volume, this physical volume, is not added into,  RAID, virtual volume group, 
    VOLUME_TYPE_GLOBAL_SPARE ,      //global hot spare volume
	VOLUME_TYPE_NAS			 ,		//NAS volume(include FTP, SAMBA, NFS)
	VOLUME_TYPE_INVIDUAL_RAID,		//independent raid volume, is not added into virtual volume group.
    VOLUME_TYPE_MAX          ,
}NET_VOLUME_TYPE;


#define    MAX_DEVICE_VOLUME_NUMS        128                //volume type upper limit

//CLIENT_QueryDevInfo , NET_QUERY_DEV_STORAGE_NAMES type port input parameter
typedef struct tagNET_IN_STORAGE_DEV_NAMES
{
    DWORD               dwSize;
    NET_VOLUME_TYPE     emVolumeType;       //volume type to get
} NET_IN_STORAGE_DEV_NAMES;

//CLIENT_QueryDevInfo , NET_QUERY_DEV_STORAGE_NAMES type volume output parameter
typedef struct tagNET_OUT_STORAGE_DEV_NAMES
{
    DWORD               dwSize;
    int                 nDevNamesNum;                       							//got device storage module name quantity
    char                szStoregeDevNames[MAX_DEVICE_VOLUME_NUMS][DH_STORAGE_NAME_LEN]; //device name list
}NET_OUT_STORAGE_DEV_NAMES;

//CLIENT_QueryDevInfo , NET_QUERY_DEV_STORAGE_INFOS port input parameter
typedef struct tagNET_IN_STORAGE_DEV_INFOS
{
    DWORD               dwSize;
    NET_VOLUME_TYPE     emVolumeType;       //volume type to get
} NET_IN_STORAGE_DEV_INFOS;

//CLIENT_QueryDevInfo , NET_QUERY_DEV_STORAGE_INFOS port output parameter
typedef struct tagNET_OUT_STORAGE_DEV_INFOS
{
    DWORD               dwSize;
    int                 nDevInfosNum;                      			//device storage moduleinfo list to get
    DH_STORAGE_DEVICE   stuStoregeDevInfos[MAX_DEVICE_VOLUME_NUMS]; //device info list, dwsize of DH_STORAGE_DEVICE need to assign value
} NET_OUT_STORAGE_DEV_INFOS;

typedef enum tagNET_RECENCY_CAR_INFO
{
    RECENCY_CAR_INFO_UNKNOW = 0 ,
    RECENCY_CAR_INFOO_NEWEST    ,      //newest
    RECENCY_CAR_INFO_ODLEST     ,      //oldest
    RECENCY_CAR_INFO_MAX        ,
}NET_RECENCY_CAR_INFO;

//CLIENT_QueryDevInfo , NET_QUERY_RECENCY_JNNCTION_CAR_INFO port input parameter
typedef struct tagNET_IN_GET_RECENCY_JUNCTION_CAR_INFO
{
    DWORD                   dwSize;
    int                     nChannel;       //snapshot channel no.
    NET_RECENCY_CAR_INFO    emRecencyType;  //get vehicle info type, newest or latest
    DWORD                   nIndex;         //no. vehicle info, from 1, if it is 0, it alsomeans no. 1
}NET_IN_GET_RECENCY_JUNCTION_CAR_INFO;

//CLIENT_QueryDevInfo , NET_QUERY_RECENCY_JNNCTION_CAR_INFO port output parameter
typedef struct tagNET_OUT_GET_RECENCY_JUNCTION_CAR_INFO
{
    DWORD           dwSize;
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;        // traffic vehicle info
}NET_OUT_GET_RECENCY_JUNCTION_CAR_INFO;

// 
#define NET_MAX_FISHEYE_WINDOW_NUM        8     // Max fish eye window number

// window position info 
typedef struct tagNET_FISHEYE_WINDOW_INFO
{
  DWORD      dwSize;
  DWORD      dwWindowID;            // window ID
  int        nFocusX;              	// EPtz, E-PTZ , focus horizontal coordinate
  int        nFocusY;              	// EPtz (E-PTZ , focus vertical coordinate  
  int        nHorizontalAngle;      // EPtz horizontal degree
  int        nVerticalAngle;        // EPtz vertical degree
}NET_FISHEYE_WINDOW_INFO;

// corresponding to CLIENT_QueryDevInfo port, NET_QUERY_DEV_FISHEYE_WININFO search Fish eye window info input parameter
typedef struct tagNET_IN_FISHEYE_WININFO
{
  DWORD       dwSize;
  int         nChannelId;           // channel no.
  int         nWindowNum;           // search window number
  int         nWindows[NET_MAX_FISHEYE_WINDOW_NUM]; // window id, cannot repeat
}NET_IN_FISHEYE_WININFO;

// corresponding to CLIENT_QueryDevInfo port, NET_QUERY_DEV_FISHEYE_WININFO search Fish eye window info output parameter
typedef struct tagNET_OUT_FISHEYE_WININFO
{
  DWORD       dwSize;
  int         nWindowNum;           //window number
  NET_FISHEYE_WINDOW_INFO stuWindows[NET_MAX_FISHEYE_WINDOW_NUM]; // windowdetail info 
}NET_OUT_FISHEYE_WININFO;

//CLIENT_QueryDevInfo , NET_QUERY_LANES_STATE port input parameter
typedef struct tagNET_IN_GET_LANES_STATE
{
  DWORD         dwSize;
  int           nLaneNumber; //-1 represents search all lane,>=0 means search specify lane
}NET_IN_GET_LANES_STATE;

//signal light indicator status 
typedef enum tagNET_TRAFFIC_LIGHT_STATUS
{
  LIGHT_STATUS_UNKNOWN = 0  ,  	//unknown 
  LIGHT_STATUS_RED      ,  		//red
  LIGHT_STATUS_GREEN     ,  	//green
  LIGHT_STATUS_YELLOW     ,  	//yellow
}NET_TRAFFIC_LIGHT_STATUS;

//signal light indicator info 
typedef struct tatNET_TRAFFIC_LIGHT_INFO
{
  DWORD            			dwSize;
  NET_TRAFFIC_LIGHT_STATUS  emStraightLightInfo;  //straight light status 
  NET_TRAFFIC_LIGHT_STATUS  emLeftLightInfo;      //left light status 
  NET_TRAFFIC_LIGHT_STATUS  emRightLightInfo;     //right light status 
  NET_TRAFFIC_LIGHT_STATUS  emUTurnLightInfo;     //u-turn light status 
}NET_TRAFFIC_LIGHT_INFO;

//lane direction
typedef enum tagNET_TRAFFIC_DIRECTION
{
  DIRECTION_UNKNOW  = 0,  // unknown 
  DIRECTION_STRAIGHT   ,   //straight
  DIRECTION_LEFT       ,   //left
  DIRECTION_RIGHT      ,   //right
  DIRECTION_UTURN      ,   //u-turn
}NET_TRAFFIC_DIRECTION;

//lane info 
typedef struct tagNET_TRAFFIC_LANE_INFO
{
  DWORD         dwSize;
  UINT          nLaneNumber;                  //lane no.,0 start 
  UINT          nSupportDirectionNum;         //lane can drive direction number
  NET_TRAFFIC_DIRECTION  emTrafficDirections[MAX_LANE_DIRECTION_NUM];  //lane direction, means this lane can drive in all directions
  NET_TRAFFIC_JAM_STATUS emJamState;          //road jam status
  //flow info 
  UINT          nLargeVehicleNum;             //large car quantity
  UINT          nMediumVehicleNum;            //medium car quantity
  UINT          nSmallVehicleNum;             //small car quantity
  UINT          nMotoNum;                     //motor quantity
}NET_TRAFFIC_LANE_INFO;

//CLIENT_QueryDevInfo , NET_QUERY_LANES_STATE port output parameter
typedef struct tagNET_OUT_GET_LANES_STATE
{
  DWORD         dwSize;
  int           nGetLaneInfoNum;          					// Get lane info quantity
  NET_TRAFFIC_LANE_INFO  stLaneInfos[MAX_LANE_INFO_NUM];    // Get lane info 
  NET_TRAFFIC_LIGHT_INFO stLightInfo;            			// signal light indicator status 
}NET_OUT_GET_LANES_STATE;

//CLIENT_QueryDevInfo , input param
typedef struct tagNET_IN_SYSTEM_INFO
{
    DWORD               dwSize;
} NET_IN_SYSTEM_INFO;

//CLIENT_QueryDevInfo , output param
typedef struct tagNET_OUT_SYSTEM_INFO
{
    DWORD               dwSize;
    BOOL                bHasRTC;                       // whether system has RTC(for recording system time),TRUE:Yes,FALSE:No
    int                 nRetMCUNum;                   // MCU number of return 	 	 
    char                szMCUVersion[MAX_MCU_NUM][DH_MAX_VERSION_LEN];         // MCU software version
}NET_OUT_SYSTEM_INFO;


// port  CLIENT_AttachLanesState input parameter
typedef struct tagNET_IN_REGDEV_NET_INFO
{
    DWORD               dwSize;
    char                szDevSerial[DH_DEV_SERIALNO_LEN];   // Device SN by auto register 
}NET_IN_REGDEV_NET_INFO;

// celluar net type
typedef enum tagNET_CELLUAR_NET_TYPE 
{
    EM_CELLUAR_NET_UNKNOW           =   -1  ,    //Unknown 
    EM_CELLUAR_NET_PRIVATE_3G_4G    =   0   ,    //Special 3G/4G network (such as the internal network of the public security authority)
    EM_CELLUAR_NET_COMMERCIAL_3G_4G =   1   ,    //Business 3G/4G network (Such as internet service provider)
    EM_CELLUAR_NET_MAX , 
}NET_CELLUAR_NET_TYPE;

//output param of CLIENT_QueryDevInfo according to NET_QUERY_REG_DEVICE_NET_INFO 
typedef struct tagNET_OUT_REGDEV_NET_INFO
{
    DWORD                   dwSize;
    NET_CELLUAR_NET_TYPE    emCelluarNetType;           //Network type when auto register 
}NET_OUT_REGDEV_NET_INFO;

// video channel type when query video channel info
typedef enum tagNET_VIDEO_CHANNEL_TYPE
{
    NET_VIDEO_CHANNEL_TYPE_ALL,                         // all types
    NET_VIDEO_CHANNEL_TYPE_INPUT,                       // input
    NET_VIDEO_CHANNEL_TYPE_OUTPUT,                      // output
} NET_VIDEO_CHANNEL_TYPE;

//input param of CLIENT_QueryDevInfo according to NET_QUERY_VIDEOCHANNELSINFO 
typedef struct tagNET_IN_GET_VIDEOCHANNELSINFO
{
    DWORD                               dwSize;
    NET_VIDEO_CHANNEL_TYPE              emType;         // video channel type to query                     
} NET_IN_GET_VIDEOCHANNELSINFO;

typedef struct tagNET_VIDEOCHANNELS_INPUT 
{
    int                     nThermographyCount;         // thermo channel count in nThermography
    int                     nThermography[64];          // thermo channel numbers
    int                     nMultiPreviewCount;         // multi preview channel count in nMultiPreview
    int                     nMultiPreview[4];	        // multi preview channel numbers
    int                     nPIPCount;                  // PIP channel count in nPIP
    int                     nPIP[4];    	            // PIP channel numbers
    int                     nCompressPlayCount;         // compress play channel count in nCompressPlay
    int                     nCompressPlay[4];	        // compress play channel numbers
	int						nSDCount;					// SD channel count in nSD
	int						nSD[64];					// SD channel numbers
	int                     nPTZCount;                  // PTZ channel count
	short                   nPTZ[64];                   // PTZ channel numbers
	int                     nFuseRadarCount;            // FuseRadar channel count in nFuseRadar
	int						nFuseRadar[64];             // FuseRadar channel numbers
	int                     nPureRadarCount;            // PureRadar channel count in nPureRadar
	int						nPureRadar[64];             // PureRadar channel numbers
    char                    reserved[4096];
} NET_VIDEOCHANNELS_INPUT;

typedef struct tagNET_VIDEOCHANNELS_OUTPUT 
{
    int                     nVGACount;                  // VGA output count in nVGA
    int                     nVGA[128];                  // VGA output channel numbers
    int                     nTVCount;                   // TV output count in nTV
    int                     nTV[128];                   // TV output channel numbers
    char                    reserved[512];
} NET_VIDEOCHANNELS_OUTPUT;

//output param of CLIENT_QueryDevInfo according to NET_QUERY_VIDEOCHANNELSINFO
typedef struct tagNET_OUT_GET_VIDEOCHANNELSINFO
{
    DWORD                       dwSize;
    NET_VIDEOCHANNELS_INPUT     stInputChannels;        // input channel info        
    NET_VIDEOCHANNELS_OUTPUT    stOutputChannels;       // output channel info
} NET_OUT_GET_VIDEOCHANNELSINFO;

// CLIENT_QueryDevInfo , NET_QUERY_WORKGROUP_NAMES input
typedef struct tagNET_IN_WORKGROUP_NAMES
{
    DWORD                       dwSize;
} NET_IN_WORKGROUP_NAMES;

// max length for workgroup name
#define WORKGROUP_NAME_LEN      32

//CLIENT_QueryDevInfo , NET_QUERY_WORKGROUP_NAMES output
typedef struct tagNET_OUT_WORKGROUP_NAMES
{
    DWORD                       dwSize;
    int                         nCount;                         // workgroup count
    char                        szName[64][WORKGROUP_NAME_LEN]; // name of each workgroup
} NET_OUT_WORKGROUP_NAMES;

//CLIENT_QueryDevInfo , NET_QUERY_WORKGROUP_INFO input
typedef struct tagNET_IN_WORKGROUP_INFO
{
    DWORD                       dwSize;
    char                        szName[WORKGROUP_NAME_LEN];     // workgroup whose info you want to query                    
} NET_IN_WORKGROUP_INFO;

//CLIENT_QueryDevInfo , NET_QUERY_WORKGROUP_INFO input
typedef struct tagNET_OUT_WORKGROUP_INFO
{
    DWORD                       dwSize;
    int                         nState;                         // state: 0 nonsense, 1 normal, 2 damaged, 3 error
    int                         nTotalSpace;                    // Total Space Unit: MB, -1 for error
    int                         nFreeSpace;                     // Free Space Unit: MB -1 for error
} NET_OUT_WORKGROUP_INFO;

//CLIENT_QueryDevInfo , NET_QUERY_WLAN_ACCESSPOINT input
typedef struct tagNET_IN_WLAN_ACCESSPOINT
{
    DWORD                       dwSize;
    char                        szSSID[DH_MAX_SSID_LEN];        // SSID of wireless network whose info you want to query. if null, query all wireless network
	char						szName[MAX_COMMON_STRING_32];	// Network Name, default is eth2
} NET_IN_WLAN_ACCESSPOINT;

typedef struct tagNET_WLAN_ACCESSPOINT_INFO
{
    char                        szSSID[DH_MAX_SSID_LEN];        // SSID (name of wireless network)
    int                         nStrength;                      // signal strength, range: 0-100
    int                         nAuthMode;                      // attestation mod:0:OPEN;1:SHARED;2:WPA;3:WPA-PSK;4:WPA2;5:WPA2-PSK;
                                                                // 6:WPA-NONE(only use in Adhoc mode),
                                                                // 7-11 are mix mode,choose one of them can to be connected 
                                                                // 7:WPA-PSK | WPA2-PSK; 8:WPA | WPA2; 9:WPA | WPA-PSK;
                                                                // 10:WPA2 | WPA2-PSK; 11:WPA | WPA-PSK |WPA2 |WPA2-PSK //12: UnKnown
    int                         nEncrAlgr;                      // 0:NONE, 1:WEP, 2:TKIP, 3:AES(CCMP), 4:TKIP+AES( mix Mode), 5:UnKnown
    char                        reserved[1016];
} NET_WLAN_ACCESSPOINT_INFO;

//CLIENT_QueryDevInfo , NET_QUERY_WLAN_ACCESSPOINT output
typedef struct tagNET_OUT_WLAN_ACCESSPOINT
{
    DWORD                       dwSize;
    int                         nCount;                         // wireless network count
    NET_WLAN_ACCESSPOINT_INFO   stuInfo[128];                   // info for each network                       
} NET_OUT_WLAN_ACCESSPOINT;



// input for CLIENT_QueryDevInfo, NET_QUERY_TRAFFICRADAR_VERSION 
typedef struct tagNET_IN_TRAFFICRADAR_VERSION
{
    DWORD                   dwSize;
    int                     nChannel;                   // serial port number
} NET_IN_TRAFFICRADAR_VERSION;
// output of CLIENT_QueryDevInfo , NET_QUERY_TRAFFICRADAR_VERSION
typedef struct tagNET_OUT_TRAFFICRADAR_VERSION
{
    DWORD                   dwSize;
    char                    szVersion[DH_MAX_VERSION_LEN];  // version
} NET_OUT_TRAFFICRADAR_VERSION;

// input for CLIENT_AttachLanesState 
typedef NET_OUT_GET_LANES_STATE NET_CB_LANES_STATE;

// callback for CLIENT_AttachLanesState 
typedef void (CALLBACK *fNotifyLanesState)(LLONG lLanesStateHandle, NET_CB_LANES_STATE* pLanesStateInfo, LDWORD dwUser, void *reserved);

// port  CLIENT_AttachLanesState input parameter
typedef struct tagNET_IN_ATTACH_LANES_STATE
{
  DWORD       dwSize;              	// this structure size
  int         nChannelID;           // channel no.
  int         nLaneNumber;          // -1order all lanes, >=0 means order specific lane
  
  fNotifyLanesState  cbNotifyLanesState;       // call function
  LDWORD      dwUser;             	// user custom parameter
} NET_IN_ATTACH_LANES_STATE;

// port  CLIENT_AttachLanesState output parameter
typedef struct tagNET_OUT_ATTACH_LANES_STATE
{
  DWORD        dwSize;             // this structure size
} NET_OUT_ATTACH_LANES_STATE;


// CLIENT_MatrixSwitch The input parameters 
typedef struct tagNET_IN_MATRIX_SWITCH
{
    DWORD           dwSize;
    DH_SPLIT_MODE   emSplitMode;                // Segmentation Model 
    int*            pnOutputChannels;           // Output channel, can specify multiple output channel switch together at the same time, the content is consistent 
												// the space application by the user, apply to sizeof(int)*nOutputChannelCount
	int             nOutputChannelCount;        // Output channel number 
    int*            pnInputChannels;            // Input channel, each split window corresponding to one input channel 
												// the space application by the user, apply to sizeof(int)*nInputChannelCount
	int             nInputChannelCount;         // Input channel number
} NET_IN_MATRIX_SWITCH;

// CLIENT_MatrixSwitch Output Parameters 

typedef struct tagNET_OUT_MATRIX_SWITCH 
{
    DWORD            dwSize;
} NET_OUT_MATRIX_SWITCH;

// CLIENT_SplitSetMultiSource The Input Parameters of the Interface 
typedef struct tagNET_IN_SPLIT_SET_MULTI_SOURCE 
{
    DWORD                   dwSize;
    EM_VIDEO_OUT_CTRL_TYPE  emCtrlType;         // Video output control method 
    int                     nChannel;           // Video output logical channel number,Effective When emCtrlType is EM_VIDEO_OUT_CTRL_CHANNEL
    const char*             pszCompositeID;     // Splicing screen ID,When emCtrlType is EM_VIDEO_OUT_CTRL_COMPOSITE_ID
    BOOL                    bSplitModeEnable;   // Whether to change segmentation model 
    DH_SPLIT_MODE           emSplitMode;        // Segmentation model,Enable when bSplitModeEnable=TRUE
    int                     nGroupID;           // Segmentation group number,Effective when bSplitModeEnable=TRUE
    int*                    pnWindows;          // Window Number Array,the space application by the user, apply to sizeof(int)*nWindowCount
    int                     nWindowCount;       // Window Number
    DH_SPLIT_SOURCE*        pstuSources;        // Video source information, corresponding to each window, the number with the number of window.the space application by the user,apply to sizeof(DH_SPLIT_SOURCE)*nWindowCount
} NET_IN_SPLIT_SET_MULTI_SOURCE;

// CLIENT_SplitSetMultiSource The output parameters of the interface
typedef struct tagNET_OUT_SPLIT_SET_MULTI_SOURCE 
{
    DWORD                   dwSize;
} NET_OUT_SPLIT_SET_MULTI_SOURCE;

// Video split operation type
typedef enum tagNET_SPLIT_OPERATE_TYPE
{
    NET_SPLIT_OPERATE_SET_BACKGROUND,            // Set background, corresponding NET_IN_SPLIT_SET_BACKGROUND  and NET_OUT_SPLIT_SET_BACKBROUND
    NET_SPLIT_OPERATE_GET_BACKGROUND,            // get background, corresponding NET_IN_SPLIT_GET_BACKGROUND  and NET_OUT_SPLIT_GET_BACKGROUND
    NET_SPLIT_OPERATE_SET_PREPULLSRC,            // set pre stream srouce, corresponding to NET_IN_SPLIT_SET_PREPULLSRC and NET_OUT_SPLIT_SET_PREPULLSRC
    NET_SPLIT_OPERATE_SET_HIGHLIGHT,             // set source frame brightness switch, corresponding to NET_IN_SPLIT_SET_HIGHLIGHT and NET_OUT_SPLIT_SET_HIGHLIGHT
    NET_SPLIT_OPERATE_SET_ZORDER,                // adjust window Z order, corresponding to NET_IN_SPLIT_SET_ZORDER  and  NET_OUT_SPLIT_SET_ZORDER
    NET_SPLIT_OPERATE_SET_TOUR,                  // window tour control, corresponding to NET_IN_SPLIT_SET_TOUR  and  NET_OUT_SPLIT_SET_TOUR
    NET_SPLIT_OPERATE_GET_TOUR_STATUS,           // Get window tour status , corresponding to NET_IN_SPLIT_GET_TOUR_STATUS  and  NET_OUT_SPLIT_GET_TOUR_STATUS
    NET_SPLIT_OPERATE_GET_SCENE,                 // Get screen window info , corresponding to NET_IN_SPLIT_GET_SCENE  and  NET_OUT_SPLIT_GET_SCENE
    NET_SPLIT_OPERATE_OPEN_WINDOWS,              // batch window, corresponding to NET_IN_SPLIT_OPEN_WINDOWS  and  NET_OUT_SPLIT_OPEN_WINDOWS
    NET_SPLIT_OPERATE_SET_WORK_MODE,             // set work mode , corresponding to NET_IN_SPLIT_SET_WORK_MODE  and  NET_OUT_SPLIT_SET_WORK_MODE
    NET_SPLIT_OPERATE_GET_PLAYER,                // Get player example, corresponding to NET_IN_SPLIT_GET_PLAYER  and  NET_OUT_SPLIT_GET_PLAYER
    NET_WM_OPERATE_SET_WORK_MODE,                // Set window working mode, corresponding  NET_IN_WM_SET_WORK_MODE and NET_OUT_WM_SET_WORK_MODE
    NET_WM_OPERATE_GET_WORK_MODE,                // Get window working mode, corresponding  NET_IN_WM_GET_WORK_MODE and NET_OUT_WM_GET_WORK_MODE
    NET_SPLIT_OPERATE_CLOSE_WINDOWS,             // close batch windows NET_IN_SPLIT_CLOSE_WINDOWS o,a NET_OUT_SPLIT_CLOSE_WINDOWS
    NET_WM_OPERATE_SET_FISH_EYE_PARAM,           // set the output rules of the fish eyes, corresponding NET_IN_WM_SET_FISH_EYE_PARAM and NET_OUT_WM_SET_FISH_EYE_PARAM
	NET_WM_OPERATE_SET_CORRIDOR_MODE,			 // set the corridor mode of the window, corresponding NET_IN_WM_SET_CORRIDOR_MODE and NET_OUT_WM_SET_CORRIDOR_MODE
	NET_WM_OPERATE_GET_CORRIDOR_MODE,			 // get the corridor mode of the window, corresponding NET_IN_WM_GET_CORRIDOR_MODE and NET_OUT_WM_GET_CORRIDOR_MODE
	NET_WM_OPERATE_SET_VOLUME_COLUMN,			 // set volume column enable, corresponding NET_IN_WM_SET_VOLUME_COLUMN and NET_OUT_WM_SET_VOLUME_COLUMN
	NET_WM_OPERATE_GET_VOLUME_COLUMN,			 // get volume column enable, corresponding NET_IN_WM_GET_VOLUME_COLUMN and NET_OUT_WM_GET_VOLUME_COLUMN
	NET_WM_OPERATE_SET_BACKGROUND,				 // set the background of window, corresponding NET_IN_WM_SET_BACKGROUND and NET_OUT_WM_SET_BACKGROUND
	NET_WM_OPERATE_GET_BACKGROUND,				 // get the background of window, corresponding NET_IN_WM_GET_BACKGROUND and NET_OUT_WM_GET_BACKGROUND
    NET_WM_OPERATE_SET_ROTATE_MODE,				 // set the rotate mode of the window, corresponding NET_IN_WM_SET_ROTATE_MODE and NET_OUT_WM_SET_ROTATE_MODE

    NET_WM_OPERATE_SET_MEETING_MODE,			// set the meeting mode of the video source display area, corresponding NET_IN_WM_SET_MEETING_MODE and NET_OUT_WM_SET_MEETING_MODE
    NET_WM_OPERATE_SET_LOCK_POSITION,			// set the current location of the lock window, corresponding NET_IN_WM_SET_LOCK_POSITION and  NET_OUT_WM_SET_LOCK_POSITION
    NET_WM_OPERATE_SET_COLLECTION_CTRL_ID,		// modify the ID of plan control, corresponding NET_IN_WM_SET_COLLECTION_CTRL_ID and  NET_OUT_WM_SET_COLLECTION_CTRL_ID
    NET_SPLIT_OPERATES_SET_SOURCE_ATTRIBUTE,	// set the properties of the signal source, corresponding NET_IN_SPLIT_SET_SOURCE_ATTRIBUTE and NET_OUT_SPLIT_SET_SOURCE_ATTRIBUTE
    NET_SPLIT_OPERATES_SET_DOCK_CONTROL,	    // set the adhesion state of the window, corresponding NET_IN_SPLIT_SET_DOCK_CONTROL and NET_OUT_SPLIT_SET_DOCK_CONTROL
    NET_WM_OPERATE_SET_MODE,			        // set window split mode,corresponding NET_IN_WM_SET_MODE and NET_OUT_WM_SET_MODE
} NET_SPLIT_OPERATE_TYPE;

// Set source frame brightness switch input parameter
typedef struct tagNET_IN_SPLIT_SET_HIGHLIGHT
{
    DWORD           dwSize; 
    int             nChannel;                   // video output channel
    int             nWindow;                    // window no.
    BOOL            bHighLightEn;               // frame brightness,TRUE-high brightness
    DH_COLOR_RGBA   stuColor;                   // frame color 
    int				nBlinkTimes;				// blink times of frame
    int				nBlinkInterval;				// the interval time between blink, unit: ms
}NET_IN_SPLIT_SET_HIGHLIGHT;

// set frame brightness enable switch output parameter
typedef struct tagNET_OUT_SPLIT_SET_HIGHLIGHT
{
    DWORD           dwSize;
}NET_OUT_SPLIT_SET_HIGHLIGHT;

// Set pre stream input parameter
typedef struct tagNET_IN_SPLIT_SET_PREPULLSRC 
{
    DWORD           dwSize;
    int             nChannel;                   // video output channel
    int             nWindow;                    // window no.
    int             nSrcCount;                  // pre stream source quantity
    DH_SPLIT_SOURCE* pSources;                  // re stream source info,the space application by the user, applt to sizeof(DH_SPLIT_SOURCE)*nSrcCount
} NET_IN_SPLIT_SET_PREPULLSRC;

// Set pre stream source return result
typedef struct tagNET_SPLIT_SET_PREPULLSRC_RESULT 
{
    DWORD           dwSize;
    BOOL            bResult;                    // set result, TRUE-successful, FALSE-failed
    DWORD           dwErrorCode;                // Error code
} NET_SPLIT_SET_PREPULLSRC_RESULT;

// Set pre source output parameter
typedef struct tagNET_OUT_SPLIT_SET_PREPULLSRC 
{
    DWORD           dwSize;
    int             nResultCount;               // result quantity, same with pre source    NET_SPLIT_SET_PREPULLSRC_RESULT* pResults;  // result
    NET_SPLIT_SET_PREPULLSRC_RESULT* pResults;  // result
} NET_OUT_SPLIT_SET_PREPULLSRC;

// Set video output background input parameter
typedef struct tagNET_IN_SPLIT_SET_BACKGROUND
{
    DWORD            dwSize;
    int              nChannel;                   // Video output channel no.
    BOOL             bEnable;                    // enable
    const char*      pszFileName;                // background name
} NET_IN_SPLIT_SET_BACKGROUND;

// Set video output background parameter
typedef struct tagNET_OUT_SPLIT_SET_BACKGROUND 
{
    DWORD            dwSize;
} NET_OUT_SPLIT_SET_BACKGROUND;

// get video output background input parameter
typedef struct tagNET_IN_SPLIT_GET_BACKGROUND 
{
    DWORD            dwSize;
    int              nChannel;                   // video output channel o.
} NET_IN_SPLIT_GET_BACKGROUND;

// get video output background output parameter
typedef struct tagNET_OUT_SPLIT_GET_BACKGROUND 
{
    DWORD			dwSize;
    BOOL            bEnable;                            // enable
    char            szFileName[DH_COMMON_STRING_256];   // background name
} NET_OUT_SPLIT_GET_BACKGROUND;

// the input parameter of setting window background
typedef struct tagNET_IN_WM_SET_BACKGROUND
{
	DWORD				dwSize;
	int					nChannel;							// video output channel ID, invalid when pszCompositeID == NULL
	char			   *pszCompositeID;						// composite ID
	int					nWindowID;							// windows ID
	BOOL				bEnable;							// whether set background or not
	char				szFileName[DH_COMMON_STRING_128];	// background name
} NET_IN_WM_SET_BACKGROUND;

// the output parameter of setting window background
typedef struct tagNET_OUT_WM_SET_BACKGROUND
{
	DWORD            	dwSize;
} NET_OUT_WM_SET_BACKGROUND;

//  the input parameter of getting window background
typedef struct tagNET_IN_WM_GET_BACKGROUND
{
	DWORD            	dwSize;
	int					nChannel;				// video output channel ID, invalid when pszCompositeID == NULL
	char			   *pszCompositeID;			// composite ID
	int					nWindowID;				// windows ID
} NET_IN_WM_GET_BACKGROUND;

//  the output parameter of getting window background
typedef struct tagNET_OUT_WM_GET_BACKGROUND
{
	DWORD            	dwSize;
	BOOL             	bEnable;                            // whether set background or not
    char             	szFileName[DH_COMMON_STRING_128];   // background name
} NET_OUT_WM_GET_BACKGROUND;


// window Z sequence
typedef enum tagNET_WINDOW_ZORDER
{
  NET_WINDOW_ZORDER_TOP,               // top
  NET_WINDOW_ZORDER_BOTTOM,            // bottom
  NET_WINDOW_ZORDER_UP,                // up
  NET_WINDOW_ZORDER_DOWN,              // down
} NET_WINDOW_ZORDER;

// window layer order
typedef struct tagDH_WND_ZORDER
{
  DWORD        	  dwSize;
  unsigned int    nWindowID;           // window no.
  unsigned int    nZOrder;             // Z order
} DH_WND_ZORDER;

// set window Z order input parameter
typedef struct tagNET_IN_SPLIT_SET_ZORDER 
{
  DWORD       		dwSize;
  int         		nChannel;            // output channel no. or cubeless video wall virtual channel no., pszCompositeID is NULL is valid 
  const char*     	pszCompositeID;      // cubeless video wall ID
  int         		nWindow;             // window no.
  NET_WINDOW_ZORDER emZOrder;            // adjust Z order
} NET_IN_SPLIT_SET_ZORDER;

// set window Z order output parameter, adjust one window Z order will affect all windows,  return adjusted all windows's Z order
typedef struct tagNET_OUT_SPLIT_SET_ZORDER
{
  DWORD        		dwSize;
  DH_WND_ZORDER*   	pZOders;            	// window order group, user allocate memory, apply to sizeof(DH_WND_ZORDER)*nMaxWndCount
  int         		nMaxWndCount;          	// window order group size
  int         		nWndCount;          	// return window quantity
} NET_OUT_SPLIT_SET_ZORDER;

// window tour motion 
typedef enum tagEM_NET_WINDOW_TOUR_ACTION 
{
  EM_NET_WND_TOUR_ACTION_START,           // start 
  EM_NET_WND_TOUR_ACTION_STOP,            // stop
} EM_NET_WINDOW_TOUR_ACTION;

// window tour control input parameter, corresponding to NET_SPLIT_OPERATE_SET_TOUR
typedef struct tagNET_IN_SPLIT_SET_TOUR 
{
  DWORD       dwSize;
  int         nChannel;            	// output channel no. or cubeless video wall virtual channel no., pszCompositeID is NULL is valid 
  const char* pszCompositeID;      	// cubeless video wall ID
  int         nWindow;            	// window no.
  EM_NET_WINDOW_TOUR_ACTION emAction;         // tour motion 
} NET_IN_SPLIT_SET_TOUR;

// window tour control output parameter, corresponding to NET_SPLIT_OPERATE_SET_TOUR
typedef struct tagNET_OUT_SPLIT_SET_TOUR 
{
  DWORD        dwSize;
} NET_OUT_SPLIT_SET_TOUR;

// Get window tour status input parameter, corresponding to NET_SPLIT_OPERATE_GET_TOUR_STATUS
typedef struct tagNET_IN_SPLIT_GET_TOUR_STATUS
{
  DWORD       dwSize;
  int         nChannel;            	// output channel no. or cubeless video wall virtual channel no., pszCompositeID is NULL is valid 
  const char* pszCompositeID;  		// cubeless video wall ID
  int         nWindow;             	// window no., -1 means all window
} NET_IN_SPLIT_GET_TOUR_STATUS;

// tour status 
typedef enum tagNET_TOUR_STATUS
{
  NET_TOUR_UNKNOWN,                // unknown 
  NET_TOUR_START,                  // touring
  NET_TOUR_STOP,                   // tour stop
}NET_TOUR_STATUS;

// window tour status info 
typedef struct tagNET_WINDOW_TOUR_STATUS_INFO 
{
  DWORD       dwSize;
  int         nWindow;            		 // window no.
  NET_TOUR_STATUS   emStatus;            // status 
} NET_WINDOW_TOUR_STATUS_INFO;

// Get window tour status output parameter, corresponding to NET_SPLIT_OPERATE_GET_TOUR_STATUS
typedef struct tagNET_OUT_SPLIT_GET_TOUR_STATUS
{
  DWORD        					dwSize;
  NET_WINDOW_TOUR_STATUS_INFO* 	pstuStatus;      // status info indicator, user allocation memory. search window no. is -1 means multi-window info group.
  int         					nMaxStatusCount; // status info max quantity, user input
  int         					nRetStatusCount; // status info actual quantity, search to get
} NET_OUT_SPLIT_GET_TOUR_STATUS;

// batch window input parameter, corresponding to NET_SPLIT_OPERATE_OPEN_WINDOWS
typedef struct tagNET_IN_SPLIT_OPEN_WINDOWS 
{
  DWORD       dwSize;
  int         nChannel;            	// output channel no. or cubeless video wall virtual channel no., pszCompositeID is NULL is valid 
  const char* pszCompositeID;       // cubeless video wall id
  int         nWindowNum;           // window quantity
  NET_RECT*   pstuWindowRects;      // window zone group,the space application by the user,apply to sizeof(NET_RECT)*nWindowNum
  BOOL        bDirectable;          // meet direct criteria 
} NET_IN_SPLIT_OPEN_WINDOWS;

// window info 
typedef struct tagNET_SPLIT_WINDOW_INFO
{
  DWORD       dwSize;
  int         nWindowID;          	// window no.
  int         nZOrder;            	// Z order
  char        szControlID[DH_DEV_ID_LEN];   // control no.
} NET_SPLIT_WINDOW_INFO;

// batch window output parameter, corresponding to NET_SPLIT_OPERATE_OPEN_WINDOWS
typedef struct tagNET_OUT_SPLIT_OPEN_WINDOWS 
{
  DWORD       dwSize;
  NET_SPLIT_WINDOW_INFO* pstuWindows;        // window info , user allocation memory, apply to sizeof(NET_SPLIT_WINDOW_INFO)*nMaxWindowCount
  int         nMaxWindowCount;        // window info max quantity, user input
  int         nRetWindowCount;        // window quantity
} NET_OUT_SPLIT_OPEN_WINDOWS;

// video split work mode 
typedef enum tagNET_SPLIT_WORK_MODE
{
  NET_SPLIT_WORK_MODE_UNKNOWN,            // unknown 
  NET_SPLIT_WORK_MODE_LOCAL,              // local normal mode 
  NET_SPLIT_WORK_MODE_REPLAY,             // playback mode 
}NET_SPLIT_WORK_MODE;

// setup work mode input parameter, corresponding to NET_SPLIT_OPERATE_SET_WORK_MODE
typedef struct tagNET_IN_SPLIT_SET_WORK_MODE 
{
  DWORD       dwSize;
  int         nChannel;            			// output channel no. or cubeless video wall virtual channel no., pszCompositeID is NULL is valid 
  const char* pszCompositeID;         		// cubeless video wall ID
  NET_SPLIT_WORK_MODE emMode;            	// work mode 
}NET_IN_SPLIT_SET_WORK_MODE;

// setup work mode output parameter, corresponding to NET_SPLIT_OPERATE_SET_WORK_MODE
typedef struct tagNET_OUT_SPLIT_SET_WORK_MODE 
{
  DWORD        dwSize;
}NET_OUT_SPLIT_SET_WORK_MODE;

// player type 
typedef enum tagNET_SPLIT_PLAYER_TYPE
{
  NET_SPLIT_PLAYER_TYPE_UNKNOWN,            // unknown 
  NET_SPLIT_PLAYER_TYPE_FILE_LIST,          // file list player
  NET_SPLIT_PLAYER_TYPE_FILE,             	// file player
}NET_SPLIT_PLAYER_TYPE;

// Get player actual input parameter, corresponding to NET_SPLIT_OPERATE_GET_PLAYER
typedef struct tagNET_IN_SPLIT_GET_PLAYER
{
  DWORD        dwSize;
  int          nChannel;            	// output channel no. or cubeless video wall virtual channel no., pszCompositeID is NULL is valid 
  const char*  pszCompositeID;         	// cubeless video wall ID
  NET_SPLIT_PLAYER_TYPE emType;         // player type 
  int          nWindow;            		// player window no.
}NET_IN_SPLIT_GET_PLAYER;

// Get player actual output parameter, corresponding to NET_SPLIT_OPERATE_GET_PLAYER
typedef struct tagNET_OUT_SPLIT_GET_PLAYER
{
  DWORD         dwSize;
  LLONG         lPlayerID;           // player actual ID
}NET_OUT_SPLIT_GET_PLAYER;

// Window Working Mode
typedef enum tagNET_WM_WORK_MODE
{
    NET_WM_WORK_MODE_UNKNOWN,                             // Unknown
    NET_WM_WORK_MODE_DISPLAY,                             // Preview mode
    NET_WM_WORK_MODE_REPLAY,                              // Playback mode  
}NET_WM_WORK_MODE;

// Set window working mode input parameter, corresponding  NET_WM_OPERATE_SET_WORK_MODE
typedef struct tagNET_IN_WM_SET_WORK_MODE
{
    DWORD                 dwSize;
    int                   nChannel;                       // Output channel no. or cubeless video wall virtual channel no., when pszCompositeID is NULL. valid
    const char*           pszCompositeID;                 // Cubeless video wall ID
    int                   nWindow;                        // Window no.
    NET_WM_WORK_MODE      emMode;                         // Window working mode
}NET_IN_WM_SET_WORK_MODE;

//Set window working mode output parameter, corresponding  NET_WM_OPERATE_SET_WORK_MODE
typedef struct tagNET_OUT_WM_SET_WORK_MODE
{
    DWORD                 dwSize;
}NET_OUT_WM_SET_WORK_MODE;

// Get window woking mode input parameter, corresponding  NET_WM_OPERATE_GET_WORK_MODE
typedef struct tagNET_IN_WM_GET_WORK_MODE
{
    DWORD                 dwSize;
    int                   nChannel;                       // Output channel no. or cubeless virtual channel no., when pszCompositeID is NULL, valid
    const char*           pszCompositeID;                 // Cubeless video wall ID
    int                   nWindow;                        // Window no.
}NET_IN_WM_GET_WORK_MODE;

//Get window working mode output parameter, corresponding  NET_WM_OPERATE_GET_WORK_MODE
typedef struct tagNET_OUT_WM_GET_WORK_MODE
{
    DWORD                 dwSize;
    NET_WM_WORK_MODE      emMode;                         // Window working mode
}NET_OUT_WM_GET_WORK_MODE;

// Set window corridor mode input parameter, corresponding  NET_WM_OPERATE_SET_CORRIDOR_MODE
typedef struct tagNET_IN_WM_SET_CORRIDOR_MODE
{
	DWORD                 dwSize;			// the value is the size of this struct
	int 				  nChannel;			// Output channel index or the virtual channel index of multi-screen display, it is valid when pszCompositeID =NULL
	const char* 		  pszCompositeID;	// Multi-screen display ID
	int 				  nWindow;			// window ID
	BOOL	  			  bIsCorridor;		// the corridor mode of the window(TRUE:open FALSE:close)
} NET_IN_WM_SET_CORRIDOR_MODE;

// Set window corridor mode output parameter, corresponding  NET_WM_OPERATE_SET_CORRIDOR_MODE
typedef struct tagNET_OUT_WM_SET_CORRIDOR_MODE
{
	DWORD                 dwSize;			// the value is the size of this struct
} NET_OUT_WM_SET_CORRIDOR_MODE;


// Get window corridor mode input parameter, corresponding  NET_WM_OPERATE_GET_CORRIDOR_MODE
typedef struct tagNET_IN_WM_GET_CORRIDOR_MODE
{
	DWORD                 dwSize;			// the value is the size of this struct
	int 				  nChannel;			// Output channel index or the virtual channel index of multi-screen display, it is valid when pszCompositeID =NULL
	const char* 		  pszCompositeID;	// Multi-screen display ID
	int 				  nWindow;			// window ID
} NET_IN_WM_GET_CORRIDOR_MODE;

// Get window corridor mode output parameter, corresponding  NET_WM_OPERATE_GET_CORRIDOR_MODE
typedef struct tagNET_OUT_WM_GET_CORRIDOR_MODE
{
	DWORD                 dwSize;			// the value is the size of this struct
	BOOL	  			  bIsCorridor;		// the corridor mode of window(TRUE:open FALSE:close)
} NET_OUT_WM_GET_CORRIDOR_MODE;

// set volume column enable intput parameter, corresponding NET_WM_OPERATE_SET_VOLUME_COLUMN
typedef struct tagNET_IN_WM_SET_VOLUME_COLUMN
{
	DWORD                 dwSize;			// size of struct
	int 				  nChannel;			// Output channel index or the virtual channel index of multi-screen display, it is valid when pszCompositeID =NULL
	const char* 		  pszCompositeID;	// Multi-screen display ID
	BOOL				  bIsEnable;	    // Display volume column(TRUE:Display FALSE:No Display)
} NET_IN_WM_SET_VOLUME_COLUMN;				

// set volume column enable output parameter, corresponding NET_WM_OPERATE_SET_VOLUME_COLUMN
typedef struct tagNET_OUT_WM_SET_VOLUME_COLUMN
{
	DWORD				   dwSize;			// size of struct
} NET_OUT_WM_SET_VOLUME_COLUMN;

// get volume column enable input parameter, corresponding NET_WM_OPERATE_GET_VOLUME_COLUMN
typedef struct tagNET_IN_WM_GET_VOLUME_COLUMN
{
	DWORD                 dwSize;			// size of struct
	int 				  nChannel;			// Output channel index or the virtual channel index of multi-screen display, it is valid when pszCompositeID =NULL
	const char* 		  pszCompositeID;	// Multi-screen display ID
} NET_IN_WM_GET_VOLUME_COLUMN;

// get volume column enable output parameter, corresponding NET_WM_OPERATE_GET_VOLUME_COLUMN
typedef struct tagNET_OUT_WM_GET_VOLUME_COLUMN
{
	DWORD				   dwSize;			// size of struct
	BOOL				   bIsEnable;		// Display volume column(TRUE:Display FALSE:No Display)	
} NET_OUT_WM_GET_VOLUME_COLUMN;

// The input for close batch windows,  corresponding to NET_SPLIT_OPERATE_CLOSE_WINDOWS
typedef struct tagNET_IN_SPLIT_CLOSE_WINDOWS
{
    DWORD               dwSize;
    int                 nChannel;                       // Output channel index or the virtual channel index of multi-screen display, it is valid when pszCompositeID =NULL
    const char*         pszCompositeID;                 // Multi-screen display ID
    int*                pnWindows;                      // The pointer of windows index array,the space application by the user,apply to sizeof(int)*nWindowCount
    int                 nWindowCount;                   // The number of windows
} NET_IN_SPLIT_CLOSE_WINDOWS;

// Close windows operation result
typedef struct tagNET_SPLIT_CLOSE_WINDOW_RESULT 
{
    BOOL                bResult;                        // Result
    char                reserved[256];                  // Reserved bytes
} NET_SPLIT_CLOSE_WINDOW_RESULT ;

// The output parameters of Close batch windows, corresponding to NET_SPLIT_OPERATE_CLOSE_WINDOWS
typedef struct tagNET_OUT_SPLIT_CLOSE_WINDOWS
{
    DWORD               dwSize;
    NET_SPLIT_CLOSE_WINDOW_RESULT* pstuResults;         // Result array, memory assigned by users, apply to sizeof(NET_SPLIT_CLOSE_WINDOW_RESULT)*nMaxResultCount. Set to Null if no need the return
    int                 nMaxResultCount;                // The maximum of result array, filled in by user.
	int                 nRetResultCount;                // The number of return result

} NET_OUT_SPLIT_CLOSE_WINDOWS;

// Display Screen Fisheye calibrate mode
typedef enum tagNET_WM_FISHEYE_CALIBRATE_MODE
{
    NET_WM_FISHEYE_CALIBRATE_MODE_UNKOWN ,            // unknown
    NET_WM_FISHEYE_CALIBRATE_MODE_CLOSE ,             // close 
    NET_WM_FISHEYE_CALIBRATE_MODE_ORIGINAL,           // original
    NET_WM_FISHEYE_CALIBRATE_MODE_PANORAMA,           // 1P
    NET_WM_FISHEYE_CALIBRATE_MODE_PAN_PLUS_ONE,       // 1P+1
    NET_WM_FISHEYE_CALIBRATE_MODE_DOUBLE_PANORAMA,    // 2P        
    NET_WM_FISHEYE_CALIBRATE_MODE_ORI_DOUBLE_PAN,     // 1+2p
    NET_WM_FISHEYE_CALIBRATE_MODE_ORI_PLUS_THREEE,    // 1+3
    NET_WM_FISHEYE_CALIBRATE_MODE_PAN_PLUS_THREEE,    // 1p+3
    NET_WM_FISHEYE_CALIBRATE_MODE_ORI_PLUS_TWO,       // 1+2
    NET_WM_FISHEYE_CALIBRATE_MODE_ORI_PLUS_FOUR,      // 1+4
    NET_WM_FISHEYE_CALIBRATE_MODE_PAN_PLUS_FOUR,      // 1p+4
    NET_WM_FISHEYE_CALIBRATE_MODE_PAN_PLUS_SIX,       // 1p+6
    NET_WM_FISHEYE_CALIBRATE_MODE_ORI_PLUS_EIGHT,     // 1+8
    NET_WM_FISHEYE_CALIBRATE_MODE_PAN_PLUS_EIGHT,     // 1P+8
}NET_WM_FISHEYE_CALIBRATE_MODE;

// Fisheye region parameter
typedef struct tagNET_WM_FISH_EYE_REGION_PARAM
{
    int     nCoordinateX;         // X Coordinate of window center to original circle
    int     nCoordinateY;         // Y Coordinate of window center to original circle
    int     nAngleH;              // Horizontal Angle of Fisheye calibrate region
    int     nAngleV;              // Vertical Angle of Fisheye calibrate region
    int 	nAvailable;			  // Available
    BYTE    Reserved[124];        // Reserverd
}NET_WM_FISH_EYE_REGION_PARAM;

#define MAX_FISH_EYE_REGION_NUM     9
// Set Fisheye init parameter, used for switching mode to last status
typedef struct tagNET_WM_SET_FISHEYE_INIT_PARAM
{
    BOOL                            bUseRegion;         // if True, using underside member to init; if FLASE, underside member is invaild; 
    int                             nCircular;          // Circular (Fisheye display mode with original, eg:1+3, 1+8 )
    int                             nPanorama;          // Panorama (Fisheye display mode with panorama, eg:1P, 2P )
	int                             nFishEyeRegionNum;  // FishEye region number 
    NET_WM_FISH_EYE_REGION_PARAM    stFishEyeRegions[MAX_FISH_EYE_REGION_NUM];    // FishEye region parameter information
    BYTE                            Reserved[1024];     // Reserved
}NET_WM_SET_FISHEYE_INIT_PARAM;

// Set FishEye EPTZ parameter
typedef struct tagNET_WM_SET_FISHEYE_EPTZ_PARAM
{
	int 							nOptWayType;		// operate way type 
	int 							nOptWinNum; 		// operate window number 
	int 							nOptWayData;		// operate way data
	BYTE                            Reserved[512];      // Reserved
}NET_WM_SET_FISHEYE_EPTZ_PARAM;


// The input parameters of Set FishEye parameter, corresponding to NET_IN_WM_SET_FISH_EYE_PARAM
typedef struct tagNET_IN_WM_SET_FISH_EYE_PARAM
{
    DWORD                           dwSize;
    int                             nChannel;           // output channel or Composite screen channel, valid when pszCompositeID is NULL 
    const char*                     pszCompositeID;     // Composite screen ID
    int                             nWindowID;          // Window ID corresponding to output screen

    NET_FISHEYE_MOUNT_MODE          emMount;            // Fisheye mount mode
    NET_WM_FISHEYE_CALIBRATE_MODE   emCalibrate;        // FishEye calibrate mode
    NET_WM_SET_FISHEYE_INIT_PARAM   stInitParam;        // FishEye init parameter
    NET_WM_SET_FISHEYE_EPTZ_PARAM	stEPtzParam;		// FishEye EPTZ parameter
}NET_IN_WM_SET_FISH_EYE_PARAM;

// The output parameters of Set FishEye parameter, corresponding to NET_OUT_WM_SET_FISH_EYE_PARAM
typedef struct tagNET_OUT_WM_SET_FISH_EYE_PARAM
{
    DWORD dwSize;
}NET_OUT_WM_SET_FISH_EYE_PARAM;

// window rotate type
typedef enum tagEM_WM_ROTATE_TYPE
{
    EM_WM_ROTATE_TYPE_NO_ROTATE,                         // no rotate 
    EM_WM_ROTATE_TYPE_90_ROTATE,                         // rotate 90 
    EM_WM_ROTATE_TYPE_180_ROTATE,                        // rotate 180
    EM_WM_ROTATE_TYPE_270_ROTATE,                        // rotate 270  
}EM_WM_ROTATE_TYPE;

// The input parameters of Set Window RotateMode parameter,corresponding to NET_IN_WM_SET_ROTATE_MODE
typedef struct tagNET_IN_WM_SET_ROTATE_MODE
{
    DWORD				dwSize;
    int                 nChannel;                       // output channel or Composite screen channel, valid when pszCompositeID is NULL 
    const char*         pszCompositeID;                 // composite screen ID
    int					nWindowID;						// window ID corresponding to output screen
    EM_WM_ROTATE_TYPE	emRotateType;					// window rotate type
} NET_IN_WM_SET_ROTATE_MODE;

// The output parameters of Set Window RotateMode parameter,corresponding to NET_OUT_WM_SET_ROTATE_MODE
typedef struct tagNET_OUT_WM_SET_ROTATE_MODE
{
    DWORD            	dwSize;
} NET_OUT_WM_SET_ROTATE_MODE;

// Signal source properties
typedef struct tagNET_SOURCE_ATTRIBUTE_INFO
{
    unsigned char       ucBrightness;       // Brightness,range 0~255
    unsigned char       ucContrast;         // Contrast,range 0~255
    unsigned char       ucSaturation;       // Saturation,range 0~255
    unsigned char       ucEQ;               // Compensation of higt frequency signal,range 0~10
    BYTE                byReserver1[4];     // Reserve of byte alignment
    int                 nMargin[4];         // Margin,range -50~50 
    BYTE                byReserver[512];    // Reserve    
}NET_SOURCE_ATTRIBUTE_INFO;

// Input param of setting signal source properties 
typedef struct tagNET_IN_SPLIT_SET_SOURCE_ATTRIBUTE
{
    DWORD                       dwSize;             
    char                        szCompositeID[64];  // Composite ID
    int                         nChannel;           // Channel 
    int                         nWindow;            // Window 

    NET_SOURCE_ATTRIBUTE_INFO   stuAttribute;       // Attribute
}NET_IN_SPLIT_SET_SOURCE_ATTRIBUTE;

// Output param of setting  signal source properties 
typedef struct tagNET_OUT_SPLIT_SET_SOURCE_ATTRIBUTE
{
    DWORD                       dwSize;             
}NET_OUT_SPLIT_SET_SOURCE_ATTRIBUTE;

// Input param of setting the adhesion state of the window 
typedef struct tagNET_IN_SPLIT_SET_DOCK_CONTROL
{
    DWORD                       dwSize;             
    char                        szCompositeID[64];  // Composite ID
    int                         nChannel;           // channel 
    int                         nWindow;            // window num 
    BOOL                        bDock;              // Is dock used
}NET_IN_SPLIT_SET_DOCK_CONTROL;

// Output param of setting the adhesion state of the window 
typedef struct tagNET_OUT_SPLIT_SET_DOCK_CONTROL
{
    DWORD                       dwSize;             
}NET_OUT_SPLIT_SET_DOCK_CONTROL;

// Input param of setting the meeting mode of the video source display area
typedef struct tagNET_IN_WM_SET_MEETING_MODE
{
    DWORD                       dwSize;             
    char                        szComposite[64];    // Composite ID
    int                         nChannel;           // Output Channel Number or Fusion Screen Virtual Channel Number,szComposite is valid when NULL
    int                         nWindow;            // window num 
    BOOL                        bEnable;            // TRUEmeeting mode; FALSEstandard mode
}NET_IN_WM_SET_MEETING_MODE;

// Output param of setting the meeting mode of the video source display area
typedef struct tagNET_OUT_WM_SET_MEETING_MODE
{
    DWORD                       dwSize;             
}NET_OUT_WM_SET_MEETING_MODE;


// Input param of setting the current location of the lock window
typedef struct tagNET_IN_WM_SET_LOCK_POSITION
{
    DWORD                       dwSize;            
    char                        szComposite[64];    // Composite ID
    int                         nChannel;           // Output Channel Number or Fusion Screen Virtual Channel Number, szComposite is valid when NULL
    int                         nWindow;            // window num , -1 means all windows
    BOOL                        bLock;              // is locked
}NET_IN_WM_SET_LOCK_POSITION;


// Output param of setting the current location of the lock window
typedef struct tagNET_OUT_WM_SET_LOCK_POSITION
{
    DWORD                       dwSize;             
}NET_OUT_WM_SET_LOCK_POSITION;

// Input param of modifying the ID of plan control
typedef struct tagNET_IN_WM_SET_COLLECTION_CTRL_ID
{
    DWORD                       dwSize;             
    int                         nChannel;           // Output Channel Number or Fusion Screen Virtual Channel Number, szComposite is valid when NULL
    char                        szComposite[64];    // Composite ID
    char                        szName[128];        // Name of plan
    char                        szControlID[8];     // Control Id of plan 
}NET_IN_WM_SET_COLLECTION_CTRL_ID;

// Output param of modifying the ID of plan control
typedef struct tagNET_OUT_WM_SET_COLLECTION_CTRL_ID
{
    DWORD                       dwSize;           
}NET_OUT_WM_SET_COLLECTION_CTRL_ID ;

// Input param of seting window split mode
typedef struct tagNET_IN_WM_SET_MODE
{
    DWORD                       dwSize;             // Struct size
    int                         nChannel;           // Channel
    int                         nWindow;            // Window number
    DH_SPLIT_MODE               emSplitMode;        // Split mode
}NET_IN_WM_SET_MODE ;

// Splited window info
typedef struct tagNET_SPLITED_WINDOW_INFO
{
    NET_RECT            stuRect;                    // windon position, 0~8192
    int                 nWindow;                    // Window number. This window is a new window after splitting. It is different from the original window number
    int                 nZOrder;                    // Window Z order
    char                szControlID[32];            // Window control ID  
    BYTE                byReserver[512];            // Reserved
}NET_SPLITED_WINDOW_INFO;


// Output param of setting window split mode
typedef struct tagNET_OUT_WM_SET_MODE
{
    DWORD                       dwSize;                 // Struct size
    UINT                        nSplitedWindowNum;      // The number of splited window info
    NET_SPLITED_WINDOW_INFO     stuSplitedWindow[144];  // Splited window info
}NET_OUT_WM_SET_MODE ;

////////////////////////////////// System status////////////////////////////////////////

// CPU info
typedef struct tagDH_CPU_INFO
{
	DWORD				dwSize;
	int					nUsage;						// CPU usage
} DH_CPU_INFO;

// CPU status
typedef struct tagDH_CPU_STATUS
{
	DWORD				dwSize;
	BOOL				bEnable;					// Search succeeded or not
	int					nCount;						// CPU amount
	DH_CPU_INFO			stuCPUs[DH_MAX_CPU_NUM];	// CPU info
} DH_CPU_STATUS;

// Memory info
typedef struct tagDH_MEMORY_INFO
{
	DWORD				dwSize;
	DWORD				dwTotal;					// Total memory, M
	DWORD				dwFree;						// Free memory, M
} DH_MEMORY_INFO;

// Memory status
typedef struct tagDH_MEMORY_STATUS 
{
	DWORD				dwSize;
	BOOL				bEnable;					// Search succeeded or not
	DH_MEMORY_INFO		stuMemory;					// Memory info
} DH_MEMORY_STATUS;

// Fan info
typedef struct tagDH_FAN_INFO
{
	DWORD				dwSize;
	char				szName[DH_DEVICE_NAME_LEN];	// Name
	DWORD				nSpeed;						// Speed
} DH_FAN_INFO;

// Fan status
typedef struct tagDH_FAN_STATUS
{
	DWORD				dwSize;
	BOOL				bEnable;					// Search succeeded or not
	int					nCount;						// Fan amount
	DH_FAN_INFO			stuFans[DH_MAX_FAN_NUM];	// Fan status
} DH_FAN_STATUS;

// power current status type
typedef enum __EM_CURRENT_STATE_TYPE
{
    EM_CURRENT_STATE_UNKNOWN = 0,
    EM_CURRENT_STATE_OVER_CURRENT,                      // current too high
    EM_CURRENT_STATE_NORMAL,                            // current normal
    EM_CURRENT_STATE_UNDER_CURRENT,                     // current too low
}EM_CURRENT_STATE_TYPE;

// power voltage status type
typedef enum tagEM_VOLTAGE_STATE_TYPE
{
	EM_VOLTAGE_STATE_UNKNOWN,							// unknown
	EM_VOLTAGE_STATE_OVER,								// over 
	EM_VOLTAGE_STATE_NORMAL,							// normal
	EM_VOLTAGE_STATE_UNDER,								// under
} EM_VOLTAGE_STATE_TYPE;

// Power info
typedef struct tagDH_POWER_INFO
{
    DWORD               dwSize;
    BOOL                bPowerOn;                       // Power is on or not
    EM_CURRENT_STATE_TYPE emCurrentState;               // power current status
	EM_VOLTAGE_STATE_TYPE emVoltageState;				// power voltage status
} DH_POWER_INFO;


// battery in-place status
typedef enum __EM_BATTERY_EXIST_STATE
{
    EM_BATTERY_EXIST_STATE_UNKNOWN = 0,
    EM_BATTERY_EXIST_STATE_EXIST,                       // battery in-place
    EM_BATTERY_EXIST_STATE_MISSING,                     // battery lost
}EM_BATTERY_EXIST_STATE;

// battery status
typedef enum __EM_BATTERY_STATE
{
	EM_BATTERY_STATE_UNKNOWN = 0,
	EM_BATTERY_STATE_NORMAL,							// normal power
	EM_BATTERY_STATE_LOW,								// low power
}EM_BATTERY_STATE;

// Battery Information 
typedef struct tagDH_BATTERY_INFO
{
    DWORD               dwSize;
    int                 nPercent;                       // Battery Capacity Percentage
    BOOL                bCharging;                      // Whether real charging 
    EM_BATTERY_EXIST_STATE emExistState;                // battery in-place status
	EM_BATTERY_STATE	emState;						// battery power status	
	float				fVoltage;						// battery voltage
} DH_BATTERY_INFO;

// Power status
typedef struct tagDH_POWER_STATUS
{
	DWORD				dwSize;
	BOOL				bEnable;					// Search succeeded or not
	int					nCount;						// Power amount
	DH_POWER_INFO		stuPowers[DH_MAX_POWER_NUM];// Power status
    int                 nBatteryNum;                        // Battery Number
    DH_BATTERY_INFO     stuBatteries[DH_MAX_BATTERY_NUM];   // Battery Status 
} DH_POWER_STATUS;

// Temperature info
typedef struct tagDH_TEMPERATURE_INFO
{
	DWORD				dwSize;
	char				szName[DH_DEVICE_NAME_LEN];	// Sensor name
	float				fTemperature;				// Temperature
} DH_TEMPERATURE_INFO;

//Temperature status
typedef struct tagDH_TEMPERATURE_STATUS
{
	DWORD				dwSize;
	BOOL				bEnable;							// Search succeeded or not
	int					nCount;								// Temperature  amount
	DH_TEMPERATURE_INFO	stuTemps[DH_MAX_TEMPERATURE_NUM];	// Temperature  info
} DH_TEMPERATURE_STATUS;

// System status
typedef struct tagDH_SYSTEM_STATUS
{
	DWORD				dwSize;
	DH_CPU_STATUS*		pstuCPU;					// CPU status
	DH_MEMORY_STATUS*	pstuMemory;					// Memory status
	DH_FAN_STATUS*		pstuFan;					// Fan status
	DH_POWER_STATUS*	pstuPower;					// Power status
	DH_TEMPERATURE_STATUS*	pstuTemp;				// Temperature  status
} DH_SYSTEM_STATUS;

// Corresponding CLIENT_QueryDevState() Interface's DH_DEVSTATE_ALL_ALARM_CHANNELS_STATE Command Parameter 
// For Alarm Channel Status 
typedef enum tagNET_ALARM_CHANNEL_TYPE
{
    NET_ALARM_CHANNEL_TYPE_ALL,                             // All channels (including all of the following)
    NET_ALARM_CHANNEL_TYPE_ALARMIN,                         // Alarm input channel 
    NET_ALARM_CHANNEL_TYPE_ALARMOUT,                        // Alarm output channel 
    NET_ALARM_CHANNEL_TYPE_ALARMBELL,                       // Signal channel 
    NET_ALARM_CHANNEL_TYPE_EXALARMIN,                       // Extension module alarm input channel 
    NET_ALARM_CHANNEL_TYPE_EXALARMOUT,                      // Extension module and alarm output channel
}NET_ALARM_CHANNEL_TYPE;

typedef struct tagNET_CLIENT_ALARM_CHANNELS_STATE
{
    DWORD                       dwSize;
    NET_ALARM_CHANNEL_TYPE      emType;                     // The type of query alarm channel 	                                                                                                                                
    int                         nAlarmInCount;              // Alarm input number, specified by the user 
    int                         nAlarmInRetCount;           // The number of returned alarm input 
    BOOL*                       pbAlarmInState;             // Alarm state of input arrays, memory allocated by the user, each element represents a channel status, TRUE for input, FALSE for no input 
															// the space application by the user,apply to sizeof(BOOL)*nAlarmInCount
	int                         nAlarmOutCount;             // The number of alarm output,specified by the user 
    int                         nAlarmOutRetCount;          // The number of alarm output 
    BOOL*                       pbAlarmOutState;            // Alarm state of output arrays, memory allocated by the user, each element represents a channel status, TRUE for output, FALSE for no output 
															// the space application by the user,apply to sizeof(BOOL)*nAlarmOutCount
	int                         nAlarmBellCount;            // Alarm Number,specified by the user 
    int                         nAlarmBellRetCount;         // Returned Alarm Number 
    BOOL*                       pbAlarmBellState;           // Alarm state array, allocate memory by the user, each element represents a channel status, TRUE for output, FALSE for no output
															// the space application by the user,apply to sizeof(BOOL)*nAlarmBellCount
	int                         nExAlarmInCount;            // Extension module alarm input number, specified by the user 
    int                         nExAlarmInRetCount;         // The number of returned extension module alarm input 
    BOOL*                       pbExAlarmInState;           // Extension module alarm input state array, Memory allocated by the user, each element represents a channel status, TRUE for output, FALSE for no output 
															// the space application by the user,apply to sizeof(BOOL)*nExAlarmInCount
	int*                        pnExAlarmInDestionation;    // The location of the extension module alarm input effective channels 
															// the space application by the user,apply to sizeof(int)*nExAlarmInCount
	int                         nExAlarmOutCount;           // Extension module alarm output number, specified by the user
    int                         nExAlarmOutRetCount;        // Extension module alarm output number 
    BOOL*                       pbExAlarmOutState;          // Extension module alarm output state array, Memory allocated by the user, each element represents a channel status, TRUE for output, FALSE for no output 
															// the space application by the user,apply to sizeof(BOOL)*nExAlarmOutCount
	int*                        pnExAlarmOutDestionation;   // The location of the extension module alarm output effective channels
															// the space application by the user,apply to sizeof(int)*nExAlarmOutCount
}NET_CLIENT_ALARM_CHANNELS_STATE;


// the number of alarm keyboard connecting on a serial port
typedef struct tagNET_ALARMKEYBOARD_COUNT
{
    DWORD               dwSize;
    int                 nAlarmKeyboardCount;        // The number of alarm keyboard connected 
}NET_ALARMKEYBOARD_COUNT;

// the device type on com port
typedef enum tagEM_COM_PORT_DEVICE_TYPE
{
    EM_COM_PORT_DEVICE_TYPE_UNKNOWN,        // Unknown
    EM_COM_PORT_DEVICE_TYPE_PTZ,            // ptz
    EM_COM_PORT_DEVICE_TYPE_GPS,            // GPS
    EM_COM_PORT_DEVICE_TYPE_ALARMKEYBOARD,  // alarm keyboard
    EM_COM_PORT_DEVICE_TYPE_EXALARMBOX,     // Exalarm box
}EM_COM_PORT_DEVICE_TYPE;

// CLIENT_GetComPortDeviceChannelInfo's interface input param(get the device channel info on com port)
typedef struct tagNET_IN_GET_COM_PORT_DEVICE_CHANNEL_INFO
{
    DWORD               dwSize;
    EM_COM_PORT_DEVICE_TYPE emDeviceType;   // device type
}NET_IN_GET_COM_PORT_DEVICE_CHANNEL_INFO;

// CLIENT_GetComPortDeviceChannelInfo's interface output param(get the device channel info on com port)
typedef struct tagNET_OUT_GET_COM_PORT_DEVICE_CHANNEL_INFO
{
    DWORD               dwSize;    
    int                 nDeviceCount;               // device count(out param,include online and offline devices)
    int                 nMaxOnlineDeviceCount;      // max number of online device(in param)
    int                 nRetOnlineDeviceCount;      // online device number(out param)      
    int*                pOnlineChannel;             // online device channel array(in param,alloc by user)    
}NET_OUT_GET_COM_PORT_DEVICE_CHANNEL_INFO;

// Get the device channel info on com port
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetComPortDeviceChannelInfo(LLONG lLoginID,const NET_IN_GET_COM_PORT_DEVICE_CHANNEL_INFO* pInParam,NET_OUT_GET_COM_PORT_DEVICE_CHANNEL_INFO* pOutParam,int nWaitTime);

////////////////////////////////// screen control////////////////////////////////////////
// CLIENT_OpenSplitWindow's interface input param(open window)
typedef struct tagDH_IN_SPLIT_OPEN_WINDOW
{
	DWORD				dwSize;
	int					nChannel;					// channel no.
	DH_RECT				stuRect;					// windon position, 0~8192
	BOOL				bDirectable;				// coordinate whether meet the confitions
} DH_IN_SPLIT_OPEN_WINDOW;

// CLIENT_OpenSplitWindow's interface output param(open window)
typedef struct tagDH_OUT_SPLIT_OPEN_WINDOW
{
	DWORD				dwSize;
	unsigned int		nWindowID;					// window ID
	unsigned int		nZOrder;					// window order	
} DH_OUT_SPLIT_OPEN_WINDOW;

// CLIENT_CloseSplitWindow's interface input param(close window)
typedef struct tagDH_IN_SPLIT_CLOSE_WINDOW
{
	DWORD				dwSize;
	int					nChannel;					// channel ID
	UINT				nWindowID;					// window order
    const char*         pszCompositeID;             // multi-screen display ID
} DH_IN_SPLIT_CLOSE_WINDOW;

// CLIENT_CloseSplitWindow's interface output param(close window)
typedef struct tagDH_OUT_SPLIT_CLOSE_WINDOW
{
	DWORD				dwSize;
} DH_OUT_SPLIT_CLOSE_WINDOW;

// CLIENT_SetSplitWindowRect's interface input param(setting the window position)
typedef struct tagDH_IN_SPLIT_SET_RECT
{
	DWORD				dwSize;
	int					nChannel;					// channel ID
	UINT				nWindowID;					// window order
	DH_RECT				stuRect;					// window position, 0~8192
	BOOL				bDirectable;				// coordinate whether meet the confitions
} DH_IN_SPLIT_SET_RECT;

// CLIENT_SetSplitWindowRect's interface output param(setting the window position)
typedef struct tagDH_OUT_SPLIT_SET_RECT
{
	DWORD				dwSize;
} DH_OUT_SPLIT_SET_RECT;

// CLIENT_GetSplitWindowRect's interface input param(get window position)
typedef struct tagDH_IN_SPLIT_GET_RECT
{
	DWORD				dwSize;
	int					nChannel;					// channel ID
	UINT				nWindowID;					// window ID
} DH_IN_SPLIT_GET_RECT;

// CLIENT_GetSplitWindowRect's interface output param(get window position)
typedef struct tagDH_OUT_SPLIT_GET_RECT
{
	DWORD				dwSize;	
	DH_RECT				stuRect;					// window position, 0~8192
} DH_OUT_SPLIT_GET_RECT;

// CLIENT_SetSplitWindowLevels's interface input param(setting window order)
typedef struct tagDH_IN_SPLIT_SET_TOP_WINDOW
{
	DWORD				dwSize;
	int					nChannel;					// channel ID
	int					nWindowID;					// windown ID
} DH_IN_SPLIT_SET_TOP_WINDOW;

// CLIENT_SetSplitWindowLevels's interface output param(setting window order)
typedef struct tagDH_OUT_SPLIT_SET_TOP_WINDOW
{
	DWORD				dwSize;
	DH_WND_ZORDER*		pZOders;					// window order array,the space application by the user,apply to sizeof(DH_WND_ZORDER)*nMaxWndCount
	int					nMaxWndCount;				// window order array size
	int					nWndCount;					// count of returned window
} DH_OUT_SPLIT_SET_TOP_WINDOW;

// CLIENT_SetDisplayMode's interface input param(monitor wall display mode settings)
typedef struct tagDH_IN_WM_SET_DISPLAY_MODE 
{
	DWORD				dwSize;
	int					nMonitorWallID;				// monitor wall ID
	const char*			pszBlockID;					// block ID, NULL/""-all region
	int					nTVID;						// display unit ID, -1 means all unit
	UINT				nDisplayMode;				// display mode, 0-standard, 1-highlighting, 2-energy saving
} DH_IN_WM_SET_DISPLAY_MODE;

// CLIENT_SetDisplayMode's interface output param(monitor wall display mode settings)
typedef struct tagDH_OUT_WM_SET_DISPLAY_MODE
{
	DWORD				dwSize;
} DH_OUT_WM_SET_DISPLAY_MODE;

// all display unit in the area of the display mode
typedef struct tagDH_BLOCK_DISPLAY_MODE
{
	DWORD				dwSize;
	int*				pTVModes;					// TV display mode
	int					nMaxTVCount;				// max count of tV
	int					nRetTVCount;				// count of retTV
} DH_BLOCK_DISPLAY_MODE;

// CLIENT_GetDisplayMode's interface input param(get monitor wall display mode)
typedef struct tagDH_IN_WM_GET_DISPLAY_MODE 
{
	DWORD				dwSize;
	int					nMonitorWallID;				// monitor wall ID
	const char*			pszBlockID;					// block ID, NULL/""-means all
	int					nTVID;						// TV ID, -1 means all
} DH_IN_WM_GET_DISPLAY_MODE;

// CLIENT_GetDisplayMode's interface output param(get monitor wall display mode)
typedef struct tagDH_OUT_WM_GET_DISPLAY_MODE
{
	DWORD				dwSize;
	DH_BLOCK_DISPLAY_MODE* pBlockModes;				// display mode, the space appliacation by the user,apply to sizeof(DH_BLOCK_DISPLAY_MODE)*nMaxBlockCount
	int					nMaxBlockCount;				// count of array
	int					nRetBlockCount;				// count of ret 
} DH_OUT_WM_GET_DISPLAY_MODE;

// CLIENT_PowerControl's interface input param(monitor wall power control)
typedef struct tagDH_IN_WM_POWER_CTRL 
{
	DWORD				dwSize;
	int					nMonitorWallID;				// monitor wall ID
	const char*			pszBlockID;					// block ID, NULL/""- means all
	int					nTVID;						// TV ID, -1 means all
	BOOL				bPowerOn;					// power on or not
} DH_IN_WM_POWER_CTRL;

// CLIENT_PowerControl's interface input param(monitor wall power control)
typedef struct tagDH_OUT_WM_POWER_CTRL
{
	DWORD				dwSize;
} DH_OUT_WM_POWER_CTRL;

// CLIENT_LoadMonitorWallCollection's interface input param(load monitor wall plans)
typedef struct tagDH_IN_WM_LOAD_COLLECTION 
{
	DWORD				dwSize;
	int					nMonitorWallID;				// monitor wall ID
	const char*			pszName;					// name of plan
} DH_IN_WM_LOAD_COLLECTION;

// CLIENT_LoadMonitorWallCollection's interface output param(load monitor wall plans)
typedef struct tagDH_OUT_WM_LOAD_COLLECTION 
{
	DWORD				dwSize;
} DH_OUT_WM_LOAD_COLLECTION;


// Plan type
typedef enum tagEM_SAVE_COLLECTION_TYPE
{
    EM_SAVE_COLLECTION_UNKNOWN,            // Unknown
    EM_SAVE_COLLECTION_VIDEO,              // Video plan
    EM_SAVE_COLLECTION_ADDITIONAL,         // Addition plan
}EM_SAVE_COLLECTION_TYPE;


// CLIENT_SaveMonitorWallCollection's interface input param(save monitor wall plans)
typedef struct tagDH_IN_WM_SAVE_COLLECTION 
{
	DWORD				dwSize;
	int					nMonitorWallID;				// monitor wall ID
	const char*			pszName;					// name pf plan
    const char*         pszControlID;               // control id
    BYTE                bReserverd[4];              // Reserve bytes for byte alignment
    EM_SAVE_COLLECTION_TYPE emType;                 // Plan type
} DH_IN_WM_SAVE_COLLECTION;

// CLIENT_SaveMonitorWallCollection's interface output param(load monitor wall plans)
typedef struct tagDH_OUT_WM_SAVE_COLLECTION 
{
	DWORD				dwSize;
} DH_OUT_WM_SAVE_COLLECTION;

// CLIENT_RenameMonitorWallCollection's interface input param(plan rename)
typedef struct tagDH_IN_WM_RENAME_COLLECTION 
{
	DWORD				dwSize;
	int					nMonitorWallID;				// monitor wall ID
	const char*			pszOldName;					// old name
	const char*			pszNewName;					// new name
} DH_IN_WM_RENAME_COLLECTION;

// CLIENT_RenameMonitorWallCollection's interface input param(plan rename)
typedef struct tagDH_OUT_WM_RENAME_COLLECTION
{
	DWORD				dwSize;
} DH_OUT_WM_RENAME_COLLECTION;

// information window areas
typedef struct tagDH_WINDOW_COLLECTION
{
	DWORD				dwSize;
	int					nWindowID;					// window ID
	BOOL				bWndEnable;					// enable
	DH_RECT				stuRect;					// rect, effect when free split mode
	BOOL				bDirectable;				// coordinate whether meet the conditions
	int					nZOrder;					// z order
	BOOL				bSrcEnable;					// source enable
	char				szDeviceID[DH_DEV_ID_LEN_EX]; // device ID
	int					nVideoChannel;				// video channel
	int					nVideoStream;				// video stream type
	int					nAudioChannel;				// audio channel
	int					nAudioStream;				// audio stream type
	int					nUniqueChannel;				// unique channel
} DH_WINDOW_COLLECTION;

// Background information of mosaic area
typedef struct tagNET_SCREEEN_BACKGROUD
{
    BOOL            bEnable;                        // Enable
    char            szName[130];                    // Background name, background is uploaded file, without path
    BYTE            byReserved[130];                // Reserved
} NET_SCREEEN_BACKGROUD;

// areas collection
typedef struct tagDH_BLOCK_COLLECTION 
{
	DWORD				dwSize;
	DH_SPLIT_MODE		emSplitMode;					// split mode
	DH_WINDOW_COLLECTION stuWnds[DH_MAX_SPLIT_WINDOW];	// window info array
	int					nWndsCount;						// count of window
	char				szName[DH_DEVICE_NAME_LEN];		// favorites name
    int                 nScreen;                       	// The output channel number, including the splicing screen 
    char                szCompositeID[DH_DEV_ID_LEN_EX]; // splicing video wall ID
    DH_WINDOW_COLLECTION* pstuWndsEx;                  	// Windows information array pointer, the memory assigned by user. Use when the size of stuWnds array is not enough.  
    int                 nMaxWndsCountEx;               	// The maximum number of windows, filled by user. pstuWndsEx the muber of the array element.
    int                 nRetWndsCountEx;               	// The number of return windows.

    int                   nSplitOsdCount;               // Number of split OSD
    NET_SPLIT_OSD         stuSplitOsd[20];              // Split OSD
    NET_SCREEEN_BACKGROUD stuScreenBackground;          // Background information of mosaic area.Currently only used for plan acquisition
} DH_BLOCK_COLLECTION;

// TV wall display unit
typedef struct tagDH_MONITORWALL_OUTPUT 
{
    DWORD       dwSize;
    char        szDeviceID[DH_DEV_ID_LEN];     	// device ID, local time is""
    int         nChannel;              			// channel no.
    char        szName[DH_DEV_NAME_LEN];      	// screen name 
} DH_MONITORWALL_OUTPUT;

// TV wall display block
typedef struct tagDH_MONITORWALL_BLOCK
{
  DWORD         dwSize;
  char          szName[DH_DEV_NAME_LEN];    	// block name 
  char          szCompositeID[DH_DEV_ID_LEN];  	// splicing video wall ID
  char          szControlID[DH_DEV_ID_LEN];   	// control ID
  int           nSingleOutputWidth;       		// single display unit occupied grid column number
  int           nSingleOutputHeight;      		// single display unit occupied grid row number
  DH_RECT       stuRect;            			// zone coordinate
  DH_TSECT      stuPowerSchedule[DH_TSCHE_DAY_NUM][DH_TSCHE_SEC_NUM]; // switch on time chart, first-dimension each element means sunday~saturday and holiday
  DH_MONITORWALL_OUTPUT* pstuOutputs;          	// display unit data,  user allocation memory
  int           nMaxOutputCount;        		// display unit group size,user fill in
  int           nRetOutputCount;        		// return display unit quantity
  char          szBlockType[DH_COMMON_STRING_32];   // display unit block type
} DH_MONITORWALL_BLOCK;

// tv wall config 
typedef struct tagDH_MONITORWALL 
{
  DWORD         dwSize;
  char          szName[DH_DEV_NAME_LEN];    // name 
  int           nGridLine;           		// grid row
  int           nGridColume;          		// grid column
  DH_MONITORWALL_BLOCK*  pstuBlocks;        // display block group, user allocation nmemory
  int           nMaxBlockCount;         	// display zone group size, user fill in
  int           nRetBlockCount;         	// return display block quantity
  BOOL          bDisable;            		// disable or not, 0-tv wall is valid , 1-tv wall is invalid
  char          szDesc[DH_COMMON_STRING_256];  // tv wall description info 
} DH_MONITORWALL;


// plan of monitor wall
typedef struct tagDH_MONITORWALL_COLLECTION 
{
	DWORD				dwSize;
	char				szName[DH_DEVICE_NAME_LEN];		// name
	DH_BLOCK_COLLECTION	stuBlocks[DH_MAX_BLOCK_NUM];	// area array
	int					nBlocksCount;					// area count
	char				szControlID[DH_DEV_ID_LEN_EX];	// control ID
    DH_MONITORWALL      stuMonitorWall;             	// tv wall config 
    EM_SAVE_COLLECTION_TYPE emType;                     // plan type
    BYTE                  byReserved[4];                // Reserve byte used for byte alignment
} DH_MONITORWALL_COLLECTION;

// CLIENT_GetMonitorWallCollections's interface input param(get plan information of monitor wall)
typedef struct tagDH_IN_WM_GET_COLLECTIONS 
{
	DWORD				dwSize;
	int					nMonitorWallID;				// monitor wall ID
} DH_IN_WM_GET_COLLECTIONS;

// CLIENT_GetMonitorWallCollections's interface output param(get plan information of monitor wall)
typedef struct tagDH_OUT_WM_GET_COLLECTIONS 
{
	DWORD				dwSize;	
	DH_MONITORWALL_COLLECTION* pCollections;		// plan of monitor wall array
	int					nMaxCollectionsCount;		// array size
	int					nCollectionsCount;			// max count of plan
} DH_OUT_WM_GET_COLLECTIONS;

// CLIENT_GetSplitWindowsInfo's interface input param
typedef struct tagDH_IN_SPLIT_GET_WINDOWS 
{
	DWORD				dwSize;
	int					nChannel;					// channel
} DH_IN_SPLIT_GET_WINDOWS;

// CLIENT_GetSplitWindowsInfo's interface output param
typedef struct tagDH_OUT_SPLIT_GET_WINDOWS 
{
	DWORD				dwSize;
	DH_BLOCK_COLLECTION	stuWindows;					// channel
} DH_OUT_SPLIT_GET_WINDOWS;

// CLIENT_LoadSplitCollection's interface input param(load collection)
typedef struct tagDH_IN_SPLIT_LOAD_COLLECTION 
{
	DWORD				dwSize;
	int					nChannel;					// channel
	const char*			pszName;					// name
} DH_IN_SPLIT_LOAD_COLLECTION;

// CLIENT_LoadSplitCollection's interface output param(load collection)
typedef struct tagDH_OUT_SPLIT_LOAD_COLLECTION 
{
	DWORD				dwSize;
} DH_OUT_SPLIT_LOAD_COLLECTION;

// CLIENT_SaveSplitCollection's interface input param(save collection)
typedef struct tagDH_IN_SPLIT_SAVE_COLLECTION 
{
	DWORD				dwSize;
	int					nChannel;					// channle
	const char*			pszName;					// name
} DH_IN_SPLIT_SAVE_COLLECTION;

// CLIENT_SaveSplitCollection's interface input param(save collection)
typedef struct tagDH_OUT_SPLIT_SAVE_COLLECTION 
{
	DWORD				dwSize;
} DH_OUT_SPLIT_SAVE_COLLECTION;

// CLIENT_RenameSplitCollection's interface input param(collection rename)
typedef struct tagDH_IN_SPLIT_RENAME_COLLECTION 
{
	DWORD				dwSize;
	int					nChannel;					// channel
	const char*			pszOldName;					// old name
	const char*			pszNewName;					// new name
} DH_IN_SPLIT_RENAME_COLLECTION;

// CLIENT_RenameSplitCollection's interface output param(collection rename)
typedef struct tagDH_OUT_SPLIT_RENAME_COLLECTION
{
	DWORD				dwSize;
} DH_OUT_SPLIT_RENAME_COLLECTION;

// CLIENT_GetSplitCollections's interface input param(get information of favorites)
typedef struct tagDH_IN_SPLIT_GET_COLLECTIONS 
{
	DWORD				dwSize;
	int					nChannel;					// channel
} DH_IN_SPLIT_GET_COLLECTIONS;

// CLIENT_GetSplitCollections's interface output param(get information of favorites)
typedef struct tagDH_OUT_SPLIT_GET_COLLECTIONS 
{
	DWORD				dwSize;	
	DH_BLOCK_COLLECTION* pCollections;				// array,the space application by the user,apply to sizeof(DH_BLOCK_COLLECTION)*nMaxCollectionsCount
	int					nMaxCollectionsCount;		// size
	int					nCollectionsCount;			// count
} DH_OUT_SPLIT_GET_COLLECTIONS;

// CLIENT_DeleteSplitCollection's interface input param(delete favorites)
typedef struct tagDH_IN_SPLIT_DELETE_COLLECTION 
{
	DWORD				dwSize;
	int					nChannel;					// channel
	const char**		ppszNames;					// array of favorites name
	int					nNameCount;					// size of array
} DH_IN_SPLIT_DELETE_COLLECTION;

// CLIENT_DeleteSplitCollection's interface input param(delete favorites)
typedef struct tagDH_OUT_SPLIT_DELETE_COLLECTION 
{
	DWORD				dwSize;
} DH_OUT_SPLIT_DELETE_COLLECTION;

// composite screen channel information
typedef struct tagDH_COMPOSITE_CHANNEL
{
	DWORD				dwSize;
	char				szMonitorWallName[DH_DEVICE_NAME_LEN];	// monitor wall name
	char				szCompositeID[DH_DEV_ID_LEN_EX];		// composite ID
	int					nVirtualChannel;						// virtual channel
} DH_COMPOSITE_CHANNEL;

// tour enable configuration
typedef struct tagDHDEV_TOUR_ENABLE
{
	DWORD				dwSize;
	BOOL				bEnable;					// enable
	BOOL				bStart;						// is touring or not(read only). bStart=FALSE when tour is able but doesn't set
} DHDEV_TOUR_ENABLE_CFG;

// CLIENT_SetDecodePolicy's interface input param(set the decoding policy)
typedef struct tagDH_IN_SET_DEC_POLICY 
{
	DWORD				dwSize;
	int					nChannel;			// channel
	int					nWindow;			// window no., -1 means all
	int					nPolicyLevel;		// policy level, a total of 5 file(-2, -1, 0, 1, 2), the greater the vale ,the bigger the fluid but delay
											// -2 real-time good, 2 fluency good, 0 default
} DH_IN_SET_DEC_POLICY;

// CLIENT_SetDecodePolicy's interface output param(set the decoding policy)
typedef struct tagDH_OUT_SET_DEC_POLICY 
{
	DWORD				dwSize;
} DH_OUT_SET_DEC_POLICY;

// CLIENT_GetDecodePolicy's interface input param(get the decoding policy)
typedef struct tagDH_IN_GET_DEC_POLICY 
{
	DWORD				dwSize;
	int					nChannel;			// channel
	int					nWindow;			// window ID, -1 means all
} DH_IN_GET_DEC_POLICY;

// CLIENT_GetDecodePolicy's interface output param(get the decoding policy)
typedef struct tagDH_OUT_GET_DEC_POLICY 
{
	DWORD				dwSize;
	int					nPolicyLevel;		// policy level, a total of 5 file(-2, -1, 0, 1, 2), the greater the vale ,the bigger the fluid but delay
											// -2 real-time good, 2 fluency good, 0 default
} DH_OUT_GET_DEC_POLICY;

// audio output mode
typedef enum
{
	DH_AUDIO_AUTO,							// automatic switch
	DH_AUDIO_DISABLE,						// all output disable 
	DH_AUDIO_FORCE,							// mandatory audio output to the user to specify a window
    DH_AUDIO_ENABLE_ONE,                    // Open the audio of target window, multi-channel of audio output is available    
    DH_AUDIO_DISABLE_ONE,                   // Close the audio of target window, multi-channel of audio output is available    
    DH_AUDIO_MULTI,                         // Multi-channel of audio output, be used when inquire not setting
} DH_AUDIO_OUTPUT_MODE;

// CLIENT_SetSplitAudioOuput's interface input param(set mode of audio output)
typedef struct tagDH_IN_SET_AUDIO_OUTPUT 
{
	DWORD				dwSize;
	int					nChannel;			// channel ID
	DH_AUDIO_OUTPUT_MODE emMode;			// mode
	int					nWindow;			// window no. , effect when emMode = DH_AUDIO_FORCE
} DH_IN_SET_AUDIO_OUTPUT;

// CLIENT_SetSplitAudioOuput's interface output param(set mode of audio output)
typedef struct tagDH_OUT_SET_AUDIO_OUTPUT
{
	DWORD				dwSize;
} DH_OUT_SET_AUDIO_OUTPUT;

// CLIENT_GetSplitAudioOuput's interface input param(get mode of audio output)
typedef struct tagDH_IN_GET_AUDIO_OUTPUT
{
	DWORD				dwSize;
	int					nChannel;			// channel ID
} DH_IN_GET_AUDIO_OUTPUT;

// CLIENT_GetSplitAudioOuput's interface output param(get mode of audio output)
typedef struct tagDH_OUT_GET_AUDIO_OUTPUT
{
	DWORD				dwSize;
	DH_AUDIO_OUTPUT_MODE emMode;				// mode of audio output
	int					nWindow;				// window no., effect when emMode = DH_AUDIO_FORCE
    int*                pMultiWindows;         	// The list of output windows number, valid when emMode = DH_AUDIO_MULTI, user assign the memory,apply to sizeof(int)*nMaxMultiWindowCount
    int                 nMaxMultiWindowCount;  	// ouput the maximum number of window list, filled by user
    int                 nRetMultiWindowCount;  	// Output the number of windows, effect  when  emMode=DH_AUDIO_MULTI
} DH_OUT_GET_AUDIO_OUTPUT;

// CLIENT_GetEncodePlan's interface output param(access to burn a CD to yer coding parameters)
typedef struct tagDH_IN_GET_ENCODE_PLAN
{
	DWORD				dwSize;
	unsigned int        nChannel;          // channel
	unsigned int        nExpectTime;       // expect time,int(min)
	unsigned int        nCapacity;         // capacity,int(M)
}DH_IN_GET_ENCODE_PLAN;
// CLIENT_GetEncodePlan's interface output param(access to burn a CD to yer coding parameters)
typedef struct tagDH_OUT_GET_ENCODE_PLAN
{
	DWORD				dwSize;
	int                 nResolutionType;    // emResolutionTypes counts
	CAPTURE_SIZE        emResolutionTypes[DH_MAX_CAPTURE_SIZE_NUM];// the scope of video resolution
	CAPTURE_SIZE        emResolution;       // the recommended video resolution
	unsigned int        nBitRate;           // bit rate
}DH_OUT_GET_ENCODE_PLAN;

// CLIENT_GetEncodePlanByResolution's interface input param(get expect time by resolution and CD capacity)
typedef struct tagNET_IN_GET_ENCODEPLANE_BY_RESOLUTION
{
	DWORD               dwSize;
	unsigned int        nChannel;               // channel id
	CAPTURE_SIZE        emResolution;			// video resolution
	unsigned int        nBitRate;               // bit rate
	unsigned int		nCapacity;				// capacity(M)
} NET_IN_GET_ENCODEPLANE_BY_RESOLUTION;

// CLIENT_GetEncodePlanByResolution's interface output param(get expect time by resolution and CD capacity)
typedef struct tagNET_OUT_GET_ENCODEPLANE_BY_RESOLUTION
{
	DWORD               dwSize;
	unsigned int        nExpectTime;			// expect time(min)
} NET_OUT_GET_ENCODEPLANE_BY_RESOLUTION;


// organization directory logical objects
typedef struct tagDH_ORGANIZATION_NODE_LOGIC_OBJECT 
{
	DWORD				dwSize;
	char				szName[DH_NODE_NAME_LEN];	// name
	char				szType[DH_DEV_TYPE_LEN];	// type
	char				szDevID[DH_DEV_ID_LEN_EX];	// deviceID
	char				szControlID[DH_DEV_ID_LEN_EX]; // control ID, read only
	int					nChannel;					// channel
} DH_ORGANIZATION_NODE_LOGIC_OBJECT;

// organization directory
typedef struct tagDH_ORGANIZATION_NODE_DIRECTORY
{
	DWORD				dwSize;
	char				szName[DH_NODE_NAME_LEN];		// name
	char				szControlID[DH_DEV_ID_LEN_EX];	// control ID
} DH_ORGANIZATION_NODE_DIRECTORY;

// info of organization directory node
typedef struct tagDH_ORGANIZATION_NODE 
{
	DWORD				dwSize;
	int					nNodeType;						// node type, 0-logical objects, 1-list
	DH_ORGANIZATION_NODE_LOGIC_OBJECT	stuLogicObject;	// logical object, effective when nNodeType==0
	DH_ORGANIZATION_NODE_DIRECTORY		stuDirectory;	// list,effective when nNodeType==1		
} DH_ORGANIZATION_NODE;

// add node param
typedef struct tagDH_ORGANIZATION_ADD_NODE_PARAM
{
	DWORD				dwSize;
	int					nPosition;					// position, -1-start, -2-end, 0~n
	DH_ORGANIZATION_NODE stuNode;					// info of node
} DH_ORGANIZATION_ADD_NODE_PARAM;

// CLIENT_OrganizationAddNodes's interface input param(add node)
typedef struct tagDH_IN_ORGANIZATION_ADD_NODES
{
	DWORD				dwSize;
	char*				pszPath;					// path
	DH_ORGANIZATION_ADD_NODE_PARAM* pstuNodes;		// node pointer,the space application by the user,apply to sizeof(DH_ORGANIZATION_ADD_NODE_PARAM)*nNodeCount
	int					nNodeCount;					// count of node
} DH_IN_ORGANIZATION_ADD_NODES;

// result of added node
typedef struct tagDH_ORGANIZATION_ADD_NODE_RESULT
{
	DWORD				dwSize;
	BOOL				bResult;					// result
	char				szPath[MAX_PATH];			// path, return node path when succeed,return add node path when failed
} DH_ORGANIZATION_ADD_NODE_RESULT;

// CLIENT_OrganizationAddNodess interface output param(add node)
typedef struct tagDH_OUT_ORGANIZATION_ADD_NODES
{
	DWORD				dwSize;
	DH_ORGANIZATION_ADD_NODE_RESULT* pstuResults;	// result pointer
	int					nMaxResultCount;			// size of result
	int					nRetResultCount;			// count of result
} DH_OUT_ORGANIZATION_ADD_NODES;

// node path
typedef struct tagDH_ORGANIZATION_NODE_PATH 
{
	DWORD				dwSize;
	char				szPath[MAX_PATH];			// path
} DH_ORGANIZATION_NODE_PATH;

// CLIENT_OrganizationDeleteNodes's interface input param(delete node)
typedef struct tagDH_IN_ORGANIZATION_DELETE_NODES
{
	DWORD				dwSize;
	DH_ORGANIZATION_NODE_PATH*	pstuPath;			// path array,the space application by the user,apply to sizeof(DH_ORGANIZATION_NODE_PATH)*nPathCount
	int					nPathCount;					// count
} DH_IN_ORGANIZATION_DELETE_NODES;

// CLIENT_OrganizationDeleteNodes's interface output param(delete node)
typedef struct tagDH_OUT_ORGANIZATION_DELETE_NODES 
{
	DWORD				dwSize;
} DH_OUT_ORGANIZATION_DELETE_NODES;

// CLIENT_OrganizationGetNodes's interface input param(get node info)
typedef struct tagDH_IN_ORGANIZATION_GET_NODES 
{
	DWORD				dwSize;
	char*				pszPath;					// path
	int					nLevel;						// level, 0-the level, 1-next level
} DH_IN_ORGANIZATION_GET_NODES;

// CLIENT_OrganizationGetNodes's interface output param(get node info)
typedef struct tagDH_OUT_ORGANIZATION_GET_NODES 
{
	DWORD				dwSize;
	DH_ORGANIZATION_NODE*	pstuNodes;				// node array,the space application by the user,apply to sizeof(DH_ORGANIZATION_NODE)*nMaxNodeCount
	int					nMaxNodeCount;				// size of array
	int					nRetNodeCount;				// count of node count
} DH_OUT_ORGANIZATION_GET_NODES;

// CLIENT_OrganizationSetNode's interface input param(get node info)
typedef struct tagDH_IN_ORGANIZATION_SET_NODE 
{
	DWORD				dwSize;
	char*				pszPath;					// path
	DH_ORGANIZATION_NODE stuNode;					// node info
} DH_IN_ORGANIZATION_SET_NODE;

// CLIENT_OrganizationSetNode's interface output param(set node)
typedef struct tagDH_OUT_ORGANIZATION_SET_NODE 
{
	DWORD				dwSize;
} DH_OUT_ORGANIZATION_SET_NODE;

// channel info of video input
typedef struct tagDH_VIDEO_INPUTS
{
	DWORD				dwSize;
	char				szChnName[DH_DEVICE_NAME_LEN];		// channel name
	BOOL				bEnable;							// enable
	char				szControlID[DH_DEV_ID_LEN_EX];		// control ID
	char				szMainStreamUrl[MAX_PATH];			// main stream url 
	char				szExtraStreamUrl[MAX_PATH];			// extra stream url
    int                 nOptionalMainUrlCount;              // spare main stream address quantity
    char                szOptionalMainUrls[DH_MAX_OPTIONAL_URL_NUM][MAX_PATH]; // spare main stream address list
    int                 nOptionalExtraUrlCount;             // spare sub stream address quantity
    char                szOptionalExtraUrls[DH_MAX_OPTIONAL_URL_NUM][MAX_PATH]; // spare substream address list
} DH_VIDEO_INPUTS;

typedef struct tagDH_REMOTE_DEVICE 
{
	DWORD				dwSize;
	BOOL				bEnable;							// enable
	char			    szIp[DH_MAX_IPADDR_LEN];		    // IP
	char			    szUser[DH_USER_NAME_LENGTH];	    // username
	char			    szPwd[DH_USER_PSW_LENGTH];	    	// password
	int			    	nPort;							    // port
	int				    nDefinition;					    // definition. 0-standard definition, 1-high definition
	DH_DEVICE_PROTOCOL  emProtocol;							// protocol type
	char			    szDevName[DH_DEVICE_NAME_LEN];		// device name
	int					nVideoInputChannels;				// count channel of video input
	int					nAudioInputChannels;				// count channel of audio input
	char				szDevClass[DH_DEV_TYPE_LEN];		// device type, such as IPC, DVR, NVR
	char				szDevType[DH_DEV_TYPE_LEN];			// device type, such as IPC-HF3300
	int					nHttpPort;							// Http port
	int					nMaxVideoInputCount;				// max count of video input
	int					nRetVideoInputCount;				// return count
	DH_VIDEO_INPUTS*	pstuVideoInputs;					// max count of audion input, user malloc the memory,apply to sizeof(DH_VIDEO_INPUTS)*nMaxVideoInputCount
	char				szMachineAddress[DH_MAX_CARD_INFO_LEN];	// machine address
	char				szSerialNo[DH_SERIALNO_LEN];		// serial no.
    int                 nRtspPort;                          // Rtsp Port

	/*use to new plaform for extension*/
	char                szUserEx[DH_USER_NAME_LEN_EX];      // username
    char                szPwdEx[DH_USER_PSW_LEN_EX];        // password

    char				szVendorAbbr[DH_COMMON_STRING_32];		// vendor abbreviation
    char             szSoftwareVersion[DH_COMMON_STRING_64];         // software version
    NET_TIME         stuActivationTime;                         // activation time 
} DH_REMOTE_DEVICE;

typedef enum tagNET_LOGIC_CHANNEL_TYPE
{
    LOGIC_CHN_UNKNOWN,              // Unknow
    LOGIC_CHN_LOCAL,                // Local channel 
    LOGIC_CHN_REMOTE,               // Remote access channel 
    LOGIC_CHN_COMPOSE,              // Synthesis of channel, for the judicial equipment contains picture in picture channel and mixing channel
    LOGIC_CHN_MATRIX,               // matrix channel, including analog matrix and digital matrix
    LOGIC_CHN_CASCADE,              // cascading channel
} NET_LOGIC_CHN_TYPE;

// available according to the source of information
typedef struct tagDH_MATRIX_CAMERA_INFO
{
	DWORD				dwSize;
	char				szName[DH_DEV_ID_LEN_EX];		// name
	char				szDevID[DH_DEV_ID_LEN_EX];		// device ID
	char				szControlID[DH_DEV_ID_LEN_EX];	// control ID
	int					nChannelID;						// channel ID, DeviceID is unique
	int					nUniqueChannel;					// unique channel
	BOOL				bRemoteDevice;					// support remote device or not
	DH_REMOTE_DEVICE	stuRemoteDevice;				// info of remote device
	NET_STREAM_TYPE     emStreamType;                   // stream type
    NET_LOGIC_CHN_TYPE  emChannelType;                  // Channel Types 
} DH_MATRIX_CAMERA_INFO;

// CLIENT_MatrixGetCameras's interface input param
typedef struct tagDH_IN_MATRIX_GET_CAMERAS 
{
	DWORD				dwSize;
} DH_IN_MATRIX_GET_CAMERAS;

// CLIENT_MatrixGetCameras's interface output param
typedef struct tagDH_OUT_MATRIX_GET_CAMERAS 
{
	DWORD				dwSize;
	DH_MATRIX_CAMERA_INFO* pstuCameras;					// array
	int					nMaxCameraCount;				// size of source array,the space application by the user,apply to sizeof(DH_MATRIX_CAMERA_INFO)*nMaxCameraCount
	int					nRetCameraCount;				// return count
} DH_OUT_MATRIX_GET_CAMERAS;

//CLIENT_QueryDevInfo , NET_QUERY_DEV_REMOTE_DEVICE_INFO inquire  the input parameters of remote device information 
typedef struct tagNET_IN_GET_DEVICE_INFO
{
    DWORD                       dwSize;                                         // when this structure be used, dwSize assigned to sizeof(NET_IN_GET_DEVICE_INFO)
    char                        szDevice[DH_DEV_ID_LEN_EX];                 	// Device ID
    // Device attribute, when szDevice is null, the following do effect
    char                        szAttributeIP[DH_COMMON_STRING_32];             // device address
    int                         nAttributePort;                                 // device port
    char                        szAttributeUsername[DH_COMMON_STRING_128];      // user name
    char                        szAttributePassword[DH_COMMON_STRING_128];      // password
    char                        szAttributeManufacturer[DH_COMMON_STRING_128];  // manufacturer protocl
}NET_IN_GET_DEVICE_INFO;

//CLIENT_QueryDevInfo , NET_QUERY_DEV_REMOTE_DEVICE_INFO inquire the output parameter of remote device information 
typedef struct tagNET_OUT_GET_DEVICE_INFO
{
    DWORD                       dwSize;         // When this structure is used, dwSize should be assigned to sizeof(NET_OUT_GET_DEVICE_INFO)
	DH_REMOTE_DEVICE            stuInfo;        // Device information, the member of this structur,  dwSize, should be assigned by user
}NET_OUT_GET_DEVICE_INFO;

// CLIENT_MatrixSetCameras's interface input param
typedef struct tagDH_IN_MATRIX_SET_CAMERAS 
{
	DWORD				dwSize;
	DH_MATRIX_CAMERA_INFO* pstuCameras;					// array,the space application by the user,apply to sizeof(DH_MATRIX_CAMERA_INFO)*nCameraCount
	int					nCameraCount;				    // size of source array
} DH_IN_MATRIX_SET_CAMERAS;

// CLIENT_MatrixSetCameras's interface output param
typedef struct tagDH_OUT_MATRIX_SET_CAMERAS 
{
	DWORD				dwSize;
} DH_OUT_MATRIX_SET_CAMERAS;

// source of window display info 
typedef struct tagDH_SPLIT_WND_SOURCE 
{
	DWORD				dwSize;
	BOOL				bEnable;						// enable
	char				szDeviceID[DH_DEV_ID_LEN];		// device ID
	char				szControlID[DH_DEV_ID_LEN];		// control ID
	int					nVideoChannel;					// video channel ID
	int					nVideoStream;					// video stream type
	int					nAudioChannel;					// audio channel ID
	int					nAudioStream;					// audio stream type
	int					nUniqueChannel;					// unique channel,read only
	BOOL				bRemoteDevice;					// support remote device
	DH_REMOTE_DEVICE	stuRemoteDevice;				// info of remote device
	NET_RECT			stuSRect;						// video source region,if rect is (0,0,0,0),it means valid data,device use default value(0,0,8192,8192)
} DH_SPLIT_WND_SOURCE;

// info of split window
typedef struct tagDH_SPLIT_WINDOW 
{
	DWORD				dwSize;
	BOOL				bEnable;						// enable
	int					nWindowID;						// window ID
	char				szControlID[DH_DEV_ID_LEN];		// control ID
	DH_RECT				stuRect;						// rect of window, effective when free split
	BOOL				bDirectable;					// coordinate whether meet the conditions
	int					nZOrder;						// Z order
	DH_SPLIT_WND_SOURCE stuSource;						// source info
    UINT                     nOSDNum;                        // OSD number
    NET_SPLIT_OSD       stuOSD[DH_VIDEO_CUSTOM_OSD_NUM_EX];    // OSD information

    BOOL                bLock;                          // Is the window locked
    BOOL                bDock;                          // Does the window have adhesion effect?
    BOOL                bMeetingMode;                   // Is the window in conference mode
} DH_SPLIT_WINDOW;

// split scene
typedef struct tagDH_SPLIT_SCENE 
{
	DWORD				dwSize;
	char				szCompositeID[DH_DEV_ID_LEN];	// composite ID
	char				szControlID[DH_DEV_ID_LEN];		// control ID
	DH_SPLIT_MODE		emSplitMode;					// split mode
	DH_SPLIT_WINDOW*	pstuWnds;						// info of array,the space application by the user,apply to sizeof(DH_SPLIT_WINDOW)*nMaxWndCount
	int					nMaxWndCount;					// size of array
	int					nRetWndCount;					// return count
} DH_SPLIT_SCENE;

// monitor wall scene
typedef struct tagDH_MONITORWALL_SCENE
{
	DWORD				dwSize;
	char				szName[DH_DEV_NAME_LEN];		// name of plan
	char				szControlID[DH_DEV_ID_LEN];		// control ID
	DH_MONITORWALL		stuMonitorWall;					// monitor wall configuration	
	DH_SPLIT_SCENE*		pstuSplitScene;					// array of split scene,the space application by the user,apply to sizeof(DH_SPLIT_SCENE)*nMaxSplitSceneCount
	int					nMaxSplitSceneCount;			// size of array
	int					nRetSplitSceneCount;			// return count
} DH_MONITORWALL_SCENE;

// CLIENT_MonitorWallGetScene's interface input param(get monitor wall scene)
typedef struct tagDH_IN_MONITORWALL_GET_SCENE 
{
	DWORD				dwSize;
	int					nMonitorWallID;					// monitor wall ID
} DH_IN_MONITORWALL_GET_SCENE;

// CLIENT_MonitorWallGetScene's interface output param(get monitor wall scene)
typedef struct tagDH_OUT_MONITORWALL_GET_SCENE 
{
	DWORD				dwSize;
	char				szName[DH_DEV_NAME_LEN];		// name of plan, can be null
	DH_MONITORWALL_SCENE stuScene;						// minotor wall scene
} DH_OUT_MONITORWALL_GET_SCENE;

// CLIENT_MonitorWallSetScene's interface input param(set monitor wall scene)
typedef struct tagDH_IN_MONITORWALL_SET_SCENE 
{
	DWORD				dwSize;
	int					nMonitorWallID;					// TV Wall No. 
	DH_MONITORWALL_SCENE stuScene;						// TV Wall Scene
} DH_IN_MONITORWALL_SET_SCENE;

// CLIENT_MonitorWallSetScene's interface output param(set monitor wall scene)
typedef struct tagDH_OUT_MONITORWALL_SET_SCENE 
{
	DWORD				dwSize;
} DH_OUT_MONITORWALL_SET_SCENE;

//CLIENT_QueryNetStat Port, input parameter when the Types of queries is NET_APP_DATA_STAT (statistics for protocol stack) 
typedef struct tagNET_IN_NETAPP_NET_DATA_STAT
{
    DWORD       dwSize;    
    char        szEthName[DH_MAX_ETH_NAME];                // The network card name
}NET_IN_NETAPP_NET_DATA_STAT;

//Receive relevant statistics, same meaning with the ifconfig 
typedef struct tagNET_NETAPP_RECEIVE_STAT
{
    DWORD        dwSize;
    DWORD        dwPackets;
    DWORD        dwBytes;
    DWORD        dwErrors;
    DWORD        dwDroped;
    DWORD        dwOverruns;
    DWORD        dwFrame;
	DWORD        dwSpeed;           // Downflow speed
}NET_NETAPP_RECEIVE_STAT;

//Transport statistics,same meaning with the ifconfig 
typedef struct tagNET_NETAPP_TRANSMIT_STAT
{
    DWORD        dwSize;
    DWORD        dwPackets;
    DWORD        dwBytes;
    DWORD        dwErrors;
    DWORD        dwDroped;
    DWORD        dwOverruns;
    DWORD        dwCarrier;
    DWORD        dwCollisions;
    DWORD        dwTxQueue;
	DWORD        dwSpeed;           // Upstream flow speed
}NET_NETAPP_TRANSMIT_STAT;

//CLIENT_QueryNetStat Port, output parameter when the Types of queries is NET_APP_DATA_STAT (statistics for protocol stack) 
typedef struct tagNET_OUT_NETAPP_NET_DATA_STAT
{                    
    DWORD                        dwSize;
    NET_NETAPP_RECEIVE_STAT      stuReceiveStat;        // Receive relevant statistics,same meaning with the ifconfig 
    NET_NETAPP_TRANSMIT_STAT     stuTransmitStat;       // Transport statistics,same meaning with the ifconfig 
    int                          nSpeed;                // Network speed, unit is Mbps
}NET_OUT_NETAPP_NET_DATA_STAT;

//CLIENT_QueryNetStatPort, input parameter when the Types of queries is NET_APP_DATA_STAT(access to physical link state)
typedef struct tagNET_IN_NETAPP_LINK_STATUS
{
    DWORD       dwSize;
    char        szEthName[DH_MAX_ETH_NAME];             // Network Card Name 
}NET_IN_NETAPP_LINK_STATUS;

//CLIENT_QueryNetStatPort, output parameter when the Types of queries is NET_APP_DATA_STAT(access to physical link state)
typedef struct tagNET_OUT_NETAPP_LINK_STATUS
{
    DWORD       dwSize;
    BOOL        bWorking;               // Whether working  
    BOOL        bIPConflict;            // Whether IP conflict 
}NET_OUT_NETAPP_LINK_STATUS;

// type of input signal
#define DH_VIDEO_SIGNAL_CVBS	0x0001
#define DH_VIDEO_SIGNAL_SDI		0x0002
#define DH_VIDEO_SIGNAL_VGA		0x0004 
#define DH_VIDEO_SIGNAL_DVI		0x0008
#define DH_VIDEO_SIGNAL_HDMI	0x0010 
#define DH_VIDEO_SIGNAL_YPBPR	0x0020 
#define DH_VIDEO_SIGNAL_SFP		0x0040 
#define DH_VIDEO_SIGNAL_HDCVI       0x0080 
#define DH_VIDEO_SIGNAL_DUAL_LINK   0x0100 

// caps of video inpt
typedef struct tagDH_VIDEO_IN_CAPS 
{
	DWORD					dwSize;
	DWORD					dwSignalType;				// type of signal in
	BOOL					bAutoFocusPeak;				// support auto focus peak or not
	BOOL					bElectricFocus;				// support electric focus or not
	BOOL					bSyncFocus;					// support sync focus
    BOOL                    bSetColor;                  // if support video color setup
    BOOL                    bGain;                      // support gain control or not
    BOOL                    bPhase;                     // support phase control or not
	int						nSubChannel;					// number of sensors
	DH_RECT					stuRect[MAX_SUBCHANNEL_NUM];	// location of each sensor
} DH_VIDEO_IN_CAPS;

// CLIENT_GetVideoInCaps's interface input param
typedef struct tagDH_IN_GET_VIDEO_IN_CAPS 
{
	DWORD			dwSize;
	int				nChannel;							// channel ID of video in
} DH_IN_GET_VIDEO_IN_CAPS;

// CLIENT_GetVideoInCaps's interface output param
typedef struct tagDH_OUT_GET_VIDEO_IN_CAPS 
{
	DWORD			dwSize;
	DH_VIDEO_IN_CAPS stuCaps;							// ability
} DH_OUT_GET_VIDEO_IN_CAPS;

// mode of video out
typedef struct tagDH_VIDEO_OUT_MODE 
{
	DWORD			dwSize;
	int				nWidth;								// horizontal resolution
	int				nHeight;							// vertical resolution
	int				nBPP;								// color depth
	int				nFormat;							// format of signel out, 0-Auto, 1-TV, 2-VGA, 3-DVI
	int				nRefreshRate;						// refersh rate
	int				nPhysicalPort;						// physical port, VGA, TV, DVI independent number
    int             nScanFormat;                       	// Scanning mode, 0 - line by line, 1 - interlaced 
} DH_VIDEO_OUT_MODE;

// CLIENT_EnumVideoOutModes's interface input param
typedef struct tagDH_IN_ENUM_VIDEO_OUT_MODES 
{
	DWORD			dwSize;
	int				nChannel;
} DH_IN_ENUM_VIDEO_OUT_MODES;

// CLIENT_EnumVideoOutModes's interface output param
typedef struct tagDH_OUT_ENUM_VIDEO_OUT_MODES 
{
	DWORD			dwSize;
	DH_VIDEO_OUT_MODE* pstuModes;						// mode array,the space application by the user,apply to sizeof(DH_VIDEO_OUT_MODE)*nMaxModeCount
	int				nMaxModeCount;						// count of mode
	int				nRetModeCount;						// return count
} DH_OUT_ENUM_VIDEO_OUT_MODES;

// minotor wall attribute type
typedef enum tagDH_OUTPUT_ATTRIBUTE_TYPE
{
	DH_OUTPUT_ATTRIBUTE_VIDEO, 
	DH_OUTPUT_ATTRIBUTE_YPBPR, 
	DH_OUTPUT_ATTRIBUTE_VGA, 
	DH_OUTPUT_ATTRIBUTE_DVI, 
	DH_OUTPUT_ATTRIBUTE_MENU, 
} DH_OUTPUT_ATTRIBUTE_TYPE;

// caps of monitor wall adjust (DH_OUTPUT_ATTRIBUTE_CAPS) Video ability
#define	DH_ATTR_VIDEO_BRIGHTNESS	0X00000001
#define	DH_ATTR_VIDEO_CONTRAST		0X00000002
#define	DH_ATTR_VIDEO_SATURATION	0X00000004
#define	DH_ATTR_VIDEO_SHAPENESS		0X00000008
#define	DH_ATTR_VIDEO_DENOISE		0X00000010

// caps of monitor wall adjust (DH_OUTPUT_ATTRIBUTE_CAPS) YPbPr ability
#define	DH_ATTR_YPBPR_BRIGHTNESS	0X00000001
#define	DH_ATTR_YPBPR_CONTRAST		0X00000002
#define	DH_ATTR_YPBPR_SATURATION	0X00000004
#define	DH_ATTR_YPBPR_SHAPENESS		0X00000008
#define	DH_ATTR_YPBPR_DENOISE		0X00000010

// caps of monitor wall adjust (DH_OUTPUT_ATTRIBUTE_CAPS) VGA ability
#define	DH_ATTR_VGA_BRIGHTNESS		0X00000001
#define	DH_ATTR_VGA_CONTRAST		0X00000002
#define	DH_ATTR_VGA_HORPOSITION		0X00000004
#define	DH_ATTR_VGA_VERPOSITION		0X00000008
#define	DH_ATTR_VGA_CLOCK			0X00000010

// caps of monitor wall adjust (DH_OUTPUT_ATTRIBUTE_CAPS) DVI ability
#define	DH_ATTR_DVI_BRIGHTNESS		0X00000001
#define	DH_ATTR_DVI_CONTRAST		0X00000002
#define	DH_ATTR_DVI_HORPOSITION		0X00000004
#define	DH_ATTR_DVI_VERPOSITION		0X00000008
#define	DH_ATTR_DVI_CLOCK			0X00000010

// caps of monitor wall adjust (DH_OUTPUT_ATTRIBUTE_CAPS) Menu ability
#define	DH_ATTR_MENU_MENU			0X00000001
#define	DH_ATTR_MENU_UP				0X00000002
#define	DH_ATTR_MENU_DOWN			0X00000004
#define	DH_ATTR_MENU_LEFT			0X00000008
#define	DH_ATTR_MENU_RIGHT			0X00000010
#define	DH_ATTR_MENU_FACTORYMENU	0X00000020

// caps of monitor wall adjust 
typedef struct tagDH_OUTPUT_ATTRIBUTE_CAPS
{
	DWORD			dwSize;
	BOOL			abVideo;			// Video enable
	DWORD			dwVideo;			// Video ability, by bite, specific to see DH_ATTR_VIDEO_BRIGHTNESS
	BOOL			abYPbPr;			// YPbPr enable
	DWORD			dwYPbPr;			// YPbPr ability, by bite, specific to see DH_ATTR_VGA_BRIGHTNESS
	BOOL			abVGA;				// VGA enable
	DWORD			dwVGA;				// VGA ability, by bite, specific to see DH_ATTR_VGA_BRIGHTNESS
	BOOL			abDVI;				// DVI enable
	DWORD			dwDVI;				// DVI ability, by bite, specific to see DH_ATTR_DVI_BRIGHTNESS
	BOOL			abMenu;				// Menu enable
	DWORD			dwMemu;				// Menu ability, by bite, specific to see DH_ATTR_MENU_MENU
} DH_OUTPUT_ATTRIBUTE_CAPS;

// CLIENT_MonitorWallGetAttributeCaps's interface input param
typedef struct tagDH_IN_MONITORWALL_GET_ARRT_CAPS
{
	DWORD			dwSize;
	int				nMonitorWallID;			// monitor wall ID
	const char*		pszCompositeID;			// composite ID
	int				nOutputID;				// output ID
} DH_IN_MONITORWALL_GET_ARRT_CAPS;

// CLIENT_MonitorWallGetAttributeCaps's interface output param
typedef struct tagDH_OUT_MONITORWALL_GET_ARRT_CAPS
{
	DWORD						dwSize;
	DH_OUTPUT_ATTRIBUTE_CAPS 	stuCaps;		// caps of attribute
} DH_OUT_MONITORWALL_GET_ARRT_CAPS;


// CLIENT_MonitorWallAutoAdjust's interface input param
typedef struct tagDH_IN_MONITORWALL_AUTO_ADJUST
{
	DWORD			dwSize;
	int				nMonitorWallID;			// monitor wall ID
	const char*		pszCompositeID;			// composite ID
	int*			pOutputs;				// array pointer,the space application by the user,apply to sizeof(int)*nOutputCount
	int				nOutputCount;			// count of pOutputs
} DH_IN_MONITORWALL_AUTO_ADJUST;

// CLIENT_MonitorWallAutoAdjust's interface output param
typedef struct tagDH_OUT_MONITORWALL_AUTO_ADJUST
{
	DWORD			dwSize;
} DH_OUT_MONITORWALL_AUTO_ADJUST;

// display unit attribute key/value
typedef struct tagDH_ATTR_PAIR
{
	DWORD	dwKey;					// attribute key
									// dwKey = DH_OUTPUT_ATTRIBUTE_VIDEO , uses DH_ATTR_VIDEO_BRIGHTNESS
									// dwKey = DH_OUTPUT_ATTRIBUTE_YPBPR, usesDH_ATTR_YPBPR_BRIGHTNESS
									// so on
	int		nValue;					// value of attribute, 0-reduce 1-increase, 2-no change
} DH_ATTR_PAIR;

// CLIENT_MonitorWallSetAttribute's interface input param
typedef struct tagDH_IN_MONITORWALL_SET_ATTR
{
	DWORD					dwSize;
	int						nMonitorWallID;					// monitor wall ID
	const char*				pszCompositeID;					// composite ID
	int						nOutputID;						// output ID
	DH_OUTPUT_ATTRIBUTE_TYPE emAttrType;					// attribute, the differ type, the stuAttrs differ also
	DH_ATTR_PAIR			stuAttrs[DH_MAX_ATTR_NUM];		// value of attribute
} DH_IN_MONITORWALL_SET_ATTR;

// CLIENT_MonitorWallSetAttribute's interface output param
typedef struct tagDH_OUT_MONITORWALL_SET_ATTR
{
	DWORD			dwSize;
} DH_OUT_MONITORWALL_SET_ATTR;

// CLIENT_MonitorWallSetBackLight's interface input param
typedef struct tagDH_IN_MONITORWALL_SET_BACK_LIGHT
{
	DWORD					dwSize;
	int						nMonitorWallID;					// monitor wall ID
	const char*				pszCompositeID;					// omposite ID
	int						nOutputID;						// output ID
	int						nMode;							// backlight model, 0-circulation patterns,1-not circulation
} DH_IN_MONITORWALL_SET_BACK_LIGHT;

// CLIENT_MonitorWallSetBackLight's interface output param
typedef struct tagDH_OUT_MONITORWALL_SET_BACK_LIGHT
{
	DWORD			dwSize;
} DH_OUT_MONITORWALL_SET_BACK_LIGHT;

// CLIENT_MonitorWallGetPowerSchedule Interface Input Parameters 
typedef struct tagNET_IN_WM_GET_POWER_SCHEDULE
{
    DWORD               dwSize;
    int                 nMonitorWallID;                     // TV Wall Serial Number 
    const char*         pszCompositeID;                     // Splicing Screen ID 
} NET_IN_MW_GET_POWER_SCHEDULE;

// CLIENT_MonitorWallGetPowerSchedule Interface Output Parameters 
typedef struct tagNET_OUT_MW_GET_POWER_SCHEDULE
{
    DWORD               dwSize;
    DH_TSECT            stuPowerSchedule[DH_TSCHE_DAY_NUM][DH_TSCHE_SEC_NUM];    // starting up schedule, the first dimension means Saturday and Sunday and other holidays 
} NET_OUT_MW_GET_POWER_SCHEDULE;

// CLIENT_MonitorWallSetPowerSchedule Interface Input Parameters
typedef struct tagNET_IN_MW_SET_POWER_SCHEDULE
{
    DWORD               dwSize;
    int                 nMonitorWallID;                     // TV wall serial number 
    const char*         pszCompositeID;                     // Splicing Screen ID, NULL means all the screen 
    DH_TSECT            stuPowerSchedule[DH_TSCHE_DAY_NUM][DH_TSCHE_SEC_NUM];    // starting up schedule, the first dimension means Saturday and Sunday and other holidays
} NET_IN_MW_SET_POWER_SCHEDULE;

// CLIENT_MonitorWallSetPowerSchedule Interface Output Parameters 
typedef struct tagNET_OUT_MW_SET_POWER_SCHEDULE
{
    DWORD               dwSize;
} NET_OUT_MW_SET_POWER_SCHEDULE;

// CLIENT_MonitorWallGetScrnCtrlParam Interface Intput Parameters 
typedef struct tagNET_IN_MW_GET_SCRN_CTRL_PARAM
{
    DWORD               dwSize;
    int                 nMonitorWallID;                     // TV wall Serial Number
    const char*         pszCompositeID;                     // Splicing Screen ID 
} NET_IN_MW_GET_SCRN_CTRL_PARAM;

#define DH_MAX_SCREEN_PORT_NUM        16                    // The biggest screen input port number 
#define DH_MAX_COMPSITE_SCREEN_NUM    256                   // The biggest splicing screen number 

// Screen Input Port Information
typedef struct tagNET_SCREEN_PORT_INFO
{
    DWORD               dwSize;
    char                szType[DH_COMMON_STRING_16];        // Port type, "DVI", "VGA", "HDMI"Etc., Allow the same type of multiple ports 
    char                szAddress[DH_COMMON_STRING_16];     // Port address 
    char                szDeviceID[DH_DEV_ID_LEN_EX];       // The video output device of a binding 
    int                 nOutputChannel;                     // Video output channel number 
} NET_SCREEN_PORT_INFO;


typedef struct tagNET_SCREEN_PORT_GROUP 
{
    DWORD                dwSize;
    int                  nPortNum;                          // Port Number
    NET_SCREEN_PORT_INFO stuPorts[DH_MAX_SCREEN_PORT_NUM];  // Port Information
} NET_SCREEN_PORT_GROUP;

// TV wall screen control parameters 
typedef struct tagNET_WM_SCRN_CTRL_PARAM
{
    DWORD                   dwSize;
    int                     nCommPort;                                  // Serial Number
    DH_COMM_PROP            stuCommProp;                                // Port Attributes
    char                    szProtocol[DH_COMMON_STRING_32];            // Port Protocol 
    int                     nResolutionNum;                             // Resolution Number
    CAPTURE_SIZE            emResolutions[DH_MAX_CAPTURE_SIZE_NUM];     // Video Resolution List 
    int                     nScreenCodeNum;                             // Screen Code Number 
    char                    szScreenCode[DH_MAX_COMPSITE_SCREEN_NUM][DH_COMMON_STRING_16];    // Screen code, using for serial command addressing,this encoding configuration by the user, can be the same 
    int                     nScreenPortsNum;                            // Number of screen input port information
    NET_SCREEN_PORT_GROUP   stuScreenPorts[DH_MAX_COMPSITE_SCREEN_NUM]; // Screen input port information     
} NET_WM_SCRN_CTRL_PARAM;

// CLIENT_MonitorWallGetScrnCtrlParam Interface Input Parameters 
typedef struct tagNET_OUT_MW_GET_SCRN_CTRL_PARAM
{
    DWORD                   dwSize;
    NET_WM_SCRN_CTRL_PARAM  stuScrnCtrlParam;           // Screen Control Parameters
} NET_OUT_MW_GET_SCRN_CTRL_PARAM;

// CLIENT_MonitorWallSetScrnCtrlParam Interface Input Parameters
typedef struct tagNET_IN_MW_SET_SCRN_CTRL_PARAM
{
    DWORD                   dwSize;
    int                     nMonitorWallID;             // TV Wall Serial Number 
    const char*             pszCompositeID;             // Splicing Screen ID 
    NET_WM_SCRN_CTRL_PARAM  stuScrnCtrlParam;           // Screen Control Parameters
} NET_IN_MW_SET_SCRN_CTRL_PARAM;

// CLIENT_MonitorWallSetScrnCtrlParam    Interface Output Parameters 
typedef struct tagNET_OUT_MW_SET_SCRN_CTRL_PARAM
{
    DWORD           dwSize;
} NET_OUT_MW_SET_SCRN_CTRL_PARAM;

// CLIENT_MonitorWallGetBackgroudColor Interface Input Parameters 
typedef struct tagNET_IN_MW_GET_BACKGROUDND_COLOR
{
    DWORD           dwSize;
    int             nMonitorWallID;             // TV Wall Serial Number
} NET_IN_MW_GET_BACKGROUDND_COLOR;

// CLIENT_MonitorWallGetBackgroudColor    Interface Output Parameters 
typedef struct tagNET_OUT_MW_GET_BACKGROUDND_COLOR
{
    DWORD           dwSize;
    DH_COLOR_RGBA   stuScreenColor;             // Screen Background Color 
    DH_COLOR_RGBA   stuWindowColor;             // Window Background Color 
} NET_OUT_MW_GET_BACKGROUDND_COLOR;

// CLIENT_MonitorWallSetBackgroudColor Interface Input Parameters 
typedef struct tagNET_IN_MW_SET_BACKGROUD_COLOR 
{
    DWORD           dwSize;
    int             nMonitorWallID;             // TV Wall Serial Number
    DH_COLOR_RGBA   stuScreenColor;             // Screen Background Color 
    DH_COLOR_RGBA   stuWindowColor;             // Window Background Color 
} NET_IN_MW_SET_BACKGROUD_COLOR;

// CLIENT_MonitorWallSetBackgroudColor Interface Output Parameters
typedef struct tagNET_OUT_MW_SET_BACKGROUD_COLOR 
{
    DWORD           dwSize;
} NET_OUT_MW_SET_BACKGROUD_COLOR;


// signal type
typedef enum tagEM_SIGNAL_TYPE
{
	EM_SIGNAL_TYPE_UNKNOWN,				// unknown
	EM_SIGNAL_TYPE_VIDEO,				// "Video"
	EM_SIGNAL_TYPE_VGA,				    // "VGA"
	EM_SIGNAL_TYPE_YPBPR,				// "YPbPr"
	EM_SIGNAL_TYPE_HDMI,				// "HDMI"
	EM_SIGNAL_TYPE_DVI,					// "DVI"
	EM_SIGNAL_TYPE_SDI,					// "SDI"
	EM_SIGNAL_TYPE_CVBS,				// "CVBS"
}EM_SIGNAL_TYPE;
// CLIENT_MonitorWallSwitchDisplaySignal interface input param
typedef struct tagNET_IN_MW_SWITCH_DISPLAY_SIGNAL
{	
	DWORD				dwSize;							// When this structure is used, dwSize should be assigned to sizeof(NET_IN_MW_SWITCH_DISPLAY_SIGNAL)
    int                 nMonitorWallID;                 // TV wall ID
	char*				pszCompositeID;					// Splicing ID
	int					nOutputID;						// Splicing Block Index ID, -1 means wall
	EM_SIGNAL_TYPE		emSignalType;					// signal type
	int					nIndex;							// index of signal interface
}NET_IN_MW_SWITCH_DISPLAY_SIGNAL;
// CLIENT_MonitorWallSwitchDisplaySignal interface output param
typedef struct tagNET_OUT_MW_SWITCH_DISPLAY_SIGNAL			
{
	DWORD				dwSize;							//When this structure is used, dwSize should be assigned to sizeof(NET_OUT_MW_SWITCH_DISPLAY_SIGNAL)
}NET_OUT_MW_SWITCH_DISPLAY_SIGNAL;
// tv wall operation type
// monitorwall operate type
typedef enum tagNET_MONITORWALL_OPERATE_TYPE
{
    NET_MONITORWALL_OPERATE_ADD,            // add tv wall, corresponding to  NET_IN_MONITORWALL_ADD and NET_OUT_MONITORWALL_ADD
    NET_MONITORWALL_OPERATE_CTRL_TOUR,      // scheme tour control, corresponding to  NET_IN_CTRL_COLLECTIONTOUR and NET_OUT_CTRL_COLLECTIONTOUR
    NET_MONITORWALL_OPERATE_GET_STATUS,     // get matrix current status, corresponding to  NET_IN_MONITORWALL_GET_STATUS NET_OUT_MONITORWALL_GET_STATUS
    NET_MONITORWALL_OPERATE_SET_COLL_SCHD,  // set scheme time schedule, corresponding to  NET_IN_MONITORWALL_SET_COLL_SCHD NET_OUT_MONITORWALL_SET_COLL_SCHD
    NET_MONITORWALL_OPERATE_GET_COLL_SCHD,  // get scheme schedule, corresponding to  NET_IN_MONITORWALL_GET_COLL_SCHD and NET_OUT_MONITORWALL_GET_COLL_SCHD
    NET_MONITORWALL_OPERATE_REMOVE,         // delete tv wall, corresponding to NET_IN_MONITORWALL_REMOVE  and  NET_OUT_MONITORWALL_REMOVE
    NET_MONITORWALL_OPERATE_SET_ENABLE,     // setup enable, corresponding to NET_IN_MONITORWALL_SET_ENABLE  and  NET_OUT_MONITORWALL_SET_ENABLE
    NET_MONITORWALL_OPERATE_GET_ENABLE,     // Get  enable, corresponding to NET_IN_MONITORWALL_GET_ENABLE  and  NET_OUT_MONITORWALL_GET_ENABLE
    NET_MONITORWALL_OPERATE_NAME_EXIST,     // tv wall exists or not, corresponding to NET_IN_MONITORWALL_NAME_EXIST  and  NET_OUT_MONITORWALL_NAME_EXIST	
    NET_MONITORWALL_OPERATE_RENAME,         // modify the monitorwall name, corresponding to NET_IN_MONITORWALL_RENAME and NET_OUT_MONITORWALL_RENAME
    NET_MONITORWALL_OPERATE_UPDATE_SOURCE_URL,  // Update the video source URL which has been set up on the wall, corresponding to NET_IN_MONITORWALL_UPDATE_SOURCE_URL and NET_OUT_MONITORWALL_UPDATE_SOURCE_URL

    NET_MONITORWALL_OPERATE_GET_LOCK_STATUS,// Getting TV Wall Lock-in State, corresponding to NET_IN_MONITORWALL_GET_LOCK_STATUS   NET_OUT_MONITORWALL_GET_LOCK_STATUS 
    NET_MONITORWALL_OPERATE_LOCK,			// Lock the TV wall (the window that opens freely can't move any more to prevent users from misoperation), corresponding to NET_IN_MONITORWALL_LOCK   NET_OUT_MONITORWALL_LOCK 
} NET_MONITORWALL_OPERATE_TYPE;

// add tv wall input parameter
typedef struct tagNET_IN_MONITORWALL_ADD
{
    DWORD dwSize;
    DH_MONITORWALL stuMonitorWall; // tv wall info
} NET_IN_MONITORWALL_ADD;

// add tv wall output parameter
typedef struct tagNET_OUT_MONITORWALL_ADD
{
    DWORD dwSize;
    unsigned int nMonitorWallID; // tv wall ID
} NET_OUT_MONITORWALL_ADD;

// CLIENT_OperateMonitorWallport input parameter=>NET_MONITORWALL_OPERATE_CTRL_TOUR
typedef struct tagNET_IN_CTRL_COLLECTIONTOUR 
{
    DWORD              dwSize;
    int                nChannel;                       // channel no.
    int                nAction;                        // tour action, 0:ebd, 1:start
} NET_IN_CTRL_COLLECTIONTOUR;

// CLIENT_OperateMonitorWallport output parameter=>NET_MONITORWALL_OPERATE_CTRL_TOUR
typedef struct tagNET_OUT_CTRL_COLLECTIONTOUR 
{
    DWORD                   dwSize;
} NET_OUT_CTRL_COLLECTIONTOUR;

// matrix operation status
typedef enum tagNET_MATRIX_STATUS
{
    MATRIX_STATUS_UNKNOWN,              // unknown 
    MATRIX_STATUS_TOUR,                 // scheme tour
    MATRIX_STATUS_NORMAL,               // normal tour
} NET_MATRIX_STATUS;

#define DH_MAX_COLLECTION_NUM   64      // max scheme
// matrix status info
typedef struct tagNET_MONITORWALL_STATUS_INFO
{
    DWORD       dwSize;
    int         nInterval;                      // tour interval
    int         nCollectionNum;                 // scheme tour
    char        szCollections[DH_MAX_COLLECTION_NUM][DH_DEVICE_NAME_LEN];         // scheme tour content
    char        szName[DH_DEVICE_NAME_LEN];     // current display scheme name
} NET_MONITORWALL_STATUS_INFO;

// // CLIENT_OperateMonitorWallport input parameter=>NET_MONITORWALL_OPERATE_GET_STATUS
typedef struct tagNET_IN_MONITORWALL_GET_STATUS 
{
    DWORD              dwSize;
    int                nChannel;                        //channel no.
} NET_IN_MONITORWALL_GET_STATUS;

// CLIENT_OperateMonitorWallport output parameter=>NET_MONITORWALL_OPERATE_GET_STATUS
typedef struct tagNET_OUT_MONITORWALL_GET_STATUS
{
    DWORD                           dwSize;
    NET_MATRIX_STATUS               emMatrixStatus;     // operation status
    NET_MONITORWALL_STATUS_INFO     stuStatusInfo;      // status info
} NET_OUT_MONITORWALL_GET_STATUS;

// tv wall scheme schedule
typedef struct tagMONITORWALL_COLLECTION_SCHEDULE
{
    DWORD               dwSize;
    char                szName[DH_DEVICE_NAME_LEN];     // schedule name
    DH_TSECT            stuSchedule[DH_TSCHE_DAY_NUM][DH_TSCHE_SEC_NUM];   // schedule, first each element means sunday~Saturday and holiday
} MONITORWALL_COLLECTION_SCHEDULE;

// CLIENT_OperateMonitorWallport input parameter=>NET_MONITORWALL_OPERATE_SET_COLL_SCHD
typedef struct tagNET_IN_MONITORWALL_SET_COLL_SCHD 
{
    DWORD               dwSize;
    int                 nCollectionNum;                 // scheme number
    MONITORWALL_COLLECTION_SCHEDULE stuCollShedule[DH_MAX_COLLECTION_NUM];  // scheme schedule
    int                 nMonitorWallID;                 // tv wall ID
} NET_IN_MONITORWALL_SET_COLL_SCHD;

// CLIENT_OperateMonitorWallport output parameter=>NET_MONITORWALL_OPERATE_SET_COLL_SCHD
typedef struct tagNET_OUT_MONITORWALL_SET_COLL_SCHD 
{
    DWORD               dwSize;
} NET_OUT_MONITORWALL_SET_COLL_SCHD;

// CLIENT_OperateMonitorWallport input parameter=>NET_MONITORWALL_OPERATE_GET_COLL_SCHD
typedef struct tagNET_IN_MONITORWALL_GET_COLL_SCHD 
{
    DWORD               dwSize;
    BOOL                bAllCollections;                // TRUE-search all scheme, no need to appoint scheme name. FALSE-search name corresponding scheme
    int                 nCollectionNum;                 // scheme, bAllCollections is FALSE valid
    char                szCollections[DH_MAX_COLLECTION_NUM][DH_DEVICE_NAME_LEN];   // scheme name
    int                 nMonitorWallID;                 // tv wall ID
} NET_IN_MONITORWALL_GET_COLL_SCHD;

// CLIENT_OperateMonitorWallport input parameter=>NET_MONITORWALL_OPERATE_GET_COLL_SCHD
typedef struct tagNET_OUT_MONITORWALL_GET_COLL_SCHD 
{
    DWORD               dwSize;
    int                 nCollectionNum;                 // scheme number
    MONITORWALL_COLLECTION_SCHEDULE stuCollShedule[DH_MAX_COLLECTION_NUM];  // scheme schedule
} NET_OUT_MONITORWALL_GET_COLL_SCHD;

// CLIENT_OperateMonitorWallport input parameter =>NET_MONITORWALL_OPERATE_REMOVE
typedef struct tagNET_IN_MONITORWALL_REMOVE 
{
    DWORD       dwSize;
    int         nMonitorWallNum;        // tv wall quantity to delete
    char        szNames[DH_MAX_MONITORWALL_NUM][DH_COMMON_STRING_128]; // tv wall  name 
} NET_IN_MONITORWALL_REMOVE;

// CLIENT_OperateMonitorWallport  output parameter =>NET_MONITORWALL_OPERATE_REMOVE
typedef struct tagNET_OUT_MONITORWALL_REMOVE 
{
    DWORD       dwSize;
} NET_OUT_MONITORWALL_REMOVE;

// tv wall enable info 
typedef struct tagNET_MONITORWALL_ENABLE_INFO
{
    DWORD       dwSize;
    BOOL        bEanble;            // enable 
    char        szName[DH_COMMON_STRING_128];  // tv wall  name 
} NET_MONITORWALL_ENABLE_INFO;

// CLIENT_OperateMonitorWallport input parameter =>NET_MONITORWALL_OPERATE_SET_ENABLE
typedef struct tagNET_IN_MONITORWALL_SET_ENABLE
{
    DWORD       dwSize;
    int         nMonitorWallNum;        // tv wall quantity to set
    NET_MONITORWALL_ENABLE_INFO stuEnable[DH_MAX_MONITORWALL_NUM]; // tv wall enable 
} NET_IN_MONITORWALL_SET_ENABLE;

// CLIENT_OperateMonitorWallport  output parameter =>NET_MONITORWALL_OPERATE_SET_ENABLE
typedef struct tagNET_OUT_MONITORWALL_SET_ENABLE
{
    DWORD        dwSize;
} NET_OUT_MONITORWALL_SET_ENABLE;

// CLIENT_OperateMonitorWallport input parameter =>NET_MONITORWALL_OPERATE_GET_ENABLE
typedef struct tagNET_IN_MONITORWALL_GET_ENABLE
{
    DWORD       dwSize;
    int         nMonitorWallNum;        //tv wall quantity to search, -1 means search alltv wall 
    char        szNames[DH_MAX_MONITORWALL_NUM][DH_COMMON_STRING_128]; // tv wall  name , nMonitorWallNum>0 is valid 
} NET_IN_MONITORWALL_GET_ENABLE;

// CLIENT_OperateMonitorWallport  output parameter =>NET_MONITORWALL_OPERATE_SET_ENABLE
typedef struct tagNET_OUT_MONITORWALL_GET_ENABLE
{
    DWORD       dwSize;
    int         nMonitorWallNum;        // tv wall quantity
    NET_MONITORWALL_ENABLE_INFO stuEnable[DH_MAX_MONITORWALL_NUM]; // tv wall enable 
} NET_OUT_MONITORWALL_GET_ENABLE;

// CLIENT_OperateMonitorWallport input parameter =>NET_MONITORWALL_OPERATE_NAME_EXIST
typedef struct tagNET_IN_MONITORWALL_NAME_EXIST 
{
    DWORD           dwSize;
    const char*     pszName;            // tv wall  name 
} NET_IN_MONITORWALL_NAME_EXIST;

// CLIENT_OperateMonitorWallport  output parameter =>NET_MONITORWALL_OPERATE_NAME_EXIST
typedef struct tagNET_OUT_MONITORWALL_NAME_EXIST 
{
    DWORD       dwSize;
    BOOL        bExist;            // tv wall exists or not
} NET_OUT_MONITORWALL_NAME_EXIST;

// CLIENT_OperateMonitorWall input parameter=>NET_MONITORWALL_OPERATE_RENAME(modify monitor wall name)
typedef struct tagNET_IN_MONITORWALL_RENAME
{
	DWORD               dwSize;
	unsigned int		unMonitorWallID;							// monitor wall ID
	char				szNewName[MAX_MONITORWALL_NAME_LEN];		// new name of monitor wall
} NET_IN_MONITORWALL_RENAME;

// CLIENT_OperateMonitorWall output parameter=>NET_MONITORWALL_OPERATE_RENAME(modify monitor wall name)
typedef struct tagNET_OUT_MONITORWALL_RENAME
{
	DWORD               dwSize;
} NET_OUT_MONITORWALL_RENAME;


// CLIENT_OperateMonitorWall input parameter=>NET_MONITORWALL_OPERATE_GET_LOCK_STATUS(Getting TV Wall Lock-in State)
typedef struct tagNET_IN_MONITORWALL_GET_LOCK_STATUS
{
    DWORD               dwSize;
    int        		    nChannel;	// Channel
} NET_IN_MONITORWALL_GET_LOCK_STATUS;



// CLIENT_OperateMonitorWall output parameter=>NET_MONITORWALL_OPERATE_GET_LOCK_STATUS(Getting TV Wall Lock-in State)
typedef struct tagNET_OUT_MONITORWALL_GET_LOCK_STATUS
{
    DWORD               dwSize;
    BOOL                bLock;      // Lock or not, true: lock; false: unlock
} NET_OUT_MONITORWALL_GET_LOCK_STATUS;


// CLIENT_OperateMonitorWall input parameter=>NET_MONITORWALL_OPERATE_LOCK(Lock the TV Wall)
typedef struct tagNET_IN_MONITORWALL_LOCK
{
    DWORD               dwSize;
    int        		    nChannel;		// Channel
    BOOL                bLock;      	// Lock or not, true: lock; false: unlock
	BYTE				byReserved[4];	// Reserved
} NET_IN_MONITORWALL_LOCK;

// CLIENT_OperateMonitorWall output parameter=>NET_MONITORWALL_OPERATE_LOCK(Lock the TV Wall)
typedef struct tagNET_OUT_MONITORWALL_LOCK
{
    DWORD               dwSize;
} NET_OUT_MONITORWALL_LOCK;

// Info of URLs that need to be updated
typedef struct tagNET_UPDATE_URL_INFO
{
    char        szOldURL[512];              // Video source URL which has been set up on the wall
    char        szNewURL[512];              // Video source URL that need to be updated
    BYTE        bReserved[1024];            // Reserved
} NET_UPDATE_URL_INFO;

// CLIENT_OperateMonitorWall input paramter=>NET_MONITORWALL_OPERATE_UPDATE_SOURCE_URL(Update the video source URL which has been set up on the wall)
typedef struct tagNET_IN_MONITORWALL_UPDATE_SOURCE_URL
{
    DWORD               dwSize;             // Struct size
    UINT                nUpdateURLNum;      // Count of URLs that need to be updated, the max value is 256
    NET_UPDATE_URL_INFO *pstuUpdateURL;     // Info of URLs that need to be updated. Resources are requested and released by usersand the source size is nUpdateURLNum*sizeof(NET_UPDATE_URL_INFO)
} NET_IN_MONITORWALL_UPDATE_SOURCE_URL;

// CLIENT_OperateMonitorWall output paramter=>NET_MONITORWALL_OPERATE_UPDATE_SOURCE_URL(Update the video source URL which has been set up on the wall)
typedef struct tagNET_OUT_MONITORWALL_UPDATE_SOURCE_URL
{
    DWORD               dwSize;             // Struct size
} NET_OUT_MONITORWALL_UPDATE_SOURCE_URL;

/************************************************************************/
/*  U disk caught
/************************************************************************/

// CLIENT_StartSniffer's interface input param
typedef struct tagDH_IN_START_SNIFFER 
{
	DWORD		dwSize;
	const char*	pszNetInterface;				// name of network card
	const char*	pszPath;						// path of caught file, it is means the default path when pszPath = NULL
	int			nSaveType;						// type of file, 0-Wireshark/Tcpdump
    const char* pszFilter;                  	// Filter Conditions ,Such as "host 172.9.88.200 and port 8080 and tcp"
} DH_IN_START_SNIFFER;

// CLIENT_StartSniffer's interface output param
typedef struct tagDH_OUT_START_SNIFFER 
{
	DWORD		dwSize;
} DH_OUT_START_SNIFFER;

// grasp the package information
typedef struct tagDH_SNIFFER_INFO
{
	DWORD		dwSize;
	DWORD		nSnifferID;					// Sniffer ID
} DH_SNIFFER_INFO;

// CLIENT_GetSnifferInfo's interface input param
typedef struct tagDH_IN_GET_SNIFFER_INFO
{
	DWORD		dwSize;
	const char*	pszNetInterface;
} DH_IN_GET_SNIFFER_INFO;

// CLIENT_GetSnifferInfo's interface output param
typedef struct tagDH_OUT_GET_SNIFFER_INFO
{
	DWORD		dwSize;
	DH_SNIFFER_INFO	* pstuSniffers;			// array of Sniffer
	int			nMaxSnifferCount;			// size of array
	int			nRetSnifferCount;			// return count
} DH_OUT_GET_SNIFFER_INFO;

/************************************************************************/
/*  manage file
/************************************************************************/

// format the partition information 
typedef struct tagDH_FORMAT_PATITION 
{
	DWORD			dwSize;
	const char*		pszStorageName;							// storage name
	const char*		pszPatitionName;						// partition name
    const char*     pszFileSystem;                          // file system
} DH_FORMAT_PATITION;

// CLIENT_CreateRemoteFile's interface input param
typedef struct tagDH_IN_CREATE_REMOTE_FILE
{
	DWORD			dwSize;
	const char*		pszPath;								// path of file
	BOOL			bDirectory;								// is directory or not
} DH_IN_CREATE_REMOTE_FILE;

// CLIENT_CreateRemoteFile's interface output param
typedef struct tagDH_OUT_CREATE_REMOTE_FILE 
{
	DWORD			dwSize;
} DH_OUT_CREATE_REMOTE_FILE;

// CLIENT_RemoveRemoteFiles's interface input param
typedef struct tagDH_IN_REMOVE_REMOTE_FILES
{
	DWORD			dwSize;
	const char**	pszPath;								// pointer of file path
	int				nFileCount;								// count of file
} DH_IN_REMOVE_REMOTE_FILES;

// CLIENT_RemoveRemoteFiles's interface output param
typedef struct tagDH_OUT_REMOVE_REMOTE_FILES 
{
	DWORD		dwSize;
} DH_OUT_REMOVE_REMOTE_FILES;

// CLIENT_RenameRemoteFile's interface input param
typedef struct tagDH_IN_RENAME_REMOTE_FILE
{
	DWORD			dwSize;
	const char*		pszOldPath;								// old path
	const char*		pszNewPath;								// new path
} DH_IN_RENAME_REMOTE_FILE;

// CLIENT_RenameRemoteFile's interface output param
typedef struct tagDH_OUT_RENAME_REMOTE_FILE 
{
	DWORD			dwSize;
} DH_OUT_RENAME_REMOTE_FILE;

// file/catalog info
typedef struct tagDH_REMOTE_FILE_INFO 
{
	DWORD			dwSize;
	BOOL			bDirectory;								// is directory or not
	char			szPath[MAX_PATH];						// path
	NET_TIME		stuCreateTime;							// create time
	NET_TIME		stuModifyTime;							// modify time
	INT64			nFileSize;								// size of file
	char			szFileType[DH_FILE_TYPE_LEN];			// type of file
} DH_REMOTE_FILE_INFO;

// remote file query condition
typedef enum tagDH_REMOTE_FILE_COND
{
    DH_REMOTE_FILE_COND_NONE,                           // no condition
    DH_REMOTE_FILE_COND_VOICE,                          // voice file, CANNOT specify search path, ONLY file name obtained
} DH_REMOTE_FILE_COND;

// CLIENT_ListRemoteFile's interface input param
typedef struct tagDH_IN_LIST_REMOTE_FILE
{
	DWORD			dwSize;
	const char*		pszPath;								// path
	BOOL			bFileNameOnly;							// only for file name
    DH_REMOTE_FILE_COND emCondition;                        // query condition
} DH_IN_LIST_REMOTE_FILE;

// CLIENT_ListRemoteFile's interface output param
typedef struct tagDH_OUT_LIST_REMOTE_FILE 
{
	DWORD					dwSize;
	DH_REMOTE_FILE_INFO*	pstuFiles;						// array of file,the space application by the user,apply to sizeof(DH_REMOTE_FILE_INFO)*nMaxFileCount
	int						nMaxFileCount;					// size of array
	int						nRetFileCount;					// return count
} DH_OUT_LIST_REMOTE_FILE;

// set file property - property name
typedef enum tagNET_SET_FILEATTR_ACTION
{
    EM_SET_FILEATTR_ACTION_UNKNOWN = 0,                 // unknown
    EM_SET_FILEATTR_ACTION_MARK,                        // file lock
} NET_SET_FILEATTR_ACTION;

// CLIENT_SetFileAttribute port input paramete
typedef struct tagDH_IN_SET_FILEATTRIBUTE
{
    DWORD                   dwSize;
    unsigned int            nDriveNo;                       // disk no.
    unsigned int            nPartition;                     // partition no.
    unsigned int            nCluster;                       // cluster no.
    NET_SET_FILEATTR_ACTION emAction;                       // each property corresponding to one key, set value depends on value
                                                            // set key:Mark file lock ,corresponding to value, delay lock time(unit:day)
    char                    szValue[DH_COMMON_STRING_64];   // property valu
} DH_IN_SET_FILEATTRIBUTE;

// CLIENT_SetFileAttribute port output parameter
typedef struct tagDH_OUT_SET_FILEATTRIBUTE
{
    DWORD                   dwSize;
} DH_OUT_SET_FILEATTRIBUTE;

// manual pop-up storage device
typedef struct tagDH_EJECT_STORAGE_DEVICE
{
	DWORD				dwSize;	
	const char*			pszStorageName;						// storage name
} DH_EJECT_STORAGE_DEVICE;

//  manual load storage device
typedef struct tagDH_LOAD_STORAGE_DEVICE 
{
	DWORD				dwSize;
	const char*			pszStorageName;						// storage name
} DH_LOAD_STORAGE_DEVICE;

// CLIENT_UploadRemoteFile's interface input param(upload file to the device)
typedef struct tagDH_IN_UPLOAD_REMOTE_FILE
{
    DWORD               dwSize;
    const char*         pszFileSrc;			// path of source file
    const char*         pszFileDst;			// path of goal file
    const char*         pszFolderDst;       // target file path: may be NULL, NULL device use default path
    unsigned int        nPacketLen;         // file pack size(byte): 0 means not pack
} DH_IN_UPLOAD_REMOTE_FILE;

// CLIENT_UploadRemoteFile's interface output param(upload file to the device)
typedef struct tagDH_OUT_UPLOAD_REMOTE_FILE
{
	DWORD					dwSize;
} DH_OUT_UPLOAD_REMOTE_FILE;

// CLIENT_DownloadRemoteFile    Interface Input Parameters (the file download)
typedef struct tagDH_IN_DOWNLOAD_REMOTE_FILE
{
    DWORD               dwSize;
    const char*         pszFileName;                    // File Name Needs to Download 
    const char*         pszFileDst;                     // File Path 
} DH_IN_DOWNLOAD_REMOTE_FILE;

// CLIENT_DownloadRemoteFile Interface Output Parameters (the file download) 
typedef struct tagDH_OUT_DOWNLOAD_REMOTE_FILE
{
    DWORD               dwSize;
	DWORD				dwMaxFileBufLen;				// The size of pstFileBuf, it is specified by user
	char				*pstFileBuf;					// File buf, application an release by user
	DWORD				dwRetFileBufLen;				// The actual size of the file
	BYTE              	byReserved[4];            		// Alignment
} DH_OUT_DOWNLOAD_REMOTE_FILE;

typedef struct tagNET_IN_DOWNLOAD_PIECE_FILE
{
	DWORD				dwSize;
	char				szFileName[MAX_PATH];		   // File name,support full path
	UINT				nOffSet;					   // Offset,unit:BYTE
	UINT				nNeedLength;				   // need length,unit:BYTE, suggest value is 32KB, not over 4MB
} NET_IN_DOWNLOAD_PIECE_FILE;
typedef struct tagNET_OUT_DOWNLOAD_PIECE_FILE
{
	DWORD				dwSize;
	UINT				nFileLength;	 // file length
	UINT				nPacketLength;   // binary data length this time, unit:BYTE,suggest value is 32KB, not over 4MB
	char*               szBuffer;        // file buffer,the space application by the user,size is nBufferLen                            
	UINT				nBufferLen;      // buffer len,unit:BYTE,the same to nNeedLength of NET_IN_DOWNLOAD_PIECE_FILE
} NET_OUT_DOWNLOAD_PIECE_FILE;
/************************************************************************/
/* cascade device
/************************************************************************/
// conditon of cascade device search
typedef struct tagDH_IN_SEARCH_CONDITON
{
	DWORD					dwSize;
	const char*				pMachineName;					// device name or no.
	const char*				pMachineAddr;					// machine address (XX.XX.XX)
	const char*				pSerialNo;						// serial no.
	const char*				pChannelName;					// channel name of video in
} DH_MATRIX_SEARCH_CONDITON;

// CLIENT_MatrixSearch's interface input param(search cascade device)
typedef struct tagDH_IN_MATIRX_SEARCH
{
	DWORD					dwSize;
	const char*				pSerialNo;						// servial no.,"Local""Root",other devices with a serial number
	DH_MATRIX_SEARCH_CONDITON stuCondition;					// condition of search, can be for a single or combination
} DH_IN_MATRIX_SEARCH;

// CLIENT_MatrixSearch's interface output param(search cascade device)
typedef struct tagDH_OUT_MATRIX_SEARCH
{
	DWORD					dwSize;
	DH_REMOTE_DEVICE*		pstuRemoteDevices;				// devices list,the space application by the user,apply to sizeof(DH_REMOTE_DEVICE)*nMaxDeviceCount
	int						nMaxDeviceCount;				// max count of device
	int						nRetDeviceCount;				// return count
} DH_OUT_MATRIX_SEARCH;

// CLIENT_GetMatrixTree's interface input param
typedef struct tagDH_IN_GET_MATRIX_TREE
{
	DWORD					dwSize;
	const char*				pSerialNo;						// servial no.,"Local""Root",other devices with a serial number
	int						nLevel;							// get device information,0-all, 1-Local, 2-Local+device under
															// 3-Local+device under+ the next next devuce
} DH_IN_GET_MATRIX_TREE;

// cascade device info
typedef struct tagDH_CASCADE_DEVICE_INFO
{
	DWORD					dwSize;
	int						nLevel;							// level
	char					szPath[MAX_PATH];				// set path,format:name1.name2.name3...
	DH_REMOTE_DEVICE		stuDeviceInfo;					// device info
} DH_CASCADE_DEVICE_INFO;

// CLIENT_GetMatrixTree's interface output param
typedef struct tagDH_OUT_GET_MATRIX_TREE
{
	DWORD					dwSize;
	DH_CASCADE_DEVICE_INFO*	pstuRemoteDevices;				// info of cascade device
	int						nMaxDeviceCount;				// max number of cascade device
	int						nRetDeviceCount;				// return count
} DH_OUT_GET_MATRIX_TREE;

// CLIENT_GetSuperiorMatrixList's interface input param
typedef struct tagDH_IN_GET_SUPERIOR_MATRIX_LIST
{
	DWORD					dwSize;
} DH_IN_GET_SUPERIOR_MATRIX_LIST;

// CLIENT_GetSuperiorMatrixList's interface output param
typedef struct tagDH_OUT_GET_SUPERIOR_MATRIX_LIST
{
	DWORD					dwSize;
	DH_REMOTE_DEVICE*		pstuRemoteDevices;				// device list
	int						nMaxDeviceCount;				// max count of device
	int						nRetDeviceCount;				// return count
} DH_OUT_GET_SUPERIOR_MATRIX_LIST;

////////////////////////////////////record backup to restore//////////////////////////////////////

// task of record backup to restore
typedef struct tagDH_RECORD_BACKUP_RESTORE_TASK
{
    DWORD				dwSize;
    unsigned int		nTaskID;                        // task ID
    char				szDeviceID[DH_DEV_ID_LEN_EX];   // device ID
    int			        nChannelID;                     // channek ID
    NET_TIME			stuStartTime;                   // start time
    NET_TIME			stuEndTime;                     // end time
    int			        nState;                         // state of backup, 0-wait, 1-working, 2-finish, 3-failed
} DH_REC_BAK_RST_TASK;

// CLIENT_AddRecordBackupRestoreTask's interface input param
typedef struct tagDH_IN_ADD_RECORD_BACKUP_RESTORE_TASK
{
    DWORD				dwSize;
    const char*			pszDeviceID;					// device ID
    int*		        pnChannels;						// array of channel,the space application by the user,apply to sizeof(int)*nChannelCount
	int					nChannelCount;					// size of array
    NET_TIME			stuStartTime;					// start time
    NET_TIME			stuEndTime;						// end time
} DH_IN_ADD_REC_BAK_RST_TASK;

// CLIENT_RemoveRecordBackupRestoreTask's interface input param
typedef struct tagDH_IN_REMOVE_RECORD_BACKUP_RESTORE_TASK
{
    DWORD				dwSize;
    unsigned int*		pnTaskIDs;						// array of task ID,the space application by the user,apply to sizeof(int)*nTaskCount
	int					nTaskCount;						// count of task
} DH_IN_REMOVE_REC_BAK_RST_TASK;

// CLIENT_QueryRecordBackupRestoreTask's interface input param
typedef struct tagDH_IN_QUERY_RECORD_BACKUP_RESTORE_TASK
{
    DWORD		        dwSize;
} DH_IN_QUERY_REC_BAK_RST_TASK;

// CLIENT_QueryRecordBackupRestoreTask's interface output param
typedef struct tagDH_OUT_QUERY_RECORD_BACKUP_RESTORE_TASK
{
    DWORD				 dwSize;
    DH_REC_BAK_RST_TASK* pTasks;						// array of task,the space application by the user,apply to sizeof(DH_REC_BAK_RST_TASK)*nMaxCount
    int					 nMaxCount;						// size of array
    int					 nReturnCount;					// return count
} DH_OUT_QUERY_REC_BAK_RST_TASK;

typedef struct tagDH_LOGIC_DEVICE_ADD_CAMERA_PARAM
{
	DWORD			dwSize;
	const char*		pszDeviceID;			// device ID
	int				nChannel;				// channel
} DH_LOGIC_DEVICE_ADD_CAMERA_PARAM;

typedef struct tagDH_LOGIC_DEVICE_ADD_CAMERA_RESULT
{
	DWORD			dwSize;
	char			szDeviceID[DH_DEV_ID_LEN];	// device ID
	int				nChannel;					// channel ID
	int				nUniqueChannel;				// uniform number
	int				nFailedCode;				// failure code, 0-succeed 1-Unique 2-have added
} DH_LOGIC_DEVICE_ADD_CAMERA_RESULT;

// CLIENT_AddLogicDeviceCamera's interface input param
typedef struct tagDH_IN_ADD_LOGIC_DEVICE_CAMERA
{
	DWORD			dwSize;
	DH_LOGIC_DEVICE_ADD_CAMERA_PARAM*	pCameras;	// array of source video ,the space application by the user,apply to sizeof(DH_LOGIC_DEVICE_ADD_CAMERA_PARAM)*nCameraCount
	int				nCameraCount;					// count of sourcevideo
} DH_IN_ADD_LOGIC_DEVICE_CAMERA;

// CLIENT_AddLogicDeviceCamera's interface output param
typedef struct tagDH_OUT_ADD_LOGIC_DEVICE_CAMERA 
{
	DWORD			dwSize;
	DH_LOGIC_DEVICE_ADD_CAMERA_RESULT* pResults;	// result,the space application by the user,apply to sizeof(DH_LOGIC_DEVICE_ADD_CAMERA_RESULT)*nMaxResultCount
	int				nMaxResultCount;				// size of array
	int				nRetResultCount;				// return count
} DH_OUT_ADD_LOGIC_DEVICE_CAMERA;

//array info
typedef struct tagDH_LOGIC_BYDEVICE_ADD_CAMERA_PARAM
{
    DWORD                   dwSize;
    int                     nUniqueChannel;             // UniqueChannel
    int                     nChannel;                   // channel         
} DH_LOGIC_BYDEVICE_ADD_CAMERA_PARAM;

//result info
typedef struct tagDH_LOGIC_BYDEVICE_ADD_CAMERA_RESULT
{
    DWORD                   dwSize;
    int                     nUniqueChannel;             // UniqueChannel
    int                     nFailedCode;                // FaileCode, 0-Success,1-unsupport           
} DH_LOGIC_BYDEVICE_ADD_CAMERA_RESULT;

// CLIENT_MatrixAddCamerasByDevice's interface input param
typedef struct tagDH_IN_ADD_LOGIC_BYDEVICE_CAMERA
{
    DWORD                   dwSize;
    char                    pszDeviceID[DH_DEV_ID_LEN]; // DeviceID
    DH_REMOTE_DEVICE        stuRemoteDevice;            // RemoteDevice Info
    int                     nCameraCount;               // source video number
    DH_LOGIC_BYDEVICE_ADD_CAMERA_PARAM* pCameras;       // array of source video,the space application by the user,apply to sizeof(DH_LOGIC_BYDEVICE_ADD_CAMERA_PARAM)*nCameraCount
}DH_IN_ADD_LOGIC_BYDEVICE_CAMERA;

// CLIENT_MatrixAddCamerasByDevice's interface output param
typedef struct tagDH_OUT_ADD_LOGIC_BYDEVICE_CAMERA
{
    DWORD                   dwSize;                         
    char                    szDeviceID[DH_DEV_ID_LEN];    // DeviceID
    int                     nMaxResultCount;              // ResultCount
    int                     nRetResultCount;              // return count
    DH_LOGIC_BYDEVICE_ADD_CAMERA_RESULT* pResults;        // result,the space application by the user,apply to sizeof(DH_LOGIC_BYDEVICE_ADD_CAMERA_RESULT)*nMaxResultCount
}DH_OUT_ADD_LOGIC_BYDEVICE_CAMERA;

// the cameras info
typedef struct tagNET_CAMERA_INFO
{	
    int                     nUniqueChannel;             // unigue channel, -1 means that the channelID is automatically assigned by the device
    unsigned int            nChannel;                   // channel ID  
    BYTE                	reserved[128];				// reserved
} NET_CAMERA_INFO;

// the camera groups info
typedef struct tagNET_CAMERA_GROUP_INFO
{
	char                    szDeviceID[DH_DEV_ID_LEN];	// device ID
    int                     nCameraCount;				// the count of cameras
    NET_CAMERA_INFO			*pCameras;       			// array of cameras, the space application by the user,apply to sizeof(NET_CAMERA_INFO)*nCameraCount
	DH_REMOTE_DEVICE        stuRemoteDevice;			// the info of remote device, effective when szDeviceID is invalid
	BYTE                	reserved[1024];				// reserved
} NET_CAMERA_GROUP_INFO;

// input param of CLIENT_MatrixAddCamerasByGroup (batch add cameras) 
typedef struct tagNET_IN_ADD_LOGIC_BYGROUP_CAMERA
{
	DWORD                   dwSize;
	int						nCameraGroup;				// the count of camera groups
	NET_CAMERA_GROUP_INFO	*pstCameraGroupInfo; 		//array of camera groups, the space application by the user,apply to sizeof(NET_CAMERA_GROUP_INFO)*nCameraGroup
} NET_IN_ADD_LOGIC_BYGROUP_CAMERA;

// the result inforamtion of cameras returned by adding camera groups
typedef struct tagNET_ADD_BYGROUP_RESULT_CAMERA
{
    unsigned int           	nUniqueChannel;             // unique channel
    unsigned int            nFailedCode;                // FaileCode, 0-Success,1-unsupport 
    BYTE					reserved[128];				// reserved
} NET_ADD_BYGROUP_RESULT_CAMERA;

//  the result inforamtion of camera groups returned by adding camera groups
typedef struct tagNET_ADD_BYGROUP_RESULT
{
	char                    			szDeviceID[DH_DEV_ID_LEN];    	// device ID
	int									nResultCam;						// the count of cameras, consistent with the nCameraCount in NET_CAMERA_GROUP_INFO
	NET_ADD_BYGROUP_RESULT_CAMERA		*pstResultCamera;				// array of cameras by adding camera groups,
																		// the space application by the user,apply to sizoef(NET_ADD_BYGROUP_RESULT_CAMERA)*nRetResultCamera
	BYTE								reserved[1024];					// reserved
} NET_ADD_BYGROUP_RESULT;

// output paramer of CLIENT_MatrixAddCamerasByGroup (batch add cameras) 
typedef struct tagNET_OUT_ADD_LOGIC_BYGROUP_CAMERA
{
	DWORD                   			dwSize;
	int									nGroupCount;			// the count of groups, consistent with the nCameraGroup in NET_IN_ADD_LOGIC_BYGROUP_CAMERA
	NET_ADD_BYGROUP_RESULT				*pstAddByGroupResult;	// array of camera groups  by adding camera groups,
																// the space application by the user,apply to sizoef(NET_ADD_BYGROUP_RESULT)*nMaxResultGroup
} NET_OUT_ADD_LOGIC_BYGROUP_CAMERA;

/************************************************************************/
/*                         Database Records                               */
/************************************************************************/

#define MAX_ORDER_NUMBER 6										// The maximum number of order rules

// Order type
typedef enum tagEM_RECORD_ORDER_TYPE
{
	EM_RECORD_ORDER_TYPE_UNKNOWN,                               // unknown
	EM_RECORD_ORDER_TYPE_ASCENT,                                // ascent
	EM_RECORD_ORDER_TYPE_DESCENT                                // descent
}EM_RECORD_ORDER_TYPE;

typedef struct tagNET_AUTHORITY_TYPE
{
  DWORD                       dwSize; 
  EM_NET_AUTHORITY_TYPE       emAuthorityType;                          //Permission Types 
  BOOL                        bAuthorityEnable;                         //Permission Enabled
}NET_AUTHORITY_TYPE;

// Information of recorded in transportation black and white list 
typedef struct tagNET_TRAFFIC_LIST_RECORD
{
  DWORD                      dwSize; 
  int                        nRecordNo;                                 // Queried Record Number 
  char                       szMasterOfCar[DH_MAX_NAME_LEN];            // Car Owner's Name
  char                       szPlateNumber[DH_MAX_PLATE_NUMBER_LEN];    // License Plate Number 
  EM_NET_PLATE_TYPE          emPlateType;                               // License Plate Type 
  EM_NET_PLATE_COLOR_TYPE    emPlateColor;                              // License Plate Color   
  EM_NET_VEHICLE_TYPE        emVehicleType;                             // Vehicle Type  
  EM_NET_VEHICLE_COLOR_TYPE  emVehicleColor;                            // Car Body Color
  NET_TIME                   stBeginTime;                               // Start Time 
  NET_TIME                   stCancelTime;                              // Undo Time
  int                        nAuthrityNum;                              // Permission Number
  NET_AUTHORITY_TYPE         stAuthrityTypes[DH_MAX_AUTHORITY_LIST_NUM];// Permissions List, White List Only 
  EM_NET_TRAFFIC_CAR_CONTROL_TYPE emControlType;                        // Monitor Type, Black List Only 
}NET_TRAFFIC_LIST_RECORD;

// Query Conditions Of Traffic Black And White List Account Records 
typedef struct
{
    DWORD                    dwSize;
    char                     szPlateNumber[DH_MAX_PLATE_NUMBER_LEN];      // License Plate Number
    char                     szPlateNumberVague[DH_MAX_PLATE_NUMBER_LEN]; // License Plate Number Fuzzy Query 
    int                      nQueryResultBegin;                           // Offset in the query results of first results returned   
    BOOL                     bRapidQuery;                                 // Whether support the quick query, TRUE: for quick, quick query time don't wait for all add, delete, change operation is completed. The default is non-quick query 
}FIND_RECORD_TRAFFICREDLIST_CONDITION;

// Suspicious vehicle Event, corresponding to DH_ALARM_TRAFFIC_SUSPICIOUSCAR
typedef struct tagALARM_TRAFFIC_SUSPICIOUSCAR_INFO
{
    DWORD                   dwSize;
    int                     nAction;                        // Event Action, -1:unknown, 0:Start, 1:Stop, 2:Pulse
    DH_MSG_OBJECT           stuVehicle;                     // Vehicle info
    NET_TRAFFIC_LIST_RECORD stuCarInfo;                     // Information of recorded in transportation black and white list 
    EVENT_COMM_INFO         stCommInfo;                     // common info
}ALARM_TRAFFIC_SUSPICIOUSCAR_INFO;

//Record Case Record Query Conditions 
typedef struct
{
    DWORD                    dwSize;
    NET_TIME                 stuStartTime;                      // Start Time 
    NET_TIME                 stuEndTime;                        // End Time
}FIND_RECORD_BURN_CASE_CONDITION;


// Entrance Card Record Query Conditions 
typedef struct tagFIND_RECORD_ACCESSCTLCARD_CONDITION
{
    DWORD                    dwSize;
    char                     szCardNo[DH_MAX_CARDNO_LEN];      // Card Number 
    char                     szUserID[DH_MAX_USERID_LEN];      // User ID 
    BOOL                     bIsValid;                         // Whether effective, TRUE: effective, FALSE: invalid 
    BOOL                     abCardNo;                         // Card inquire condition effects or not, for member szCardNo
    BOOL                     abUserID;                         // User ID inquire condition effects or not, for member  szUserID
    BOOL                     abIsValid;                        // IsValid inquire condition effects or not, for member  bIsValid
}FIND_RECORD_ACCESSCTLCARD_CONDITION;

// Access password record query conditions 
typedef struct tagFIND_RECORD_ACCESSCTLPWD_CONDITION
{
    DWORD                     dwSize;
    char                      szUserID[DH_MAX_USERID_LEN];      // User ID
}FIND_RECORD_ACCESSCTLPWD_CONDITION;

// Order field of entrance guard access records
typedef enum tagEM_RECORD_ACCESSCTLCARDREC_ORDER_FIELD
{
	EM_RECORD_ACCESSCTLCARDREC_ORDER_FIELD_UNKNOWN = 0,			// unknown
	EM_RECORD_ACCESSCTLCARDREC_ORDER_FIELD_RECNO,				// Record No.
	EM_RECORD_ACCESSCTLCARDREC_ORDER_FIELD_CREATETIME,			// Create time
}EM_RECORD_ACCESSCTLCARDREC_ORDER_FIELD;

// Order rule of entrance guard access records
typedef struct tagFIND_RECORD_ACCESSCTLCARDREC_ORDER
{
	EM_RECORD_ACCESSCTLCARDREC_ORDER_FIELD		emField;		// field
	EM_RECORD_ORDER_TYPE						emOrderType;    // order type
	char										byReverse[64];  // Reserved
}FIND_RECORD_ACCESSCTLCARDREC_ORDER;

// Entrance guard access records query conditions 
typedef struct tagFIND_RECORD_ACCESSCTLCARDREC_CONDITION
{
    DWORD                     dwSize;
    char                      szCardNo[DH_MAX_CARDNO_LEN];      // User ID
    NET_TIME                  stStartTime;                      // Start Time 
    NET_TIME                  stEndTime;                        // End Time
}FIND_RECORD_ACCESSCTLCARDREC_CONDITION;

// A&C extry/exit search criteria
typedef struct tagFIND_RECORD_ACCESSCTLCARDREC_CONDITION_EX
{
    DWORD										dwSize;
    BOOL										bCardNoEnable;						// Enable card search
    char										szCardNo[DH_MAX_CARDNO_LEN];		// Card No.
    BOOL										bTimeEnable;						// Enable search by period
    NET_TIME									stStartTime;						// Start time 
	NET_TIME									stEndTime;							// End time 
	int											nOrderNum;							// The number of rules
	FIND_RECORD_ACCESSCTLCARDREC_ORDER			stuOrders[MAX_ORDER_NUMBER];		// The array of rules
}FIND_RECORD_ACCESSCTLCARDREC_CONDITION_EX;


// sensor record search criteria
typedef struct tagFIND_RECORD_SENSORRECORD_CONDITION
{
	DWORD					  dwSize;							
	NET_TIME                  stStartTime;                      // Start time, required 
    NET_TIME                  stEndTime;                        // End time, required 
	UINT					  uDeviceID;						// Acquisition device ID, optional.High 8 bits mean instrument type,low 24 bits mean the instrument serial number in the group.For example:0-electricity,1-analog sensor.0xffffffff means invalid
	BOOL                      bDeviceIDEnable;                  // Enbale search by device ID
	BOOL                      bStatusEnable;                    // Enable search by status
	BYTE					  byStatus;                         // Data status,optinal.0:normal,1:abnormal.0xff:invalid
	BYTE					  byReserved[3];					// Reserved
} FIND_RECORD_SENSORRECORD_CONDITION;

// Holiday Recordset Query Conditions 
typedef struct tagFIND_RECORD_ACCESSCTLHOLIDAY_CONDITION
{
    DWORD                     dwSize;	
    char            		  szHolidayNo[DH_COMMON_STRING_32];       // holiday no
}FIND_RECORD_ACCESSCTLHOLIDAY_CONDITION;

// electronic tag query conditions
typedef struct tagFIND_RECORD_ELECTRONICSTAG_CONDITION
{
	DWORD					dwSize;										// struct size
	NET_TIME                stStartTime;								// the start time of Through Time, required
    NET_TIME                stEndTime;									// the end time of Through Time, required
	BOOL					abDevId;									// whether the device ID is effective or not
	UINT					unDevID;									// device id ,from 0, optional
	BOOL					abMatchPic;									// whether the picture matched is effective or not
    BOOL					bMatch;										// whether the picture has been matched, optional
    BOOL					abPlateNumber;								// whether the plate number is effective or not
    char					szPlateNumber[DH_MAX_PLATE_NUMBER_LEN];		// plate number, optional
} FIND_RECORD_ELECTRONICSTAG_CONDITION;


//Record Resident info Query Conditions
typedef struct tagFIND_RECORD_RESIDENT_CONDTION
{
	DWORD 					  dwSize;
	char 					  szICNum[DH_MAX_IC_LEN];		   //Identify Card
}FIND_RECORD_RESIDENT_CONDTION;

// traffic flow record search filter
typedef struct tagFIND_RECORD_TRAFFICFLOW_CONDITION
{
    DWORD                     dwSize;
    BOOL                      abChannelId;                      // channel no. search filter is valid or not     
    int                       nChannelId;                       // channel no.
    BOOL                      abLane;                           // lane no. searchfilter is valid or not
    int                       nLane;                            // lane no.
    BOOL                      bStartTime;						// The start time search critiera is valid or not    
    NET_TIME                  stStartTime;                      // start time
    BOOL					  bEndTime;							// The end time search criteria is valid or not. 
    NET_TIME                  stEndTime;                        // end time 
    BOOL                      bStatisticsTime;                 // query if statistics time or notbStartTime and bEndTime TRUE
}FIND_RECORD_TRAFFICFLOW_CONDITION;

#define DH_MAX_CALLTYPE_LIST_NUM        16              // call  type search criteria listmax number 
#define DH_MAX_ENDSTATE_LIST_NUM        16              // final status  search criteria listmax number 

// call record search criteria 
typedef struct tagFIND_RECORD_VIDEO_TALK_LOG_CONDITION
{
    DWORD               dwSize;
    BOOL                bCallTypeEnable;                // call  type search criteria valid or not
    int                 nCallTypeListNum;               // corresponding to emCallTypeList valid enumeration number 
    EM_VIDEO_TALK_LOG_CALLTYPE   emCallTypeList[DH_MAX_CALLTYPE_LIST_NUM];  // call  type enable list
    BOOL                bEndStateEnable;                // final status  search criteria isvalid or not
    int                 nEndStateListNum;               // corresponding to emEndStateList valid enumeration number 
    EM_VIDEO_TALK_LOG_ENDSTATE   emEndStateList[DH_MAX_ENDSTATE_LIST_NUM];  // final status enable list
    BOOL                bTimeEnable;                    // Time enable
    NET_TIME            stStartTime;                    // Start Time
    NET_TIME            stEndTime;                      // End Time
}FIND_RECORD_VIDEO_TALK_LOG_CONDITION;

// status  record search criteria 
typedef struct tagFIND_RECORD_REGISTER_USER_STATE_CONDITION
{
    DWORD               dwSize;
    BOOL                bUserIDEnable;                  // userID search criteria is valid or not
    char                szUserID[DH_MAX_USERID_LEN];    // user ID
    BOOL                bOnlineEnable;                  // online search criteria is valid or not
    int					nOnline;            			// Online
    BOOL                bVideoTalkingEnable;            // audio talk status  search criteria  is valid or not 
    EM_REGISTER_USER_STATE     emVideoTalking;          // audio talk status 
}FIND_RECORD_REGISTER_USER_STATE_CONDITION;

// contact record search criteria 
typedef struct tagFIND_RECORD_VIDEO_TALK_CONTACT_CONDITION
{
    DWORD               dwSize;
    BOOL                bVTShortNumberEnable;                                   // visual talk short no. search criteria  is valid or not 
    char                szVTShortNumber[DH_COMMON_STRING_32];                   // visual talk short no.
    BOOL                bVTLongNumberEnable;                                    // visual talk long no. search criteria  is valid or not 
    char                szVTLongNumber[DH_COMMON_STRING_64];                    // visual talk long no.
}FIND_RECORD_VIDEO_TALK_CONTACT_CONDITION;

// Delivered commodies search criteria 
typedef struct tagFIND_RECORD_COMMODITY_NOTICE_CONDITION
{
    DWORD                           dwSize;
    BOOL                            bIDEnable;                                   // Enable ID Search
    char                            szID[DH_COMMON_STRING_64];                   // ID
}FIND_RECORD_COMMODITY_NOTICE_CONDITION;

// Medical check info search criteria 
typedef struct tagFIND_RECORD_HEALTH_CARE_NOTICE_CONDITION
{
    DWORD                           dwSize;
    BOOL                            bIDEnable;                                   // Enable ID Search
    char                            szID[DH_COMMON_STRING_64];                   // ID
}FIND_RECORD_HEALTH_CARE_NOTICE_CONDITION;


// traffic flow record
typedef struct tagNET_RECORD_TRAFFIC_FLOW_STATE 
{
    DWORD                           dwSize;
    int                             nRecordNum;                 // record no.
    int                             nChannel;                   // channel no.   
    int                             nLane;                      // lane no.
    int                             nVehicles;                  // pass vehicle total
    float                           fAverageSpeed;              // average speed, unit km/h
    float                           fTimeOccupyRatio;           // time occupancy rate, as within unit time passed vehicle used time total and unit occupied scale
    float                           fSpaceOccupyRatio;          // space occupancy, as percentage of total vehicle length to time interval average vehicle driving distance
    float                           fSpaceHeadway;              // head distance, with adjacent vehicle, unit meter/vehicle
    float                           fTimeHeadway;               // head distance, unit meter/vehicle
    int                             nLargeVehicles;             // truck flow(9m<vehicle length<12m), vehicle/unit time
    int                             nMediumVehicles;            // Midsize vehicle flow(6m<vehicle length<9m), vehicle/unit time
    int                             nSmallVehicles;             // car flow(4m<vehicle legnth<6m), vehicle/unit, 
    float                           fBackOfQueue;               // line length, unit: meter, from signal cross to front line end
    int                             nPasserby;                  // Number of passer-by 
}NET_RECORD_TRAFFIC_FLOW_STATE;

// CLIENT_FindRecord    Interface Input Parameters 
typedef struct _NET_IN_FIND_RECORD_PARAM
{
    DWORD                     dwSize;          // The Structure Size 
    EM_NET_RECORD_TYPE        emType;          // The record type to query
    void*                     pQueryCondition; // Query types corresponding to the query conditions 
											   // the space application by the user,according to query condition type,find corresponding structure,then ensure memory size
}NET_IN_FIND_RECORD_PARAM;

// CLIENT_FindRecord  Interface Output Parameters 
typedef struct _NET_OUT_FIND_RECORD_PARAM
{
    DWORD                     dwSize;          // Structure Size
    LLONG                     lFindeHandle;    // Query Log Handle,Uniquely identifies a certain query
}NET_OUT_FIND_RECORD_PARAM;

// CLIENT_FindNextRecord  Interface Input Parameters 
typedef struct _NET_IN_FIND_NEXT_RECORD_PARAM
{
    DWORD                     dwSize;          // Structure Size 
    LLONG                     lFindeHandle;    // Query Log Handle
    int                       nFileCount;      // The current number of records  need query 
}NET_IN_FIND_NEXT_RECORD_PARAM;

// CLIENT_FindNextRecord  Interface Output Parameters 
typedef struct _NET_OUT_FIND_NEXT_RECORD_PARAM
{
    DWORD                     dwSize;          // Structure Size 
    void*                     pRecordList;     // Record List, the user allocates memory, ensure structure by query record type(EM_NET_RECORD_TYPE) of NET_IN_FIND_RECORD_PARAM,then ensure memory size
    int                       nMaxRecordNum;   // Max list Record Number 
    int                       nRetRecordNum;   // Query to the number of records, when the query to the article number less than want to query the number, end 
}NET_OUT_FIND_NEXT_RECORD_PARAM;

typedef struct tagNET_INSERT_RECORD_INFO
{
    DWORD                     dwSize;
    NET_TRAFFIC_LIST_RECORD   *pRecordInfo;    // Record the content information,the space application by the user,apply to sizeof(NET_TRAFFIC_LIST_RECORD)                    
}NET_INSERT_RECORD_INFO;

typedef struct tagNET_UPDATE_RECORD_INFO
{
    DWORD                     dwSize;
    NET_TRAFFIC_LIST_RECORD   *pRecordInfo;    // Record the content information,the space application by the user,apply to sizeof(NET_TRAFFIC_LIST_RECORD)                      
}NET_UPDATE_RECORD_INFO;

typedef struct tagNET_REMOVE_RECORD_INFO
{
    DWORD                     dwSize;
    int                       nRecordNo;       // Queried Record Number    
}NET_REMOVE_RECORD_INFO;

typedef struct tagNET_IN_OPERATE_TRAFFIC_LIST_RECORD
{
    DWORD                     dwSize;
    
    EM_RECORD_OPERATE_TYPE    emOperateType;   // Operate Type
    EM_NET_RECORD_TYPE        emRecordType;    // record type to operate (Just NET_RECORD_TRAFFICREDLIST and NET_RECORD_TRAFFICBLACKLIST is valid)
    void                      *pstOpreateInfo; // the space application by the user,please refer to emOperateType to ensure corresponding structure,then ensure memory size
    
}NET_IN_OPERATE_TRAFFIC_LIST_RECORD;

//In current implementation of operation interface, only return nRecordNo operation, stRetRecord is temporarily unavailable 
typedef struct tagNET_OUT_OPERATE_TRAFFIC_LIST_RECORD
{
    DWORD                     dwSize;
    int                       nRecordNo;        //Record Number     
}NET_OUT_OPERATE_TRAFFIC_LIST_RECORD;

//Continuous control PTZ corresponding structure 
typedef struct tagPTZ_Control_Continuously
{
    PTZ_SPEED_UNIT         stuSpeed;              //PTZ speed 
    int                    nTimeOut;              //Continuous motion timeout, the unit is in seconds 
    char                   szReserve[64];         //Reserved
}PTZ_CONTROL_CONTINUOUSLY;

//Absolute control PTZ corresponding structure 
typedef struct tagPTZ_Control_Absolutely
{
    PTZ_SPACE_UNIT         stuPosition;           //PTZ Absolute Speed 
    PTZ_SPEED_UNIT         stuSpeed;              //PTZ Operation Speed
    char                   szReserve[64];         //Reserved
}PTZ_CONTROL_ABSOLUTELY;

//PTZ control coordinate unit,track move
typedef struct tagPTZ_LOCATION_SPACE_UNIT
{
    int                    nPositionX;           //PTZ horizontal motion position, effective range:[0,3600]
    int                    nPositionY;           //PTZ vertical motion position, effective range:[-1800,1800]
    int                    nZoom;                //PTZ zoom position
    char                   szReserve[32];        //Reserved
}PTZ_LOCATION_SPACE_UNIT;

//PTZ control coordinate unit,speed
typedef struct tagPTZ_LOCATION_SPEED_UNIT
{
    int                    nSpeedX;				//PTZ horizontal real Speed ,Left is negative,Right is positive,1000 means 10 degree per second,expanded 100 times
    int                    nSpeedY;				//PTZ vertical real Speed ,Left is negative,Right is positive,1000 means 10 degree per second,expanded 100 times
    char                   szReserve[32];       //Reserved
}PTZ_LOCATION_SPEED_UNIT;

//ptz Continuous movement,command DH_EXTPTZ_INTELLI_TRACKMOVE 
typedef struct tagPTZ_CONTROL_INTELLI_TRACKMOVE
{
	DWORD						dwSize;				   // Structure Size
	int							nChannelID;            // channel id
	int							nFlag;				   // move flag
													   // 0:location,speed  is invalid,position Zoom is valid
													   // 1:Continuous movement,speed is invalid,position Zoom is invalid
													   // 2:Continuous movement,speed is valid,position Zoom is invalid
	
	PTZ_LOCATION_SPACE_UNIT     stuPosition;           // PTZ Absolute move position 
    PTZ_LOCATION_SPEED_UNIT		stuSpeed;              // PTZ Operation Speed
}PTZ_CONTROL_INTELLI_TRACKMOVE;

// Set focus mode. command: DH_EXTPTZ_INTELLI_SETLENSWISDOMSTATE
typedef struct tagPTZ_CONTROL_INTELLI_SETLENSWISDOMSTATE
{
	DWORD						dwSize;				   // Structure Size
	int							nChannelID;            // Channel id
	int							nMode;				   // 0: Normal scene mode(Default:0)
													   // 1: Intelligent tracking scene mode
}PTZ_CONTROL_INTELLI_SETLENSWISDOMSTATE;

// Set focus area. command: DH_EXTPTZ_INTELLI_SETFOCUSAREA
typedef struct tagPTZ_CONTROL_INTELLI_SETFOCUSAREA
{
	DWORD						dwSize;				   // Structure Size
	int							nChannelID;            // Channel id
	int							nState;				   // Enable state of focus area when target tracking
													   // 1:Set focus area
													   // 0:Cancel focus area
	NET_RECT					stuRect;			   // Focus area, Range[0~8191]
}PTZ_CONTROL_INTELLI_SETFOCUSAREA;

//auxiliary	Auxiliary point	command: DH_EXTPTZ_AUXIOPEN,DH_EXTPTZ_AUXICLOSE, ptz control interface:CLIENT_DHPTZControlEx2
typedef struct tagPTZ_CONTROL_AUXILIARY
{
	DWORD						dwSize;
	char						szFunctionName[DH_COMMON_STRING_32];   // PTZ auxiliary function name,use interface CLIENT_DHPTZControlEx2 by command CFG_CAP_CMD_PTZ can get expected info(CFG_PTZ_PROTOCOL_CAPS_INFO)
}PTZ_CONTROL_AUXILIARY;

// Alarm input channel information 
typedef struct tagNET_ALARM_IN_CHANNEL
{
    DWORD                   dwSize;
    BOOL                    bValid;                             // whether effective,FALSE show the alarm channel is not used
    int                     nChannel;                           // Alarm channel number 
    char                    szDeviceID[DH_DEV_ID_LEN];          // Device ID, Local alarm channel: "Local",remote device : use uuid express
    char                    szName[DH_DEV_NAME_LEN];            // Alarm  Channel Names 
}NET_ALARM_IN_CHANNEL;

// Alarm Channel Number 
typedef struct tagNET_ALARM_CHANNEL_COUNT 
{
    DWORD                   dwSize;
    int                     nLocalAlarmIn;                      // Local Alarm Input Channel Number
    int                     nLocalAlarmOut;                     // Local Alarm Output Channel Number 
    int                     nRemoteAlarmIn;                     // Remote Alarm Input Channel Number 
    int                     nRemoteAlarmOut;                    // Remote Alarm Output Channel Number 
}NET_ALARM_CHANNEL_COUNT;

//With speed rotation site PTZ control corresponding to the preset structure 
typedef struct tagPTZ_Control_GotoPreset
{
    int                     nPresetIndex;           //Preset BIT Index 
    PTZ_SPEED_UNIT          stuSpeed;               //PTZ Operation Speed
    char                    szReserve[64];          //Reserved
}PTZ_CONTROL_GOTOPRESET;

//remove preset PTZ control corresponding to the preset structure
typedef struct tagPTZ_Control_RemovePreset
{
    int                     nPresetIndex;           //Preset BIT Index
    char                    szReserve[64];          //Reserved
}PTZ_CONTROL_REMOVEPRESET;

//With speed rotation site and snap PTZ control corresponding to the preset structure 
typedef struct tagPTZ_Control_GotoPresetSnap
{
    int                     nPresetIndex;           //Preset BIT Index 
	int						nChannel;               //channel NO
    PTZ_SPEED_UNIT          stuSpeed;               //PTZ Operation Speed
    char                    szReserve[64];          //Reserve
}PTZ_CONTROL_GOTOPRESETSNAP;

// CLIENT_SetTourSource   Interface input parameters (Settings window round tour shows source) 
typedef struct tagNET_IN_SET_TOUR_SOURCE 
{
    DWORD                   dwSize;
    int                     nChannel;               // Output Channel Number 
    int                     nWindow;                // Window Number
    DH_SPLIT_SOURCE*        pstuSrcs;               // Display Origin Array,can be round tour in the window,the space application by the user,apply to sizeof(DH_SPLIT_SOURCE)*nSrcCount  
    int                     nSrcCount;              // Display Origin Number
} NET_IN_SET_TOUR_SOURCE;

// CLIENT_SetTourSource    Interface output parameters (Settings window round tour shows source) 
typedef struct tagNET_OUT_SET_TOUR_SOURCE
{
    DWORD                   dwSize;
} NET_OUT_SET_TOUR_SOURCE;

// CLIENT_GetTourSource port input parameter 
typedef struct tagNET_IN_GET_TOUR_SOURCE 
{
    DWORD           dwSize;
    int             nChannel;           // output channel no., pszCompsiteIDis NULL, it is valid 
    const char*     pszCompositeID;     // splicing video wall ID
    int             nWindow;            // window no., -1 means all window
} NET_IN_GET_TOUR_SOURCE;

// window tour display source info 
typedef struct tagNET_SPLIT_TOUR_SOURCE 
{
    DWORD           dwSize;
    DH_SPLIT_SOURCE*    pstuSrcs;       // display source group, user allocation memory,apply to sizeof(DH_SPLIT_SOURCE)*nMaxSrcCount
    int             nMaxSrcCount;       // display source max quantity
    int             nRetSrcCount;       // return display source quantity
} NET_SPLIT_TOUR_SOURCE;

// CLIENT_GetTourSource port  output parameter 
typedef struct tagNET_OUT_GET_TOUR_SOURCE
{
    DWORD          dwSize;  
    NET_SPLIT_TOUR_SOURCE* pstuWndSrcs; // window tour info group, user allocation memory,the space application by the user,apply to sizeof(NET_SPLIT_TOUR_SOURCE)*nMaxWndCount
    int            nMaxWndCount;        // window max group, user fill in
    int            nRetWndCount;        // return window  quantity
} NET_OUT_GET_TOUR_SOURCE;

// split tour status info 
typedef struct tagNET_SPLIT_TOUR_STATUS_INFO
{
    DWORD          dwSize;
    int            nWindow;             // window no.
    NET_TOUR_STATUS   	emStatus;       // status 
    DH_SPLIT_WND_SOURCE stuSource;      //  current display source info 
}NET_SPLIT_TOUR_STATUS_INFO;

// tour status call function origin, lAttachHandle is CLIENT_AttachSplitTour return value 
typedef void (CALLBACK *fTourStatusCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_SPLIT_TOUR_STATUS_INFO* pstStatus, void* reserved, LDWORD dwUser);

// CLIENT_AttachSplitTourport input parameter 
typedef struct tagNET_IN_ATTACH_SPLIT_TOUR
{
    DWORD           dwSize;
    int             nChannel;           // output channel no., pszCompsiteIDis NULL, it is valid 
    const char*     pszCompositeID;     // splicing video wall ID
    fTourStatusCallBack cbStatus;       // tour status call function
    LDWORD          dwUser;             // tour status call function
}NET_IN_ATTACH_SPLIT_TOUR;

// CLIENT_AttachSplitTourport  output parameter 
typedef struct tagNET_OUT_ATTACH_SPLIT_TOUR 
{
    DWORD           dwSize;
}NET_OUT_ATTACH_SPLIT_TOUR;

// the work mode of this window
typedef enum tagEM_WINDOW_WORKMODE
{
	EM_WINDOW_DISPLAY,				// display(default)
	EM_WINDOW_REPLAY,				// replay
} EM_WINDOW_WORKMODE;

// display source infomation
typedef struct tagNET_SOURCE_INFO
{
	int 				nWindowID;					// current window ID
	int					nCaremaChannel;				// current video source channel ID
	NET_TIME			stuStartTime;				// the start time
	EM_WINDOW_WORKMODE	emWorkMode;					// work mode of the windows
	BYTE				bReserved[128];				// reserved byte
}NET_SOURCE_INFO;

// the display sources of windows
typedef struct tagNET_WINDOW_SOURCE_INFO
{
	DWORD				dwSize;
	int					nRetSrcCount;							// actual numer of source
	NET_SOURCE_INFO		*pstSourceInfo;							// display source infomation of each window
} NET_WINDOW_SOURCE_INFO;

// the call back function of windows sources, lAttachHandleis CLIENT_AttachWindowsSource return value
typedef void (CALLBACK *fWindowSourceCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_WINDOW_SOURCE_INFO* pstWindowSource, void* reserved, LDWORD dwUser);

// CLIENT_AttachWindowsSource input parameter 
typedef struct tagNET_IN_ATTACH_WINDOW_SOURCE
{
	DWORD					dwSize;
	int						nWindowID;					// window ID, -1 means the entire screen
	int 					nChannel;					// video out channel,  it is effective when pszCompositeID is NULL
	const char*         	pszCompositeID;             // composite ID
	fWindowSourceCallBack 	cbWindowSource;             // the call back function of windows sources
    LDWORD              	dwUser;                     // the param of window source call back
} NET_IN_ATTACH_WINDOW_SOURCE;

// CLIENT_AttachWindowsSource output parameter
typedef struct tagNET_OUT_ATTACH_WINDOW_SOURCE
{
    DWORD               dwSize;
}NET_OUT_ATTACH_WINDOW_SOURCE;

// input parameter of interface CLIENT_WindowRegionEnlarge 
typedef struct tagNET_IN_WINDOW_REGION_ENLARGE
{
	DWORD					dwSize;
    int                 	nChannel;           // video out channel or virtual channel
	int						nWindowID;			// window ID
	NET_RECT				stuRect;			// area of windw magnification, the coordinate system is virtual coodinate system.[0~8192]
} NET_IN_WINDOW_REGION_ENLARGE;

// out parameter of interface CLIENT_WindowRegionEnlarge
typedef struct tagNET_OUT_WINDOW_REGION_ENLARGE
{
	DWORD					dwSize;
} NET_OUT_WINDOW_REGION_ENLARGE;

// input parameter of interface CLIENT_WindowEnlargeReduction
typedef struct tagNET_IN_WINDOW_ENLARGE_REDUCTION
{
	DWORD					dwSize;
    int                 	nChannel;           // video out channel or virtual channel
	int						nWindowID;			// window ID
} NET_IN_WINDOW_ENLARGE_REDUCTION;

// outparameter of interface CLIENT_WindowEnlargeReduction
typedef struct tagNET_OUT_WINDOW_ENLARGE_REDUCTION
{
	DWORD					dwSize;
} NET_OUT_WINDOW_ENLARGE_REDUCTION;

// opreate type of mouse
typedef enum tagEM_MOUSE_OPREATE_TYPE
{
	EM_MOUSE_OPREATE_LEFT_PRESS		= 1,	// left key press
	EM_MOUSE_OPREATE_LEFT_RELEASE,			// loosen the left key
	EM_MOUSE_OPREATE_RIGHT_PRESS,			// right key press
	EM_MOUSE_OPREATE_RIGHT_RELEASE,			// lossen the right key
	EM_MOUSE_OPREATE_MOUSE_MOVE,			// mouse movement
	EM_MOUSE_OPREATE_MOUSE_SCROLL,			// mouse scrolling
} EM_MOUSE_OPREATE_TYPE;

// the flag of mouse button
typedef enum tagEM_MOUSE_FLAG_TYPE
{
	EM_MOUSE_FLAG_LEFT		= 0,			// left key
	EM_MOUSE_FLAG_RIGHT,					// right key
} EM_MOUSE_FLAG_TYPE;

// input parameter of interface CLIENT_WindowButtonAction
typedef struct tagNET_IN_WINDOW_ONBUTTON_ACTION
{
	DWORD					dwSize;
    int                 	nChannel;           // output channel or splice screen virtual channel
	int						nWindowID;			// window ID
	EM_MOUSE_OPREATE_TYPE	emOpreateType;		// opreate type of mouse
	EM_MOUSE_FLAG_TYPE		emMouseFlag;		// the flag of mouse button
	int						nZDelta;			// mouse rolling speed, greater than 0 means rolling forward, 
												// less than 0 means rolling backwards, equal to 0 means no rolling
	DH_POINT				stuMousePoint;		// position of the mouse in the window
} NET_IN_WINDOW_ONBUTTON_ACTION;

// output parameter of interface CLIENT_WindowButtonAction
typedef struct tagNET_OUT_WINDOW_ONBUTTON_ACTION
{
	DWORD					dwSize;
} NET_OUT_WINDOW_ONBUTTON_ACTION;


// fAttachRecordInfoCB parameter, information of reported video file 
typedef struct tagNET_CB_RECORD_INFO
{
    DWORD                   dwSize;
    int                     nChannel;               // Channel number 
    char                    szFileName[MAX_PATH];   // The name of the video 
    DWORD                   dwType;                 // Video type,defined by bit as follows:
                                                    // Bit0-Timing video 
                                                    // Bit1-Dynamic test video 
                                                    // Bit2-Alarm video
                                                    // Bit3-Video card number
    DWORD                   dwState;                // Video status, 0 - packaging, 1 - to delete 
} NET_CB_RECORD_INFO;



// Video update callback function prototype, lAttachHandle is return value of CLIENT_AttachRecordInfo, n strip per time, pBuf->dwSize * n == nBufLen
typedef void (CALLBACK *fAttachRecordInfoCB)(LLONG lLoginID, LLONG lAttachHandle, NET_CB_RECORD_INFO* pBuf, int nBufLen, LDWORD dwUser);

// CLIENT_AttachRecordInfo  Input Parameters
typedef struct tagNET_IN_ATTACH_RECORD_INFO
{
    DWORD                   dwSize;
    int                     nInterval;              // Time Interval, Every Interval second, equipment send video information 
    int                     nDelay;                 // Report Delay, after equipment choice a random number between 1 and nDelay value, delay report video state, nDelayMust be smaller than nInterval
    fAttachRecordInfoCB     cbAttachRecordInfo;     // Video update callback function 
    LDWORD                  dwUser;                 // User data 
} NET_IN_ATTACH_RECORD_INFO;

typedef struct tagNET_OUT_ATTACH_RECORD_INFO
{
    DWORD                   dwSize;
} NET_OUT_ATTACH_RECORD_INFO;


//Subscribe to PTZ metadata interface and callback function prototypes 
//Pbufs at this stage mainly DH_PTZ_LOCATION_INFO type 
typedef void (CALLBACK *fPTZStatusProcCallBack)(LLONG lLoginID, LLONG lAttachHandle, void* pBuf, int nBufLen, LDWORD dwUser);

// Subscribe to PTZ metadata interface input parameters 
typedef struct tagNET_IN_PTZ_STATUS_PROC
{
    DWORD                   dwSize;
    int                     nChannel;              // PTZ Channel 
    fPTZStatusProcCallBack  cbPTZStatusProc;       // Callback function 
    LDWORD                  dwUser;                // User data
}NET_IN_PTZ_STATUS_PROC;

// Subscribe to PTZ metadata interface output parameters 
typedef struct tagNET_OUT_PTZ_STATUS_PROC
{
    DWORD                   dwSize;
}NET_OUT_PTZ_STATUS_PROC;

//PTZ conditions for visual structure
typedef struct tagDH_OUT_PTZ_VIEW_RANGE_STATUS
{
    DWORD      dwSize;
    double     dbDistance;                         // Visual range, the unit: m 
    int        nAngelH;                            // Horizontal viewing angles, 0~1800, unit: 1/10 degrees 
    int        nAzimuthH;                          // Horizontal azimuth Angle, 0 ~ 3600, unit: 1/10 degrees 
    int        nInclinationH;                      // Horizontal inclination angle, -900~900, unit: 1/10 degree
	int        nAngelV;                            // Vertical viewing angles, 0~1800, unit: 1/10 degrees
	int        nAzimuthV;                          // Vertical azimuth Angle, 0 ~ 3600, unit: 1/10 degrees
}DH_OUT_PTZ_VIEW_RANGE_STATUS;

//Subscribe to yuntai horizon callback function prototype 
typedef void (CALLBACK *fViewRangeStateCallBack)(LLONG lLoginID, LLONG lAttachHandle, DH_OUT_PTZ_VIEW_RANGE_STATUS* pBuf, int nBufLen, LDWORD dwUser);

// Subscribe to the visible range input parameters 
typedef struct tagNET_IN_VIEW_RANGE_STATE
{
    DWORD                   dwSize;
    int                     nChannel;              // PTZ channel
    fViewRangeStateCallBack cbViewRange;           // State Callback Function 
    LDWORD                  dwUser;                // User Data
}NET_IN_VIEW_RANGE_STATE;

// Subscribe to the visible range output parameters 
typedef struct tagNET_OUT_VIEW_RANGE_STATE
{
    DWORD                   dwSize;
}NET_OUT_VIEW_RANGE_STATE;

// Weather info 
typedef struct tagNET_WEATHER_INFO
{
	float				    fWindSpeed;		       // Wind speed,Unit:m/s,Range:[0.0,60.0]	
	float					fTemperature;		   // Temperature,Unit:Centigrade,Range:[-40.0,+80.0]
	float					fHumidity;			   // postfix:%,Range[0.0,100.0]
	unsigned int			nLight;				   // Light,Unit:W/(m*m),Range:[0,2000]
	float					fWindDirection;		   // Wind direction,Unit:degree,Range:[0,360)
	float				    fAirPressure;		   // Air pressure,Unit:hPa,Range[10~1100]
    int                     nRainfall;             // Rainfall, Uint:0.01mm
	BYTE					byReserved[2044];	   // reserved
}NET_WEATHER_INFO;

// Subscribe to ptz weather info callback function
typedef void (CALLBACK *fWeatherInfoCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_WEATHER_INFO* pBuf, int nBufLen, LDWORD dwUser);

//  Subscribe to the weather info input parameters
typedef struct tagNET_IN_WEATHER_INFO
{
	DWORD                   dwSize;
	int                     nChannel;              // PTZ channel
	fWeatherInfoCallBack	cbWeatherInfo;         // Callback Function 
	LDWORD                  dwUser;                // User Data
}NET_IN_WEATHER_INFO;

// Subscribe to the weather info output parameters
typedef struct tagNET_OUT_WEATHER_INFO
{
	DWORD                   dwSize;
}NET_OUT_WEATHER_INFO;

// configuration of set view range by object input parameters
typedef struct tagNET_IN_SET_VIEW_RANGE_BY_OBJECT
{
	DWORD					dwSize;					
	int						nChannel;				// channel number(0 begin)
	int						nDistance;				// object distance(Unit:centimeter) 
	int						nWidth;					// object width(Unit:centimeter)
	int						nScreenRatio;			// screen Ratio
}NET_IN_SET_VIEW_RANGE_BY_OBJECT;

// configuration of set view range by object output parameters
typedef struct tagNET_OUT_SET_VIEW_RANGE_BY_OBJECT
{
    DWORD                   dwSize;
}NET_OUT_SET_VIEW_RANGE_BY_OBJECT;

// configuration of set view range by GPS input parameters(CLIENT_SetViewRangeByGPS)
typedef struct tagNET_IN_SET_VIEW_RANGE_BY_GPS
{
	DWORD					dwSize;					
	int						nChannel;				// channel number(0 begin)
	double				    dLongitude;			    // longitude,[-180, 180],unit:degree(),negative:west longitude
	double					dLatitude;				// latitude,[-90, 90],unit:degree(),negative:south latitude
}NET_IN_SET_VIEW_RANGE_BY_GPS;

// configuration of set view range by GPS output parameters(CLIENT_SetViewRangeByGPS)
typedef struct tagNET_OUT_SET_VIEW_RANGE_BY_GPS
{
	DWORD                   dwSize;
}NET_OUT_SET_VIEW_RANGE_BY_GPS;

//Set the PTZ vision information 
typedef struct tagPTZ_VIEW_RANGE_INFO
{
    int                     nStructSize;
    int                     nAzimuthH;              // Horizontal azimuth Angle, 0~3600, unit: degrees 
}PTZ_VIEW_RANGE_INFO;

//Query PTZ optical zoom value( corresponding to DH_DEVSTATE_PTZ_ZOOM_INFO ) 
typedef struct tagDH_OUT_PTZ_ZOOM_INFO
{
    int                     dwSize;
    int                     nZoomValue;              // zoom value
}DH_OUT_PTZ_ZOOM_INFO;

// Channel number information 
typedef struct tagNET_CHN_COUNT_INFO
{
    DWORD                   dwSize;
    int                     nMaxTotal;              // Equipment to the total number of channels (the sum of all valid channel number
    int                     nCurTotal;              // the number of configured on channels 
    int                     nMaxLocal;              // Maximum number of local channels, including motherboard and pluggable cartoon 
    int                     nCurLocal;              // configured local channel number 
    int                     nMaxRemote;             // Maximum number of remote channel 
    int                     nCurRemote;             // Configured remote channel number
} NET_CHN_COUNT_INFO;

// Equipment channel number information  
typedef struct tagNET_DEV_CHN_COUNT_INFO
{
    DWORD                   dwSize;
    NET_CHN_COUNT_INFO      stuVideoIn;             // Video Input Channel 
    NET_CHN_COUNT_INFO      stuVideoOut;            // Video Output Channel 
} NET_DEV_CHN_COUNT_INFO;

//  detailed information of video state
typedef struct tagNET_RECORD_STATE_DETAIL 
{
    DWORD                   dwSize;
    BOOL                    bMainStream;            // The main stream, TRUE - are video, FALSE - not in the video 
    BOOL                    bExtraStream1;          // Auxiliary stream 1, TRUE - are video, FALSE - not in the video 
    BOOL                    bExtraStream2;          // Auxiliary stream 2, TRUE - are video, FALSE - not in the video 
    BOOL                    bExtraStream3;          // Auxiliary stream 3, TRUE - are video, FALSE - not in the video 
} NET_RECORD_STATE_DETAIL;


//PTZ Absolute Focus Corresponding Structure 
typedef struct tagPTZ_Focus_Absolutely
{
    DWORD                    dwValue;               // PTZ Focused On Location, range (0~8191) 
    DWORD                    dwSpeed;               // PTZ Focused On Speed, the scope (0~7) 
    char                     szReserve[64];         // reserved 64 bytes 
}PTZ_FOCUS_ABSOLUTELY;

// CLIENT_PlayAudioFile   Interface Input Parameters 
typedef struct tagNET_IN_PLAY_AUDIO_FILE
{
    DWORD                   dwSize;
    const char*             pszFilePath;            // File Path
    DWORD                   dwOutput;               // Output Path, can be a variety of output, according to the bit, bit0-mic, bit1-speaker
} NET_IN_PLAY_AUDIO_FILE;

// CLIENT_PlayAudioFile   Interface Output Parameters 
typedef struct tagNET_OUT_PLAY_FILE_STREAM
{
    DWORD                   dwSize;
} NET_OUT_PLAY_AUDIO_FILE;

// RTSP URLInformation list structure 
typedef struct tagNET_DEV_RTSPURL_LIST
{
    DWORD                   dwSize;
    int                     nChannelID;                                 // Channel number (user input parameters) 
    int                     nUrlNum;                                    // Url Address Number 
    char                    szURLList[DH_MAX_URL_NUM][DH_MAX_URL_LEN];  // UrlAddress List 
}NET_DEV_RTSPURL_LIST;

// PTZ control - fan and corresponding structure 
typedef struct tagPTZ_Control_SectorScan
{
    int             nBeginAngle;                    // Staring Angle,Range:[-180,180]
    int             nEndAngle;                      // Ending Angle,Range:[-180,180]
    int             nSpeed;                         // Speed,Range:[0,255]
    char            szReserve[64];                  // Reserved 64 bytes 
}PTZ_CONTROL_SECTORSCAN;

// control Fish eye E-PTZ info 
typedef struct tagPTZ_CONTROL_SET_FISHEYE_EPTZ
{
    DWORD       dwSize;	                // structure size
    DWORD       dwWindowID;             // EPtz control window no.
    DWORD       dwCommand;              // E-PTZ command 
    DWORD       dwParam1;               // command corresponding to parameter 1
    DWORD       dwParam2;               // command corresponding to  parameter 2
    DWORD       dwParam3;               // command corresponding to  parameter 3
    DWORD       dwParam4;               // command corresponding to  parameter 4
}PTZ_CONTROL_SET_FISHEYE_EPTZ;

// Track Control Information
typedef struct tagPTZ_CONTROL_SET_TRACK_CONTROL
{
        DWORD           dwSize;                         // dwSize need to be assigned sizeof(PTZ_CONTROL_SET_TRACK_CONTROL)
        DWORD           dwChannelID;                    // channel number
        DWORD           dwCommand;                      // Control command, orresponding to enum NET_TRACK_CONTROL_CMD
        DWORD           dwParam1;                       // command corresponding to parameter 1
        DWORD           dwParam2;                       // command corresponding to parameter 2
        DWORD           dwParam3;                       // command corresponding to parameter 3
} PTZ_CONTROL_SET_TRACK_CONTROL;
//===============Area Scan, Ptz operator=============================

// Area Scan command of ptz (interface is CLIENT_DHPTZAreaScan)
typedef enum tagNET_AREASCAN_EPTZ_CMD
{
	NET_AREASCAN_EPTZ_CMD_SET,					// set Area Scan info command(szInBuffer according to PTZ_CONTROL_SET_AREA_SCAN_LIMIT,szOutBuffer,dwOutBufferSize is invalid)
	NET_AREASCAN_EPTZ_CMD_DEL,					// delete Area Scan info command(szInBuffer according to PTZ_CONTROL_DEL_AREA_SCAN,szOutBuffer,dwOutBufferSize is invalid)
	NET_AREASCAN_EPTZ_CMD_GET, 					// get Area Scan info command(szInBuffer according to PTZ_CONTROL_GET_AREA_SCAN_IN,szOutBuffer according to PTZ_CONTROL_GET_AREA_SCAN_OUT )
	NET_AREASCAN_EPTZ_CMD_START,				// start Area Scan command(szInBuffer according to PTZ_CONTROL_START_AREA_SCAN,szOutBuffer,dwOutBufferSize is invalid)
	NET_AREASCAN_EPTZ_CMD_STOP,					// stop Area Scan command(szInBuffer according to PTZ_CONTROL_STOP_AREA_SCAN,szOutBuffer,dwOutBufferSize is invalid)
}NET_AREASCAN_EPTZ_CMD;

// set area scan info 
typedef struct tagPTZ_CONTROL_SET_AREA_SCAN_LIMIT
{
    DWORD           dwSize;                         // the size of this struct
    int				nChannelID;                     // channel id
	int             nIndex;							// area number,the number form 1.
	char			szLimitMode[16];				// Area boundary, "Left": left boundary "Right":right boundary
	int             nZoom;							// Zoom,range:0~128, default 0
} PTZ_CONTROL_SET_AREA_SCAN_LIMIT;

// delete area scan info
typedef struct tagPTZ_CONTROL_DEL_AREA_SCAN
{
    DWORD           dwSize;                         // the size of this struct
    int				nChannelID;                     // channel id
	int             nIndex;							// area number,the number form 1.
} PTZ_CONTROL_DEL_AREA_SCAN;

// get area scan info,input param
typedef struct tagPTZ_CONTROL_GET_AREA_SCAN_IN
{
    DWORD           dwSize;                         // the size of this struct
    int				nChannelID;                     // channel id
	int             nSize;							// area scan numbers
} PTZ_CONTROL_GET_AREA_SCAN_IN;

// area state info
typedef struct tagNET_AREASCAN_STATE 
{
    BOOL            bValid;							// area state
	BYTE			Reserved[128];					// Reserved
}NET_AREASCAN_STATE;

// get area scan info,output param
typedef struct tagPTZ_CONTROL_GET_AREA_SCAN_OUT
{
    DWORD                       dwSize;                             // the size of this struct
	UINT				        nValidNum;						    // valid number of arrary stuStateInfo
    NET_AREASCAN_STATE			stuStateInfo[DH_COMMON_STRING_32];  // array of area state info
}PTZ_CONTROL_GET_AREA_SCAN_OUT;

// Area Scan start info
typedef struct tagPTZ_CONTROL_START_AREA_SCAN
{
    DWORD           dwSize;                         // the size of this struct
    int				nChannelID;                     // channel id
	int             nIndex;							// area number,the number form 1.
	int             nSpeed;							// horizontal scan speed,range 1~255
	int				nTitleAngle;					// Vertical scan angele, range 0~90 unit: degrees 
} PTZ_CONTROL_START_AREA_SCAN;

// Area Scan stop info
typedef struct tagPTZ_CONTROL_STOP_AREA_SCAN
{
    DWORD           dwSize;                         // the size of this struct
    int				nChannelID;                     // channel id
	int             nIndex;							// area number,the number form 1.
} PTZ_CONTROL_STOP_AREA_SCAN;

//===============Area Scan, Ptz operator=============================

// the type of region focus
typedef enum tagEM_NET_FOCUS_REGION_MODE
{
    EM_NET_FOCUS_REGION_MODE_GLOBAL,                // global
    EM_NET_FOCUS_REGION_MODE_AUTO,                  // auto
    EM_NET_FOCUS_REGION_MODE_INROIREGION,           // in the ROI region
    EM_NET_FOCUS_REGION_MODE_OUTROIREGION,          // out of the ROI region

}EM_NET_FOCUS_REGION_MODE;

// the info of focus region(corresponding to DH_EXTPTZ_SET_FOCUS_REGION)
typedef struct tagPTZ_CONTROL_SET_FOCUS_REGION
{
    DWORD                       dwSize;             // sizeof(PTZ_CONTROL_SET_FOCUS_REGION)   
    EM_NET_FOCUS_REGION_MODE    emMode;	            // focus mode
    NET_RECT                    stuRect;            // focus region,value form 0 to 8192                        
} PTZ_CONTROL_SET_FOCUS_REGION;


// CLIENT_TransmitInfoForWeb   Interface Extension Parameters 
typedef struct tagNET_TRANSMIT_EXT_INFO
{
    DWORD           dwSize;
    unsigned char*  pInBinBuf;                      // Binary Input Data Buffer 
    DWORD           dwInBinBufSize;                 // Binary Input Data Length 
    int             nJsonDataLen;                   // Json Output Data Length
    int             nBinDataLen;                    // Binary Output Data Length
} NET_TRANSMIT_EXT_INFO;

// Monitor CAN Bus Data 
// fAttachProxyCB Parameter 
typedef struct tagNET_CB_CANDATA
{
    DWORD           dwSize;
    int             nDataLength;                    // Common Data Length
    unsigned char*  pDataContent;                   // Common Data Content
}NET_CB_CANDATA;

// Monitor CAN bus data callback function prototype , lAttachHandle is return value of CLIENT_AttachCAN
typedef void (CALLBACK *fAttachCANCB) (LLONG lLoginID, LLONG lAttachHandle, NET_CB_CANDATA* pBuf, LDWORD dwUser);

// CLIENT_AttachCAN() Input Parameters 
typedef struct tagNET_IN_ATTACH_CAN
{
    DWORD          dwSize;
    int            nChannel;                        // Monitor CAN channel number 
    fAttachCANCB   cbAttachCAN;                     // Callback Registered Video Phone State Changes 
    LDWORD         dwUser;                          // User Data 
}NET_IN_ATTACH_CAN;

// CLIENT_AttachCAN() Output Parameters 
typedef struct tagNET_OUT_ATTACH_CAN
{
    DWORD          dwSize;
}NET_OUT_ATTACH_CAN;

// CLIENT_SendCAN() input parameter
typedef struct tagNET_IN_SEND_CAN
{
    DWORD          dwSize;
    int            nChannel;                       // CAN channel no.
	int            nSendDataLength;                // Send data length
    unsigned char* pSendData;                      // Send data content
}NET_IN_SEND_CAN;

// CLIENT_SendCAN() output parameter
typedef struct tagNET_OUT_SEND_CAN
{
    DWORD          dwSize;
}NET_OUT_SEND_CAN;

// parameter of fAttachDevCommCB
typedef struct tagNET_CB_DEVCOMMDATA
{
    DWORD           dwSize;
    int             nDataLength;                    // data length
    unsigned char*  pDataContent;                   // data content
}NET_CB_DEVCOMMDATA;

// callback prototype of listening to data from trans comm, lAttachHandle is return value of CLIENT_AttachDevComm
typedef void (CALLBACK *fAttachDevCommCB) (LLONG lLoginID, LLONG lAttachHandle, NET_CB_DEVCOMMDATA* pBuf, LDWORD dwUser);

// CLIENT_AttachDevComm() input parameter
typedef struct tagNET_IN_ATTACH_DEVCOMM
{
    DWORD               dwSize;
    int                 nChannel;                        // channel
    fAttachDevCommCB    cbAttachDevComm;                 // callback function
    LDWORD              dwUser;                          // user param
}NET_IN_ATTACH_DEVCOMM;

// CLIENT_AttachDevComm() output parameter
typedef struct tagNET_OUT_ATTACH_DEVCOMM
{
    DWORD          dwSize;
}NET_OUT_ATTACH_DEVCOMM;

// Gets the current equipment serial number, corresponding CLIENT_QueryDevState() Interface's DH_DEVSTATE_GET_COMM_COUNT command parameter 
typedef struct tagNET_GET_COMM_COUNT
{
    DWORD          dwSize;
    int            nChannelCout;                    // Number Of Accessed serial port
}NET_GET_COMM_COUNT;

// CLIENT_ExChangeData  port input  structure 
typedef struct tagNET_IN_EXCHANGEDATA
{
    DWORD           dwSize;
    int             nChannel;                       // serial port no
    BOOL            bFlag;                          // TRUE is to send data and wait for response, FALSE is to collect data
    int             nCollectTime;                   // Serial collection time length(unit:ms)
    int             nSendDataLength;                // send data length, bFlag = TRUE valid
    unsigned char*  pSendData;                      // send data content, bFlag = TRUE valid
}NET_IN_EXCHANGEDATA;

// CLIENT_ExChangeData port output  structure 
typedef struct tagNET_OUT_EXCHANGEDATA
{
    DWORD           dwSize;
}NET_OUT_EXCHANGEDATA;

// PTZ preset
typedef struct tagNET_PTZ_PRESET 
{
    int                     nIndex;                         // no.
    char                    szName[PTZ_PRESET_NAME_LEN];    // name
    char                    szReserve[64];                  // reserve 64 bytes
} NET_PTZ_PRESET;

// PTZ preset list
typedef struct tagNET_PTZ_PRESET_LIST 
{
    DWORD                   dwSize;
    DWORD                   dwMaxPresetNum;                 // preset max
    DWORD                   dwRetPresetNum;                 // return preset quantity
    NET_PTZ_PRESET          *pstuPtzPorsetList;             // preset list(apply according to max quantity),the space appliacation by the user,apply to sizeof(NET_PTZ_PRESET)*dwMaxPresetNum
} NET_PTZ_PRESET_LIST;

// event type EVENT_IVS_TRAFFIC_RESTRICTED_PLATE (limited plate event)corresponding data module description info
typedef struct tagDEV_EVENT_TRAFFIC_RESTRICTED_PLATE
{
    int                     nChannelID;                     // channel no.
    char                    szName[DH_EVENT_NAME_LEN];      // event name
    int                     nTriggerType;                   // TriggerType:, 0 vehicle detector, 1 radar, 2 video
    DWORD                   PTS;                            // time stamp(unit is ms)
    NET_TIME_EX             UTC;                            // event time
    int                     nEventID;                       // event ID
    int                     nSequence;                      // snapshot no., as 3,2,1,1 means snapshot end,0 means abnormal end
    BYTE                    byEventAction;                  // event action, 0 means impulse event,1 means continuous event start,2 means continuous event end;
    BYTE                    byImageIndex;                   // picture no., same time(to second)may have many pictures, from 0
    BYTE                    byReserved1[2];
    int                     nLane;                          // corresponding lane no.
    DH_MSG_OBJECT           stuObject;                      // detect object
    DH_MSG_OBJECT           stuVehicle;                     // vehicle info
    DH_EVENT_FILE_INFO      stuFileInfo;                    // event corresponding file info
    int                     nMark;                          // basic level generated trigger snapshot frame mark
    int                     nFrameSequence;                 // video analysis frame no.
    int                     nSource;                        // video analysis data surce address
    DWORD                   dwSnapFlagMask;                 // snapshot mark (by bit), see NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO      stuResolution;                  // corresponding picture resolution
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;        // traffic vehicle info
    NET_GPS_INFO            stuGPSInfo;                     // GPS info ,use in mobile DVR/NVR
    BYTE                    byReserved[984];                // reserve text
    EVENT_COMM_INFO         stCommInfo;                     // public info 
}DEV_EVENT_TRAFFIC_RESTRICTED_PLATE;

// event type EVENT_IVS_TRAFFIC_OVERSTOPLINE (cross line event)corresponding to data module info
typedef struct tagDEV_EVENT_TRAFFIC_OVERSTOPLINE
{
    int                     nChannelID;                     // channel no.
    char                    szName[DH_EVENT_NAME_LEN];      // event name
    int                     nTriggerType;                   // TriggerType: trigger type, 0 detect, 1 radar, 2 video
    DWORD                   PTS;                            // time stamp( unit is ms)
    NET_TIME_EX             UTC;                            // event time
    int                     nEventID;                       // event ID
    int                     nSequence;                      // snapshot no.
    BYTE                    byEventAction;                  // event action, 
    BYTE                    byImageIndex;                   // picture no., within same time, may have more than one picture, start ftom 0
    BYTE                    byReserved1[2];
    int                     nLane;                          // corresponding to lane no.
    DH_MSG_OBJECT           stuObject;                      // detected object
    DH_MSG_OBJECT           stuVehicle;                     // vehicle body info
    DH_EVENT_FILE_INFO      stuFileInfo;                    // event corresponding to text
    int                     nMark;                          // bottom trigger snapshot frame mark
    int                     nFrameSequence;                 // video analysis no.
    int                     nSource;                        // video analysis data source address
    DWORD                   dwSnapFlagMask;                 // snapshot maek, see NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO      stuResolution;                  // corresponding to picture resolution
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;        // traffic vehicle info
    int                     nSpeed;                         // vehicle speed,Km/h
    NET_GPS_INFO            stuGPSInfo;                     // GPS info ,use in mobile DVR/NVR
    BYTE                    byReserved[984];                // reserved text
    EVENT_COMM_INFO         stCommInfo;                     // public info 
}DEV_EVENT_TRAFFIC_OVERSTOPLINE;



// event type EVENT_IVS_TRAFFIC_WITHOUT_SAFEBELT(Traffic unfasten seat belt event event )corresponding to data block description info 
typedef struct tagDEV_EVENT_TRAFFIC_WITHOUT_SAFEBELT
{
    int           nChannelID;					// channel no.
    char          szName[DH_EVENT_NAME_LEN];    // event name 
    int           nTriggerType;                 // TriggerType:trigger type , 0 vehicle detector, 1 radar, 2 video
    DWORD         PTS;                          // time stamp(unit is ms)
    NET_TIME_EX   UTC;                          // event occurred time
    int           nEventID;                     // event ID
    int           nSequence;                    // means snaoshot no., as 3,2,1,1 means snapshotend ,0 means abnormal end
    BYTE          byEventAction;                // event  motion , 0 means pulse event ,1 means  continuity  event  start ,2 means  continuity  event end;  BYTE          byReserved1[2];
    BYTE          byImageIndex;                 // picture no., same time(accurate to second)may have multiple pictures , start from 0 
    BYTE          byReserved1[2];
    DH_EVENT_FILE_INFO   stuFileInfo;           // event corresponding to file info 
    int           nLane;                        // corresponding to lane no.
    int           nMark;                        // bottom generated trigger snapshot frame mark
    int           nFrameSequence;               // video analysis frame no.
    int           nSource;                      // video analysis data source address
    DH_MSG_OBJECT      stuObject;               // detection object 
    DH_MSG_OBJECT      stuVehicle;              // body info 
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;    // Traffic vehicle info 
    int           nSpeed;                       // vehicle actual speed,Km/h
    NET_SAFEBELT_STATE   emMainSeat;            // main driver seat belt status 
    NET_SAFEBELT_STATE   emSlaveSeat;           // co-drvier seat belt status 
    DWORD         dwSnapFlagMask;               // snapshot mark(by bit), see NET_RESERVED_COMMON  
    DH_RESOLUTION_INFO   stuResolution;         // corresponding to picture resolution
    NET_GPS_INFO        stuGPSInfo;             // GPS info ,use in mobile DVR/NVR
    BYTE          byReserved[984];              // reserved text
    EVENT_COMM_INFO     stCommInfo;             // public info 
}DEV_EVENT_TRAFFIC_WITHOUT_SAFEBELT;

// event type EVENT_IVS_TRAFFIC_DRIVER_SMOKING (driver smoke event )corresponding to data block description info 
typedef struct tagDEV_EVENT_TRAFFIC_DRIVER_SMOKING
{
    int                 nChannelID;                     // channel no.
    char                szName[DH_EVENT_NAME_LEN];      // event name 
    int                 nTriggerType;                   // TriggerType: trigger type , 0 vehicle detector, 1 radar, 2 video
    DWORD               PTS;                            // time stamp(unit is ms)
    NET_TIME_EX         UTC;                            // event occurred time
    int                 nEventID;                       // event ID
    int                 nSequence;                      // means snapshot no.,  as 3,2,1,1 means snapshot end,0 means abnormal end
    BYTE                byEventAction;                  // event  motion , 0 means pulse  event ,1 means  continuity  event  start ,2 means  continuity  event end;  BYTE          byReserved1[2];
    BYTE                byImageIndex;                   // picture no., same time(accurate to second) may be multiple pictures , start from 0  
    BYTE                byReserved1[2];
    DH_EVENT_FILE_INFO  stuFileInfo;                    // event corresponding to file info 
    int                 nLane;                          // corresponding to lane no.
    int                 nMark;                          // bottom occurred trigger snapshot mark
    int                 nFrameSequence;                 // video analysis frame no.
    int                 nSource;                        // video analysis data source address
    DH_MSG_OBJECT       stuObject;                      // detection received object 
    DH_MSG_OBJECT       stuVehicle;                     // body info 
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;    // Traffic vehicle info 
    int                 nSpeed;                         // car actual speed,Km/h
    DWORD               dwSnapFlagMask;                 // snapshot mark(by bit), see NET_RESERVED_COMMON  
    DH_RESOLUTION_INFO  stuResolution;                  // corresponding to picture resolution
    EVENT_COMM_INFO     stCommInfo;                     // public info 
    NET_GPS_INFO        stuGPSInfo;                     // GPS info ,use in mobile DVR/NVR
    char                szDriverID[32];                 // driver ID
    BYTE                byReserved[952];                // reserve text
}DEV_EVENT_TRAFFIC_DRIVER_SMOKING;

// event type EVENT_IVS_TRAFFIC_DRIVER_CALLING(driver call event )corresponding to data block description info 
typedef struct tagDEV_EVENT_TRAFFIC_DRIVER_CALLING
{
    int           nChannelID;                   // channel no.
    char          szName[DH_EVENT_NAME_LEN];    // event name 
    int           nTriggerType;                 // TriggerType: trigger type , 0 vehicle detector, 1 radar, 2 video
    DWORD         PTS;                          // time stamp(unit is ms)
    NET_TIME_EX   UTC;                          // event occurred time
    int           nEventID;                     // event ID
    int           nSequence;                    // means snapshot no., as 3,2,1,1 means snapshot end,0 means abnormal end
    BYTE          byEventAction;                // event  motion , 0 means pulse  event ,1 means  continuity  event  start ,2 means  continuity  event end;  BYTE          byReserved1[2];
    BYTE          byImageIndex;                 // picture no., same time (accurate to second) maybe multiple picture , start from 0  
    BYTE          byReserved1[2];
    DH_EVENT_FILE_INFO   stuFileInfo;           // event corresponding to file info 
    int           nLane;                        // corresponding to lane no.
    int           nMark;                        // bottom trigger snapshot frame mark
    int           nFrameSequence;               // video analysis frame no.
    int           nSource;                      // video analysis data source address
    DH_MSG_OBJECT      stuObject;               // detection received object 
    DH_MSG_OBJECT      stuVehicle;              // body info 
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;    // Traffic vehicle info 
    int           nSpeed;                       // vehicle actual speed,Km/h
    DWORD         dwSnapFlagMask;               // snapshot mark(by bit), see NET_RESERVED_COMMON  
    DH_RESOLUTION_INFO   stuResolution;         // corresponding to picture resolution
    EVENT_COMM_INFO     stCommInfo;             // public info 
    NET_GPS_INFO        stuGPSInfo;             // GPS info ,use in mobile DVR/NVR
    char                szDriverID[32];         // driver ID
    BYTE                byReserved[952];        // reserve text
}DEV_EVENT_TRAFFIC_DRIVER_CALLING;

// event type EVENT_IVS_OBJECT_DETECTION(object feature detection event )corresponding to data description info 
typedef struct tagDEV_EVENT_TRAFFIC_OBJECT_DETECTION
{
    int	        nChannelID;                     // channel no.
    char        szName[128];                    // event name 
    char        bReserved1[4];                  // field align
    double      PTS;                            // time stamp(unit is ms)
    NET_TIME_EX UTC;                        	// event occurred time
    int         nEventID;                       // event ID
    DH_EVENT_FILE_INFO stuFileInfo;             // event corresponding to file info 
    BYTE        bEventAction;                   // event  motion , 0 means pulse event ,1 means  continuity  event  start ,2 means  continuity  event end;
    BYTE        byReserved[2];                  // reserved text
    BYTE        byImageIndex;                   // picture no., same time(accurate to second)may be multiple picture , start from 0 
    DWORD       dwSnapFlagMask;                 // snapshot mark(by bit), see NET_RESERVED_COMMON  
    int         nSourceIndex;                   // event source device index,-1 means data invalid
    char        szSourceDevice[MAX_PATH];       // event source device SN, field does not exist or null means local device 
    unsigned int    nOccurrenceCount;           // event trigger accumilated times 
    int         nObjectNum;                     // object info number
    DH_MSG_OBJECT_EX  *pstObjectInfo;           // object info data 
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // public info 
    BYTE        byReserved2[892];              	// reserved text
}DEV_EVENT_TRAFFIC_OBJECT_DETECTION;

// redundant power abnormal alarm
typedef struct tagALARM_POWER_ABNORMAL_INFO
{
    DWORD                   dwSize;
    int                     nChannelID;                     // channel no.
    NET_TIME                stuTime;                        // time
    DWORD                   dwAction;                       // event ation, 0:Start, 1:Stop
}ALARM_POWER_ABNORMAL_INFO;

// Tri-status enable
typedef enum tagNET_THREE_STATE_ENABLE
{
    EM_STATE_ENABLE_INVALID = 0,            // invalid
    EM_STATE_ENABLE_OFF,                    // off
    EM_STATE_ENABLE_ON,                     // on
} NET_THREE_STATE_ENABLE;

// config enable change reported event
typedef struct tagCONFIG_ENABLE_CHANGE_INFO
{
    DWORD                   dwSize;
    int                     nChannelID;                     // chanle no., start from 0
    NET_THREE_STATE_ENABLE  emMotionDetect;                 // motion detect,     0: invalid , 1: off, 2: on
	NET_THREE_STATE_ENABLE  emLossDetect;                   // video loss enable, 0: invalid , 1: off, 2: on	NET_THREE_STATE_ENABLE  emBlindDetect;                  // video tempering enable, 0: invalid , 1: off, 2: on	NET_THREE_STATE_ENABLE  emAlarmLocal;                   // external alarm enable, 0: invalid , 1: off, 2: on
	NET_THREE_STATE_ENABLE  emBlindDetect;                  // blind detect enable, 0: invalid , 1: off, 2: on
	NET_THREE_STATE_ENABLE  emAlarmLocal;                   // alarm local enable, 0: invalid , 1: off, 2: on
}ALARM_CONFIG_ENABLE_CHANGE_INFO;

// ITC HWS000 IT TYPE
typedef enum tagEM_ITC_HWS000_IT_TYPE
{
    EM_ITC_HWS000_IT_TYPE_UNKNOWN,      // unknown
    EM_ITC_HWS000_IT_TYPE_HIGH_SPEED,   // high speed
    EM_ITC_HWS000_IT_TYPE_LOW_SPEED,    // low speed
}EM_ITC_HWS000_IT_TYPE;

// ITC HWS000 RS TYPE
typedef enum tagEM_ITC_HWS000_RS_TYPE
{
    EM_ITC_HWS000_RS_TYPE_UNKNOWN,      // unknown
    EM_ITC_HWS000_RS_TYPE_ONLINE,       // online
    EM_ITC_HWS000_RS_TYPE_OFFLINE,      // offline
}EM_ITC_HWS000_RS_TYPE;

// ITC HWS000 FS TYPE
typedef enum tagEM_ITC_HWS000_FS_TYPE
{
    EM_ITC_HWS000_FS_TYPE_UNKNOWN,     // unknown
    EM_ITC_HWS000_FS_TYPE_ONLINE,      // online
    EM_ITC_HWS000_FS_TYPE_OFFLINE,     // offline
}EM_ITC_HWS000_FS_TYPE;

// the alarm event for ITC_HWS000
typedef struct tagALARM_ITC_HWS000
{
    DWORD dwSize;
    EM_ITC_HWS000_IT_TYPE emItType;   // the type of breaking rules
    EM_ITC_HWS000_RS_TYPE emRsType;   // the type of radar state
    EM_ITC_HWS000_FS_TYPE emFsType;   // the type of flashlight state
    int nOcNum;                       // the count of high speed
    int nLcNum;                       // the count of low speed
    int nAcNum;                       // the count of breaking rules
    int nFcNum;                       // the count of light flash
}ALARM_ITC_HWS000;

// car status
typedef enum tagEM_CAR_COME_STATUS
{
    EM_CAR_COME_STATUS_UNKNOWN,                         //unknown
    EM_CAR_COME_STATUS_COME_IN,                         //come in
    EM_CAR_COME_STATUS_COME_OUT,                        //come out
}EM_CAR_COME_STATUS;

// the event of telephonenumber check
typedef struct tagALARM_TELEPHONE_CHECK_INFO
{
    DWORD                       dwSize; 
    EM_CAR_COME_STATUS          emCarStatus;               //car status
    char                        szTelephoneNum[32];        //telephone number
}ALARM_TELEPHONE_CHECK_INFO;

#define UPDATE_VERSION_LEN        64

// get device upgrade status corresponding structure 
typedef struct tagDHDEV_UPGRADE_STATE_INFO
{
    int                  nState;                            // 0:None- no update found, default status; 1:Regular-general upgrade; 
                                                            // 2:Emergency-forced; 3:Upgrading-upgrading
    
    char                szOldVersion[UPDATE_VERSION_LEN];   // old version
    char                szNewVersion[UPDATE_VERSION_LEN];   // new version
    DWORD               dwProgress;                         // upgrading progress
    int                 reserved[256];                      // reserve text
}DHDEV_UPGRADE_STATE_INFO;

// Warning line intrusion direction 
typedef enum tagNET_CROSSLINE_DIRECTION_INFO
{
    EM_CROSSLINE_DIRECTION_UNKNOW = 0 , 
    EM_CROSSLINE_DIRECTION_LEFT2RIGHT ,   //From left to right
    EM_CROSSLINE_DIRECTION_RIGHT2LEFT ,   //From right to left
    EM_CROSSLINE_DIRECTION_ANY        ,   
}NET_CROSSLINE_DIRECTION_INFO;

// Warning line event (Corresponding to event  DH_EVENT_CROSSLINE_DETECTION)
typedef struct tagALARM_EVENT_CROSSLINE_INFO
{
    DWORD                           dwSize;                         
    int					            nChannelID;						// Channel No.
    double				            PTS;							// Time stamp (Unit is ms)
    NET_TIME_EX			            UTC;							// Event occurrence time 
    int					            nEventID;						// Event ID
    int                             nEventAction;                   // Event operation. 0=pulse event.1=continious event begin. 2=continuous event stop

    NET_CROSSLINE_DIRECTION_INFO    emCrossDirection;               // Intrusion direction 
    int                             nOccurrenceCount;               // Triggered amount 
    int                             nLevel;                         // Event type
	BOOL							bIsObjectInfo;					// Target information detection enablement
	DH_MSG_OBJECT			        stuObject;                      // Object information detected
	int								nRetObjectNum;						// Actually returns multiple detected object information
	DH_MSG_OBJECT			        stuObjects[MAX_TARGET_OBJECT_NUM];  // Multiple detected object information
}ALARM_EVENT_CROSSLINE_INFO;

// Move detection event(Corresponding to event  DH_ALARM_MOVEDETECTION)
typedef struct tagALARM_MOVE_DETECTION_INFO
{
	int                             nAction;                   		// Event operation. 0=pulse event.1=start. 2=stop
	int					            nChannelID;						// Channel No.
    double				            dbPTS;							// Time stamp (Unit is ms)
    NET_TIME_EX			            stuTime;						// Event occurrence time 
    int					            nEventID;						// Event ID

	int								nCount;							// Triggered amount 
	BYTE                 			byReserved[1024];               // reserve text
} ALARM_MOVE_DETECTION_INFO;

// WanderDetection event(Corresponding to event  DH_ALARM_WANDERDETECTION)
typedef struct tagALARM_WANDERDETECTION_INFO
{
	int                             nAction;                   		// Event operation. 0=pulse event.1=start. 2=stop
	int					            nChannelID;						// Channel No.
    double				            dbPTS;							// Time stamp (Unit is ms)
    NET_TIME_EX			            stuTime;						// Event occurrence time 
    int					            nEventID;						// Event ID

	int 							nCount;							// Triggered amount 
	int								nLevel;							// event level
	short							nPreserID;						// Event triggered preset period, starting from 1 (no unknown)
	char							szPresetName[64];				// Preset name for event triggered
	BYTE                 			byReserved[958];                // reserve text
} ALARM_WANDERDETECTION_INFO;

// Cross fencedetection event(Corresponding to event  DH_ALARM_CROSSFENCEDETECTION)
typedef struct tagALARM_CROSSFENCEDETECTION_INFO
{
	int                             nAction;                   		// Event operation. 0=pulse event.1=start. 2=stop
	int					            nChannelID;						// Channel No.
    double				            dbPTS;							// Time stamp (Unit is ms)
    NET_TIME_EX			            stuTime;						// Event occurrence time 
    int					            nEventID;						// Event ID

	NET_CROSSLINE_DIRECTION_INFO	emCrossDirection;               // Intrusion direction 
	int 							nCount;							// Triggered amount 
	BYTE                			byReserved[1024];   			// reserve text
} ALARM_CROSSFENCEDETECTION_INFO;

// red light event(Corresponding to event  ALARM_TRAFFIC_PEDESTRIAN_RUN_REDLIGHT_DETECTION_INFO)
typedef struct tagALARM_TRAFFIC_PEDESTRIAN_RUN_REDLIGHT_DETECTION_INFO
{
	int                             nAction;                   		// Event operation. 0=pulse event.1=start. 2=stop
	int					            nChannelID;						// Channel No.
    double				            dbPTS;							// Time stamp (Unit is ms)
    NET_TIME_EX			            stuTime;						// Event occurrence time 
    int					            nEventID;						// Event ID
	BYTE                			byReserved[1024];   			// reserve text
} ALARM_TRAFFIC_PEDESTRIAN_RUN_REDLIGHT_DETECTION_INFO;

//fight detection event(Corresponding to event  DH_ALARM_FIGHTDETECTION)
typedef struct tagNET_ALARM_FIGHTDETECTION
{	
	int                             nAction;                   		// Event operation, 0:Start, 1:Stop
	int					            nChannelID;						// Channel No., start from 0
    double				            dbPTS;							// Time stamp (Unit is ms)
    NET_TIME_EX			            stuTime;						// Event occurrence time 
	NET_EXTENSION_INFO              stuExtensionInfo;				// Extension info
	BYTE                			byReserved[892];   			    // reserve text
}NET_ALARM_FIGHTDETECTION;

#define VTO_BUILDING_LEN			8
#define VTO_UNIT_LEN				8

//VTO access identify(Corresponding to event DH_ALARM_ACCESSIDENTIFY)
typedef struct tagNET_ALARM_ACCESSIDENTIFY_INFO
{	
    NET_TIME_EX			            stuTime;						 // Event occurrence time     
	char 							szVTOBuilding[VTO_BUILDING_LEN]; // VTO building no
	char 							szVTOUnit[VTO_UNIT_LEN];		 // VTO uinit no 
	BYTE                			byReserved[1024];   			 // reserve text
}NET_ALARM_ACCESSIDENTIFY_INFO;

// call no answer event, under directly connected(Corresponding to event DH_ALARM_CALL_NO_ANSWERED)
typedef struct tagNET_ALARM_CALL_NO_ANSWERED_INFO
{
	NET_TIME_EX			            stuTime;						 // Event occurrence time 
	char 							szCallID[MAX_CALL_ID_LEN];		 // Call ID
	int                             nAction;						 // Event operation. 1=start. 2=stop
	int					            nChannelID;						 // Channel ID
	BYTE                			byReserved[1016];   			 // reserve text
} NET_ALARM_CALL_NO_ANSWERED_INFO;

// parking detection event(Corresponding to event  DH_ALARM_PARKINGDETECTION)
typedef struct tagALARM_PARKINGDETECTION_INFO
{
	int                             nAction;                   		// Event operation. 0=pulse event.1=start. 2=stop
	int					            nChannelID;						// Channel No.
    double				            dbPTS;							// Time stamp (Unit is ms)
    NET_TIME_EX			            stuTime;						// Event occurrence time 
    int					            nEventID;						// Event ID

	int 							nCount;							// Triggered amount 
	BYTE                			byReserved[1024];   			// reserve text
} ALARM_PARKINGDETECTION_INFO;

// Rioter detection event(Corresponding to event  DH_ALARM_RIOTERDETECTION)
typedef struct tagALARM_RIOTERDETECTION_INFO
{
	int                             nAction;                   		// Event operation. 0=pulse event.1=start. 2=stop
	int					            nChannelID;						// Channel No.
    double				            dbPTS;							// Time stamp (Unit is ms)
    NET_TIME_EX			            stuTime;						// Event occurrence time 
    int					            nEventID;						// Event ID

	int 							nCount;							// Triggered amount 
	BYTE                			byReserved[1024];   			// reserve text
} ALARM_RIOTERDETECTION_INFO;

//  traffic parking event(Corresponding to event  DH_ALARM_TRAFFIC_PARKING)
typedef struct tagALARM_TRAFFIC_PARKING_INFO 
{
	int                             nAction;                   		// Event operation. 0=pulse event.1=start. 2=stop
	int					            nChannelID;						// Channel No.
    double				            dbPTS;							// Time stamp (Unit is ms)
    NET_TIME_EX			            stuTime;						// Event occurrence time 
    int					            nEventID;						// Event ID

	BYTE                			byReserved[1024];   			// reserve text
} ALARM_TRAFFIC_PARKING_INFO;


// traffic jam event(Corresponding to event  DH_ALARM_TRAFFIC_JAM)
typedef struct tagALARM_TRAFFIC_JAM_INFO 
{
	int                             nAction;                   		// Event operation. 0=pulse event.1=start. 2=stop
	int					            nChannelID;						// Channel No.
    double				            dbPTS;							// Time stamp (Unit is ms)
    NET_TIME_EX			            stuTime;						// Event occurrence time 
    int					            nEventID;						// Event ID

	BYTE                			byReserved[1024];   			// reserve text
} ALARM_TRAFFIC_JAM_INFO;

// traffic pedestrain event(Corresponding to event  DH_ALARM_TRAFFIC_PEDESTRAIN)
typedef struct tagALARM_TRAFFIC_PEDESTRAIN_INFO
{
	int                             nAction;                   		// Event operation. 0=pulse event.1=start. 2=stop
	int					            nChannelID;						// Channel No.
    double				            dbPTS;							// Time stamp (Unit is ms)
    NET_TIME_EX			            stuTime;						// Event occurrence time 
    int					            nEventID;						// Event ID

	BYTE                			byReserved[1024];   			// reserve text
} ALARM_TRAFFIC_PEDESTRAIN_INFO;

// traffic throw event(Corresponding to event  DH_ALARM_TRAFFIC_THROW)
typedef struct tagALARM_TRAFFIC_THROW_INFO
{
	int                             nAction;                   		// Event operation. 0=pulse event.1=start. 2=stop
	int					            nChannelID;						// Channel No.
    double				            dbPTS;							// Time stamp (Unit is ms)
    NET_TIME_EX			            stuTime;						// Event occurrence time 
    int					            nEventID;						// Event ID

	BYTE                			byReserved[1024];   			// reserve text
} ALARM_TRAFFIC_THROW_INFO;

// traffic retrograde event(Corresponding to event  DH_ALARM_TRAFFIC_RETROGRADE)
typedef struct tagALARM_TRAFFIC_RETROGRADE_INFO
{
	int                             nAction;                   		// Event operation. 0=pulse event.1=start. 2=stop
	int					            nChannelID;						// Channel No.
    double				            dbPTS;							// Time stamp (Unit is ms)
    NET_TIME_EX			            stuTime;						// Event occurrence time 
    int					            nEventID;						// Event ID
 
	BYTE                			byReserved[1024];   			// reserve text
} ALARM_TRAFFIC_RETROGRADE_INFO;

// traffic overspeed event(Corresponding to event  DH_ALARM_TRAFFIC_OVERSPEED)
typedef struct tagALARM_TRAFFIC_OVERSPEED_INFO 
{
	int                             nAction;                   		// Event operation. 0=pulse event.1=start. 2=stop
	int					            nChannelID;						// Channel No.
    double				            dbPTS;							// Time stamp (Unit is ms)
    NET_TIME_EX			            stuTime;						// Event occurrence time 
    int					            nEventID;						// Event ID

	int								nSpeed;							// car speed
	int								nSpeedUpperLimit;				// speed upper limit
	int								nSpeedLowerLimit;				// speed lower limit
	BYTE                			byReserved[1024];   			// reserve text
} ALARM_TRAFFIC_OVERSPEED_INFO;

// traffic underspeed event(Corresponding to event  DH_ALARM_TRAFFIC_UNDERSPEED)
typedef struct tagALARM_TRAFFIC_UNDERSPEED_INFO 
{
	int                             nAction;                   		// Event operation. 0=pulse event.1=start. 2=stop
	int					            nChannelID;						// Channel No.
    double				            dbPTS;							// Time stamp (Unit is ms)
    NET_TIME_EX			            stuTime;						// Event occurrence time 
    int					            nEventID;						// Event ID

	int								nSpeed;							// car speed
	int								nSpeedUpperLimit;				// speed upper limit
	int								nSpeedLowerLimit;				// speed lower limit
	BYTE                			byReserved[1024];   			// reserve text
} ALARM_TRAFFIC_UNDERSPEED_INFO;


//retrogade detection event (Corresponding to event DH_ALARM_RETROGRADE_DETECTION)
typedef struct tagALARM_RETROGRADE_DETECTION_INFO
{
	int                             nAction;                   		// Event operation. 0=pulse event.1=start. 2=stop
	int					            nChannelID;						// Channel No.
    double				            dbPTS;							// Time stamp (Unit is ms)
    NET_TIME_EX			            stuTime;						// Event occurrence time 
    int					            nEventID;						// Event ID
	int 							nCount;							// Triggered amount 
	BYTE                			byReserved[1024];   			// reserve text
} ALARM_RETROGRADE_DETECTION_INFO;




// AIO App config(Corresponding to event DH_ALARM_AIO_APP_CONFIG_EVENT)
typedef struct tagALARM_AIO_APP_CONFIG_EVENT_INFO
{
	NET_TIME_EX			            stuTime;							// Event occurrence time 
	char 							szAddress[DH_MAX_IPADDR_LEN];		// ip address
	BYTE                			byReserved[1024];   				// reserve text
}ALARM_AIO_APP_CONFIG_EVENT_INFO;


//DH_ALARM_BOX(Corresponding to DH_ALARM_BOX)
typedef struct tagALARM_BOX_INFO
{
	int                             nAction;                   		// Event operation. 1=start. 2=stop
    double				            dbPTS;							// Time stamp (Unit is ms)
    NET_TIME_EX			            stuTime;						// Event occurrence time 
    int					            nEventID;						// 
	
	int 							nAlarmBoxIndex;					// alarm box index, start from 0
	int								nAlarmIndex;					// alarm box inside channel, start from 0
	BYTE                			byReserved[1024];   			// reserved
} ALARM_BOX_INFO;

// under voltage alarm ( Corresponding to event DH_ALARM_UNDER_VOLTAGE )
typedef struct tagALARM_UNDER_VOLTAGE_INFO
{
    int                             nAction;                   		// Event operation. 1=start. 2=stop
    int					            nChannelID;						// Channel
    double				            dbPTS;							// Time stamp (Unit is ms)
    NET_TIME_EX			            stuTime;						// Event occurrence time 
    int					            nEventID;						// Event ID
    BYTE                			byReserved[512];       			// Reserved
}ALARM_UNDER_VOLTAGE_INFO;

// over voltage alarm ( Corresponding to event DH_ALARM_OVER_VOLTAGE )
typedef struct tagALARM_OVER_VOLTAGE_INFO
{
    int                             nAction;                   		// Event operation. 1=start. 2=stop
    int					            nChannelID;						// Channel
    double				            dbPTS;							// Time stamp (Unit is ms)
    NET_TIME_EX			            stuTime;						// Event occurrence time 
    int					            nEventID;						// Event ID
    BYTE                			byReserved[512];       			// Reserved  
}ALARM_OVER_VOLTAGE_INFO;

// alarm of tired physiological ( Corresponding to event DH_ALARM_TIRED_PHYSIOLOGICAL )
typedef struct tagALARM_TIRED_PHYSIOLOGICAL
{
    int                             nAction;                   		// Event operation. 0=pulse event. 1=start. 2=stop
    int					            nChannelID;						// Channel
    double				            dbPTS;							// Time stamp (Unit is ms)
    NET_TIME_EX			            stuTime;						// Event occurrence time 
    int					            nEventID;						// Event ID

	NET_GPS_STATUS_INFO				stuGPSStatus;					// GPS info
    BYTE                			byReserved[512];       			// Reserved    
} ALARM_TIRED_PHYSIOLOGICAL;


// alarm of calling when driver ( Corresponding to event DH_ALARM_CALLING_WHEN_DRIVING )
typedef struct tagALARM_CALLING_WHEN_DRIVING
{
    int                             nAction;                   		// Event operation. 0=pulse event. 1=start. 2=stop
    int					            nChannelID;						// Channel
    double				            dbPTS;							// Time stamp (Unit is ms)
    NET_TIME_EX			            stuTime;						// Event occurrence time 
    int					            nEventID;						// Event ID

	NET_GPS_STATUS_INFO				stuGPSStatus;					// GPS info
    BYTE                			byReserved[512];       			// Reserved     
} ALARM_CALLING_WHEN_DRIVING;


// alarm of traffic driver smoking ( Corresponding to event DH_ALARM_TRAFFIC_DRIVER_SMOKING )
typedef struct tagALARM_TRAFFIC_DRIVER_SMOKING
{
    int                             nAction;                   		// Event operation. 0=pulse event. 1=start. 2=stop
    int					            nChannelID;						// Channel
    double				            dbPTS;							// Time stamp (Unit is ms)
    NET_TIME_EX			            stuTime;						// Event occurrence time 
    int					            nEventID;						// Event ID

	NET_GPS_STATUS_INFO				stuGPSStatus;					// GPS info
    BYTE                			byReserved[512];       			// Reserved      
} ALARM_TRAFFIC_DRIVER_SMOKING;


// alarm of traffic driver lower head ( Corresponding to event DH_ALARM_TRAFFIC_DRIVER_LOWER_HEAD )
typedef struct tagALARM_TRAFFIC_DRIVER_LOWER_HEAD
{
    int                             nAction;                   		// Event operation. 0=pulse event. 1=start. 2=stop
    int					            nChannelID;						// Channel
    double				            dbPTS;							// Time stamp (Unit is ms)
    NET_TIME_EX			            stuTime;						// Event occurrence time 
    int					            nEventID;						// Event ID

	NET_GPS_STATUS_INFO				stuGPSStatus;					// GPS info
    BYTE                			byReserved[512];       			// Reserved      
} ALARM_TRAFFIC_DRIVER_LOWER_HEAD;


// alarm of traffic driver look around ( Corresponding to event DH_ALARM_TRAFFIC_DRIVER_LOOK_AROUND )
typedef struct tagALARM_TRAFFIC_DRIVER_LOOK_AROUND
{
    int                             nAction;                   		// Event operation. 0=pulse event. 1=start. 2=stop
    int					            nChannelID;						// Channel
    double				            dbPTS;							// Time stamp (Unit is ms)
    NET_TIME_EX			            stuTime;						// Event occurrence time 
    int					            nEventID;						// Event ID

	NET_GPS_STATUS_INFO				stuGPSStatus;					// GPS info
    BYTE                			byReserved[512];       			// Reserved       
} ALARM_TRAFFIC_DRIVER_LOOK_AROUND;


// alarm of traffic driver leave post ( Corresponding to event DH_ALARM_TRAFFIC_DRIVER_LEAVE_POST )
typedef struct tagALARM_TRAFFIC_DRIVER_LEAVE_POST
{
    int                             nAction;                   		// Event operation. 0=pulse event. 1=start. 2=stop
    int					            nChannelID;						// Channel
    double				            dbPTS;							// Time stamp (Unit is ms)
    NET_TIME_EX			            stuTime;						// Event occurrence time 
    int					            nEventID;						// Event ID

	NET_GPS_STATUS_INFO				stuGPSStatus;					// GPS info
    BYTE                			byReserved[512];       			// Reserved     
} ALARM_TRAFFIC_DRIVER_LEAVE_POST;


// alarm of traffic driver yawn ( Corresponding to event DH_ALARM_TRAFFIC_DRIVER_YAWN )
typedef struct tagALARM_TRAFFIC_DRIVER_YAWN
{
    int                             nAction;                   		// Event operation. 0=pulse event. 1=start. 2=stop
    int					            nChannelID;						// Channel
    double				            dbPTS;							// Time stamp (Unit is ms)
    NET_TIME_EX			            stuTime;						// Event occurrence time 
    int					            nEventID;						// Event ID

	NET_GPS_STATUS_INFO				stuGPSStatus;					// GPS info
    BYTE                			byReserved[512];       			// Reserved       
} ALARM_TRAFFIC_DRIVER_YAWN;

// Vehicle position alarm event(DH_ALARM_TRAFFIC_VEHICLE_POSITION)
typedef struct tagALARM_TRAFFIC_VEHICLE_POSITION
{
	int             nAction;                   						// Event operation. 0=pulse event. 1=start. 2=stop
	char			szEventName[DH_COMMON_STRING_128];				// Event Name
	unsigned int	nObjectID;										// Object ID
	char			szPlateNumber[DH_COMMON_STRING_128];			// car plate Number
	int				nPosition;										// The location of the license plate and bayonet(0:capture the distance between the bayonet and the license plate, >0:cross the snap line; <0:not over the capture line)
	BYTE            byOpenStrobeState;                              // Open status, see EM_OPEN_STROBE_STATE
	BYTE			byReserved[511];       							// Reserved  
} ALARM_TRAFFIC_VEHICLE_POSITION;

// alarm of the connection status between the device and the base ( Corresponding to event DH_ALARM_MPTBASE_CONNECT )
typedef struct tagALARM_MPTBASE_CONNECT
{
	int 							nAction;						// Event operation. 1=start. 2=stop
	BYTE                			byReserved[512];       			// Reserved   
} ALARM_MPTBASE_CONNECT;

// the reason of shut down
typedef enum tagEM_SHUTDOWN_REASON_TYPE
{
	EM_SHUTDOWN_REASON_UNKNOWN, 				// unknown
	EM_SHUTDOWN_REASON_LOWERPOWER,				// lower power
	EM_SHUTDOWN_REASON_LOSTPOWER,				// lost power
	EM_SHUTDOWN_REASON_CRASH,					// system crash
} EM_SHUTDOWN_REASON_TYPE;

//alarm of CGI triggered manual video recording(Corresponding to event DH_ALARM_CGIRECORD)
typedef struct tagALARM_CGIRECORD
{
	int                             nAction;                   		// Event operation.  1=start. 2=stop
    int                             nChannelID;						// Record channel
    double                          dbPTS;							// Time stamp (Unit is ms)
    NET_TIME_EX                     stuTime;						// Event occurrence time  
    int                             nEventID;						// Event ID
	NET_TIME_EX                     stuStartTime;					// Record start time
	NET_TIME_EX                     stuStopTime;					// Record end time
	BYTE                            byReserved[512];				// Reserved bytes	 
} ALARM_CGIRECORD;

// Alarm of battery temperature(corresponding to DH_ALARM_BATTERY_TEMPERATURE)
typedef struct tagALARM_BATTERY_TEMPERATURE_INFO
{
	int					nBatteryIndex;                // Battery no
	NET_TIME_EX			stuTime;                      // Event time
	float				fTemperature;				  // Battery temperature,Unit:C	
	BYTE				byReserved[1024];			  // Reserved
}ALARM_BATTERY_TEMPERATURE_INFO;

// Alarm of tire pressure(corresponding to DH_ALARM_TIRE_PRESSURE)
typedef struct tagALARM_TIRE_PRESSURE_INFO
{
    int                             nAction;                   		// Event operation.  1=start. 2=stop
    int                             nEventID;						// Event ID    
    double                          dbPTS;							// Time stamp (Unit is ms)	
    NET_TIME_EX                     stuTime;						// Event occurrence time

    int                             nTireIndex;						// Index of tire,begin with 1
    int                             nAlarmType;                     // Alarm type,1-low Pressure ,2-high Pressure
    float                           fUpperLimit;					// upper limit of tire pressure,unit:BAR
    float                           fLowerLimit;					// lower limit of tire Pressure,unit:BAR
    float                           fCurrentPressure;               // current tire pressure,unit:BAR
    BYTE                            byReserved[512];				// Reserved		 
} ALARM_TIRE_PRESSURE_INFO;

// alarm of access event form blacklist,Corresponding to DH_ALARM_ACCESS_CTL_BLACKLIST
typedef struct tagALARM_ACCESS_CTL_BLACKLIST
{
    int                             nChannel;                                          // channel
    char                            szAccessName[DH_COMMON_STRING_64];                 // accesscontrol name
    char                            szUserID[DH_COMMON_STRING_32];                     // user id
    char                            szCardNo[DH_COMMON_STRING_64];                     // card number
    char                            szCitizenIDNo[20];                                 // citizen id
    BYTE                			byReserved[512];       			                   // Reserved
}ALARM_ACCESS_CTL_BLACKLIST;

// alarm of unauthorized maliciouswip,Corresponding to DH_ALARM_ACCESS_CTL_UNAUTHORIZED_MALICIOUSWIP
typedef struct tagALARM_ACCESS_CTL_UNAUTHORIZED_MALICIOUSWIP
{
    int                             nChannel;                           // channel
    char                            szDoorName[DH_MAX_DOORNAME_LEN];    // name
    char						    szUserID[MAX_COMMON_STRING_16];		// user id
    char                            szCardNo[DH_COMMON_STRING_64];      // card number
    NET_TIME_EX			            stuTime;						    // Event occurrence time
    BYTE                			byReserved[476];  
}ALARM_ACCESS_CTL_UNAUTHORIZED_MALICIOUSWIP;

// , DH_ALARM_USERLOCK
typedef struct tagALARM_USERLOCK_INFO
{	
	double				            dbPTS;							// Time stamp (Unit is ms)
	NET_TIME_EX			            stuTime;						// Event occurrence time
	int					            nEventID;						// Event ID    

	char							szUserName[MAX_USER_NAME_LEN];  // Username
	char							szGroup[MAX_GROUP_LEN];			// Group
	char							szIllegalLoginIP[MAX_ILLEGAL_LOGIN_IP_LEN];	// Illegal login IP
	BYTE                            byReserved[1024];				// Reserved	
}ALARM_USERLOCK_INFO;

// alarm of download remote file, Corresponding to DH_ALARM_DOWNLOAD_REMOTE_FILE
typedef struct tagALARM_DOWNLOAD_REMOTE_FILE_INFO
{	
	double				            dbPTS;							// Time stamp (Unit is ms)
	NET_TIME_EX			            stuTime;						// Event occurrence time
	int					            nEventID;						// Event ID  
	
	char							szURL[DH_COMMON_STRING_256];	// the URL address of the remote file
	UINT							nProgress;						// the progress of downloading, [0,100]	
	UINT							nVelocity;						// average download speed, unit: Kb/s
	BYTE                            byReserved[1016];				// Reserved		
}ALARM_DOWNLOAD_REMOTE_FILE_INFO;


// conflict info
typedef struct tagNET_CONFLICT_INFO 
{
	char							szSlaveMac[DH_COMMON_STRING_32];	// Slave Mac
	int								nSlaveID;							// Slave ID
	int								nSlavePort;							// Slave port
	BYTE							byReserved[64];						// Reserved
} NET_CONFLICT_INFO;

// max count of conflict info
#define	MAX_COUNT_CONFLICT	16

// Alarm of VTH Conflict(corresponding to DH_ALARM_VTH_CONFLICT)
typedef struct tagALARM_VTH_CONFLICT_INFO 
{
    int                             nAction;                   			// Event operation. 0=pulse. 1=start. 2=stop
	int                             nEventID;							// Event ID    
    double                          dbPTS;								// Time stamp (Unit is ms)
    NET_TIME_EX                     stuTime;							// Event occurrence time
	
	int								nConflictNum;						// count of conflict info
	NET_CONFLICT_INFO				stConflictInfo[MAX_COUNT_CONFLICT];	// Conflict info
	char							szVTNCNum[DH_COMMON_STRING_32];		// Video Talk Network Control Number
	char							szVTHNum[DH_COMMON_STRING_32];		// Video Talk Home Number
	BYTE                            byReserved[512];					// Reserved	
} ALARM_VTH_CONFLICT_INFO;

// alarm ot the latest status of shut down ( Corresponding to event DH_ALARM_LATEST_SHUTDOWN)
typedef struct tagALARM_LATEST_SHUTDOWN
{
	EM_SHUTDOWN_REASON_TYPE			emShutdownReason;				// the reason of shut down
	BYTE                			byReserved[512];       			// reserved 
} ALARM_LATEST_SHUTDOWN;

// alarm of distance detection (Corresponding to event DH_ALARM_DISTANCE_DETECTION)
typedef struct tagALARM_DISTANCE_DETECTION_INFO
{
	int                             nAction;                   			// Event operation. 0=pulse. 1=start. 2=stop	
	int                             nEventID;							// Event ID   
    double                          dbPTS;								// Time stamp (Unit is ms)
    int								nChannel;							// channel ID
    NET_TIME_EX                     stuTime;							// Event occurrence time
	int								nPresetID;							// preset ID
	BYTE                			byReserved[508];       				// Reserved	
} ALARM_DISTANCE_DETECTION_INFO;

// alarm of stay detection (Corresponding to event DH_ALARM_STAY_DETECTION)
typedef struct tagALARM_STAY_DETECTION_INFO
{
	int                             nAction;                   			// Event operation. 0=pulse. 1=start. 2=stop		
	int                             nEventID;							// Event ID   
    double                          dbPTS;								// Time stamp (Unit is ms)
	int								nChannel;							// Channel ID
	NET_TIME_EX                     stuTime;							// Event occurrence time
    int								nGroupId;							// Event group IDthe only id of one group file
    int								nCountInGroup;						// the file count in the current file's group
    int								nIndexInGroup;						// the index of the file in the group
    int								nCount;								// Event Attach Count
	int								nPresetID;							// Preset ID
	BYTE                			byReserved[508];       				// Reserved
} ALARM_STAY_DETECTION_INFO;


// alarm of auto inspection (Corresponding to event DH_ALARM_AUTO_INSPECTION) 
typedef struct tagALARM_AUTO_INSPECTION
{
	double				            dbPTS;							// Time stamp (Unit is ms)
	NET_TIME_EX			            stuTime;						// Event occurrence time 
	int					            nEventID;						// Event ID

	NET_TIME_EX						stuStartTime;					// start time of auto inspection
	BOOL							bCheckResult;					// Device check result,FALSE means fail,TRUE means success
	BYTE							byReserved[1024];				// Reserved
}ALARM_AUTO_INSPECTION;

// Event type
typedef enum tagEM_FACE_VERIFICATION_ACCESS_SNAP_TYPE
{
	EM_FACE_VERIFICATION_ACCESS_SNAP_TYPE_UNKNOWN,			// unknown
	EM_FACE_VERIFICATION_ACCESS_SNAP_TYPE_ENTRY,			// entry
	EM_FACE_VERIFICATION_ACCESS_SNAP_TYPE_EXIT,				// exit
}EM_FACE_VERIFICATION_ACCESS_SNAP_TYPE;

// Person info
typedef struct tagNET_PERSON_INFO
{
	BOOL			bCheckResult;					// Facial check result, TRUE means success, FALSE means fail
	char			szName[MAX_NAME_LENGTH];		// Name, This field is valid Only when bCheckResult is TRUE 
	char			szSnapURL[MAX_SNAP_URL_LEN];    // Face snap URL
	BYTE			byReserved[512];				// Reserved
}NET_PERSON_INFO;

// Good info
typedef struct tagNET_GOOD_INFO
{
	char			szCode[MAX_CODE_LEN];			    // Good code number
	char			szSnapURL[MAX_SNAP_URL_LEN];		// Good snap URL
	BYTE			byReserved[512];				    // Reserved
}NET_GOOD_INFO;

// operation type
typedef enum tagEM_OPERATION_TYPE
{
	EM_OPERATION_TYPE_UNKNOWN,					// unknown
	EM_OPERATION_TYPE_FETCH,                    // fetch good
	EM_OPERATION_TYPE_STORE,					// store good
	EM_OPERATION_TYPE_EXCHANGE,					// exchange good
	EM_OPERATION_TYPE_CHECK,					// check good				
}EM_OPERATION_TYPE;

// alarm of face verification access snap(Corresponding to event DH_ALARM_FACE_VERIFICATION_ACCESS_SNAP)
typedef struct tagALARM_FACE_VERIFICATION_ACCESS_SNAP_INFO
{
	double										dbPTS;									// Time stamp (Unit is ms)
	NET_TIME_EX									stuTime;								// Event occurrence time 
	int											nEventID;								// Event ID

	int											nRecNo;									// Record number, it is the same to record number of AccessControl event	
	EM_FACE_VERIFICATION_ACCESS_SNAP_TYPE       emEventType;							// Event type
	NET_PERSON_INFO								stuPersonInfo[MAX_PERSON_INFO_NUM];		// Person info
	int											nRetPersonInfoNum;						// return num of person info
	NET_GOOD_INFO								stuGoodInfo[MAX_GOOD_INFO_NUM];			// Good info
	int											nRetGoodInfoNum;						// return num of good info
	EM_OPERATION_TYPE							emOperation;							// operation type
	BYTE										byReserved[1020];						// Reserved
}ALARM_FACE_VERIFICATION_ACCESS_SNAP_INFO;

// alarm of video blind, (Corresponding to event DH_ALARM_VIDEOBLIND)
typedef struct  tagALARM_VIDEO_BLIND_INFO
{
	int                             nAction;                   		// Event operation. 1=start. 2=stop
    int					            nChannelID;						// channel
    double				            dbPTS;							// Time stamp (Unit is ms)
    NET_TIME_EX			            stuTime;						// Event occurrence time 
    int					            nEventID;						// Event ID
	NET_TIME_EX						stuStartTime;					// Start time,it is Reported when nAction is 2
	NET_GPS_STATUS_INFO				stuGPS;							// GPS information
    BYTE                			byReserved[1024];       		// Reserved    
} ALARM_VIDEO_BLIND_INFO;

// alarm of driver not confirm, (Corresponding to event DH_ALARM_DRIVER_NOTCONFIRM)
typedef struct tagALARM_DRIVER_NOTCONFIRM_INFO
{
	int                             nAction;                   		// Event operation. 1=start. 2=stop
	NET_TIME_EX			            stuTime;						// Event occurrence time 
    double				            dbPTS;							// Time stamp (Unit is ms)
    BYTE                			byReserved[512];       			// Reserved  
} ALARM_DRIVER_NOTCONFIRM_INFO;

// alarm of violate, (Corresponding to event DH_ALARM_VIOLATE_NO_FLY_TIME)
typedef struct tagALARM_VIOLATE_NO_FLY_TIME_INFO
{
	int                             nAction;                   		// Event operation. 1=start. 2=stop  
    NET_TIME_EX			            stuTime;						// Event occurrence time 
    double				            dbPTS;							// Time stamp (Unit is ms)

    BYTE                			byReserved[512];       			// Reserved   
}ALARM_VIOLATE_NO_FLY_TIME_INFO;

//alarm box alarm ( Corresponding to event DH_ALARM_BOX_ALARM )
typedef struct tagALARM_BOX_ALARM_INFO
{
    int                             nAction;                   		    // Event operation. 1=start. 2=stop
    int					            nChannelID;						    // Channel id
    double				            dbPTS;							    // Time stamp (Unit is ms)
    NET_TIME_EX			            stuTime;						    // Event occurrence time
    int					            nEventID;						    // Event id


    char                            szAlarmChannelName[DH_COMMON_STRING_64];   // Alarm channel name
	int								nAlarmBoxIndex;						// alarm box index
	int								nAlarmIndex;						// internal channel id of alaram box
    BYTE                			byReserved[1016];   			    // Reserved
}ALARM_BOX_ALARM_INFO;

// alarm sos alert(Corresponding to event DH_ALARM_SOSALERT)
typedef struct tagALARM_SOSALERT_INFO
{
	int								nChannelID;								// Channel id
	int								nEventID;								// Event id
	double							dbPTS;									// Time stamp (Unit is ms)
	NET_TIME_EX						stuTime;								// Event occurrence time

	char							szPlateNumber[DH_COMMON_STRING_128];	// Plate number
	NET_GPS_STATUS_INFO 			stGPSStatusInfo;						// GPS information
	BYTE							byReserved[1024];						// Reserved
}ALARM_SOSALERT_INFO;

// alarm GyroAbnormalAttitude(Corresponding to evnet DH_ALARM_GYROABNORMALATTITUDE)
typedef struct tagALARM_GYROABNORMALATTITUDE_INFO
{
	int								nAction;								// Event operation. 1=start. 2=stop
	int								nChannelID;								// Channel id
	double							dbPTS;									// Time stamp (Unit is ms)
	NET_TIME_EX						stuTime;								// Event occurrence time
	int								nEventID;								// Event id

	double							dbGyroCurRoll;							// The current roll angleuint:degree
	double							dbGyroCurPitch;							// The current pitch angleuint:degree
	double							dbGyroCurAccel;							// The current accelerationuint:m/s^2
	BYTE							byReserved[1024];						// Reserved
}ALARM_GYROABNORMALATTITUDE_INFO;

//alarm of output channel change(Corresponding to DH_ALARM_ALARMOUTPUT)
typedef struct tagALARM_ALARMOUTPUT_INFO
{
	int 							nAction;								// Event operation,1:Start 2:Stop
	NET_TIME_EX						UTC;									// Event occurrence time 
	int								nChannel;								// Channel
}ALARM_ALARMOUTPUT_INFO;

//alarm of PSTN report failure(Corresponding to DH_ALARM_PSTNREPORTFAILURE)
typedef struct tagALARM_PSTNREPORTFAILURE_INFO
{
	NET_TIME_EX 					UTC;								// Event occurrence time 
}ALARM_PSTNREPORTFAILURE_INFO;

//Fault type
typedef enum tagGSMFIELD_FAULT_TYPE
{
	GSMFIELD_FAULT_UNKNOWN,						// Unknown
	GSMFIELD_FAULT_GSMModule,					// Comunicating module offline
	GSMFIELD_FAULT_SIMCard,						// No sim card
}GSMFIELD_FAULT_TYPE;
//Alarm of Comunicating module offline or no sim card(Corresponding to DH_ALARM_NOGSMFIELD)
typedef struct tagALARM_NOGSMFIELD_INFO
{
	int								nAction;		// Event operation,1:Start 2:Stop
	NET_TIME_EX 					UTC;			// Event occurrence time 
	GSMFIELD_FAULT_TYPE			emFaultType;	// Fault type
}ALARM_NOGSMFIELD_INFO;
//Alarm of Comunicating module Video motion record alarm(Corresponding to DH_ALARM_MOTION_RECORD_ALARM)
typedef struct tagALARM_MOTION_RECORD_INFO
{
    int								nAction;			// Event operation,1:Start 2:Stop
    int                             nChannel;           // Channel
    BOOL                            bMotionIsOpen;      // Whether the video motion is opening or not
    BOOL                            bRecordIsOpen;      // Whether the record is opening or not
    BYTE                			byReserved[512];    // Reserved
}ALARM_MOTION_RECORD_INFO;
// alarm of face info collect. (Corresponding to event DH_ALARM_FACEINFO_COLLECT)
typedef struct tagALARM_FACEINFO_COLLECT_INFO
{
	
	int                             nAction;                   		// Event operation. 1=start. 2=stop
    NET_TIME_EX			            stuTime;						//  Event occurrence time 
	double				            dbPTS;							// Time stamp (Unit is ms)
	char							szUserID[DH_MAX_USERID_LEN];	// user ID
	BYTE                			byReserved[512];       			// Reserved  
} ALARM_FACEINFO_COLLECT_INFO;

// alarm of high speed, (Corresponding to event DH_ALARM_HIGH_SPEED)
typedef struct tagALARM_HIGH_SPEED_INFO
{
	int                             nAction;                   		// Event operation. 1=start. 2=stop
    NET_TIME_EX			            stuTime;						// Event occurrence time 
	double				            dbPTS;							// Time stamp (Unit is ms)
    NET_GPS_STATUS_INFO 			stGPSStatusInfo;                // GPS info
	int								nSpeedLimit;					// limit speed, km/h
	int								nCurSpeed;						// current speed, km/h
	int								nMaxSpeed;					    // Max speed,Km/h
	NET_TIME_EX						stuStartTime;					// Start time,it is Reported when nAction is 2
	BYTE                			byReserved[472];       			// Reserved      
} ALARM_HIGH_SPEED_INFO;

//  alarm of driver video loss, (Corresponding to event DH_ALARM_VIDEO_LOSS)
typedef struct tagALARM_VIDEO_LOSS_INFO
{
	int                             nAction;                   		// Event operation. 1=start. 2=stop
	int					            nChannelID;						// channel ID
	double				            dbPTS;							// Time stamp (Unit is ms)
	BYTE							byReserved1[4];					// alagin
	NET_TIME_EX			            stuTime;						// Event occurrence time 
	NET_TIME_EX						stuStartTime;					// Start time,it is Reported when nAction is 2			
	NET_GPS_STATUS_INFO				stuGPS;							// GPS information
	BYTE                			byReserved[1024];       		// Reserved
} ALARM_VIDEO_LOSS_INFO;

// alarm of get authorized, (Corresponding to DH_ALARM_SMARTHOME_GET_AUTHORIZED)
typedef	struct tagALARM_SMARTHOME_GET_AUTHORIZED
{	
	int								nAction;						// 0:pulse 1:start 2:sop
	NET_TIME_EX			            UTC;							// event occur time
	char							byReserved[1024];				// reserved
}ALARM_SMARTHOME_GET_AUTHORIZED;

// alarm of update scene list, (Corresponding to DH_ALARM_SMARTHOME_UPDATE_SCENE)
typedef struct tagALARM_SMARTHOME_UPDATE_SCENE
{
	int								nAction;						// 0:pulse 1:start 2:sop
	NET_TIME_EX			            UTC;							// event occur time
	char							byReserved[1024];				// reserved
}ALARM_SMARTHOME_UPDATE_SCENE;

// ASG alarm type
typedef enum tagEM_ASG_ALARM_TYPE
{
	EM_ASG_ALARM_BREAK_UNKNOWN,										// unknown
	EM_ASG_ALARM_BREAK_DOWN,										// break down
	EM_ASG_ALARM_ANTI_DEMOLITION,									// anti demolition
	EM_ASG_ALARM_FOLLOW,											// follow
	EM_ASG_ALARM_TIMEOUT,											// time out
	EM_ASG_ALARM_STAY,												// stay
	EM_ASG_ALARM_FORCIBLY_OPEN,										// forcibly open
	EM_ASG_ALARM_MISTAKENLY_ENTER,									// mistakenly enter
	EM_ASG_ALARM_REVERSE_ENTER,										// reverse enter
	EM_ASG_ALARM_CLIMB,												// climb
}EM_ASG_ALARM_TYPE;

// alarm of ASG (Corresponding to event DH_ALARM_ASG)
typedef struct tagALARM_ASG_INFO
{
	int								nAction;						// 0:pulse 1:start 2:sop
	int					            nChannelID;						// channel id
	NET_TIME_EX			            UTC;							// event occur time
	EM_ASG_ALARM_TYPE				emAlarmType;					// alarm type
	char							byReserved[1024];				// reserved
}ALARM_ASG_INFO;

// ASG stay( corresponding to ALARM_ASGSTAY_INFO )
typedef struct tagALARM_ASGSTAY_INFO
{
    int                             nAction;                        // 0:pulse 1:start 2:sop
    int                             nChannelID;                     // channel id
    NET_TIME_EX                     UTC;                            // event occur time
    char                            byReserved[1020];               // reserved
} ALARM_ASGSTAY_INFO;

// ASG following( corresponding to ALARM_ASGFOLLOWING_INFO )
typedef struct tagALARM_ASGFOLLOWING_INFO
{
    int                             nAction;                        // 0:pulse 1:start 2:sop
    int                             nChannelID;                     // channel id
    NET_TIME_EX                     UTC;                            // event occur time
    char                            byReserved[1020];               // reserved
} ALARM_ASGFOLLOWING_INFO;

// ASG limb over( corresponding to ALARM_ASGCLIMBOVER_INFO )
typedef struct tagALARM_ASGCLIMBOVER_INFO
{
    int                             nAction;                        // 0:pulse 1:start 2:sop
    int                             nChannelID;                     // channel id
    NET_TIME_EX                     UTC;                            // event occur time
    char                            byReserved[1020];               // reserved
} ALARM_ASGCLIMBOVER_INFO;

// alarm type
typedef enum tagEM_ASGBREAKDOWN_ALARM_TYPE
{
    EM_ASGBREAKDOWN_ALARM_TYPE_UNKNOWN,                             // unknown
    EM_ASGBREAKDOWN_ALARM_TYPE_INFRARED,                            // infrared
    EM_ASGBREAKDOWN_ALARM_TYPE_COMMUNICATION,                       // communication
    EM_ASGBREAKDOWN_ALARM_TYPE_DOOR_WING,                           // door wing
} EM_ASGBREAKDOWN_ALARM_TYPE;

// ASG break down( corresponding to ALARM_ASGBREAKDOWN_INFO )
typedef struct tagALARM_ASGBREAKDOWN_INFO
{
    int                             nAction;                        // 0:pulse 1:start 2:sop
    int                             nChannelID;                     // channel id
    NET_TIME_EX                     UTC;                            // event occur time
    EM_ASGBREAKDOWN_ALARM_TYPE      emAlarmType;                    // alarm type
    char                            byReserved[1016];               // reserved
} ALARM_ASGBREAKDOWN_INFO;

#define  VTS_STATE_LONGNUMBER_LEN	24
// VTS state
typedef enum tagVTS_STATE
{
    EM_VTS_STATE_UNKNOWN = 0	, 
	EM_VTS_STATE_BUSY			,								// "Busy" 
	EM_VTS_STATE_IDLE			,								// "Idle" 
}VTS_STATE;

// VTS state update
typedef struct tagALARM_VTSTATE_UPDATE_INFO
{
	int					            nChannelID;						// Channel No.
    NET_TIME			            stuTime;						// Event occurrence time 
	VTS_STATE						emState;						// device state
	char							szLongNum[VTS_STATE_LONGNUMBER_LEN];	// long nember
	BYTE                			byReserved[1024];   			// reserve text
} ALARM_VTSTATE_UPDATE_INFO;

//video talk path ( Corresponding to event DH_ALARM_VIDEO_TALK_PATH )
typedef struct tagALARM_VIDEO_TALK_PATH_INFO
{
    int                             nAction;                   		    // Event operation. 0=pulse event. 1=start. 2=stop
    int					            nChannelID;						    // Channel id
    double				            dbPTS;							    // Time stamp (Unit is ms)
    NET_TIME_EX			            stuTime;						    // Event occurrence time
	char							szSrcDevID[DH_COMMON_STRING_128];	// Src Device ID
	char							szDstDevID[DH_COMMON_STRING_128];	// Dst Device ID
    BYTE                			byReserved[1024];   			    // Reserved
} ALARM_VIDEO_TALK_PATH_INFO;


//Warning zone event( Corresponding to event DH_EVENT_CROSSREGION_DETECTION)
typedef struct tagALARM_EVENT_CROSSREGION_INFO
{
    DWORD                           dwSize;    
    int					            nChannelID;						// Channel No. 
    double				            PTS;							// Time stamp (Unit is ms)
    NET_TIME_EX			            UTC;							// Event occurrence time
	int					            nEventID;						// Event ID
    int                             nEventAction;                   // Event operation. 0=pulse event.1=continues event begin. 2=continuous event stop

    NET_CROSSREGION_DIRECTION_INFO  emDirection;                    // Warning zone intrusion direction
    NET_CROSSREGION_ACTION_INFO     emActionType;                   // Detected types in the warning zone 
    int                             nOccurrenceCount;               // Rule triggered amount
    int                             nLevel;                         // Event type
	char							szName[DH_COMMON_STRING_128];   // name
	BOOL							bIsObjectInfo;					// Target information detection enablement
	DH_MSG_OBJECT			        stuObject;                      // Object information detected
	int								nRetObjectNum;						// Actually returns multiple detected object information 
	DH_MSG_OBJECT			        stuObjects[MAX_TARGET_OBJECT_NUM];  // Multiple detected object information

}ALARM_EVENT_CROSSREGION_INFO;


//Abandoned object event (Corresponding to event DH_EVENT_LEFT_DETECTION)
typedef struct tagALARM_EVENT_LEFT_INFO
{
    DWORD               dwSize;    
    int					nChannelID;						// Channel No.
    double				PTS;							// Time stamp (Unit is ms)
    NET_TIME_EX			UTC;							// Event occurrence time 
    int					nEventID;						// Event ID
    int                 nEventAction;                   // Event operation. 0=pulse event.1=continues event begin. 2=continuous event stop
    
    int                 nOccurrenceCount;               // Rule triggered amount
    int                 nLevel;                         // Event type 
	short				nPreserID;						// Event triggered preset period, starting from 1 (no unknown)
	char				szPresetName[64];				// Preset name for event triggered
}ALARM_EVENT_LEFT_INFO;

//Human face detect event( corresponding to event DH_EVENT_FACE_DETECTION)
typedef struct tagALARM_EVENT_FACE_INFO
{
    DWORD               dwSize;    
    int					nChannelID;						// Channel No.
    double				PTS;							// Time stamp (Unit is ms)
    NET_TIME_EX			UTC;							// Event occurrence time 
    int					nEventID;						// Event ID
    int                 nEventAction;                   // Event operation. 0=pulse event.1=continues event begin. 2=continuous event stop
}ALARM_EVENT_FACE_INFO;

   
//IPC alarm,local alarm IPC send out by DVR or NVR(Corresponding to event  DH_ALARM_IPC)
typedef struct tagALARM_IPC_INFO
{
    DWORD               dwSize;    
    int					nChannelID;						// Channel No. 
    int                 nEventAction;                   // Event operation. 0=pulse event.1=continues event begin. 2=continuous event stop
	NET_TIME_EX			UTC;							// Event occurrence time 
	char				szName[MAX_ALARM_CHANNEL_NAME_LEN];	// Alarm channel name 
}ALARM_IPC_INFO;


// NAS file task type
typedef enum tagNASFILE_STATUS_TYPE
{
	EM_NASFILE_STATUS_TYPE_UNKNOW,
    EM_NASFILE_STATUS_TYPE_COPY,   //copy
    EM_NASFILE_STATUS_TYPE_MOVE,   //move
}NASFILE_STATUS_TYPE;

// NAS file task state
typedef enum tagNASFILE_STATUS_STATE
{
	EM_NASFILE_STATUS_STATE_UNKNOW,
    EM_NASFILE_STATUS_STATE_FAILED,    	//failed
    EM_NASFILE_STATUS_STATE_SUCCESSED,  //successed
}NASFILE_STATUS_STATE;

//NAS file status event( corresponding to event DH_ALARM_NASFILE_STATUS)
typedef struct tagALARM_NASFILE_STATUS_INFO
{
	double						dbPTS;															// Time stamp (Unit is ms)
	NET_TIME_EX					stuTime;														// Event occurrence time
	NASFILE_STATUS_STATE		emTaskState;													// Task state
	char						szTaskID[DH_COMMON_STRING_128];									// Task ID
	NASFILE_STATUS_TYPE			emTaskType;														// File task type
	int							nSrcNum;														// Src number
    char						szSrcList[MAX_NASFILE_NUM][DH_COMMON_STRING_128];				// Src list               
	char                        szDstPath[DH_COMMON_STRING_128];								// Dst path
    int							nProgress;														// Task progress
    BYTE                		byReserved[1028];       										// reserved
} ALARM_NASFILE_STATUS_INFO;
typedef struct tagALARM_TALKING_CANCELCALL_INFO
{
    NET_TIME_EX					stuTime;														// Event occurrence time
    char                        szCallID[DH_COMMON_STRING_32];                                  // Call ID                   
}ALARM_TALKING_CANCELCALL_INFO;

// Crowd detection(corresponding to DH_ALARM_CROWD_DETECTION)
typedef struct tagALARM_CROWD_DETECTION_INFO
{ 
	int					  nChannelID;							// Channel ID
	int					  nEventID;								// Event ID
	double				  PTS;									// Time stamp (Unit:ms)
	NET_TIME_EX			  UTC;									// Event occurrence time 
	int                   nEventAction;							// Event action,1 means continues event start,2 means continuous event stop
	EM_ALARM_TYPE		  emAlarmType;							// Alarm Type
	char				  szName[MAX_CROWD_DETECTION_NAME_LEN];	// Event name
	int					  nCrowdListNum;						// Crowd list num
	int					  nRegionListNum;						// Region list num
	NET_CROWD_LIST_INFO	  stuCrowdList[MAX_CROWD_LIST_NUM];		// Crowd list info
	NET_REGION_LIST_INFO  stuRegionList[MAX_REGION_LIST_NUM];	// Region list info
	NET_EXTENSION_INFO    stuExtensionInfo;				        // Extension info
	BYTE				  byReserved[896];						// Reserved
}ALARM_CROWD_DETECTION_INFO;

// the state of reabstract
typedef enum tagEM_ABSTRACT_STATE
{
	EM_ABSTRACT_UNKNOWN,		// unknown
	EM_ABSTRACT_SUCCESS,		// success
	EM_ABSTRACT_FALSE,			// false
	EM_ABSTRACT_PROCESS,		// process(only GroupID)
} EM_ABSTRACT_STATE;

// The error code of modeling failed 
typedef enum tagEM_FEATURE_ERROR_CODE
{
    EM_FEATURE_ERROR_SUCCESS,			                // Success
    EM_FEATURE_ERROR_UNKNOWN,			                // Unknown
    EM_FEATURE_ERROR_IMAGE_FORMAT_ERROR,			    // Image format error
    EM_FEATURE_ERROR_NOFACE_OR_NOTCLEAR,		        // No face or image is not clear enough
    EM_FEATURE_ERROR_MULT_FACES,	            		// Multiple faces
    EM_FEATURE_ERROR_IMAGH_DECODE_FAILED,		    	// Image decode failed
    EM_FEATURE_ERROR_NOT_SUGGEST_STORAGE,		        // Not suggest for storage
    EM_FEATURE_ERROR_DATABASE_OPERATE_FAILED,			// Database operate failed
    EM_FEATURE_ERROR_GET_IMAGE_FAILED,			        // Failed to get image
    EM_FEATURE_ERROR_SYSTEM_EXCEPTION,		            // System exception
}EM_FEATURE_ERROR_CODE;

// result info of reabstract
typedef struct tagFACE_FEATURE_ABSTRACT_INFO
{
	EM_ABSTRACT_STATE	  		emAbstractState;						// the state of reabstract
	int					  		nProcess;								// the process of reabstract
	char                  		szUID[DH_MAX_PERSON_ID_LEN];          	// user ID
	char                  		szGroupId[DH_COMMON_STRING_64]; 		// group ID
	UINT						nSucceedCnt;							// success num of modeling,for IPC
	UINT						nFailedCnt;								// fail num of modeling,for IPC
	EM_FEATURE_ERROR_CODE		emFeatureError;							// The error code of modeling (valid when FailedCnt > 0 ): for IPC
	BYTE				  		byReserved[500];						// Reserved
} FACE_FEATURE_ABSTRACT_INFO;

// the event of face feature reabstract(corresponding to DH_ALARM_FACE_FEATURE_ABSTRACT)
typedef struct tagALARM_FACE_FEATURE_ABSTRACT_INFO
{
	int					  		nEventID;								// Event ID
	NET_TIME_EX			  		UTC;									// Event occurrence time 
	double				  		PTS;									// Time stamp (Unit:ms)
	BYTE						byReserved1[4];							// Alignment
	int							nRetAbstractInfo;						// The actual number of the result info of reabstract
	FACE_FEATURE_ABSTRACT_INFO	stuAbstractInfo[MAX_ABSTRACT_INFO_NUM];	// The result info of reabstract
	BYTE				  		byReserved[512];						// Reserved
} ALARM_FACE_FEATURE_ABSTRACT_INFO;

// Alarm of record schedule change (Corresponding to ALARM_RECORD_SCHEDULE_CHANGE_INFO)
typedef struct tagALARM_RECORD_SCHEDULE_CHANGE_INFO 
{
	int						nChannelID;								// Channel ID
	int						nEventID;								// Event ID
	double					dbPTS;									// Time stamp (Unit:ms)
	NET_TIME_EX				stuTime;								// Event occurrence time 				
	int						nEventAction;							// Event operation. 0=pulse event.1=continues event begin. 2=continuous event stop

	char					szUser[DH_COMMON_STRING_128];			// Username
	BYTE					byReserved[1024];						// Reserved
} ALARM_RECORD_SCHEDULE_CHANGE_INFO;

// Alarm of NTP change (Corresponding to ALARM_NTP_CHANGE_INFO)
typedef struct tagALARM_NTP_CHANGE_INFO 
{
	int						nEventID;								// Event ID
	int						nEventAction;							// Event operation. 0=pulse event.1=continues event begin. 2=continuous event stop
	double					dbPTS;									// Time stamp (Unit:ms)
	NET_TIME_EX				stuTime;								// Event occurrence time 				
	
	char					szUser[DH_COMMON_STRING_128];			// Username
	BYTE					byReserved[1028];						// Reserved
} ALARM_NTP_CHANGE_INFO;

//Raid Sync State
typedef enum tagEM_RAID_SYNC_STATE
{
	EM_RAID_SYNC_STATE_UNKNOWN = -1,                                // unknown
	EM_RAID_SYNC_STATE_SELFADAPTION,                                // Self-Adaption
	EM_RAID_SYNC_STATE_SYNCPRIORITY,                                // Sync Priority
	EM_RAID_SYNC_STATE_BUSINESSPRIORITY,                            // Business Priority
	EM_RAID_SYNC_STATE_EQUILIBRIUM,                                 // Equilibrium
}EM_RAID_SYNC_STATE;

//HDD Smart info
typedef struct tagNET_HDDSMART_INFO
{
	int                             nID;                            // ID
	int                             nCurrent;                       // Current
	char                            szName[DH_COMMON_STRING_64];    // Name
	int                             nWorst;                         // Worst
	int                             nThreshold;                     // Threshold
	char                            szRaw[DH_COMMON_STRING_32];     // Actual Value
	int                             nPredict;                       // The predictive value of the state of HDD
	EM_RAID_SYNC_STATE              emSync;                         // Raid Sync State
	BYTE                			byReserved[512];       			// Reserved Byte 
}NET_HDDSMART_INFO;

//alarm of HDD Temperature Alarm( DH_ALARM_HDD_TEMPERATUREALARM )
typedef struct tagALARM_HDD_TEMPERATUREALARM_INFO
{
	int                             nAction;                   		// Action:1:Start 2:Stop
	int                             nTemperature;                   // HDD Temperature
	NET_TIME_EX			            stuTime;						// Event occurrence time
	char                 			szHDDName[DH_COMMON_STRING_64];	// HDD Name
	NET_HDDSMART_INFO               stuHDDSmartInfo;                // HDD Smart info
	BYTE                			byReserved[512];       			// Reserved Byte 
}ALARM_HDD_TEMPERATUREALARM_INFO;

//alarm of HDD Shake Alarm( DH_ALARM_HDD_SHAKEALARM )
typedef struct tagALARM_HDD_SHAKEALARM_INFO
{
	int                             nAction;                   		// Action:1:Start 2:Stop
	NET_TIME_EX			            stuTime;						// Event occurrence time
	char                 			szHDDName[DH_COMMON_STRING_64];	// HDD Name
	NET_HDDSMART_INFO               stuHDDSmartInfo;                // HDD Smart info
	BYTE                			byReserved[512];       			// Reserved Byte 
}ALARM_HDD_SHAKEALARM_INFO;

//Patrol Status
typedef	enum tagEM_PATROL_STATUS
{
	EM_PATROL_STATUS_UNKNOWN,										// unknown
	EM_PATROL_STATUS_START,											// Start
	EM_PATROL_STATUS_END,											// End
	EM_PATROL_STATUS_FAIL,											// Fail
}EM_PATROL_STATUS;

//alarm of Patrol Status Alarm( DH_ALARM_PATROL_STATUS )
typedef struct tagALARM_PATROL_STATUS_INFO
{
	NET_TIME_EX			            stuTime;						// Event occurrence time
	EM_PATROL_STATUS				emPatrolStatus;					// Patrol Status
	BYTE                			byReserved[512];       			// Reserved Byte 
}ALARM_PATROL_STATUS_INFO;


//Trigger mode
typedef enum tagEM_AREAARM_TRIGGERMODE
{
	EM_AREAARM_TRIGGERMODE_UNKNOWN,           // Unknown
	EM_AREAARM_TRIGGERMODE_KEYPAD,            // Keypad
	EM_AREAARM_TRIGGERMODE_REMOTECONTROL,     // Remote control
	EM_AREAARM_TRIGGERMODE_USER,              // User
	EM_AREAARM_TRIGGERMODE_LOCAL,             // Local
}EM_AREAARM_TRIGGERMODE;

//User
typedef enum tagEM_AREAARM_USER
{
	EM_AREAARM_USER_UNKNOWN,           // Unknown
	EM_AREAARM_USER_SUPERVISOR,        // Supervisor
	EM_AREAARM_USER_MANAGER,           // Manager
	EM_AREAARM_USER_MASTER,            // Master
	EM_AREAARM_USER_USER,              // User
	EM_AREAARM_USER_TEMPORARY,         // Temporary
	EM_AREAARM_USER_DURESS,            // Duress
	EM_AREAARM_USER_PATROL,            // Patrol
}EM_AREAARM_USER;

// Arm states
typedef enum tagEM_ARM_STATE
{
	EM_ARM_STATE_UNKNOWN,           		// Unknown
	EM_ARM_STATE_TOTAL_ARMING,              // Total
	EM_ARM_STATE_PARTIAL1_ARMING,           // partial1
	EM_ARM_STATE_PARTIAL2_ARMING,           // partial2
	EM_ARM_STATE_PARTIAL1_PARTIAL2_ARMING,  // partial1+2
	EM_ARM_STATE_FORCEARMING,               // force arming
	EM_ARM_STATE_DISARMING,                 // disarming
}EM_ARM_STATE;

//alarm of area arm mode change(Corresponding to DH_ALARM_AREAARM_MODECHANGE)
typedef struct tagALARM_AREAARM_MODECHANGE_INFO
{ 
	int                       nAreaIndex;                           // Area ID
	int					      nEventID;								// Event ID
	NET_TIME_EX			      UTC;									// Event occurrence time
	EM_AREAARM_TRIGGERMODE    emTriggerMode;                        // Trigger mode
	EM_AREAARM_USER           emUser;                               /* useruseful when emTriggerMode = EM_AREAARM_USER_USER*/
	UINT                      nID;									/* ID,emTriggerMode = EM_AREAARM_TRIGGERMODE_KEYPAD
	keypad address;emTriggerMode =EM_AREAARM_TRIGGERMODE_REMOTECONTROL remote control ID*/
	EM_ARM_STATE              emArmState;                           // arm state
	BYTE				      byReserved[1024];						// Reserved Byte
}ALARM_AREAARM_MODECHANGE_INFO;

// lost module type
typedef enum tagEM_LOSTMODULE_TYPE
{
	EM_LOSTMODULE_TYPE_UNKNOWN,           		   // Unknown
	EM_LOSTMODULE_TYPE_WIRED,                      // Wired
	EM_LOSTMODULE_TYPE_WIRELESS,                   // Wireless
}EM_LOSTMODULE_TYPE;

#define MAX_ZONE_NUMBER      72   //Max zone number         

//alarm of zone module lost(Corresponding to DH_ALARM_ZONEMODULELOST)
typedef struct tagALARM_ZONEMODULE_LOST_INFO
{ 
	EM_LOSTMODULE_TYPE        emType;                               // lost module type
	int					      nEventID;								// Event ID
	NET_TIME_EX			      UTC;									// Event occurrence time
	int                       nZones;                               // zone number
	int                       arrZones[MAX_ZONE_NUMBER];   			// zones
	bool                      bOnLine;                              // Net state,false:offline true:online
	BYTE                      byReserved1[3];                       // Alignment
 	BYTE				      byReserved[1024];						// Reserved Byte
}ALARM_ZONEMODULE_LOST_INFO;

// defence area type
typedef enum tagEM_DEFENCE_AREA_TYPE
{
	EM_DEFENCE_AREA_TYPE_UNKNOWN,       // Unknown area
	EM_DEFENCE_AREA_TYPE_INTIME,        // Intime area
	EM_DEFENCE_AREA_TYPE_DELAY,         // Delay area
	EM_DEFENCE_AREA_TYPE_DELAY2,        // Delay2 area 
	EM_DEFENCE_AREA_TYPE_FOLLOW,        // Follow area 
	EM_DEFENCE_AREA_TYPE_EXITEND,       // Exitend area
	EM_DEFENCE_AREA_TYPE_FULLDAY,       // Fullday area
	EM_DEFENCE_AREA_TYPE_FIRE,          // Fir area 
	EM_DEFENCE_AREA_TYPE_PANIC,         // Panic area 
	EM_DEFENCE_AREA_TYPE_ROBBERY,       // Robbery area
	EM_DEFENCE_AREA_TYPE_MEDICAL,       // Medical area 
	EM_DEFENCE_AREA_TYPE_KEY,           // key area
}EM_DEFENCE_AREA_TYPE;

//area alarm trigger type
typedef enum tagEM_AREAALARM_TRIGGER_TYPE
{
	EM_AREAALARM_TRIGGER_TYPE_UNKNOWN,   // Unknown
	EM_AREAALARM_TRIGGER_TYPE_ALARM,     // Open
	EM_AREAALARM_TRIGGER_TYPE_TAMPER,    // Tamper
	EM_AREAALARM_TRIGGER_TYPE_MASK,      // Mask
	EM_AREAALARM_TRIGGER_TYPE_SHORT,     // Short
}EM_AREAALARM_TRIGGER_TYPE;

// alarm of area alarm(Corresponding to DH_ALARM_AREAALARM)
typedef struct tagALARM_AREAALARM_INFO
{ 
	int                       nAreaIndex;                           // Area ID
	int					      nEventID;								// Event ID
	NET_TIME_EX			      UTC;									// Event occurrence time
	char                      szName[128];                          // Name
	EM_DEFENCE_AREA_TYPE      emDefenceAreaType;                    // Defence area type
	int                       nIndex;                               // Channel ID
	EM_AREAALARM_TRIGGER_TYPE emTrigerType;                         // trigger type
 	BYTE				      byReserved[1024];						// Reserved Byte
}ALARM_AREAALARM_INFO;

#define MAX_AREA_NUMBER   8     //max area number

//alarm of zone open(Corresponding to DH_ALARM_ZONEOPEN)
typedef struct tagALARM_ZONEOPEN_INFO
{ 	
	int                       nAction;               // Event action 1:Start 2:Stop
	int					      nEventID;				 // Event ID
	NET_TIME_EX			      UTC;					 // Event occurrence time
	char                      szName[128];           // Name
	int                       nAreaNum;              // Area number
	int                       arrAreas[MAX_AREA_NUMBER]; // Area ID
	int                       nChannelID;            // Channel ID
 	BYTE				      byReserved[1024];		 // Reserved Byte
}ALARM_ZONEOPEN_INFO;

//alarm of system tamper(Corresponding to DH_ALARM_SYSTEMTAMPER)
typedef struct tagALARM_SYSTEMTAMPER_INFO
{ 	
	int                       nAction;               // Event Action 1:Start 2:Stop
	int					      nEventID;				 // Event ID
	NET_TIME_EX			      UTC;					 // Event occurrence time
 	BYTE				      byReserved[1024];		 // Reserved Byte
}ALARM_SYSTEMTAMPER_INFO;


// alarm of citizen pircture compare(DH_ALARM_CITIZEN_PICTURE_COMPARE)
typedef struct tagALARM_CITIZEN_PICTURE_COMPARE_INFO 
{
	int						nChannelID;								// channel id
	int						nEventID;								// event id
	NET_TIME_EX				stuTime;								// evnet time(UTC)				
	BOOL                	bCompareResult;                     	// compare result,TRUE:success,FALSE:failed
    BYTE                	nSimilarity;                        	// Similarity,unit:%,rang:[1,100]
    BYTE                	nThreshold;                         	// Threshold,rang:[1,100]
    BYTE                	byReserved1[2];                      	// bytes reserved
    EM_CITIZENIDCARD_SEX_TYPE emSex;                        		// sex
    int                 	nEthnicity;                         	// Ethnicity(see DEV_EVENT_ALARM_CITIZENIDCARD_INFO::nEthnicity)
    char                	szCitizen[DH_COMMON_STRING_64];    		// citizen name    
    char                	szAddress[DH_COMMON_STRING_256];    	// address
    char                	szNumber[DH_COMMON_STRING_64];          // citizen number
    char                    szAuthority[DH_COMMON_STRING_256];      // Authority
    NET_TIME            	stuBirth;                               // Birth(y-m-d)
    NET_TIME            	stuValidityStart;                   	// Validity start time(y-m-d)
    BOOL               		bLongTimeValidFlag;                 	 // When the value is TRUE, the stop date menas always valid, at this time, the stuValidityEnd is null. 
                                                            // When the value is FALSE, refer to stuValidityEnd value for stop date.
    NET_TIME            	stuValidityEnd;                     	// Validity end time(y-m-d)
	char                	szCardNo[DH_COMMON_STRING_32];      	// IC cardNo
	char                	szCellPhone[DH_COMMON_STRING_32];   	// cellphone
	UINT					nEventType;								// event type: 0: citizen picture compare result	1:citizen picture collection
	char					szUserID[32];							// user id of citizen picture collection (customized)
	BYTE					byReserved[988];						// Reserved
} ALARM_CITIZEN_PICTURE_COMPARE_INFO;

//alarm of HDD Health Alarm( DH_ALARM_HDD_HEALTHALARM )
typedef struct tagALARM_HDD_HEALTHALARM_INFO
{
	int                             nAction;                   		// Action:1:Start 2:Stop
	NET_TIME_EX			            stuTime;						// Event occurrence time
	char                 			szHDDName[DH_COMMON_STRING_64];	// HDD Name
	NET_HDDSMART_INFO               stuHDDSmartInfo;                // HDD Smart info
	BYTE                			byReserved[512];       			// Reserved Byte 
}ALARM_HDD_HEALTHALARM_INFO;

// alarm of storage work directory switch( DH_ALARM_STORAGE_WORKDIRECTORY_SWITCH )
typedef struct tagALARM_STORAGE_WORKDIRECTORY_SWITCH_INFO
{
	NET_TIME_EX			            stuTime;						// Event occurrence time
	char                            szGroup[DH_COMMON_STRING_64];   // directory in the work group
}ALARM_STORAGE_WORKDIRECTORY_SWITCH_INFO;

//Scene State
typedef struct tagHOMESCENE_STATE_INFO
{
	char 							szName[128];					//Scene name
	BOOL							bOnline;						//online state
	BYTE							byReserved[512];				//reserved
}HOMESCENE_STATE_INFO;
//alarm of smart home scene change(DH_ALARM_HOMESCENE_CHANGE)
typedef struct tagALARM_HOMESCENE_CHANGE_INFO
{
	char							szSceneID[32];					//Scene ID
	HOMESCENE_STATE_INFO			stuState;						//Scene state
	BYTE							byReserved[512];				//reserved
}ALARM_HOMESCENE_CHANGE_INFO;

// Board action
typedef enum tagEM_BOARDHOTPLUG_ACTION
{
	EM_BOARDHOTPLUG_ACTION_UNKNOWN,									// unknown
	EM_BOARDHOTPLUG_ACTION_ADD,										// board add
	EM_BOARDHOTPLUG_ACTION_REMOVE,									// board remove
}EM_BOARDHOTPLUG_ACTION;


//alarm of device board hot-plug (DH_ALARM_DEVBOARDHOTPLUG)
typedef struct tagALARM_DEVBOARDHOTPLUG_INFO
{
	NET_TIME_EX			            stuTime;						// event time(UTC)
	EM_BOARDHOTPLUG_ACTION			emBoardAction;					// board action
	int								nBoardSlot;						// Board slot index
	BYTE                			byReserved[512];       			// Reserved 
}ALARM_DEVBOARDHOTPLUG_INFO;

//alarm of linkage alarm (DH_ALARM_TRAFFIC_LINKAGEALARM)		
typedef struct tagALARM_TRAFFIC_LINKAGEALARM_INFO
{
	NET_TIME_EX			            stuTime;						// event time(UTC)
	char							szCode[DH_COMMON_STRING_32];	// Event code
	BYTE                			byReserved[1024];       		// Reserved
}ALARM_TRAFFIC_LINKAGEALARM_INFO;

// alarm of coaxial alarm local (DH_ALARM_COAXIAL_ALARM_LOCAL)
typedef struct tagALARM_COAXIAL_ALARM_LOCAL_INFO
{
	int								nAction;						// event action : 1:Start 2:Stop
	NET_TIME_EX						UTC;							// event time(UTC)
	
	int								nAlarmChannel;					// alarm input channel
	NET_SENSE_METHOD				emSenseMethod;					// sense method
	char							szName[MAX_COMMON_STRING_64];	// alarm name
	int								nChannelID;						// channel id
	BYTE                			byReserved[1020];       		// reserved
} ALARM_COAXIAL_ALARM_LOCAL_INFO;

// alarm of NAS File Remove Status( DH_ALARM_NAS_FILE_REMOVE_STATUS )
typedef struct tagALARM_NAS_FILE_REMOVE_STATUS_INFO 
{
	int						nEventID;								// Event ID
	int						nAction;								// Event operation. 0=pulse event.1=continues event begin. 2=continuous event stop
	double					dbPTS;									// Time stamp (Unit:ms)
	NET_TIME_EX				stuTime;								// Event occurrence time 				
	
	NASFILE_STATUS_STATE	emStatus;								// status
	char					szID[MAX_COMMON_STRING_128];			// ID
	UINT					nProgress;								// progress: 0 ~ 100
	BYTE					byReserved[1028];						// reserved
} ALARM_NAS_FILE_REMOVE_STATUS_INFO;

// alarm of NAS APK Install Request( DH_ALARM_NAS_APK_INSTALL_REQUEST )
typedef struct tagALARM_NAS_APK_INSTALL_REQUEST_INFO 
{
	DWORD					dwSize;
	char					szApkPath[MAX_COMMON_STRING_128];		// Apk Path
} ALARM_NAS_APK_INSTALL_REQUEST_INFO;

// APK install status
typedef enum tagEM_NAS_APK_INSTALL_STATUS
{
	EM_NAS_APK_INSTALL_STATUS_UNKNOWN,								// unknown
	EM_NAS_APK_INSTALL_STATUS_FAILED,								// failed
	EM_NAS_APK_INSTALL_STATUS_SUCCEED,								// succeed
	EM_NAS_APK_INSTALL_STATUS_INSTALLING,							// installing
} EM_NAS_APK_INSTALL_STATUS;

// alarm of NAS APK Install Status( DH_ALARM_NAS_APK_INSTALL_STATUS )
typedef struct tagALARM_NAS_APK_INSTALL_STATUS_INFO 
{
	int							nEventID;							// Event ID
	int							nAction;							// Event operation. 0=pulse event.1=continues event begin. 2=continuous event stop
	double						dbPTS;								// Time stamp (Unit:ms)
	NET_TIME_EX					stuTime;							// Event occurrence time 					
	
	EM_NAS_APK_INSTALL_STATUS	emStatus;							// status
	char						szApkPath[MAX_COMMON_STRING_128];	// APK Path
	UINT						nProgress;							// progress: 0 ~ 100
	BYTE						byReserved[1028];					// reserved
} ALARM_NAS_APK_INSTALL_STATUS_INFO;

// file compress type
typedef enum tagEM_FILE_COMPRESS_TYPE
{
	EM_FILE_COMPRESS_TYPE_UNKNOWN,									// unknown
	EM_FILE_COMPRESS_TYPE_COMPRESS,									// compress, corresponding to pInParam = NET_IN_COMPRESS_FILE, pOutParam = NET_OUT_COMPRESS_FILE
	EM_FILE_COMPRESS_TYPE_DECOMPRESS,								// decompress, corresponding to pInParam = NET_IN_DECOMPRESS_FILE, pOutParam = NET_OUT_DECOMPRESS_FILE
} EM_FILE_COMPRESS_TYPE;

// file compress status
typedef enum tagEM_FILE_COMPRESS_STATUS 
{
	EM_FILE_COMPRESS_STATUS_UNKNOWN,								// unknwon
	EM_FILE_COMPRESS_STATUS_FAILED,									// failed
	EM_FILE_COMPRESS_STATUS_SUCCEED,								// succeed
	EM_FILE_COMPRESS_STATUS_NEED_PWD,								// need password
	EM_FILE_COMPRESS_STATUS_WRONG_PWD,								// wrong password
	EM_FILE_COMPRESS_STATUS_NO_FILE,								// no file
} EM_FILE_COMPRESS_STATUS ;

// alarm of File Compress Status( DH_ALARM_FILE_COMPRESS_STATUS )
typedef struct tagALARM_FILE_COMPRESS_STATUS_INFO 
{
	int						nEventID;								// Event ID
	int						nAction;								// Event operation. 0=pulse event.1=continues event begin. 2=continuous event stop
	double					dbPTS;									// Time stamp (Unit:ms)
	NET_TIME_EX				stuTime;								// Event occurrence time 					
	
	char					szID[MAX_COMMON_STRING_128];			// ID
	EM_FILE_COMPRESS_TYPE	emType;									// Type
	int						nSrcNum;								// Src File number
	char					szSrcList[MAX_NASFILE_NUM][MAX_COMMON_STRING_128];		// Src File list
	char					szDstPath[MAX_COMMON_STRING_128];		// Dst Path
	EM_FILE_COMPRESS_STATUS	emStatus;								// status
	UINT					nProgress;								// progress: 0 ~ 100
	BYTE					byReserved[1024];						// reserved
} ALARM_FILE_COMPRESS_STATUS_INFO;

// Stranger alarm info( DH_ALARM_STRANGER_ALARM )
typedef struct tagALARM_STRANGER_ALARM_INFO
{
	int						nChannelID;						// Local alarm input channel ID
	int						nEventID;						// Event ID
	int						nAction;						// Event operation.1=continues event begin. 2=continuous event stop
	NET_TIME_EX				UTC;							// event time(UTC)
	BYTE					byReserved[1024];				// Reserved
}ALARM_STRANGER_ALARM_INFO;

// QR code check info( DH_ALARM_QR_CODE_CHECK )
typedef struct tagALARM_QR_CODE_CHECK_INFO
{
	int						nEventID;						// Event ID
	NET_TIME_EX		        UTC;							// Event occurrence time 	
	double					dbPTS;							// Time stamp (Unit:ms)
	char                    szQRCode[256];                  // QR code
	BYTE					byReserved[1024];	            // Reserved
}ALARM_QR_CODE_CHECK_INFO;

// door lock work mode
typedef enum tagEM_LOCK_MODE
{
	EM_MODE_UNKNOWN =  -1,							        // unknown
	EM_MODE_NORMAL =  0,							        // normal mode
	EM_MODE_CHANNEL =  1,							        // channel mode(lock handle directly open door)
	EM_MODE_UNDISTURBED = 2,						        // undisturbed mode(lock is opened,no prompting sound)
} EM_LOCK_MODE ;

// lock mode alarm info( DH_ALARM_ACCESS_CTL_LOCK_MODE  )
typedef struct tagALARM_ACCESS_CTL_LOCK_MODE_INFO
{
	int                      nEventID;                      // Event ID
	NET_TIME_EX	             UTC;					        // Event occurrence time
	double					 dbPTS;					        // Time stamp (Unit:ms)
	char                     szSN[32];                      // Device serial number
	EM_LOCK_MODE		     emLockMode;                    // door lock work mode
	BYTE					 byReserved[1020];		        // Reserved
}ALARM_ACCESS_CTL_LOCK_MODE_INFO;

// alarm of lock room number binding( DH_ALARM_LOCK_ROOM_NUM_BIND )
typedef struct tagALARM_LOCK_ROOM_NUM_BIND_INFO
{
	int                     nEventID;                       // Event ID
	NET_TIME_EX             UTC;                            // Event occurrence time
	double                  dbPTS;                          // Time stamp (Unit:ms)
	char                    szSN[32];                       // Device serial number
    char                    szName[64];                     // Room number of door lock,this field is discarded
    UINT                   nTaskID;                        // Task ID
	char                    szRoomNo[64];                   // Room number of intelligent lock 
	BYTE                    byReserved[956];                // Reserved
}ALARM_LOCK_ROOM_NUM_BIND_INFO;

// alarm of Leave detection(DH_ALARM_LEAVE_DETECTION)
typedef struct tagALARM_LEAVE_DETECTION_INFO
{
	int						nChannelID;						// channel ID
	int						nAction;						// Event operation. 0=pulse event.1=continues event begin. 2=continuous event stop
	NET_TIME_EX				UTC;							// Event occurrence time
	BYTE					byReserved[1024];				// Reserved
}ALARM_LEAVE_DETECTION_INFO;

// Line info
typedef struct tagALARM_LANE_INFO
{
	UINT		nQueueLen;				// Queue lenUintm
	UINT		nLane;					// Lane numberStarting from 0,the lane counts from left to tight01234
	UINT		nUserDefinedLaneNumber;	// User Defined lane number
	BYTE		byReserved[256];		// Reserved
}ALARM_LANE_INFO;

// alarm of Traffic guangzhoujiaotong queue lenDH_ALARM_TRAFFICGZJJ_QUEUE_LEN
typedef struct tagALARM_TRAFFICGZJJ_QUEUE_LEN_INFO
{
	int						nChannelID;		// channel ID
	int						nAction;		// Event operation,0 means pulse event.1 means continues event begin. 2 means continuous event stop
	double                  dbPTS;          // Time stamp (Unit:ms)
	NET_TIME_EX             UTC;            // Event occurrence time
	int						nEventID;		// Event ID

	UINT					nPeriodByMs;	// Reporting intervalUnitms
	ALARM_LANE_INFO			stuAlarmLane[5];// Line info
	BYTE					byReserved[1024];// Reserved
} ALARM_TRAFFICGZJJ_QUEUE_LEN_INFO;

// Car Type
typedef enum _EM_NET_CARTYPE
{
	NET_CARTYPE_UNKNOW = 0,           // Unknow
	NET_CARTYPE_PASSENGERCAR,         // Passengercar
	NET_CARTYPE_LARGETRUCK,           // Largetruck
	NET_CARTYPE_MIDTRUCK,             // Midtruck
	NET_CARTYPE_SALOONCAR,            // Salooncar
	NET_CARTYPE_MICROBUS,             // Microbus
	NET_CARTYPE_MICROTRUCK,           // Microtruck
	NET_CARTYPE_TRICYCLE,             // Tricycle
	NET_CARTYPE_MOTOR,                // Motor
	NET_CARTYPE_PASSERBY,             // Passerby
	NET_CARTYPE_SUVMPV,               // SUV-MPV
	NET_CARTYPE_MIDPASSENGERCAR,      // Midpassengercar
	NET_CARTYPE_TANKCAR,              // Tank car
	NET_CARTYPE_SUV,                  // SUV
	NET_CARTYPE_MPV,                  // MPV
	NET_CARTYPE_BUS,                  // Bus
	NET_CARTYPE_PICKUP,               // Pickup
	NET_CARTYPE_MINICARRIAGE,         // Minicarriage
	NET_CARTYPE_OILTANKTRUCK,         // Oiltanktruck
	NET_CARTYPE_SLOTTANKCAR,          // Slottankcar
	NET_CARTYPE_RESERVED1,            // Reserved1
	NET_CARTYPE_DREGSCAR,             // Dregscar
	NET_CARTYPE_CONCRETEMIXERTRUCK,   // Concretemixertruck
	NET_CARTYPE_TAXI,				  // Taxt
	NET_CARTYPE_POLICE,				  // Police
	NET_CARTYPE_AMBULANCE,            // Ambulance
	NET_CARTYPE_GENERAL,			  // General
	NET_CARTYPE_WATERINGCAR,		  // Wateringcar
	NET_CARTYPE_RESERVED2,            // Reserved2
	NET_CARTYPE_FIREENGINE,			  // Fireengine
	NET_CARTYPE_TRACTOR,			  // Tractor
	NET_CARTYPE_MACHINESHOPTRUCK,	  // Machineshopiruck
	NET_CARTYPE_POWERLOTVEHICLE,	  // Powerlotvehicle
	NET_CARTYPE_SUCTIONSEWAGETRUCK,   // Suctionsewagetruck
	NET_CARTYPE_NORMALVEHICLETANKTRUCK,//NormalVehicleTankTruck 
	NET_CARTYPE_TWOCYCLE,             // Twocycle
} EM_NET_CARTYPE;

// Lane coil information(mainly vehicle information inside the coil)
typedef struct tagCOILS_INFO
{
	UINT					nCarId;			//  Vehicle ID(not license plate number, ID is the number of the record of the object detected by the device)
	char					PlateNum[64];	//  Plate number
	EM_NET_CARTYPE			emCarType;		//	Car Type
	BYTE					byReserved[1024];// Reserved
} COILS_INFO;

// Line Info
typedef struct tagLANE_INFO
{
	UINT					nLane;						// Physical Lane Number (Range 0~4)
	int						nLaneType;					// Lane type,dashed lane0, solid lane1
	double					dbLaneOcc;					// Lane space occupancy,Range[0.0~1.0]
	UINT					nRoadwayNumber;				// Custom Lane NumberRange:0~128
	int						nCurrentLaneVehicleNum;		// Number of Current Lane Vehicles
	int						nVehicleNum;				// From the end of the last statistics to the present,the number of passing carsequipment 0.5 seconds down
	UINT					nCarId;						// Keep the ID of the most recent valid passing(not the license plate number), and the CarID is number of the record of
														// the object detected by the device
	double					dbCarEnterTime;				// Number Carld Vehicle Entry Damaged Lane Time
	double					dbCarLeaveTime;				// Time for Carld Vehicle Number to Leave Solid Lane
	UINT					nCarDistance;				// Number CarID Vehicle Distance, Unit:M
	int						nQueueLen;					// The distance between the vehicle at the rear of the lane and the parking line, in meters
	double					dbCarSpeed;					// Number CarId Vehicle Average Vehicle Speed, Unit:m/s
	int						nCoilsInfoNum;				// Number of actual return coil information
	COILS_INFO				stuCoilsInfo[70][2];		// Lane coil information(mainly vehicle information in the coil)
	int						nRetSolidLanNum;			// Number of actual return dashed lanes
	int						nSolidLaneNum[6];			// Custom Lane Number of Solid Lane Corresponding to Damaged Lane
	int						nVehicleNumByTypeNum;		// Statistical Number of Real Return Vehicle Types
	UINT					nVehicleNumByType[64];		// Lane type statistics, array subscripts  correspond to differernt vehicle types(model reference EM_NET_VEHICLE_TYPE), subscripts correspond to the number of vehicle type statistics
	int						nEndLen;					// When a vehicle is running, the distance between the rear vehicle position and the parking line is in meters, Unit:M
	BYTE					byReserved[1024];			// Reserved
} LANE_INFO;

// alarm of TrafficXinKongDH_ALARM_TRAFFIC_XINKONG
typedef struct tagALARM_TRAFFIC_XINKONG_INFO
{
	int						nChannelID;					// channel ID
	int						nAction;					// There is only one event action 0, which represents a pulse event
	double                  dbPTS;						// Time stamp (Unit:ms)
	NET_TIME_EX             UTC;						// Event occurrence time
	int						nEventID;					// Event ID

	char					szName[128];				// Event name
	BYTE					byReserved1[4];				// byte alignment
	int						nLaneInfoNum;				// Number of Actual Return Lane Information
	LANE_INFO				stuLaneInfo[6];				// Lane information
	BYTE					byReserved[1024];			// Reserved
} ALARM_TRAFFIC_XINKONG_INFO;

// Event type of Jablotron alarm
typedef enum tagEM_JABLOTRON_ALARM_TYPE
{
	EM_JABLOTRON_ALARM_TYPE_UNKNOWN,						// Unknown
	EM_JABLOTRON_ALARM_TYPE_INTRUSION,						// Intrusion
	EM_JABLOTRON_ALARM_TYPE_FIRE,							// Fire
	EM_JABLOTRON_ALARM_TYPE_PANIC,							// Panic
	EM_JABLOTRON_ALARM_TYPE_ARMED,							// Armed
	EM_JABLOTRON_ALARM_TYPE_DISARMED,						// Disarmed
	EM_JABLOTRON_ALARM_TYPE_PG,								// PG
}EM_JABLOTRON_ALARM_TYPE;

typedef struct tagHMS_TIME
{
    DWORD                   dwHour;                         // Hour
    DWORD                   dwMinute;                       // Minute
    DWORD                   dwSecond;                       // Second
}HMS_TIME;

// Jablotron alarm info( DH_ALARM_JABLOTRON_ALARM )
typedef struct tagALARM_JABLOTRONALARM_INFO
{
    int                         nChannelID;                                 // Channel ID
    int                         nAction;                                    // Event operation. 0=pulse event.1=continues event begin. 2=continuous event stop
    char                        szName[128];                                // Event name
    EM_JABLOTRON_ALARM_TYPE     emAlarmType;                                // Event type of Jablotron alarm
    unsigned int				nDefenceZone;                               // DefenceZone number,1~15
    HMS_TIME                    stuTime;                                    // JablotronTimestamp
    BYTE                        byReserved[1024];                           // Reserved 
}ALARM_JABLOTRONALARM_INFO;

// Face box color
typedef struct tagNET_CFG_FACE_BOX_COLOR
{
	int					nFaceID;									// Face ID
	NET_COLOR_RGBA		stuColor;									// Color
	BYTE				byReserved[108];							// Reserved						
}NET_CFG_FACE_BOX_COLOR;

// Alarm of face recognition( DH_ALARM_FACE_RECOGNITION )
typedef struct tagALARM_FACE_RECOGNITION_INFO
{
	int							nChannelID;									// channel ID
	int                         nAction;                                    // Event operation. 0=pulse event.1=continues event begin. 2=continuous event stop
	NET_TIME_EX					UTC;										// Event occurrence time 	
	NET_CFG_FACE_BOX_COLOR		stuFaceBoxColor;							// Face box color
	BYTE						byReserved[4096];							// Reserved 
}ALARM_FACE_RECOGNITION_INFO;

// alarm of vehicle oil level( DH_ALARM_VEHICLE_OILLEVEL )
typedef struct tagALARM_VEHICLE_OILLEVEL_INFO
{
	int							nChannelID;									// channel id
	int							nAction;									// Event operation. 0=pulse event.1=continues event begin. 2=continuous event stop
	NET_TIME_EX					UTC;										// Event occurrence time	
	float						fOilLevel;									// vehicle oil level, Unit:%
	BYTE						byReserved[1024];							// Reserved 
}ALARM_VEHICLE_OILLEVEL_INFO;

// alarm of vehicle load( DH_ALARM_VEHICLE_LOAD )
typedef struct tagALARM_VEHICLE_LOAD_INFO
{
	int							nChannelID;									// channel ID
	int							nAction;									// Event operation. 0=pulse event.1=continues event begin. 2=continuous event stop
	NET_TIME_EX					UTC;										// Event occurrence time	
	UINT						nADValue;									// AD value
	float						fLoad;										// Current load,Unit:kg
	BYTE						byReserved[1024];							// Reserved 
}ALARM_VEHICLE_LOAD_INFO;

// Engine failure status
typedef enum tagEM_ENGINE_FAILURE_STATUS
{
	EM_ENGINE_FAILURE_UNKNOWN = 0,											// Unknown
	EM_ENGINE_FAILURE_NOTACTIVE,											// "Not active"
	EM_ENGINE_FAILURE_ACTIVE,												// "Active"
	EM_ENGINE_FAILURE_BLINK,												// "Blink"
	EM_ENGINE_FAILURE_NOTAVAILABLE,											// "Not Available"
}EM_ENGINE_FAILURE_STATUS;

// Alarm of engine failure status( DH_ALARM_ENGINE_FAILURE_STATUS )
typedef struct tagALARM_ENGINE_FAILURE_STATUS_INFO
{
	int							nChannelID;									// channel ID
	int							nAction;									// Event operation. 0=pulse event.1=continues event begin. 2=continuous event stop
	NET_TIME_EX					UTC;										// Event occurrence time	
	EM_ENGINE_FAILURE_STATUS	emStatus;									// Engine failure status
	NET_GPS_STATUS_INFO			stuGPS;										// GPS information
	BYTE						byReserved[1024];							// Reserved 
}ALARM_ENGINE_FAILURE_STATUS_INFO;

//enum of vehicle state
typedef enum tagEM_VEHICLE_STATE
{
	EM_VEHICLE_STATE_UNKNOWN = 0,
	EM_VEHICLE_STATE_PARK,							// Park
	EM_VEHICLE_STATE_MOTION,						// motion(over 0km/h)
	EM_VEHICLE_STATE_SPORT,							// sport(over 10km/h)
}EM_VEHICLE_STATE;

// vehicle gear type
typedef enum tagEM_VEHICLE_GEARS_TYPE
{
	EM_VEHICLE_GEARS_UNKNOWN = -1,
	EM_VEHICLE_GEARS_P,								//P
	EM_VEHICLE_GEARS_R,								//R
	EM_VEHICLE_GEARS_N,								//N
	EM_VEHICLE_GEARS_D,								//D
	EM_VEHICLE_GEARS_S,								//S
}EM_VEHICLE_GEARS_TYPE;

// alarm of vehicle state( DH_ALARM_VEHICLE_STATE )
typedef struct tagALARM_VEHICLE_STATE_INFO
{
	int							nChannelID;									// channel ID
	int							nAction;									// Event operation. 0=pulse event.1=continues event begin. 2=continuous event stop
	NET_TIME_EX					UTC;										// Event occurrence time	
	
	EM_VEHICLE_STATE			emVehicleState;								// Vehicle State
	UINT						nOilTankage;								// Fuel tank capacity, Unit:0.1L
	UINT						nCurrentFuel;								// Current fuel tank volume, Unit:0.1L
	UINT						nConsumptionOil;							// Current fuel consumption, L/100km; 0.1L
	UINT						nTotalUsedFuel;								// Total fuel consumption, Unit:0.1L
	UINT						nTotalDistance;								// Total mileage, Unit:0.1 Km
	int							nServiceDistance;							// Maintenance distance, Unit:0.1Km
	EM_VEHICLE_GEARS_TYPE		emCurrentGear;								// Current gear
	UINT						nSpeed;										// Current speed, Unit0.1Km/h
	char						szTaskID[64];								// TaskID
	NET_GPS_STATUS_INFO			stuGPS;										// GPS information
	int							nAlarmFlag;									// When maintenance distance less than 2000km, this alarmflag will be set, 0:has alarm 1:no alarm 2:nonsense
	BYTE						byReserved[1020];							// Reserved 
}ALARM_VEHICLE_STATE_INFO;

//Alarm of IMSI check( DH_ALARM_IMSI_CHECK )
typedef struct tagALARM_IMSI_CHECK_INFO
{
	int							nIndex;										// SIM index
	int							nAction;									// Event operation. 0=pulse event.1=continues event begin. 2=continuous event stop
	NET_TIME_EX					UTC;										// Event occurrence time	

	char						szIMSI[32];									// Detected IMSI
	BYTE						byReserved[1024];							// Reserved 
}ALARM_IMSI_CHECK_INFO;

// alarm of vehicle into blind area( DH_ALARM_BLIND_ALARM )
typedef struct tagALARM_BLIND_ALARM_INFO
{
	int							nChannelID;									// channel ID
	int							nAction;									// Event operation. 0=pulse event.1=continues event begin. 2=continuous event stop
	NET_TIME_EX					UTC;										// Event occurrence time	
	
	NET_GPS_STATUS_INFO			stuGPS;										// GPS information
	BYTE						byReserved[1024];							// Reserved 
}ALARM_BLIND_ALARM_INFO;

// Alarm of vehicle maintaince( DH_ALARM_VEHICLE_MAINTAINCE )
typedef struct tagALARM_VEHICLE_MAINTAINCE_INFO
{
	int							nIndex;										// channel ID
	int							nAction;									// Event operation. 0=pulse event.1=continues event begin. 2=continuous event stop
	NET_TIME_EX					UTC;										// Event occurrence time	
	
	char						szMaintainer[32];							// Maintainer
	char						szMaintainerID[32];							// Maintainer ID
	char						szInfo[256];								// Custom information
	BYTE						byReserved[1024];							// Reserved 
}ALARM_VEHICLE_MAINTAINCE_INFO;

// Alarm of fire detection (DH_ALARM_FIRE_DETECTION)
typedef struct tagALARM_FIRE_DETECTION_INFO
{
	int							nChannelID;									// channel ID
	int							nAction;									// Event operation. 0=pulse event.1=continues event begin. 2=continuous event stop
	NET_TIME_EX					UTC;										// Event occurrence time

	BYTE						byReserved[1024];							// Reserved 
}ALARM_FIRE_DETECTION_INFO;

// Parkinglock state
typedef enum tagEM_PARKINGLOCK_STATE
{
	EM_PARKINGLOCK_STATE_UNKNOWN = 0,										// Unknown
	EM_PARKINGLOCK_STATE_LOCKRISE,											// Lock rise
	EM_PARKINGLOCK_STATE_LOCKDOWN,											// Lock down
	EM_PARKINGLOCK_STATE_LOCKERROR,											// Lock error
}EM_PARKINGLOCK_STATE;

// Trigger source
typedef enum tagEM_TRIGGER_SOURCE
{
	EM_TRIGGER_SOURCE_UNKNOWN = 0,											// Unknown
	EM_TRIGGER_SOURCE_SWING_ARM,											// Swing arm
	EM_TRIGGER_SOURCE_BLUETOOTH,											// Bluetooth control
	EM_TRIGGER_SOURCE_RS485,												// RS485 control
	EM_TRIGGER_SOURCE_ULTRASOUND,											// Ultrasound detection
	EM_TRIGGER_SOURCE_REMOTE_CONTROL,										// Remote control
}EM_TRIGGER_SOURCE;

// alram of parkinglock state( DH_ALARM_PARKINGLOCK_STATE )
typedef struct tagALARM_PARKINGLOCK_STATE_INFO
{
	int							nIndex;										// Channel ID
	int							nAction;									// Event operation. 0=pulse event.1=continues event begin. 2=continuous event stop
	NET_TIME_EX					UTC;										// Event occurrence time	

	UINT						nLane;										// Parking number
	EM_PARKINGLOCK_STATE		emState;									// State
	EM_TRIGGER_SOURCE			emTriggerSource;							// The trigger source
	BYTE						byReserved[1024];							// Reserved 
}ALARM_PARKINGLOCK_STATE_INFO;

// NAS server name
typedef enum tagEM_SERVERNAME
{
	EM_SERVERNAME_UNKNOWN,		// Unknown
	EM_SERVERNAME_NFS,			// NFS
	EM_SERVERNAME_FTP,			// FTP
	EM_SERVERNAME_SAMBA,		// SAMBA
	EM_SERVERNAME_ISCSI,		// ISCSI
}EM_SERVERNAME;

// NAS server alarm info(Corresponding to DH_ALARM_NAS_SERVER_STATE)
typedef struct tagALARM_NAS_SERVER_STATE_INFO
{
	int							nAction;									// Event operation.1=continues event begin. 2=continuous event stop
	NET_TIME_EX					UTC;										// Event occurrence time
	EM_SERVERNAME				emServerNames[4];							// NAS server name
	int							nRetServerNamesNum;							// return NAS server name num
	BYTE						byReserved[1024];							// Reserved
}ALARM_NAS_SERVER_STATE_INFO;

// Volume group fault alarm info(Corresponding to DH_ALARM_VOLUME_GROUP_FAULT)
typedef struct tagALARM_VOLUME_GROUP_FAULT_INFO
{
	int							nAction;									// Event operation.1=continues event begin. 2=continuous event stop
	NET_TIME_EX					UTC;										// Event occurrence time
	char						szName[32];									// Volume fault name
	char						szMembers[512][32];							// Volume members
	int							nRetMembersNum;								// Return volume members num
	BYTE						byReserved[1024];							// Reserved
}ALARM_VOLUME_GROUP_FAULT_INFO;

// Disk check alarm info(Corresponding to DH_ALARM_DISK_CHECK)
typedef struct tagALARM_DISK_CHECK_INFO
{
	int							nAction;									// Event operation.1=continues event begin. 2=continuous event stop
	NET_TIME_EX					UTC;										// Event occurrence time
	char						szName[128];								// Name
	BYTE						byReserved[1024];							// Reserved
}ALARM_DISK_CHECK_INFO;

///////////////////////////////// The recording session /////////////////////////////////////////

// CLIENT_StartBurnSession port input parameter
typedef struct tagNET_IN_START_BURN_SESSION 
{
    DWORD               dwSize;
    unsigned int        nSessionID;                         // session ID
} NET_IN_START_BURN_SESSION;

typedef struct tagNET_OUT_START_BURN_SESSION 
{
    DWORD               dwSize;
} NET_OUT_START_BURN_SESSION;

// Burning session
typedef enum tagNET_BURN_MODE
{
    BURN_MODE_SYNC,                     // sync
    BURN_MODE_TURN,                     // turn
    BURN_MODE_CYCLE,                    // cycle
} NET_BURN_MODE;

// Extension Burning mode
typedef enum tagNET_BURN_EXTMODE
{
	BURN_EXTMODE_UNKNOWN,					 // unknown
    BURN_EXTMODE_NORMAL = 1,                 // Normal Burning
    BURN_EXTMODE_NODISK,                     // Nodist Burning
} NET_BURN_EXTMODE;

// burning stream format
typedef enum tagNET_BURN_RECORD_PACK
{
    BURN_PACK_DHAV,                     // DHAV
    BURN_PACK_PS,                       // PS
    BURN_PACK_ASF,                      // ASF
    BURN_PACK_MP4,                      // MP4
    BURN_PACK_TS,                       // TS
} NET_BURN_RECORD_PACK;

// CLIENT_StartBurn port input parameter
typedef struct tagNET_IN_START_BURN 
{
    DWORD                dwSize;
    DWORD                dwDevMask;                             // burning device mask, by bit means multiple burning device group
    int                  nChannels[DH_MAX_BURN_CHANNEL_NUM];    // burning channel group
    int                  nChannelCount;                         // burning channel number
    NET_BURN_MODE        emMode;                                // burning mode
    NET_BURN_RECORD_PACK emPack;                                // burning stream format
    NET_BURN_EXTMODE     emExtMode;                             // Extension Burning mode
} NET_IN_START_BURN;

// CLIENT_StartBurn port output parameter
typedef struct tagNET_OUT_START_BURN 
{
    DWORD               dwSize;
} NET_OUT_START_BURN;

// CLIENT_BurnMarkTag port input parameter
typedef struct tagNET_IN_BURN_MAAK_TAG
{
    DWORD               dwSize;
    const char*         pszDescInfo;                            // mark description info
} NET_IN_BURN_MARK_TAG;

// CLIENT_BurnMarkTag port output parameter
typedef struct tagNET_OUT_BURN_MAAK_TAG
{
    DWORD               dwSize;
} NET_OUT_BURN_MARK_TAG;

// CLIENT_BurnChangeDisk port input parameter
typedef struct tagNET_IN_BURN_CHANGE_DISK
{
    DWORD               dwSize;
    BOOL                nAction;                                // switch action, 0-start, 1-end
} NET_IN_BURN_CHANGE_DISK;

// CLIENT_BurnChangeDisk port output parameter
typedef struct tagNET_OUT_BURN_CHANGE_DISK
{
    DWORD               dwSize;
} NET_OUT_BURN_CHANGE_DISK;

// burning status
typedef enum tagNET_BURN_STATE
{
    BURN_STATE_STOP,                    // stop
    BURN_STATE_STOPING,                 // stoping
    BURN_STATE_INIT,                    // initialize
    BURN_STATE_BURNING,                 // burning
    BURN_STATE_PAUSE,                   // pause
    BURN_STATE_CHANGE_DISK,             // changing
    BURN_STATE_PREPARE_EXTRA_FILE,      // attachment initialize
    BURN_STATE_WAIT_EXTRA_FILE,         // wait for attachment burning
    BURN_STATE_UPLOAD_FILE_START,       // attachment burning
    BURN_STATE_CHECKING_DISK,           // detecting disk
    BURN_STATE_DISK_READY,              // disk is ready
} NET_BURN_STATE;

// burning error code
typedef enum tagNET_BURN_ERROR_CODE
{
    BURN_CODE_NORMAL,                   // normal
    BURN_CODE_UNKNOWN_ERROR,            // unknown error
    BURN_CODE_SPACE_FULL,               // burning full
    BURN_CODE_START_ERROR,              // start burning error
    BURN_CODE_STOP_ERROR,               // stop burning  error
    BURN_CODE_WRITE_ERROR,              // burning error
	BURN_CODE_UNKNOWN,					// unknown
} NET_BURN_ERROR_CODE;

// CLIENT_BurnGetState port input parameter
typedef struct tagNET_IN_BURN_GET_STATE
{
    DWORD                dwSize;
} NET_IN_BURN_GET_STATE;

// CD driver used state
typedef enum tagEM_NET_BURN_DEV_USED_STATE
{
	EM_NET_BURN_DEV_USED_STATE_UNKNOWN, // unknown
	EM_NET_BURN_DEV_USED_STATE_STOP,	// stop
	EM_NET_BURN_DEV_USED_STATE_BURNING,	// buring
}EM_NET_BURN_DEV_USED_STATE;

// burning device status
typedef struct tagNET_BURN_DEV_STATE 
{
    DWORD                dwSize;
    int                  nDeviceID;                             // ROM device ID
    char                 szDevName[DH_BURNING_DEV_NAMELEN];     // ROM devicename
    DWORD                dwTotalSpace;                          // ROM total capacity, uni KB
    DWORD                dwRemainSpace;                         // ROM remaining capacity, unit KB
	EM_NET_BURN_DEV_USED_STATE	            emUsedType;			// ROM used state
	NET_BURN_ERROR_CODE						emError;			// sing ROM error
} NET_BURN_DEV_STATE;

// CLIENT_BurnGetState port output parameter
typedef struct tagNET_OUT_BURN_GET_STATE
{
    DWORD                dwSize;
    NET_BURN_STATE       emState;                               // burning status
    NET_BURN_ERROR_CODE  emErrorCode;                           // error code
    DWORD                dwDevMask;                             // burning device mask, by bit means multiple device group
    int                  nChannels[DH_MAX_BURN_CHANNEL_NUM];    // burning channel group
    int                  nChannelCount;                         // burning channel number
    NET_BURN_MODE        emMode;                                // burning mode
    NET_BURN_RECORD_PACK emPack;                                // burning stream format
    int                  nFileIndex;                            // current burning file no.
    NET_TIME             stuStartTime;                          // burning start time
    NET_BURN_DEV_STATE   stuDevState[DH_MAX_BURNING_DEV_NUM];   // burning device status
    int                  nRemainTime;                           // Event operation. 0=pulse event.1=continues event begin. 2=continuous event stop
	NET_BURN_EXTMODE	 emExtMode;								// extra mode,when emExtMode = BURN_EXTMODE_NODISK,stuDevState maybe invalid
} NET_OUT_BURN_GET_STATE;

// fAttachBurnStateCB parameter
typedef struct tagNET_CB_BURNSTATE
{
    DWORD               dwSize;
    const char*         szState;                        // info type
                                                        //"UploadFileStart":may start to upload attachment
                                                        //"InitBurnDevice":initialize burning device
                                                        //"Burning":burning
                                                        //"BurnExtraFileStop":stop burning
                                                        //"BurnFilePause":pause burning
                                                        //"SpaceFull":burning space full
                                                        //"BurnFileError": burning error    
    const char*         szFileName;                     // current burning file name, use to "UploadFileStart" start upload attachment info
    unsigned int        dwTotalSpace;                   // total capacity, unit KB, use to "Burning" , display capacity or calculate progress
    unsigned int        dwRemainSpace;                  // free capacity, unit KB, useto "Burning"
    const char*         szDeviceName;                   // burning device name, use for different burning devices
    int                 nRemainTime;                    // Burning remaining time. Unit is second. -1=invalid 
}NET_CB_BURNSTATE;

// burning device callback function original, lAttachHandle is CLIENT_AttachBurnState return value,each 1 item, pBuf->dwSize == nBufLen
typedef void (CALLBACK *fAttachBurnStateCB) (LLONG lLoginID, LLONG lAttachHandle, NET_CB_BURNSTATE* pBuf, int nBufLen, LDWORD dwUser);

// burning device callback extension function original
typedef void (CALLBACK *fAttachBurnStateCBEx)(LLONG lLoginID, LLONG lAttachHandle, NET_OUT_BURN_GET_STATE* pBuf, int nBufLen, LDWORD dwUser);

// CLIENT_AttachBurnState() input parameter
typedef struct tagNET_IN_ATTACH_STATE
{
    DWORD                   dwSize;
    const char*             szDeviceName;                   // disk name, as "/dev/sda"
    fAttachBurnStateCB      cbAttachState;                  // burning listening callback
    LDWORD                  dwUser;                         // user data
    LLONG                   lBurnSession;                   // burning session handle, CLIENT_StartBurnSession retuen value. This value is 0, szDeviceName is valid, by burning device subscribe burning status
    fAttachBurnStateCBEx    cbAttachStateEx;                // extension burning listening callback
    LDWORD                  dwUserEx;                       // extension burninglistening callback user data
}NET_IN_ATTACH_STATE;

// CLIENT_AttachBurnState output parameter
typedef struct tagNET_OUT_ATTACH_STATE
{
    DWORD                   dwSize;
}NET_OUT_ATTACH_STATE;

// burning device callback function orginal, lUploadHandle is CLIENT_StartUploadFileBurned return value
typedef void (CALLBACK *fBurnFileCallBack) (LLONG lLoginID, LLONG lUploadHandle, int nTotalSize, int nSendSize, LDWORD dwUser);

// CLIENT_StartUploadFileBurned() input parameter
typedef struct tagNET_IN_FILEBURNED_START
{
    DWORD                   dwSize;
    const char*             szMode;                        // file upload method "append", append mode, now burning file name fixed as" FILE.zip ",filename ignored
    const char*             szDeviceName;                  // disk name, as "/dev/sda"
    const char*             szFilename;                    // local file name
    fBurnFileCallBack       cbBurnPos;                     // burning progress callback
    LDWORD                  dwUser;                        // user data
    LLONG                   lBurnSession;                  // burning handle, CLIENT_StartBurnSession return value This value is , szDeviceName valid, now by burning device subscribe burning status
}NET_IN_FILEBURNED_START;

// CLIENT_StartUploadFileBurned output parameter
typedef struct tagNET_OUT_FILEBURNED_START
{
    DWORD                   dwSize;
    char                    szState[DH_MAX_NAME_LEN];      // "start":system is ready,may start to upload; "busy":system busy, try later."error":system is not burning, return error, request failed
}NET_OUT_FILEBURNED_START;

// burning case info
typedef struct tagNET_BURN_CASE_INFO
{
    DWORD       dwSize;
    int         nChannel;                                   // channel no.
    NET_TIME    stuStartTime;                               // burning start time
    NET_TIME    stuEndTime;                                 // burning end time
    int         nIndex;                                     // sn
    int         nCode;                                      // no.
    int         nDiscNum;                                   // disk no.        
    char        szName[DH_COMMON_STRING_128];               // name
    char        szPlace[DH_COMMON_STRING_128];              // location
    char        szInvestigator[DH_MAX_CASE_PERSON_NUM][DH_COMMON_STRING_32]; // handled by
    char        szSuspects[DH_MAX_CASE_PERSON_NUM][DH_COMMON_STRING_32];     // invloved
    char        szMemo[DH_COMMON_STRING_256];               // note
    char        szVideoName[DH_COMMON_STRING_128];          // record name
    char        szRecorder[DH_COMMON_STRING_32];            // burned by
} NET_BURN_CASE_INFO;

// burning device callback function original, lAttachHandle is CLIENT_AttachBurnCase return value
typedef void (CALLBACK *fBurnCaseCallBack) (LLONG lAttachHandle, NET_BURN_CASE_INFO* pBuf, DWORD dwBufLen, void* pReserved, LDWORD dwUser);

// CLIENT_AttachBurnCase port input parameter
typedef struct tagNET_IN_ATTACH_BURN_CASE
{
    DWORD                dwSize;
    fBurnCaseCallBack    cbBurnCase;                        // case info callback function
    LDWORD               dwUser;                            // user data
} NET_IN_ATTACH_BURN_CASE;

// CLIENT_AttachBurnCase port output parameter
typedef struct tagNET_OUT_ATTACH_BURN_CASE
{
    DWORD                dwSize;
} NET_OUT_ATTACH_BURN_CASE;

// burning device state info
typedef enum tagEM_NET_BURN_DEV_BUS_TYPE
{
    EM_NET_BURN_DEV_BUS_TYPE_UNKNOWN,   // Unknown
    EM_NET_BURN_DEV_BUS_TYPE_IDE,       // IDE
    EM_NET_BURN_DEV_BUS_TYPE_USB,       // USB
    EM_NET_BURN_DEV_BUS_TYPE_1394,      // 1394
    EM_NET_BURN_DEV_BUS_TYPE_SATA,      // SATA
    EM_NET_BURN_DEV_BUS_TYPE_ESATA,     // ESATA
}EM_NET_BURN_DEV_BUS_TYPE;
// device burn medium type
typedef enum tagEM_NET_BURN_DEV_BK_TYPE
{
    EM_NET_BURN_DEV_BK_TYPE_UNKNOWN,    // Unknown
    EM_NET_BURN_DEV_BK_TYPE_DHFS,       // dahua file system
    EM_NET_BURN_DEV_BK_TYPE_DISK,       // Disk
    EM_NET_BURN_DEV_BK_TYPE_CDRW,       // cdrom
}EM_NET_BURN_DEV_BK_TYPE;
// device burn state information
typedef struct tagNET_BURN_DEV_STATE_INFO
{
    char            szName[DH_COMMON_STRING_256];               // burning device name
    unsigned int    nTotalSpace;                                // CD driver total space, unit KB
    unsigned int    nFreeSpace;                                 // CD driver free space, unit KB
    EM_NET_BURN_DEV_TRAY_TYPE        emTrayType;                // CD driver tray state
    EM_NET_BURN_DEV_OPERATE_TYPE     emOperateType;             // CD driver using state
    EM_NET_BURN_DEV_BUS_TYPE         emBusType;                 // burning device bus type
    EM_NET_BURN_DEV_BK_TYPE          emBkType;                  // burning device bk type
} NET_BURN_DEV_STATE_INFO;



// the info list of burning device's state
typedef struct tagNET_BURN_DEV_STATE_INFO_LIST
{
    unsigned int    nListCount; // list count
	NET_BURN_DEV_STATE_INFO *pstuNetBurnDevStateInfo;   // list info
}NET_BURN_DEV_STATE_INFO_LIST;

// burning device state callback function original,lAttachHandle is CLIENT_AttachBurnDevState return value
typedef void (CALLBACK *fBurnDevStateCallBack) (LLONG lAttachHandle, const NET_BURN_DEV_STATE_INFO_LIST* pBuf, DWORD dwBufLen, void* pReserved, LDWORD dwUser);

// CLIENT_AttachBurnDevState port input parameter
typedef struct tagNET_IN_ATTACH_BURN_DEV_STATE
{
    DWORD                       dwSize;
    fBurnDevStateCallBack       cbBurnDevState;             // burning device state callback function
    LDWORD                      dwUser;                     // user data
} NET_IN_ATTACH_BURN_DEV_STATE;

// CLIENT_AttachBurnDevState port output parameter
typedef struct tagNET_OUT_ATTACH_BURN_DEV_STATE
{
    DWORD                dwSize;
} NET_OUT_ATTACH_BURN_DEV_STATE;

/////////////////////////////////// Case backup burn files ///////////////////////////////////////

#define CASE_BACK_UP_CHANNEL_MAX_NUM        32  // the max channel num of backupping case
#define CASE_BACK_UP_FILE_TYPE_MAX_NUM      8   // the max file type num of backupping case
#define CASE_BACK_UP_INQUEST_INFO_MAX_NUM   8   // the max inquest info num of backupping case
#define CASE_BACK_UP_DEVICE_MAX_NUM         8   // the max device num of backupping case

// the file type for backupping case
typedef enum tagEM_CASE_BACK_UP_FILE_TYPE
{
    EM_CASE_BACK_UP_FILE_TYPE_UNKNOWN,          // Unknown
    EM_CASE_BACK_UP_FILE_TYPE_DAV,              // DAV
    EM_CASE_BACK_UP_FILE_TYPE_JPG,              // JPG
    EM_CASE_BACK_UP_FILE_TYPE_TXT,              // TXT
}EM_CASE_BACK_UP_FILE_TYPE;

// the mode of backupping case
typedef enum tagEM_CASE_BACK_UP_MODE_TYPE
{
    EM_CASE_BACK_UP_MODE_TYPE_UNKNOWN,          // Unknown
    EM_CASE_BACK_UP_MODE_TYPE_SYNC,             // Sync:all the devices burn the same files
    EM_CASE_BACK_UP_MODE_TYPE_CYCLE,            // Cycle:burn the files with devices on by one
}EM_CASE_BACK_UP_MODE_TYPE;

// the pack type of backupping case
typedef enum tagEM_CASE_BACK_UP_PACK_TYPE
{
    EM_CASE_BACK_UP_PACK_TYPE_UNKNOWN,          // Unknown
    EM_CASE_BACK_UP_PACK_TYPE_DHAV,             // DHAV
    EM_CASE_BACK_UP_PACK_TYPE_MP4,              // MP4
    EM_CASE_BACK_UP_PACK_TYPE_PS,               // PS   
}EM_CASE_BACK_UP_PACK_TYPE;

// the inquest info of backupping case
typedef struct tagNET_CASE_BACK_UP_INQUEST_INFO
{
    char szTitle[128];                          // Title
    char szText[128];                           // Text
    BYTE byReserved[512];                       // Reserved
}NET_CASE_BACK_UP_INQUEST_INFO;

// the conditon of backupping case
typedef struct tagNET_CASE_BACK_UP_QUERY_CONDITION
{
    int                             nChannelNum;                                        // channel num                            
    int                             nChannels[CASE_BACK_UP_CHANNEL_MAX_NUM];            // the array of channels
    NET_TIME                        stuStartTime;                                       // start time
    NET_TIME                        stuEndTime;                                         // end time
    int                             nFileTypeNum;                                       // file type num
    EM_CASE_BACK_UP_FILE_TYPE       emFileTypes[CASE_BACK_UP_FILE_TYPE_MAX_NUM];        // the array of file types
    char                            szCaseNumber[256];                                  // case number
    int                             nInquestInfoNum;                                    // inquest info num
    NET_CASE_BACK_UP_INQUEST_INFO   stuInquestInfo[CASE_BACK_UP_INQUEST_INFO_MAX_NUM];  // the array of inquest info
    BYTE                            byReserved[1024];                                   // reserved
}NET_CASE_BACK_UP_QUERY_CONDITION;

// the mode info of backupping case
typedef struct tagNET_CASE_BACK_UP_MODE
{
    EM_CASE_BACK_UP_MODE_TYPE   emBackupMode;                                           // backup mode
    int                         nDeviceNum;                                             // device num
    char                        szDeviceName[CASE_BACK_UP_DEVICE_MAX_NUM][256];         // the array of device
    EM_CASE_BACK_UP_PACK_TYPE   emPackType;                                             // backup file type
    BOOL                        bExtraFile;                                             // extra file enable or not
    BOOL                        bDataCheck;                                             // data check enable or not
    BYTE                        byReserved[1024];                                       // reserved
}NET_CASE_BACK_UP_MODE;

// the in param of start case backup
typedef struct tagNET_IN_START_CASE_BACK_UP
{
    DWORD                               dwSize;                                         // struct size
    NET_CASE_BACK_UP_QUERY_CONDITION    stuCondition;                                   // condition
    NET_CASE_BACK_UP_MODE               stuMode;                                        // backup mode
}NET_IN_START_CASE_BACK_UP;

// the error code type of start case backup
typedef enum tagEM_CASE_BACK_UP_START_ERROR_CODE
{
    EM_CASE_BACK_UP_START_ERROR_CODE_UNKNOWN,                                           // Unknown
    EM_CASE_BACK_UP_START_ERROR_CODE_NORMAL,                                            // Normal
    EM_CASE_BACK_UP_START_ERROR_CODE_BACKUPING,                                         // Backupping
    EM_CASE_BACK_UP_START_ERROR_CODE_NO_FINDFILE,                                       // can not find the file
    EM_CASE_BACK_UP_START_ERROR_CODE_DEVICE_BUSY,                                       // device is busy
    EM_CASE_BACK_UP_START_ERROR_CODE_NO_SUPPORT_MEDIA_FORMAT,                           // not supported media format
    EM_CASE_BACK_UP_START_ERROR_CODE_DEVICE_ERROR,                                      // device error
    EM_CASE_BACK_UP_START_ERROR_CODE_BACKUP_FILE_OVER_LIMIT,                            // Backup File Over Limit    
    EM_CASE_BACK_UP_START_ERROR_CODE_OTHER_ERROR,                                       // other error
}EM_CASE_BACK_UP_START_ERROR_CODE;

// the out param of start case backup
typedef struct tagNET_OUT_START_CASE_BACK_UP
{
    DWORD                               dwSize;                                         // struct size
    EM_CASE_BACK_UP_START_ERROR_CODE    emErrorCode;                                    // error code
}NET_OUT_START_CASE_BACK_UP;

// the in param of stop case backup
typedef struct tagNET_IN_STOP_CASE_BACK_UP
{
    DWORD                               dwSize;                                         // struct size
}NET_IN_STOP_CASE_BACK_UP;

// the out param of stop case backup
typedef struct tagNET_OUT_STOP_CASE_BACK_UP
{
    DWORD                               dwSize;                                         // struct size
}NET_OUT_STOP_CASE_BACK_UP;

// the state type of case backup
typedef enum tagEM_CASE_BACK_UP_STATE_TYPE
{
    EM_CASE_BACK_UP_STATE_TYPE_UNKNOWN,                                                 // Unknown
    EM_CASE_BACK_UP_STATE_TYPE_INIT,                                                    // Initing
    EM_CASE_BACK_UP_STATE_TYPE_STOP,                                                    // stoped
    EM_CASE_BACK_UP_STATE_TYPE_STOPPING,                                                // stopping
    EM_CASE_BACK_UP_STATE_TYPE_BACKUPING,                                               // backupping           
    EM_CASE_BACK_UP_STATE_TYPE_CHANGE_DISK,                                             // change disk
    EM_CASE_BACK_UP_STATE_TYPE_PREPARE_EXTRA_FILE,                                      // prepare of extra file
    EM_CASE_BACK_UP_STATE_TYPE_WAIT_EXTRA_FILE,                                         // wait for extra file
    EM_CASE_BACK_UP_STATE_TYPE_UPLOAD_FILE_START,                                       // upload extra file
}EM_CASE_BACK_UP_STATE_TYPE;

// the error code of state for case backup
typedef enum tagEM_CASE_BACK_UP_ERROR_CODE
{
    EM_CASE_BACK_UP_ERROR_CODE_UNKNOWN,                                                 // Unknown
    EM_CASE_BACK_UP_ERROR_CODE_NORMAL,                                                  // normal
    EM_CASE_BACK_UP_ERROR_CODE_SPACE_FULL,                                              // space full
    EM_CASE_BACK_UP_ERROR_CODE_START_ERROR,                                             // start error   
    EM_CASE_BACK_UP_ERROR_CODE_STOP_ERROR,                                              // stop error
    EM_CASE_BACK_UP_ERROR_CODE_WRITE_ERROR,                                             // write file error   
    EM_CASE_BACK_UP_ERROR_CODE_OTHER_ERROR,                                             // other error      
}EM_CASE_BACK_UP_ERROR_CODE;

// the info of state for case backup
typedef struct tagNET_CASE_BACK_UP_STATE
{
    EM_CASE_BACK_UP_STATE_TYPE  emBackUpState;                                          // backup state
    EM_CASE_BACK_UP_ERROR_CODE  emErrorCode;                                            // error code
    BYTE                        byReserved[512];                                        // reserved
}NET_CASE_BACK_UP_STATE;

// the file info for case backup
typedef struct tagNET_CASE_BACK_UP_FILE_INFO
{
    int                         nFileCount;                                             // the total file count
    int                         nCurFileIndex;                                          // the index of cur backup file 
    TP_U64                      nFileTotalLength;                                       // the total file length
    TP_U64                      nCurBackupTotalLength;                                  // the total length of back-upped files
    TP_U64                      nCurBackupFileTotalLength;                              // the lengh of cur backup file
    TP_U64                      nCurBackupFileLength;                                   // the back-upped length of cur backup file  
    BYTE                        byReserved[512];                                        // reserved
}NET_CASE_BACK_UP_FILE_INFO;

// the device info of case backup
typedef struct tagNET_CASE_BACK_UP_DEVICE_INFO
{
    int                         nDeviceID;                                              // device id
    char                        szDeviceName[256];                                      // device name
    int                         nTotalSpace;                                            // the total space, unit:KB
    int                         nRemainSpace;                                           // the left space, unit:KB
    EM_CASE_BACK_UP_STATE_TYPE  emBackUpState;                                          // the backup state
    EM_CASE_BACK_UP_ERROR_CODE  emErrorCode;                                            // error code
    BYTE                        byReserved[512];                                        // reserved
}NET_CASE_BACK_UP_DEVICE_INFO;

// the state of case backup for callback
typedef struct tagNET_OUT_CASE_BACK_UP_STATE
{
    DWORD                           dwSize;                                             // struct size
    NET_CASE_BACK_UP_STATE          stuBackUpState;                                     // state info
    NET_CASE_BACK_UP_FILE_INFO      stuFileInfo;                                        // file info
    int                             nDeviceNum;                                         // device num    
    NET_CASE_BACK_UP_DEVICE_INFO    stuDeviceInfo[CASE_BACK_UP_DEVICE_MAX_NUM];         // the array of device    
}NET_OUT_CASE_BACK_UP_STATE;

// the callback function for case backup state
typedef void (CALLBACK *fAttachCaseBackUpState)(LLONG lLoginID, LLONG lAttachHandle, const NET_OUT_CASE_BACK_UP_STATE* pBuf, int nBufLen, LDWORD dwUser);

// the in param for attach case backup state
typedef struct tagNET_IN_ATTACH_CASE_BACK_UP_STATE
{
    DWORD                           dwSize;                                             // struct size
    fAttachCaseBackUpState          cbAttachState;                                      // callback function
    LDWORD                          dwUser;                                             // user data
}NET_IN_ATTACH_CASE_BACK_UP_STATE;

// the out param for attach case backup state
typedef struct tagNET_OUT_ATTACH_CASE_BACK_UP_STATE
{
    DWORD                           dwSize;                                             // struct size
}NET_OUT_ATTACH_CASE_BACK_UP_STATE;

// the in param for detach case backup state
typedef struct tagNET_IN_DETACH_CASE_BACK_UP_STATE
{
    DWORD                           dwSize;                                             // struct size
}NET_IN_DETACH_CASE_BACK_UP_STATE;

// the out param for detach case backup state
typedef struct tagNET_OUT_DETACH_CASE_BACK_UP_STATE
{
    DWORD                           dwSize;                                             // struct size
}NET_OUT_DETACH_CASE_BACK_UP_STATE;

// the in param for get info of case backup 
typedef struct tagNET_IN_GET_CASE_BACK_UP_INFO
{
    DWORD                           dwSize;                                             // struct size
}NET_IN_GET_CASE_BACK_UP_INFO;

// the out param for get info of case backup
typedef struct tagNET_OUT_GET_CASE_BACK_UP_INFO
{
    DWORD                               dwSize;                                         // struct size
    NET_CASE_BACK_UP_QUERY_CONDITION    stuCondition;                                   // condition
    NET_CASE_BACK_UP_MODE               stuMode;                                        // backup mode
}NET_OUT_GET_CASE_BACK_UP_INFO;

// start case backup
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartBackUpCase(LLONG lLoginID, const NET_IN_START_CASE_BACK_UP* pstInParam, NET_OUT_START_CASE_BACK_UP *pstOutParam, int nWaitTime );

// stop case backup
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopBackUpCase(LLONG lLoginID, const NET_IN_STOP_CASE_BACK_UP* pstInParam, NET_OUT_STOP_CASE_BACK_UP *pstOutParam, int nWaitTime );

// attach the state of case backup
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachBackUpCaseState(LLONG lLoginID, const NET_IN_ATTACH_CASE_BACK_UP_STATE* pstInParam, NET_OUT_ATTACH_CASE_BACK_UP_STATE *pstOutParam, int nWaitTime );

// detach the state of case backup
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachBackUpCaseState(LLONG lAttachHandle, const NET_IN_DETACH_CASE_BACK_UP_STATE* pstInParam, NET_OUT_DETACH_CASE_BACK_UP_STATE *pstOutParam, int nWaitTime );

// get the info of case backup
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetCaseBackUpInfo(LLONG lLoginID, const NET_IN_GET_CASE_BACK_UP_INFO* pstInParam, NET_OUT_GET_CASE_BACK_UP_INFO *pstOutParam, int nWaitTime );

/////////////////////////////////// Case backup burn files ///////////////////////////////////////

/////////////////////////////////// Compose channel ///////////////////////////////////////

#define NET_COMPOSE_CHANNEL_MAX_SPLIT_WINDOW_NUM 36     // the max split window num of compose channel

// the temp split window info
typedef struct tagNET_TEMP_SPLIT_WINDOW_INFO
{
    int nChannel;                                       // the channel number
    BOOL bAudio;                                        // the video and audio mixed or not
    DH_RECT stuPosition;                                // window position,The point coordinates [0,8192)
    BYTE byReserved[128];                               // reserved
}NET_TEMP_SPLIT_WINDOW_INFO;

// the in param of get the temp split info
typedef struct tagNET_IN_GET_TEMP_SPLIT
{
    DWORD dwSize;                                       // struct size
    int nComposeChannel;                                // the compose channel
}NET_IN_GET_TEMP_SPLIT;

// the out param of get the temp split info
typedef struct tagNET_OUT_GET_TEMP_SPLIT
{
    DWORD dwSize;                                       // struct size
    DH_SPLIT_MODE emSplitMode;                          // split mode,max to DH_SPLIT_36
    int nSplitNum;                                      // the window num,max to 36
    NET_TEMP_SPLIT_WINDOW_INFO stuWindowInfo[NET_COMPOSE_CHANNEL_MAX_SPLIT_WINDOW_NUM]; // the array of window
}NET_OUT_GET_TEMP_SPLIT;

// the in param of set the temp split info
typedef struct tagNET_IN_SET_TEMP_SPLIT
{
    DWORD dwSize;                                       // struct size
    int nComposeChannel;                                // the compose channel
    DH_SPLIT_MODE emSplitMode;                          // split mode,max to DH_SPLIT_36
    int nSplitNum;                                      // the window num,max to 36
    NET_TEMP_SPLIT_WINDOW_INFO stuWindowInfo[NET_COMPOSE_CHANNEL_MAX_SPLIT_WINDOW_NUM]; // the array of window
}NET_IN_SET_TEMP_SPLIT;

// the out param of set the temp split
typedef struct tagNET_OUT_SET_TEMP_SPLIT
{
    DWORD dwSize;                                       // struct size
}NET_OUT_SET_TEMP_SPLIT;

// the split window info
typedef struct tagNET_TEMP_SOURCE_WINDOW_INFO
{
    int nWindowID;                                      // window index,start from 0
    int nUniqueChannel;                                 // the unique channel
    BYTE byReserved[128];                               // reserved
}NET_TEMP_SOURCE_WINDOW_INFO;

// the in param of set the temp split source
typedef struct tagNET_IN_SET_TEMP_SOURCE
{
    DWORD dwSize;                                       // struct size
    int nComposeChannel;                                // the compose channel
    int nWindowNum;                                     // the window num
    NET_TEMP_SOURCE_WINDOW_INFO stuWindowInfo[NET_COMPOSE_CHANNEL_MAX_SPLIT_WINDOW_NUM]; // the array of window info
}NET_IN_SET_TEMP_SOURCE;

// the out param of set the temp split source
typedef struct tagNET_OUT_SET_TEMP_SOURCE
{
    DWORD dwSize;                                       // struct size   
}NET_OUT_SET_TEMP_SOURCE;

// set the temp split info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetTempSplit(LLONG lLoginID, const NET_IN_SET_TEMP_SPLIT* pstInParam, NET_OUT_SET_TEMP_SPLIT *pstOutParam, int nWaitTime );

// get the temp split info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetTempSplit(LLONG lLoginID, const NET_IN_GET_TEMP_SPLIT* pstInParam, NET_OUT_GET_TEMP_SPLIT *pstOutParam, int nWaitTime );

// set the temp split source info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetTempSource(LLONG lLoginID, const NET_IN_SET_TEMP_SOURCE* pstInParam, NET_OUT_SET_TEMP_SOURCE *pstOutParam, int nWaitTime );

/////////////////////////////////// Combined Channel ///////////////////////////////////////

/////////////////////////////////// Storage ///////////////////////////////////////

// remote storage writing-in result
typedef enum tagNET_STORAGE_WRITE_STATE
{
    NS_WRITE_UNKNOWN,                                   // unknown
    NS_WRITE_OK,                                        // successful
    NS_WRITE_DISK_IO_ERROR,                             // disk IO error
    NS_WRITE_DISK_NOT_READY,                            // disk not ready
    NS_WRITE_DISK_FAULT,                                // disk failure
    NS_WRITE_STREAM_NOT_EXIST,                          // data stream ID inexists
    NS_WRITE_MOUNT_DISK_ERROR,                          // disk load error
} NET_STORAGE_WRITE_STATE;

// remote module info
typedef struct tagNET_STORAGE_BLOCK 
{
    DWORD                   dwSize;
    unsigned int            nID;                        // CQFS module ID
    unsigned int            nStreamID;                  // data stream SN
    unsigned int            nRecycleTimestamp;          // CQFS recycle time stamp
    unsigned int            nBeginTimestamp;            // module internal data start time stamp
    unsigned int            nEndTimestamp;              // module internal data endtime stamp
    unsigned int            nLockCount;                 // lock value, 0 means not locked
    char                    szDiskUUID[DH_COMMON_STRING_64]; // disk UUID
} NET_STORAGE_BLOCK;

// remote storage info status
typedef struct tagNET_STORAGE_WRITE_INFO
{
    DWORD                    dwSize;
    NET_STORAGE_WRITE_STATE  emState;                   // writing in result
    int                      nBlockCount;               // module quantity
    NET_STORAGE_BLOCK        stuBlocks[DH_MAX_NET_STRORAGE_BLOCK_NUM]; // module info
} NET_STORAGE_WRITE_INFO;

//////////////////////////////////////////////////////////////////////////
/// \fn subscribe write-in remote storage info status callback function
/// \brief 
/// \author yang_xiuqing
/// \param  LLONG lAttachHandle [OUT] subscribe handle, CLIENT_NetStorageAttachWriteInfo return value 
/// \param  NET_STORAGE_WRITE_INFO * pBuf [OUT] remote storage info status
/// \param  int nBufLen [OUT] status info length
/// \param  LDWORD dwUser user data
/// \return n/a
///////////////////////////////////////////////////////////////////////////
typedef void (CALLBACK *fNetStorageAttachWriteInfoCB)(LLONG lAttachHandle, NET_STORAGE_WRITE_INFO* pBuf, int nBufLen, LDWORD dwUser);

// CLIENT_NetStorageAttachWriteInfo port input parameter
typedef struct tagNET_IN_STORAGE_ATTACH_WRITE_INFO
{
    DWORD                           dwSize;
    const char*                     pszName;                // remote storage name, value from NAS config
    fNetStorageAttachWriteInfoCB    cbISCSIBlcok;           // callback function
    LDWORD                          dwUser;                 // user data
} NET_IN_STORAGE_ATTACH_WRITE_INFO;

// CLIENT_NetStorageAttachWriteInfo port output parameter
typedef struct tagNET_OUT_STORAGE_ATTACH_WRITE_INFO
{
    DWORD                       dwSize;
} NET_OUT_STORAGE_ATTACH_WRITE_INFO;

// CLIENT_NetStorageGetWriteInfo port input parameter
typedef struct tagNET_IN_STORAGE_GET_WRITE_INFO 
{
    DWORD                       dwSize;
    const char*                 pszName;                    // remote storage name
} NET_IN_STORAGE_GET_WRITE_INFO;

// CLIENT_NetStorageGetWriteInfo port output parameter
typedef struct tagNET_OUT_STORAGE_GET_WRITE_INFO 
{
    DWORD                       dwSize;    
    int                         nBlockCount;                // module quantity
    NET_STORAGE_BLOCK           stuBlocks[DH_MAX_NET_STRORAGE_BLOCK_NUM]; // module info
} NET_OUT_STORAGE_GET_WRITE_INFO;

// RAID operation type
typedef enum tagNET_RAID_OPERATE_TYPE
{
    NET_RAID_OPERATE_ADD,                    // add RAID, corresponding structure  NET_IN_RAID_ADD  and NET_OUT_RAID_ADD
    NET_RAID_OPERATE_REMOVE,                 // delete RAID, corresponding structure  NET_IN_RAID_REMOVE  and NET_OUT_RAID_REMOVE
    NET_RAID_OPERATE_GET_SUBDEVICE,          // get RAID sub device info, corresponding structure  NET_IN_RAID_GET_SUBDEVICE  and NET_OUT_RAID_GET_SUBDEVICE
    NET_RAID_OPERATE_GET_SUBSMART,           // get RAID sub device SMART info, corresponding structure  NET_IN_RAID_GET_SUBSMART  and NET_OUT_RAID_GET_SUBSMART
    NET_RAID_OPERATE_MODIFY,                 // modify RAID, corresponding to  structure  NET_IN_RAID_MODIFY and NET_OUT_RAID_MODIFY
} NET_RAID_OPERATE_TYPE;

// RAID info
typedef struct tagNET_RAID_INFO 
{
    DWORD                dwSize;
    char                 szName[DH_COMMON_STRING_64];     // name, as time name returned by device
    char                 szLevel[DH_COMMON_STRING_16];    // level, such as "RAID0", "RAID5" and etc.
    int                  nMemberNum;                      // member quantity
    char                 szMembers[DH_MAX_MEMBER_PER_RAID][DH_COMMON_STRING_64]; // member info
} NET_RAID_INFO;

// add RAID return result
typedef struct tagNET_RAID_ADD_RESULT 
{
    DWORD                dwSize;
    BOOL                 bResult;
    DWORD                dwErrorCode;                    // failed error code
    char                 szName[DH_COMMON_STRING_64];    // name
} NET_RAID_ADD_RESULT;

// add RAID input parameter
typedef struct tagNET_IN_RAID_ADD 
{
    DWORD                dwSize;
    int                  nRaidNun;                        	// RAID quantity
    NET_RAID_INFO        stuRaids[DH_MAX_RAID_NUM];         // RAID info
} NET_IN_RAID_ADD;

// add RAID oiutput parameter
typedef struct tagNET_OUT_RAID_ADD 
{
    DWORD                dwSize;
    int                  nResultNum;                        // result
    NET_RAID_ADD_RESULT  stuResults[DH_MAX_RAID_NUM];       // RAID operation result
} NET_OUT_RAID_ADD;

// delete RAID return result
typedef struct tagNET_RAID_REMOVE_RESULT 
{
    DWORD                dwSize;
    BOOL                 bResult;
    DWORD                dwErrorCode;                       // failed error code
} NET_RAID_REMOVE_RESULT;

// delete RAID input parameter
typedef struct tagNET_IN_RAID_REMOVE 
{
    DWORD                dwSize;
    int                  nRaidNum;                         // RAID quantity
    char                 szRaids[DH_MAX_RAID_NUM][DH_COMMON_STRING_64];    // RAID name group
} NET_IN_RAID_REMOVE;

// delete RAID output parameter
typedef struct tagNET_OUT_RAID_REMOVE
{
    DWORD                dwSize;
    int                  nResultNum;                       // result
    NET_RAID_REMOVE_RESULT stuResults[DH_MAX_RAID_NUM];    // RAID operation result
} NET_OUT_RAID_REMOVE;

// get RAID sub device input parameter
typedef struct tagNET_IN_RAID_GET_SUBDEVICE 
{
    DWORD                dwSize;
    const char*          pszRaidName;                    // RAID name
} NET_IN_RAID_GET_SUBDEVICE;

// get RAID sub device output parameter
typedef struct tagNET_OUT_RAID_GET_SUBDEVICE 
{
    DWORD                dwSize;
    int                  nSubDeviceNum;                  // sub device quantity
    DH_STORAGE_DEVICE    stuSubDevices[DH_MAX_MEMBER_PER_RAID]; // sub device quantity
} NET_OUT_RAID_GET_SUBDEVICE;

// RAID sub device SMART info
typedef struct tagNET_RAID_SMART_INFO 
{
    DWORD                dwSize;
    unsigned int         nID;                            // property ID
    char                 szName[DH_COMMON_STRING_64];    // property name
    int                  nCurrent;                       // property value
    int                  nWorst;                         // max error value
    int                  nThreshold;                     // threshold
    int                  nPredict;                       // status
    char                 szRaw[DH_COMMON_STRING_16];     // actual value
} NET_RAID_SMART_INFO;

// get RAID sub device SMART info input parameter
typedef struct tagNET_IN_RAID_GET_SUBSMART
{
    DWORD                dwSize;
    const char*          pszSubDevName;                  // RAID sub device name 
} NET_IN_RAID_GET_SUBSMART;

// get RAID sub device SMART info output parameter
typedef struct tagNET_OUT_RAID_GET_SUBSMART
{
    DWORD                dwSize;
    int                  nSmartNum;                          // SMART info
    NET_RAID_SMART_INFO  stuSmartInfos[MAX_SMART_VALUE_NUM]; // SMART info
} NET_OUT_RAID_GET_SUBSMART;

// modify RAID return result
typedef struct tagNET_RAID_MODIFY_RESULT 
{
    DWORD                dwSize;
    BOOL                 bResult;
    DWORD                dwErrorCode;                       // failed error code
} NET_RAID_MODIFY_RESULT;

// modify RAID input parameter
typedef struct tagNET_IN_RAID_MODIFY
{
    DWORD                dwSize;
    int                  nRaidNun;                          // RAID quantity
    NET_RAID_INFO        stuRaids[DH_MAX_RAID_NUM];         // RAID info
} NET_IN_RAID_MODIFY;

// modify RAID output parameter
typedef struct tagNET_OUT_RAID_MODIFY 
{
    DWORD                dwSize;
    int                  nResultNum;                        // result
    NET_RAID_MODIFY_RESULT stuResults[DH_MAX_RAID_NUM];     // RAID operation result
} NET_OUT_RAID_MODIFY;


//////////////////////////////// external device //////////////////////////////////////////

// external device type
typedef enum tagNET_EXT_DEV_TYPE
{
    EXT_DEV_UNKNOWN,                    // unknow
    EXT_DEV_PROJECTOR,                  // projector
    EXT_DEV_SEQUENCE_POWER,            	// power sequence
} NET_EXT_DEV_TYPE;

// external device info
typedef struct tagNET_EXTERNAL_DEVICE 
{
    DWORD               dwSize;
    NET_EXT_DEV_TYPE    emType;                             // device type
    char                szDevID[DH_DEV_ID_LEN_EX];          // device ID, SN
    char                szDevName[DH_DEV_ID_LEN_EX];        // device name 
} NET_EXTERNAL_DEVICE;

// power sequence control parameter
typedef struct tagNET_CTRL_SEQPOWER_PARAM
{
    DWORD               dwSize;
    const char*         pszDeviceID;                        // device ID
    int                 nChannel;                           // output or output sequence
} NET_CTRL_SEQPOWER_PARAM;

// projector control parameter
typedef struct tagNET_CTRL_PROJECTOR_PARAM 
{
    DWORD               dwSize;
    const char*         pszDeviceID;                        // device ID
} NET_CTRL_PROJECTOR_PARAM;

// IR button
typedef struct tagNET_CTRL_INFRARED_KEY_PARAM 
{
    DWORD               dwSize;
    int                 nChannel;                           // IR control channel no.
    unsigned int        nKey;                               // IR button ID
} NET_CTRL_INFRARED_KEY_PARAM;

// no HDD alarm
typedef struct tagALARM_NO_DISK_INFO
{
    DWORD               dwSize;
    NET_TIME            stuTime;                            // time
    DWORD               dwAction;                           // event action, 0:Start, 1:Stop
}ALARM_NO_DISK_INFO;
//protective capsule status enumeration
typedef enum __EM_CAPSULE_STATE
{
    CAPSULE_STATE_UNKNOW ,      //undefine
    CAPSULE_STATE_NORMAL ,      //normal
    CAPSULE_STATE_TIME_OUT ,    //overtime
    CAPSULE_STATE_EMERGENCY_CALL,   //sos call
}EM_CAPSULE_STATE;

//protective capsule event
typedef struct tagALARM_PROTECTIVE_CAPSULE_INFO
{
    DWORD               dwSize;
    EM_CAPSULE_STATE    emCapsuleState; //protective capsule status
    DWORD               nLock;          //0:unlock, 1:lock; only when emCapsuleStateis CAPSULE_STATE_NORMAL valid
    DWORD               nInfrared;      //0:idle (no one),1:trigger(someone); only emCapsuleState is CAPSULE_STATE_NORMAL valid
}ALARM_PROTECTIVE_CAPSULE_INFO;

// Get Fish eye capacity input parameter 
typedef struct tagNET_IN_VIDEOIN_FISHEYE_CAPS
{
    DWORD       dwSize; 
    int         nChannel; //channel no.
}NET_IN_VIDEOIN_FISHEYE_CAPS;

// Get Fish eye capacity  output parameter 
typedef struct tagNET_OUT_VIDEOIN_FISHEYE_CAPS
{
    DWORD                   dwSize; 
    int                     nMountModeNum;              // supported installation mode number     
    NET_FISHEYE_MOUNT_MODE  emMountModes[NET_MAX_FISHEYE_MOUNTMODE_NUM]; // supported installation mode list
    int                     nCalibrateModeNum;          // supported Fish eye correction mode number  
    NET_FISHEYE_CALIBRATE_MODE emCalibrateModes[NET_MAX_FISHEYE_CALIBRATEMODE_NUM]; // supported Fish eye correction mode list
    int                     nEPtzCmdNum;                // supported Fish eye E-PTZ operation number 
    NET_FISHEYE_EPTZ_CMD    emEPtzCmds[NET_MAX_FISHEYE_EPTZCMD_NUM]; // supported Fish eye E-PTZ operationlist
    NET_FISHEYE_TYPE        emType;                     // Fish eye type 
}NET_OUT_VIDEOIN_FISHEYE_CAPS;

// get power sequence input parameter
typedef struct tagNET_IN_CAP_SEQPOWER 
{
    DWORD                dwSize;
    const char*          pszDeviceID;                       // device ID
} NET_IN_CAP_SEQPOWER;

// get power sequence output parameter
typedef struct tagNET_OUT_CAP_SEQPOWER
{
    DWORD                dwSize;
    int                  nChannelNum;                       // channel no.
} NET_OUT_CAP_SEQPOWER;

// get device encode config corresponding capacity input parameter
typedef struct tagNET_IN_ENCODE_CFG_CAPS
{
    DWORD               dwSize;           
    int                 nChannelId;                         // channel no.    
    int                 nStreamType;                        // stream type, 0:main stream, 1:sub stream1, 2:sub stream2, 3:sub stream3, 4:snapshot stream
															// can be left unset, whatever value it is set, you get results of main stream, sub stream1 and snapshot stream
    char*               pchEncodeJson;                      // Encode config, cia calling dhconfigsdk.dll port CLIENT_PacketData to get
                                                            // correspondingsampling command is CFG_CMD_ENCODE                 
}NET_IN_ENCODE_CFG_CAPS;

// stream config corresponding capacity
typedef struct tagNET_STREAM_CFG_CAPS
{
    DWORD               dwSize;
    int                 nAudioCompressionTypes[DH_MAX_AUDIO_ENCODE_TYPE]; // supported audio encode type, see DH_TALK_CODING_TYPE
    int                 nAudioCompressionTypeNum;                   // audio compression quantity
    int                 dwEncodeModeMask;                           // video encode mode mask, see "encode mode"
    DH_RESOLUTION_INFO  stuResolutionTypes[DH_MAX_CAPTURE_SIZE_NUM];// supportedvideo resolution, discard
    int                 nResolutionFPSMax[DH_MAX_CAPTURE_SIZE_NUM]; // different resolution max frame, subscript nResolutionTypescorresponding 
    int                 nResolutionTypeNum;                         // video resolution quantity
    int                 nMaxBitRateOptions;                         // max video stream(kbps) 
    int                 nMinBitRateOptions;                         // min video stream(kbps)
    BYTE                bH264ProfileRank[DH_PROFILE_HIGH];          // supported H.264 Profile level,refer to enumeration type EM_H264_PROFILE_RANK;  
    int                 nH264ProfileRankNum;                        // supported H.264 Profile level
    int                 nCifPFrameMaxSize;                          // when resolution is  cif, max p frame(Kbps)
    int                 nCifPFrameMinSize;                          // when currentresolution is cif, min p frame(Kbps)
    int                 nFPSMax;                                    // video max frame rate, as 0 , make nResolutionFPSMax as standard
    DH_RESOLUTION_INFO  stuIndivResolutionTypes[DH_MAX_COMPRESSION_TYPES_NUM][DH_MAX_CAPTURE_SIZE_NUM];// supportedvideo resolution
	BOOL				abIndivResolution;							// 0: stuResolutionTypes,nResolutionTypeNum is valid
                                                                    // 1: stuIndivResolutionTypes, nIndivResolutionNums is valid
    int                 nIndivResolutionNums[DH_MAX_COMPRESSION_TYPES_NUM];// number of video resolution quantity with different encoding mode  
}NET_STREAM_CFG_CAPS;

// get device encode config corresponding capacity output parameter
typedef struct tagNET_OUT_ENCODE_CFG_CAPS
{
    DWORD               dwSize;
    NET_STREAM_CFG_CAPS stuMainFormatCaps[DH_REC_TYPE_NUM];      	// main stream corresponding capacity
    NET_STREAM_CFG_CAPS stuExtraFormatCaps[DH_N_ENCODE_AUX];        // sub stream config corresponding capacity
    NET_STREAM_CFG_CAPS stuSnapFormatCaps[SNAP_TYP_NUM];           	// snap stream config corresponding capacity
    int                 nMainFormCaps;                              // number of main stream config
    int                 nExtraFormCaps;                             // number of Extra stream config
    int                 nSnapFormatCaps;                            // number of snap stream config
}NET_OUT_ENCODE_CFG_CAPS;

// Video detect device caps
typedef struct tagNET_IN_VIDEO_DETECT_CAPS
{
    DWORD               dwSize;           
    int                 nChannel;  //channel, start from 0
}NET_IN_VIDEO_DETECT_CAPS;

// media capability type
typedef enum tagNET_MEDIA_CAP_TYPE
{
    NET_MEDIA_CAP_TYPE_SENSORINFO,      // camera sensor info
} NET_MEDIA_CAP_TYPE;

// CLIENT_GetDevCaps NET_MEDIAMANAGER_CAPS input parameter
typedef struct tagNET_IN_MEDIAMANAGER_GETCAPS
{
    DWORD               dwSize;
    NET_MEDIA_CAP_TYPE  emType;         // capability type to query
} NET_IN_MEDIAMANAGER_GETCAPS;

// get snap config capbility input parameter	 
typedef struct tagNET_IN_SNAP_CFG_CAPS	 	 	 
{        	 	 	 
    int                 nChannelId;                     // channel num(start from 0) 	 	 	 
    BYTE                bReserved[1024];                // Reserved	 	 	 
}NET_IN_SNAP_CFG_CAPS;	 	 	 

#define DH_MAX_FPS_NUM                128                // max length of nFramesPerSecList array	 	 	 
#define DH_MAX_QUALITY_NUM            32                 // max length of nQualityList array	 	 	 

// get snap config capbility output parameter	 	 	 
typedef struct tagNET_OUT_SNAP_CFG_CAPS 	 	 	 
{	 	 	 
    int                 nResolutionTypeNum;                // valid length of stuResolutionTypes array	 	 	 
    DH_RESOLUTION_INFO  stuResolutionTypes[DH_MAX_CAPTURE_SIZE_NUM];	 	 	 
    DWORD               dwFramesPerSecNum;                 // valid length of nFramesPerSecList array		 	 	 
    int                 nFramesPerSecList[DH_MAX_FPS_NUM]; // -25:1f/25s;-24:1f/24s;-23:1f/23s;-22:1f/22s...
                                                           // 0: invalid;1:1f/s;2:2f/s;3:13f/s
                                                           // 4:4f/s;5:5f/s;17:17f/s;18:18f/s
                                                           // 19:19f/s;20:20f/s...
												           // 25: 25f/s 	  	 	 
    DWORD               dwQualityMun;                      // valid length of nQualityList array	 	 	 
    DWORD               nQualityList[DH_MAX_QUALITY_NUM];  // Image quality(1-6,6 means the best quality)
                                                           // 6:100%; 5:80%; 4:60% 3:50%; 2:30%; 1:10%	 	 
    DWORD               dwMode;                            // (Bit)0:activate scheduled snapshot,1:Manually activate snapshot	 	 	 
    DWORD               dwFormat;                          // (Bit)0:BMP format,1:JPG format 	 	 
    BYTE                bReserved[2048];                   // Reserved	 	 
} NET_OUT_SNAP_CFG_CAPS;

// camera sensor type
typedef enum tagNET_CAMERA_SENSOR
{
    NET_CAMERA_SENSOR_NORMAL,           // normal (visible light)
    NET_CAMERA_SENSOR_LEPTON,           // Lepton infrared
    NET_CAMERA_SENSOR_TAU,              // Tau infrared
} NET_CAMERA_SENSOR;

// camera sensor info
typedef struct tagNET_CAMERA_SENSORINFO
{
    NET_CAMERA_SENSOR   emSensorType;       // sensor type
    int                 nChannelsCount;     // count of channels of the sensor type
    int                 nChannels[512];     // channels of the sensor type
    char                reserved[512];
} NET_CAMERA_SENSORINFO;

// media info - camera sensor
typedef struct tagNET_MEDIA_SENSORINFO
{
    BOOL                    bSupport;               // whether or not support querying this capability. when TRUE, members below are valid
    int                     nSensorTypeCount;       // count of sensor types of the device
    NET_CAMERA_SENSORINFO   stuDetail[16];          // detailed info for each sensor type, nSensorTypeCount elements are in effect 
    char                    reserved[1024];
} NET_MEDIA_SENSORINFO;

// CLIENT_GetDevCaps NET_MEDIAMANAGER_CAPS output parameter
typedef struct tagNET_OUT_MEDIAMANAGER_GETCAPS
{
    DWORD                   dwSize;
    NET_MEDIA_SENSORINFO    stuSensorInfo;                  // camera sensor info
} NET_OUT_MEDIAMANAGER_GETCAPS;

// type of videoin caps
typedef enum tagNET_ENUM_VIDEOIN_CAP_TYPE
{
    NET_VIDEOIN_CAP_TYPE_CONFLICT,                          // conflict caps of videoin, CorrespondingStructure NET_OUT_VIDEOIN_CONFLICT_CAPS
}NET_ENUM_VIDEOIN_CAP_TYPE;

// CLIENT_GetDevCaps NET_VIDEOIN_CAPS input parameter
typedef struct tagNET_IN_VIDEOIN_CAPS
{
    DWORD                               dwSize;
    int                                 nChannel;           // channel id
    NET_ENUM_VIDEOIN_CAP_TYPE           emCapType;          // type of videoin caps
}NET_IN_VIDEOIN_CAPS;

// enumeration of conflict
typedef enum tagNET_ENUM_CONFLICT_TYPE
{
    NET_ENUM_CONFLICT_TYPE_UNKNOWN,                          // unknown
    NET_ENUM_CONFLICT_TYPE_MAIN,                             // Main
    NET_ENUM_CONFLICT_TYPE_EXTRA1,                           // EXTRA1
    NET_ENUM_CONFLICT_TYPE_EXTRA2,                           // EXTRA2
    NET_ENUM_CONFLICT_TYPE_TVOUT,                            // TVOUT
    NET_ENUM_CONFLICT_TYPE_DSP,                              // DSP
    NET_ENUM_CONFLICT_TYPE_SMARTENC,                         // Smart Enc
    NET_ENUM_CONFLICT_TYPE_SETGOP,                           // SET GOP
    NET_ENUM_CONFLICT_TYPE_ROI,                              // ROI
    NET_ENUM_CONFLICT_TYPE_CBR,                              // CBR
    NET_ENUM_CONFLICT_TYPE_SVC,                              // SVC
    NET_ENUM_CONFLICT_TYPE_MJPEG,                            // MJPEG
    NET_ENUM_CONFLICT_TYPE_ROTATE_90,                        // ROTATE 90
}NET_ENUM_CONFLICT_TYPE;

// Conflict
typedef struct tagNET_CONFLICT_TYPE
{
    NET_ENUM_CONFLICT_TYPE      emConflict1;                 // Conflict 1              
    NET_ENUM_CONFLICT_TYPE      emConflict2;                 // Conflict 2
    char                        reserved[64];
}NET_CONFLICT_TYPE;

typedef struct tagNET_VIDEOIN_CONFLICT_CAPS
{
    BOOL                        bConflict;                  // Enable conflict
    int                         nConflictNum;               // Conflict Number
    NET_CONFLICT_TYPE           stuConflict[MAX_VIDEOIN_CONFLICT_NUM];            // Conflict
}NET_VIDEOIN_CONFLICT_CAPS;

// CLIENT_GetDevCaps NET_VIDEOIN_CAPS output parameter
typedef struct tagNET_OUT_VIDEOIN_CAPS
{
    DWORD                       dwSize;
    NET_VIDEOIN_CONFLICT_CAPS   stuConflictCap;             // struct of conflict cap
}NET_OUT_VIDEOIN_CAPS;

// CLIENT_GetDevCaps  NET_VIDEO_MOSAIC_CAPS input parameter
typedef struct tagNET_IN_MEDIA_VIDEOMOSAIC_GETCAPS
{
	DWORD               dwSize;						        // the size of this struct
} NET_IN_MEDIA_VIDEOMOSAIC_GETCAPS;     

// CLIENT_GetDevCaps  NET_VIDEO_MOSAIC_CAPS output parameter
typedef struct tagNET_OUT_MEDIA_VIDEOMOSAIC_GETCAPS
{
	DWORD               dwSize;									// the size of this struct
	int					nSupportCount;							// counts of supports channels of the device
	short				snSupport[MAX_MOSAIC_CHANNEL_NUM];		// the channels which supported mosaic, -1 mean all
	int					nMosaicCount;							// the count of mosaic particles
	char				szMosaic[MAX_MOSAIC_NUM];				// the size of mosaic particles
	DH_SIZE				stuRectMax;								// the max size of mosaic block
	DH_SIZE				stuRectMin;								// the min size of mosaic block
} NET_OUT_MEDIA_VIDEOMOSAIC_GETCAPS;

// CLIENT_GetDevCaps NET_FACE_BOARD_CAPS input parameter
typedef struct tagNET_IN_FACEBOARD_CAPS
{
    DWORD               dwSize;						            // the size of this struct
}NET_IN_FACEBOARD_CAPS;

// CLIENT_GetDevCaps NET_VIDEO_IMAGECONTROL_CAPS input parameter
typedef struct tagNET_IN_VIDEO_IMAGECONTROL_CAPS
{
	DWORD               dwSize;									// the size of this struct 
	int					nChannel;								// channel ID
} NET_IN_VIDEO_IMAGECONTROL_CAPS;

// the stable caps type
typedef enum tagNET_EM_STABLE_CAPS_TYPE
{
	EM_STABLE_UNSPPORT,					// unsupport
	EM_STABLE_ELEC,						// electornic
	EM_STABLE_LIGHT,					// light
	EM_STAVLE_ELEC_AND_LIGHT,			// electornic and light
	EM_STABLE_CONTROL,					// control
	EM_STABLE_ELEC_AND_CONTROL,			// electornic and control
	EM_STABLE_LIGHT_AND_CONTROL,		// light and control
} NET_EM_STABLE_CAPS_TYPE;

// CLIENT_GetDevCaps NET_VIDEO_IMAGECONTROL_CAPS output parameter
typedef struct tagNET_OUT_VIDEO_IMAGECONTROL_CAPS
{
	DWORD               			dwSize;							// the size of this struct
	BOOL							bSupport;						// support Mirror or Flip or Rotate90 or not
	BOOL							bMirror;						// support mirror or not
	BOOL							bFlip;							// support flip or not
	BOOL							bRotate90;						// support rotate90 or not
	BOOL							bFreeze;						// support freeze or not
	NET_EM_STABLE_CAPS_TYPE			emStable;						// support stable or not
} NET_OUT_VIDEO_IMAGECONTROL_CAPS;

// CLIENT_GetDevCaps NET_VIDEOIN_EXPOSURE_CAPS input parameter
typedef struct tagNET_IN_VIDEOIN_EXPOSURE_CAPS
{
	DWORD               dwSize;									// the size of this struct
	int					nChannel;								// channel ID
} NET_IN_VIDEOIN_EXPOSURE_CAPS;

#define MAX_EXPOSURE_COUNT	8

// exposure mode
typedef enum tagNET_EM_EXPOSURE_MODE
{
	NET_EM_EXPOSURE_AUTO,					// auto
	NET_EM_EXPOSURE_LOWNICE,				// low nice
	NET_EM_EXPOSURE_ANTISHADOW,				// anti shadow
	NET_EM_EXPOSURE_MANUALRANGE	= 4,		// manual range
	NET_EM_EXPOSURE_APERTUREFIRST,			// aperture first
	NET_EM_EXPOSURE_MANUALFIXATION,			// manual fixation
	NET_EM_EXPOSURE_GIANFIRST,				// gian first
	NET_EM_EXPOSURE_SHUTTERFIRST,			// shutter first
	NET_EM_EXPOSURE_FLASHMATCH,				// flash match
} NET_EM_EXPOSURE_MODE;

// the anti ficker mode
typedef enum tagNET_EM_ANTIFLICKER_MODE
{
	NET_EM_ANTIFLICKER_OUTDOOR,			// outdoor
	NET_EM_ANTIFLICKER_50HZ,			// 50Hz
	NET_EM_ANTIFLICKER_60HZ,			// 60Hz
} NET_EM_ANTIFLICKER_MODE;


typedef struct tagNET_SPEED_CAPS
{
	int			nRetManual;										// the actual count of shutters in manual
	int			nManual[DH_COMMON_STRING_16];					// the actual list of shutters in manual
	int			nRetManual50Hz;									// the actual count of shutters in 50HZ
	int			nManual50Hz[DH_COMMON_STRING_16];				// the actual list of shutters in 50HZ
	int			nRetManual60Hz;									// the actual count of shutters in 60HZ
	int			nManual60Hz[DH_COMMON_STRING_16];				// the actual list of shutters in 60HZ
	int			nRetShutterPAL;									// the actual count of P shutters in shutter priority
	int			nShutterPAL[DH_COMMON_STRING_16];				// the actual list of P shutters in shutter priority
	int			nRetShutterNTSC;								// the actual count of N shutters in shutter priority
	int			nShutterNTSC[DH_COMMON_STRING_16];				// the actual list of N shutters in shutter priority
	BYTE		bReserved[128];									// reserved
} NET_SPEED_CAPS;

typedef struct tagNET_SLOW_SPEED_CAPS
{
	int			nRetPal;
	int			nPal[DH_COMMON_STRING_16];
	int			nRetNtsc;
	int			nNtsc[DH_COMMON_STRING_16];
	BYTE		bReserved[128];	
} NET_SLOW_SPEED_CAPS;

// CLIENT_GetDevCaps NET_VIDEOIN_EXPOSURE_CAPS output parameter
typedef struct tagNET_OUT_VIDEOIN_EXPOSURE_CAPS
{
	DWORD               		dwSize;									// the size of this struct
	BOOL						bSupport;								// support seting exposure or not
	int							nExposureMode;							// the actual count of exposure mode
	NET_EM_EXPOSURE_MODE		emExposureMode[MAX_EXPOSURE_COUNT];		// the supported exposure modes
	BOOL						bAntiFlicker;							// support seting anti flicker or not
	int							nAntiFlicker;							// the actual count of anti flicker mode
	NET_EM_ANTIFLICKER_MODE		emAntiFlicker[MAX_ANTIFLICKERMODE_COUNT];// the actual list of anti flicker mode
	int							nMinCompensation;						// the min value of compensation
	int							nMaxCompensation;						// the max value of compensation
	BOOL						bGainUpperLimit;						// support gain limit or not
	int							nMinGain;								// min value of gain
	int							nMaxGain;								// max value of gain
	BOOL						bSlowAutoExposure;						// support slow exposure or not
	int							nMinSlowAutoExposure;					// min value of slow exposure
	int							nMaxSlowAutoExposure;					// max value of slow exposure
	BOOL						bSlowShutter;							// support slow shutter or not
	float						fMinValueLow;							// the min value of auto exposure time lower limit
	float						fMaxValueLow;							// the max value of auto exposure time lower limit
	float						fMinValueUp;							// the min value of auto exposure time upper limit
	float						fMaxValueUp;							// the max value of auto exposure time upper limit
	NET_SPEED_CAPS				stuSpeedCaps;							// the capability of exposure speed
	NET_SLOW_SPEED_CAPS			stuSlowSpeedCaps;						// the capability of slow exposure speed
	BOOL						bIrisAuto;								// support auto iris or not
	int							nIrisMin;								// min value of iris
	int							nIrisMax;								// max value of iris
	BOOL						bSupportIrisRange;						// the capability of iris range
	BOOL						bDoubleExposure;						// support setting double shutter or not
	BOOL						bRecoveryTime;							// support auto recovery or not
} NET_OUT_VIDEOIN_EXPOSURE_CAPS;

// CLIENT_GetDevCaps NET_VIDEOIN_DENOISE_CAPS input parameter
typedef struct tagNET_IN_VIDEOIN_DENOISE_CAPS
{
	DWORD				dwSize; 								// the size of this struct
	int 				nChannel;								// channel ID
} NET_IN_VIDEOIN_DENOISE_CAPS;

// the type of 3D denoise
typedef enum tagNET_EM_3DSUPPORT_TYPE
{
	NET_EM_3DSUPPORT_UNKOWN,									// unknown
	NET_EM_3DSUPPORT_OFF,										// off 
	NET_EM_3DSUPPORT_AUTO,										// auto 
	NET_EM_3DSUPPORT_MANUAL,									// manual
} NET_EM_3DSUPPORT_TYPE;

// the mode of 3D denoise
typedef struct tagNET_3D_ALGORITHM_MODE
{
	// mask representationbit0 means noise algorithm bit0,bit1 means noise algorithm bit1,bit2...
	DWORD	dwSingleExposure;				// the capability of single shutter
	DWORD	dwDoubleExposureFullRate;		// the capability of full double denoise
	DWORD	dwDoubleExposureHalfRate;		// the capability of half double denoise
	DWORD	dsThreeExposure;				// the capability of three shutter
	BYTE	bReserved[128];					// reverd
} NET_3DALGORITHM_MODE;

#define		MAX_3DTYPE_COUNT			8			// max 3D denoise count 
#define		MAX_GROUP_COUNT				2			// max group of denoise 
#define		MAX_PROGRAM_COUNT			8			// max program count

// the capability of 2D denoise
typedef struct tagNET_SUPPORT2D_CAPS
{
	BOOL						bSupport2D;								// support 2D denoise or not
	int							n2DLevelMin;							// the min level of 2D denoise
	int							n2DLevelMax;							// the max level of 2D denoise
	int							nMaxRAWLevel;							// th max value 2D denoise which support RAW, 0 means not support
	BYTE						bReserved[128];							// reverd
} NET_SUPPORT2D_CAPS;

// the program of per denoise group
typedef struct tagNET_DENOISEGROUP_PROGRAM
{
	int							nProgramCount;							// the actual count of programs
	int							nProgram[MAX_PROGRAM_COUNT];			// the actual list of programs
} NET_DENOISEGROUP_PROGRAM;

// the capability of 3D denoise
typedef struct tagNET_SUPPORT3D_CAPS
{
	BOOL						bSupport3D;								// support 3D denose or not
	int							n3DTypeCount;							// the count of 3D denoise type
	NET_EM_3DSUPPORT_TYPE		em3DSupportType[MAX_3DTYPE_COUNT];		// the list of 3D denoise type
	int							n3DLevelMin;							// the min level of 3D denoise
	int							n3DLevelMax;							// the max level of 3D denoise
	int							nAutoLevelMin;							// the min level of auto 3D denoise
	int							nAutoLevelMax;							// the max level of auto 3D denoise
	NET_3DALGORITHM_MODE		stuAlgorithmSDMode;						// the algorithm mode supported by 3D denoise
	int							nGroupCount;							// the actual counts of groups
	NET_DENOISEGROUP_PROGRAM	stuDenoiseGroup[MAX_GROUP_COUNT]; 		// the list of groups
	int							nDenoiseScheme;							// the plame of denoise
	BYTE						bReserved[128];							// reverd
} NET_SUPPORT3D_CAPS;

// CLIENT_GetDevCaps NET_VIDEOIN_DENOISE_CAPS output parameter
typedef struct tagNET_OUT_VIDEOIN_DENOISE_CAPS
{
	DWORD						dwSize; 								// the size of this struct
	BOOL						bSupport;								// support setting denoise or not
	NET_SUPPORT2D_CAPS			stu2DCaps;								// the capability of 2D denoise 
	NET_SUPPORT3D_CAPS			stu3DCaps;								// the capability of 3D denoise
	BOOL						bSupportAlgorithm1;						// support denoise algorithm 1 or not
	int							nTnfLevelRangeMin;						// the min level of time renge
	int							nTnfLevelRangeMax;						// the max level of time renge
	int							nSnfLevelRangeMin;						// the min level of space renge
	int							nSnfLevelRangeMax;						// the min level of space renge
	int							nSeniotTypeCount;						// the count of seniot type
	NET_EM_3DSUPPORT_TYPE		emSeniorType[MAX_3DTYPE_COUNT];			// the list of seniot type
} NET_OUT_VIDEOIN_DENOISE_CAPS;

// CLIENT_GetDevCaps NET_VIDEOIN_BACKLIGHT_CAPS input parameter
typedef struct tagNET_IN_VIDEOIN_BACKLIGHT_CAPS
{
	DWORD				dwSize; 								// the size of this struct
	int 				nChannel;								// channel ID
} NET_IN_VIDEOIN_BACKLIGHT_CAPS;

// back mode
typedef enum tagNET_EM_BACK_MODE
{
	NET_EM_BACKLIGHT_MODE_UNKNOW,					// unknow
	NET_EM_BACKLIGHT_MODE_OFF,						// off
	NET_EM_BACKLIGHT_MODE_BACKLIGHT,				// back light
	NET_EM_BACKLIGHT_MODE_WIDEDYNAMIC,				// widedynamic
	NET_EM_BACKLIGHT_MODE_GLAREINHIBITION,			// glareinhibition
	NET_EM_BACKLIGHT_MODE_SSA,						// SSA
} NET_EM_BACK_MODE;

// back light mode
typedef enum tagNET_EM_BLACKLIGHT_MODE
{
	NET_EM_BLACKLIGHT_UNKNOW,						// unkonw
	NET_EM_BLACKLIGHT_DEFAULT,						// default
	NET_EM_BLACKLIGHT_REGION,						// region
} NET_EM_BLACKLIGHT_MODE;

// the mode of Intensity
typedef enum tagNET_EM_BACK_INTENSITY_MODE
{
	NET_EM_INTENSITY_UNKNOWN,			// unkonw
	NET_EM_INTENSITY_OFF,				// Disable 
	NET_EM_INTENSITY_AUTO,				// AutoIntensity 
	NET_EM_INTENSITY_MANUAL,			// ManualIntensity
} NET_EM_BACK_INTENSITY_MODE;

// the mode of hightlight suppression
typedef enum tagNET_EM_GLAREINHIBITION_MODE
{
	NET_EM_GLAREINHIBITION_UNKNOWN,		// unknown
	NET_EM_GLAREINHIBITION_DEFAULT,		// default
	NET_EM_GLAREINHIBITION_FPGA,		// Fpga
} NET_EM_GLAREINHIBITION_MODE;

#define MAX_MODE_COUNT		8		// the max count of hightlight suppression mode

// CLIENT_GetDevCaps NET_VIDEOIN_BACKLIGHT_CAPS output parameter
typedef struct tagNET_OUT_VIDEOIN_BACKLIGHT_CAPS
{
	DWORD						dwSize; 								// the size of this struct
	BOOL						bSupport;								// support setting bcaklight or not
	int							nBackModeCount;							// the actual count of black mode
	NET_EM_BACK_MODE			emBackMode[MAX_MODE_COUNT];				// the list of black mode
	int							nBackLightModeCount;					// the actual count of black light mode
	NET_EM_BLACKLIGHT_MODE		emBackLightMode[MAX_MODE_COUNT];		// the list of black light mode
	int							nWideDynamicRange;						// support wide dynamic range or not
	int							nSSAIntensity;							// the count of SSA modes
	NET_EM_BACK_INTENSITY_MODE	emIntensityMode[MAX_MODE_COUNT];		// the list of SSA modes
	NET_EM_GLAREINHIBITION_MODE	emGlareInhibition[MAX_MODE_COUNT];		// the list of glareInhibition modes
} NET_OUT_VIDEOIN_BACKLIGHT_CAPS;

// CLIENT_GetDevCaps NET_VIDEOIN_WHITEBALANCE_CAPS input parameter
typedef struct tagNET_IN_VIDEOIN_WHITEBALANCE_CAPS
{
	DWORD				dwSize; 								// the size of this struct
	int 				nChannel;								// channel ID
} NET_IN_VIDEOIN_WHITEBALANCE_CAPS;

// white balance type
typedef enum tagNET_EM_WHITEBALANCE_TYPE
{
	NET_EM_WHITEBALANCE_UNKNOW,					// unkonw
	NET_EM_WHITEBALANCE_DISABLE,				// Disable
	NET_EM_WHITEBALANCE_AUTO,					// Auto
	NET_EM_WHITEBALANCE_SUNNY,					// Sunny, about 6500K
	NET_EM_WHITEBALANCE_CLOUDY,					// Cloudy,7500K
	NET_EM_WHITEBALANCE_HOME,					// Home, about 5000K
	NET_EM_WHITEBALANCE_OFFICE,					// Office, about 4400K
	NET_EM_WHITEBALANCE_NIGHT,					// Night, about 2800K
	NET_EM_WHITEBALANCE_CUSTOM,					// Custom
	NET_EM_WHITEBALANCE_HIGHCOLORTEMP,			// HighColorTemperature
	NET_EM_WHITEBALANCE_LOWCOLORTEMP,			// LowColorTemperature
	NET_EM_WHITEBALANCE_AUTOCOLORTEMP,			// AutoColorTemperature
	NET_EM_WHITEBALANCE_CUSTOMCOLORTEMP,		// CustomColorTemperature
	NET_EM_WHITEBALANCE_INDOOR,					// Indoor
	NET_EM_WHITEBALANCE_OUTDOOR,				// Outdoor
	NET_EM_WHITEBALANCE_ATW,					// ATW
	NET_EM_WHITEBALANCE_MANUAL,					// Manual
	NET_EM_WHITEBALANCE_AUTOOUTDOOR,			// AutoOutdoor
	NET_EM_WHITEBALANCE_SODIUMAUTO,				// SodiumAuto
	NET_EM_WHITEBALANCE_SODIUM,					// Sodium, about 2000K
	NET_EM_WHITEBALANCE_MANUALDATUM,			// ManualDatum
	NET_EM_WHITEBALANCE_PARTWHITEBALANCE,		// PartWhiteBalance
	NET_EM_WHITEBALANCE_NATURAL,				// Natural, 2000K-12000K 
	NET_EM_WHITEBALANCE_STREETLAMP,				// StreetLamp, 1000K-5000K
} NET_EM_WHITEBALANCE_TYPE;

#define MAX_BALANCEMODES_COUNT			16		// the max counts of white balance modes

// CLIENT_GetDevCaps NET_VIDEOIN_WHITEBALANCE_CAPS output param
typedef struct tagNET_OUT_VIDEOIN_WHITEBALANCE_CAPS
{
	DWORD								dwSize; 								// the size of this struct
	BOOL								bSupport;								// support white balance or not
	int									nWhiteBalance;							// the cuonts of white balance supported
	NET_EM_WHITEBALANCE_TYPE			emWhiteBalance[MAX_BALANCEMODES_COUNT];	// the list of white balance supported
} NET_OUT_VIDEOIN_WHITEBALANCE_CAPS;

// CLIENT_GetDevCaps NET_VIDEOIN_DAYNIGHT_CAPS input param
typedef struct tagNET_IN_VIDEOIN_DAYNIGHT_CAPS
{
	DWORD				dwSize; 								// the size of this struct
	int 				nChannel;								// channel ID
} NET_IN_VIDEOIN_DAYNIGHT_CAPS;

// ICR switch type
typedef enum tagNET_EM_ICR_TYPE
{
	NET_EM_ICR_UNKONOW,			// unknow
	NET_EM_ICR_ELECTRON,		// electronics
	NET_EM_ICR_MECHANISM,		// mechanics
} NET_EM_ICR_TYPE;

// color to black
typedef enum tagNET_EM_COLORBLACK_MODE
{
	NET_EM_COLORBLACK_UNKNOWN,					// unknown
	NET_EM_COLORBLACK_COLOR,					// color
	NET_EM_COLORBLACK_BRIGHTNESS,				// automatic switching based on brightness
	NET_EM_COLORBLACK_BLACKWHITE,				// alawys black and white
	NET_EM_COLORBLACK_PHOTORESISTOR,			// photosensitive resistor
	NET_EM_COLORBLACK_GAIN,						// switch accord to gain
	NET_EM_COLORBLACK_ALARMINPUT,				// external alarm input 
	NET_EM_COLORBLACK_IO,						// external I/O input
} NET_EM_COLORBLACK_MODE;

// CLIENT_GetDevCaps NET_VIDEOIN_DAYNIGHT_CAPS output parameter
typedef struct tagNET_OUT_VIDEOIN_DAYNIGHT_CAPS
{
	DWORD						dwSize; 								// the size of this struct
	BOOL						bSupport;								// the ability to set night and day
	int							nICRType;								// the actual counts of ICR type
	NET_EM_ICR_TYPE				emICRType[MAX_MODE_COUNT];				// the list of ICR types
	int							nColorBlackMode;						// the actual counts of color to black mode
	NET_EM_COLORBLACK_MODE		emColorBlackMode[MAX_MODE_COUNT];		// the list of color to black modes
	int							nSensitivityRangeMin;					// the min of color to black sensitivity
	int							nSensitivityRangeMax;					// the max of color to black sensitivity
	int							nDelayRangeMin;							// the min delay of dat and night switching
	int							nDelayRangeMax;							// the max delay of dat and night switching
} NET_OUT_VIDEOIN_DAYNIGHT_CAPS;

// CLIENT_GetDevCaps NET_VIDEOIN_ZOOM_CAPS input parameter
typedef struct tagNET_IN_VIDEOIN_ZOOM_CAPS
{
	DWORD				dwSize; 								// the size of this struct
	int 				nChannel;								// channel ID
} NET_IN_VIDEOIN_ZOOM_CAPS;

// CLIENT_GetDevCaps NET_VIDEOIN_ZOOM_CAPS output parameter
typedef struct tagNET_OUT_VIDEOIN_ZOOM_CAPS
{
	DWORD						dwSize; 								// the size of this struct

	BOOL						bSupport;								// support zoom or not
	int							nSpeedRangeMin;							// th min speed of the zoom
	int 						nSpeedRangeMax;							// the max speed of the zoom
	BOOL						bDigitalZoomSupport;					// support digital zoom or not
	int							nZoomLimitRangeMin;						// the min data of the zoom in this speed	
	int							nZoomLimitRangeMax;						// the max data of the zoom in this speed
} NET_OUT_VIDEOIN_ZOOM_CAPS;

// CLIENT_GetDevCaps NET_VIDEOIN_FOCUS_CAPS input parameter
typedef struct tagNET_IN_VIDEOIN_FOCUS_CAPS
{
	DWORD				dwSize; 								// the size of this struct
	int 				nChannel;								// channel ID
} NET_IN_VIDEOIN_FOCUS_CAPS;

// focus mode
typedef enum tagNET_EM_FOCUS_MODE
{
	NET_EM_FOCUS_OFF,				// off 
	NET_EM_FOCUS_ASSIST,			// assist
	NET_EM_FOCUS_AUTO,				// auto
	NET_EM_FOCUS_SEMI_AUTO,			// semi auto
	NET_EM_FOCUS_MANUAL,			// manual
} NET_EM_FOCUS_MODE;

// focus limit select mode
typedef enum tagNET_EM_FOCUS_LIMITSELECT_MODE
{
	NET_EM_FOCUS_LIMITSELECT_UNKNOW,			// unknow
	NET_EM_FOCUS_LIMITSELECT_MANUAL,			// manual
	NET_EM_FOCUS_LIMITSELECT_AUTO,				// auto
} NET_EM_FOCUS_LIMITSELECT_MODE;

// focus type
typedef enum tagNET_EM_FOCUS_TYPE
{
	NET_EM_FOCUS_UNKNOWN,						// unknown
	NET_EM_FOCUS_AUTOTRACE,						// auto trace
} NET_EM_FOCUS_TYPE;

// CLIENT_GetDevCaps NET_VIDEOIN_FOCUS_CAPS output parameter
typedef struct tagNET_OUT_VIDEOIN_FOCUS_CAPS
{
	DWORD							dwSize; 								// the size of this struct
	BOOL							bSupport;								// support focus or not
	int								nFcousMode;								// the actual counts of focus modes
	NET_EM_FOCUS_MODE				emFocusMode[MAX_MODE_COUNT];			// the list of focus modes
	int								nLimitMode;								// the actual counts of focus limit modes
	NET_EM_FOCUS_LIMITSELECT_MODE	emLimitMode[MAX_MODE_COUNT];			// the list counts of focus limit modes
	BOOL							bSupportFocusRegion;					// support domain focus or not
	BOOL							bSensitivity;							// support focus sensitivity or not
	BOOL							bIRCorrection;							// support infrared focus corredtion or not
	BOOL							bFocusLimit;							// support focus limit or not
	int								nFocusTypeCount;						// the actual counts of focus modes
	NET_EM_FOCUS_TYPE				emFocusType[MAX_MODE_COUNT];			// the list counts of focus modes

    int                             nFocusLimitRangeCount;                  // Number of Focus Limit Range Values
    int								nFocusLimitRange[16];					// Supporting Focus Limit, Focus Limit Range, Unit Millimeter
    /*1. Default to [100, 1000, 2000, 3000, 5000] to be compatible with previous devices
    2. When xxxx1 exists in the gear, it is necessary to replace 1 with 0 and append character +; for example, when 200001 is displayed, it is 20000mm + (usually displayed in more intuitive units, such as 200m +).*/
} NET_OUT_VIDEOIN_FOCUS_CAPS;

//// CLIENT_GetDevCaps NET_VIDEOIN_SHARPNESS_CAPS input parameter
typedef struct tagNET_IN_VIDEOIN_SHARPNESS_CAPS
{
	DWORD				dwSize; 								// the size of this struct
	int 				nChannel;								// channel ID
} NET_IN_VIDEOIN_SHARPNESS_CAPS;

// sharpness mode
typedef enum tagNET_EM_SHARPNESS_MODE
{
	NET_EM_SHARPNESS_AUTO,				// auto
	NET_EM_SHARPNESS_MANAUL,			// manual
}NET_EM_SHARPNESS_MODE;

// CLIENT_GetDevCaps NET_VIDEOIN_SHARPNESS_CAPS output paremeter
typedef struct tagNET_OUT_VIDEOIN_SHARPNESS_CAPS
{
	DWORD						dwSize; 								// the size of this struct
	BOOL						bSupport;								// support domain sharpness or not
	int							nSharpnessMode;							// the actual counts of sharpness modes
	NET_EM_SHARPNESS_MODE		emSharpnessMode[MAX_MODE_COUNT];		// the this counts of sharpness modes
	int							nSharpnessMin;							// the min value of sharpness
	int							nSharpnessMax;							// the max value of sharpness

	BOOL						bSupportRestrain;						// support sharpness restrain or not
	int							nRestrainLevelMin;						// the min level of sharpness restrain
	int							nRestrainLevelMax;						// the max level of sharpness restrain
} NET_OUT_VIDEOIN_SHARPNESS_CAPS;

// CLIENT_GetDevCaps NET_VIDEOIN_COLOR_CAPS input parameter
typedef struct tagNET_IN_VIDEOIN_COLOR_CAPS
{
	DWORD				dwSize; 								// the size of this struct
	int 				nChannel;								// channel ID
} NET_IN_VIDEOIN_COLOR_CAPS;

// the style type of picture
typedef enum tagNET_EM_STYLE_TYPE
{
	NET_EM_STYLE_UNKONWON,			// unknown
	NET_EM_STYLE_GENTLE,			// gentle
	NET_EM_STYLE_STANDARD,			// stanard
	NET_EM_STYLE_FLAMBOYANT,		// flamboyant
} NET_EM_STYLE_TYPE;

// the capability of picture style
typedef struct tagNET_COLOR_STYLE_CAPS
{
	BOOL				bSupport;								// support seting picture style or not
	int					nStyleType;								// the actual counts of picture styles
	NET_EM_STYLE_TYPE	emStyleType[MAX_MODE_COUNT];			// the list counts of picture styles
	BYTE				bReserved[128];							// reserve
} NET_COLOR_STYLE_CAPS;

#define MAX_GRAYVALUE_COUNT			8  // the max count og gray value

// the capability of gray scale
typedef struct tagNET_GRAY_SCALE_CAPS
{
	BOOL				bSupport;								// support set gray scale or not
	int					nValueCount;							// the actual counts of gray value
	int					nValue[MAX_GRAYVALUE_COUNT][2];		// the list counts of gray value
	BYTE				bReserved[128];							// reserve
} NET_GRAY_SCALE_CAPS;

// CLIENT_GetDevCaps NET_VIDEOIN_COLOR_CAPS output parameter
typedef struct tagNET_OUT_VIDEOIN_COLOR_CAPS
{
	DWORD					dwSize; 							// the size of this struct
	BOOL					bSupport;							// support seting image attributes or not
	BOOL					bBrightness;						// support seting brightness or not
	BOOL					bContrast;							// support seting contrast or not
	BOOL					bSaturation;						// support seting stayration or not
	BOOL					bHue;								// support seting HUE or not
	BOOL					bGamma;								// support seting gamma or not
	BOOL					bChromaSuppress;					// support seting chroma suppress or not
	NET_COLOR_STYLE_CAPS	stuColorStype;						// support seting color style or not
	NET_GRAY_SCALE_CAPS		stuGrayScale;						// support seting gray scale or not
} NET_OUT_VIDEOIN_COLOR_CAPS;

// CLIENT_GetDevCaps NET_VIDEOIN_RAWFRAME_CAPS input parameter
typedef struct tagNET_IN_VIDEOIN_RAWFRAME_CAPS
{
	DWORD					dwSize;
}NET_IN_VIDEOIN_RAWFRAME_CAPS;

// YUV Data format capability set
typedef struct tagNET_RAWFRAMETYPE_DATA
{
	int						nListNum;										// The number of actual returns
	char					szList[DH_COMMON_STRING_16][DH_COMMON_STRING_8];// List of supported YUV data formats
	BYTE					byReserved[1024];
}NET_RAWFRAMETYPE_DATA;

// CLIENT_GetDevCaps NET_VIDEOIN_RAWFRAME_CAPS output parameter
typedef struct tagNET_OUT_VIDEOIN_RAWFRAME_CAPS
{
	DWORD								dwSize;
	NET_RAWFRAMETYPE_DATA				stuFrameData;
}NET_OUT_VIDEOIN_RAWFRAME_CAPS;

// temperature unit
typedef enum tagEM_TEMPERATURE_UNIT
{
	EM_TEMPERATURE_CENTIGRADE,			// centigrade
	EM_TEMPERATURE_FAHRENHEIT,			// fahrenheit
	EM_TEMPERATURE_KELVIN,				// kelvin
} EM_TEMPERATURE_UNIT;

#define MAX_UNIT_COUNT		8		// the max count of temperature units

// CLIENT_GetDevCaps NET_FACE_BOARD_CAPS output parameter
typedef struct tagNET_OUT_FACEBOARD_CAPS
{
    DWORD               	dwSize;						            // the size of this struct
    BOOL                	bHasBattery;                            // if has battery
    BOOL                	bSupportPowerVoltageDetect;             // if support power voltage detection
    BOOL					bTemperatures;							// support temperatures or not
    BOOL					bOSDTemperatureUnit;					// support temperature unit or not
    int						nRetUnitCount;							// the counts of temperature unit supported
    EM_TEMPERATURE_UNIT		emTempreatureUnit[MAX_UNIT_COUNT];		// the supported units of temperature
}NET_OUT_FACEBOARD_CAPS;

// CLIENT_GetDevCaps NET_COAXIAL_CONTROL_IO_CAPS input param
typedef struct tagNET_IN_GET_COAXIAL_CONTROL_IO_CAPS
{
	DWORD							dwSize;							// Structure size
	int								nChannel;						// channel 
} NET_IN_GET_COAXIAL_CONTROL_IO_CAPS;

// CLIENT_GetDevCaps NET_COAXIAL_CONTROL_IO_CAPS output param
typedef struct tagNET_OUT_GET_COAXIAL_CONTROL_IO_CAPS
{
	DWORD							dwSize;							// Structure size
	BOOL							bSupportControlLight;			// whether support control light
	BOOL							bSupportControlSpeaker;			// whether support control specker audio
} NET_OUT_GET_COAXIAL_CONTROL_IO_CAPS;

// CLIENT_GetDevCaps NET_FACEINFO_CAPS input param
typedef struct tagNET_IN_GET_FACEINFO_CAPS
{
    DWORD							dwSize;							// Structure size
}NET_IN_GET_FACEINFO_CAPS;

// Recognition Algorithm
typedef enum tagEM_RECOGNITIONALGORITHM_TYPE
{
    EM_RECOGNITIONALGORITHM_UNKNOWN,                                    // unknown
    EM_RECOGNITIONALGORITHM_DAHUA,                                      // dahua
    EM_RECOGNITIONALGORITHM_SHANGTANG,                                  // shangtang
    EM_RECOGNITIONALGORITHM_YITU,                                       // yitu
    EM_RECOGNITIONALGORITHM_HANWANG,                                    // hanwang
    EM_RECOGNITIONALGORITHM_FIREEYE,                                    // fireeye
}EM_RECOGNITIONALGORITHM_TYPE;

// CLIENT_GetDevCaps  NET_FACEINFO_CAPS output param
typedef struct tagNET_OUT_GET_FACEINFO_CAPS
{
    DWORD							    dwSize;							// Structure size
    int                                 nRecognitionType;               // support Recognition Type0:white light,1:infrered
    EM_RECOGNITIONALGORITHM_TYPE        emRecognitionAlgorithm;         // Recognition Algorithm
    DWORD                               nRecognitionVersion;            // Recognition Version,0x00010502 means 1.5.2
    UINT                                nMaxFaces;                      // max face number
    int                                 nMaxPhotoSize;                  // max photo size,unit:KB
    UINT                                nMaxInsertRate;                 // max insert rate
    BOOL                                bIsSupportGetPhoto;             // is support get photo, TRUE:yes, FALSE:no
    BOOL                                bIsSupportFaceEigen;            // is support get face eigen, TRUE:yes, FALSE:no
}NET_OUT_GET_FACEINFO_CAPS;

typedef enum tagEM_DETECT_VERSION_TYPE
{
    EM_DETECT_VERSION_UNKNOW = 0 , 
    EM_DETECT_VERSION_V1_0 ,           //Ver1 motion detection
    EM_DETECT_VERSION_V3_0 ,           //Ver3 motion detection
}EM_DETECT_VERSION_TYPE;
#define    MAX_DETECT_VERSION_NUM           64

typedef enum tagEM_BLIND_DETECT_VERSION_TYPE
{
    EM_BLIND_DETECT_VERSION_UNKNOW = 0 ,
    EM_BLIND_DETECT_VERSION_FULL_SCREEN ,   //Full screen detection
    EM_BLIND_DETECT_VERSION_MULTI_WINDOW ,  //Multi window detection
}EM_BLIND_DETECT_VERSION_TYPE;
#define    MAX_BLIND_DETECT_VERSION_NUM     64

// Smart motion detection type
typedef enum tagEM_SMART_MOTION_TYPE
{
	EM_SMART_MOTION_UNKNOWN,		// unknown
	EM_SMART_MOTION_HUMAN,			// human
	EM_SMART_MOTION_VEHICLE,		// vehicle
} EM_SMART_MOTION_TYPE;

// Smart motion detection caps
typedef struct tagNET_SMART_MOTION_CAPS
{
	BOOL						bSupport;					// support smart motion detection or not
	UINT						nSmartTypeNum;				// count of smart motion detection type
	EM_SMART_MOTION_TYPE		emSmartMotionType[8];		// smart motion detection types
	BYTE						byReserved[512];				// reserved
} NET_SMART_MOTION_CAPS;

typedef struct tagNET_OUT_VIDEO_DETECT_CAPS
{
        DWORD                       dwSize;         
        BOOL                        bSupportBlind;          //Is support BlindScreen detect, TRUE:yes, FALSE:no
        BOOL                        bSupportLoss;           //Is support VideoLoss detect, TRUE:yes, FALSE:no
        BOOL                        bSupportMotion;         //Is support VideoMotion detect, TRUE:yes, FALSE:no
        BOOL                        bMotionResult;          //Is support to get motion detect result in every region
        DWORD                       nMotionColumns;         //Columns of motion detect detect region
        DWORD                       nMotionRows;            //Rows of motion detect detect region
        DWORD                       nMotionDetectWindow;    //Video windows of motion detect
        DWORD                       nBlindColumns;          //Columns of video blind detect region
        DWORD                       nBlindRows;             //Rows of video blind detect region
        DWORD                       nBlindDetectWindow;     //Video windows of video blind detect
        BOOL                        bPositionDetect;        //Is support motion position detect
        DWORD                       nDetectVersionNum;      //Number of supported motion detect versions
        EM_DETECT_VERSION_TYPE      emDetectVersions[MAX_DETECT_VERSION_NUM];               //Supported motion detect versions info
        DWORD                       nBlindDetectVersionNum; //Number of supported video blind detect versions
        EM_BLIND_DETECT_VERSION_TYPE emBlindDetectVersions[MAX_BLIND_DETECT_VERSION_NUM];   //Supported video blind detect versions info
        BOOL                        bMotionLinkPtzPreset;   //Is support motion detect linked ptz preset, TRUE:yes, FALSE:no
        BOOL                        bMotionLinkPtzTour;     //Is support motion detect linked ptz tour, TRUE:yes, FALSE:no
        BOOL                        bMotionLinkPtzPattern;  //Is support motion detect linked ptz pattern, TRUE:yes, FALSE:no
        BOOL                        bUnFocusDetect;         //Is support unfocus detect, TRUE:yes, FALSE:no
        BOOL                        bAlarmDetect;           //Is support detect and trigger alarm when motion detect is working, TRUE:yes, FALSE:no
		BOOL						bSupportMoveDetect;		//Is support Moved detect, TRUE:yes, FALSE:no
		NET_SMART_MOTION_CAPS		stuSmartMotionCaps;		// smart motion detection caps

}NET_OUT_VIDEO_DETECT_CAPS;

// fall event type
typedef struct tagALARM_FALLING_INFO
{
    DWORD               dwStructSize;                               // structure size
    BYTE                bEventAction;                               // event action, 0 means impulse event,1 means continuous event start,2 means continuous event end;
    BYTE                byRserved[3];                               // align 
	char				szUserID[32];								// User ID logged in at local alarm
	char				szUserName[128];							// User name logged in at local alarm
}ALARM_FALLING_INFO;

//order Bus status call function model
typedef void (CALLBACK *fBusStateCallBack)(LLONG lAttachHandle, LONG lCommand, char *pBuf, DWORD dwBufLen, LDWORD dwUser);

// swipe card type
typedef enum tagNET_DRIVER_CHECK_TYPE
{
    NET_DRIVER_CHECK_TYPE_UNKNOWN,                                  // unknow
    NET_DRIVER_CHECK_TYPE_SIGNIN,                                   // sign up
    NET_DRIVER_CHECK_TYPE_SIGNOUT,                                  // sign out
} NET_DRIVER_CHECK_TYPE;

// swipe card
typedef enum tagNET_DRIVER_CHECK_METHOD
{
    NET_DRIVER_CHECK_METHOD_UNKNOWN,                                // unknown
    NET_DRIVER_CHECK_METHOD_POS,                                    // POS device
    NET_DRIVER_CHECK_METHOD_HAND,                                   // manually input
} NET_DRIVER_CHECK_METHOD;

// alarm event type DH_ALARM_BUS_DRIVER_CHECK( driver recognition card detection event)corresponding to data description info
typedef struct tagALARM_BUS_DRIVER_CHECK_INFO
{
    DWORD                   dwSize;
    char                    szCarNo[DH_MAX_PLATE_NUMBER_LEN];       // plate
    char                    szDriverName[DH_COMMON_STRING_16];      // driver name
    char                    szDriverID[DH_MAX_PERSON_ID_LEN];       // ID
    char                    szOrganize[DH_COMMON_STRING_128];       // licence issuing organization name
    NET_TIME_EX             stUsefulLife;                           // licence validity
    NET_GPS_STATUS_INFO     stGPSStatusInfo;                        // GPS info
    NET_TIME_EX             stCheckTime;                            // sign up time
    NET_DRIVER_CHECK_METHOD emCheckMethod;                          // sign up method
    NET_DRIVER_CHECK_TYPE   emCheckType;                            // sign up type
}ALARM_BUS_DRIVER_CHECK_INFO;

// alarm event type DH_ALARM_DEVICE_MSG_NOTIFY(device to platform notice event)corresponding to data description info
typedef struct tagALARM_DEVICE_MSG_NOTIFY_INFO
{
    DWORD                   dwSize;
    char                    szMsg[DH_COMMON_STRING_256];            // message content
    NET_GPS_STATUS_INFO     stuGPSStatusInfo;                       // GPS info
} ALARM_DEVICE_MSG_NOTIFY_INFO;

// alarm event type DH_ALARM_VEHICLE_STANDING_OVER_TIME(parking timeout alarm)corresponding to  data description info
typedef struct tagALARM_VEHICLE_STANDING_OVER_TIME_INFO
{
    DWORD                   dwSize;
    NET_GPS_STATUS_INFO     stuGPSStatusInfo;                       // GPS info
    NET_TIME_EX             stuTime;                                // first occurance time
    NET_TIME_EX             stuUtc;                                 // current event occurrence time
    DWORD                   dwUtc;                                  // current event occurrence time
    BOOL                    bEventConfirm;                          // confirm needed or not, invalid in CLIENT_StartListenEx callback
} ALARM_VEHICLE_STANDING_OVER_TIME_INFO;

// direction
typedef enum tagNET_LINE_DIRECTION
{
    NET_LINE_DIRECTION_UNKNOWN,                                     // unknown
    NET_LINE_DIRECTION_POSTIVE,                                     // firward direction
    NET_LINE_DIRECTION_NEGATIVE,                                    // opposite direction
    NET_LINE_DIRECTION_AROUND,                                      // loop
    NET_LINE_DIRECTION_DISPERSE,                                    // disperse
} NET_LINE_DIRECTION;

// in/out station status
typedef enum tagNET_BUS_STATE
{
    NET_BUS_STATE_UNKNOWN,                                         // unknown
    NET_BUS_STATE_ILLEGAL,                                         // illegal
    NET_BUS_STATE_LEGAL,                                           // legal
} NET_BUS_STATE;

// stop announcement method
typedef enum tagNET_PORT_TYPE
{
    NET_PORT_TYPE_UNKOWN,                                           // unknown
    NET_PORT_TYPE_MANUAL,                                           // manual stop announcement
    NET_PORT_TYPE_GPS,                                              // GPS stopannouncement
} NET_PORT_TYPE;

// mobile unlock event data type 
typedef enum tagEM_VEHICLE_DATA_TYPE
{
    EM_VEHICLE_DOOR_OPEN_DATA_UNKNOWN = 0,
    EM_VEHICLE_DOOR_OPEN_DATA_REALTIME,               // real-time data
    EM_VEHICLE_DOOR_OPEN_DATA_HISTORY,                // re-send data
}EM_VEHICLE_DATA_TYPE;

// alarm event type DH_ALARM_BUS_IMPORT_SITE(in station event)corresponding to data description info
typedef struct tagALARM_BUS_IMPORT_SITE_INFO
{
    DWORD                   dwSize;
    char                    szSiteID[DH_COMMON_STRING_64];          // station mark
    DWORD                   dwSiteNum;                              // stop order
    NET_LINE_DIRECTION      emDirection;                            // direction
    char                    szLineID[DH_COMMON_STRING_64];          // maek
    NET_TIME_EX             stuTime;                                // in/out station time
    int                     nTime;                                  // used to confirm event time, UTC, unit is second
    NET_BUS_STATE           emState;                                // if in/out station on time
    NET_PORT_TYPE           emType;                                 // stop announcement method
    NET_GPS_STATUS_INFO     stuGPSStatusInfo;                       // GPS info
    DWORD                   dwSiteCount;                            // total stop point
    char                    szSiteName[DH_COMMON_STRING_64];        // stop name 
    char                    szDesignation[DH_COMMON_STRING_64];     // path no.
    EM_VEHICLE_DATA_TYPE    emDataType;                             // event data type 
    BOOL                    bNeedConfirm;                           // confirm or not, via callCLIENT_BusConfirmEventport to confirm
	unsigned int			nFromMileage;							// The mileage from prev station to current station,Unit:m
	unsigned int			nTotalMileage;							// The total mileage from original station to current station,Unit:m
	unsigned int			nFromCostTime;							// The cost time from prev station to current station,Unit:s
	unsigned int			nTotalCostTime;							// The total cost time from original station to current station,Unit:s
} ALARM_BUS_IMPORT_SITE_INFO;

typedef struct tagNET_SUBTOTAL
{
    unsigned int            nDevNum;                // Device id
    unsigned int            nInside;                // Number of ready to get in the car
    unsigned int            nExited;                // Number of ready to get off the car
    BYTE                    byRserved[256];         // Reserved bytes
}NET_SUBTOTAL;
//alarm event type DH_ALARM_BUS_EXPORT_SITE(out station event)corresponding to data description info
typedef struct tagALARM_BUS_EXPORT_SITE_INFO
{
    DWORD                   dwSize;
    char                    szSiteID[DH_COMMON_STRING_64];          // stop mark
    DWORD                   dwSiteNum;                              // order
    NET_LINE_DIRECTION      emDirection;                            // direction
    char                    szLineID[DH_COMMON_STRING_64];          // mark
    NET_TIME_EX             stuTime;                                // in/out station time
    int                     nTime;                                  // used to confirm  event time, UTC, unit is second
    NET_BUS_STATE           emState;                                // if out station on time
    NET_PORT_TYPE           emType;                                 // stop announcement method
    NET_GPS_STATUS_INFO     stuGPSStatusInfo;                       // GPS info
    DWORD                   dwSiteCount;                            // total stop point
    char                    szSiteName[DH_COMMON_STRING_64];        // stop name 
    char                    szDesignation[DH_COMMON_STRING_64];     // path no.
    EM_VEHICLE_DATA_TYPE    emDataType;                             // event data type 
    BOOL                    bNeedConfirm;                           // confirm or not, via call CLIENT_BusConfirmEventport to confirm
	unsigned int			nFromMileage;							// The mileage from prev station to current station,Unit:m
	unsigned int			nTotalMileage;							// The total mileage from original station to current station,Unit:m
	unsigned int			nFromCostTime;							// The cost time from prev station to current station,Unit:s
	unsigned int			nTotalCostTime;							// The total cost time from original station to current station,Unit:s
    int                     nCurrentPeople;                         // The number of people counted in this closing event.When the number of getting off is greater than the number of getting on the bus,the number of people counted is nagative
    unsigned int			nTotalIn;                               // The number of people that get on the car in this closing event
    unsigned int			nTotalOut;                              // The number of people that get off the car in this closing event
    unsigned int			nSubtotalCount;                         // The number of device that count people
    NET_SUBTOTAL            stuSubtotal[32];                        // Number of people info counted by different devices. Up to 32 device(A car may have mulitiple device count people)
} ALARM_BUS_EXPORT_SITE_INFO;

// abnormal event type 
typedef enum tagEM_ALARM_BUS_ABNORMAL_EVENT_TYPE
{
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_UNKNOWN,      // unknown 
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_RUNNING,      // recover operation, "Running"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_MEAL,         // eat, "Meal"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_BLOCK,        // jam, "Block"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_CALL,         // call, "Call"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_BREAKDOWN,    // breakdown, "Breakdown"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_DISCONTINUED, // stop operation, "Discontinued"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_ROBING,       // robing, "Robing"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_OVERLOAD,     // overload, "Overload"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_DISPUTE,      // dispute, "Dispute"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_ACCIDENT,     // event, "Accident"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_OVERSPEED,    // over speed, "OverSpeed"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_RENTAL,       // rental, "Rental"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_MAINTENANCE,  // maintenance, "Maintenance"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_CLOSURE,      // closure, "Closure"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_PUBSECURITY,       // "PubSecurity"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_ENTER_PARK,        // "EnterPark"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_LEAVE_PARK,        // "LeavePark"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_REFUEL,            // "Refuel"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_FIRE,              // "Fire"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_HELP,              // "Help"
}EM_ALARM_BUS_ABNORMAL_EVENT_TYPE;

// alarm event type DH_ALARM_BUS_ABNORMAL(vehicle abnormal event )corresponding to data description info 
typedef struct tagALARM_BUS_ABNORMAL_INFO
{
    DWORD                   dwSize;
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE    emEventType;            // abnormal event type 
    char                    szCarNo[DH_MAX_PLATE_NUMBER_LEN];   // plate
    char                    szLineID[DH_COMMON_STRING_64];      // path mark
    NET_LINE_DIRECTION      emLineDirection;                    // path direction
    NET_TIME_EX             stuTime;                            // occur time
    NET_GPS_STATUS_INFO     stuGPSStatusInfo;                   // GPSinfo 
} ALARM_BUS_ABNORMAL_INFO;

// alarm event type DH_ALARM_ENCLOSURE_ALARM(e-fence event)corresponding to data description info
typedef struct tagALARM_ENCLOSURE_ALARM_INFO
{
    DWORD                   dwSize;
    DWORD                   dwAlarmType;                            // alarm type, by bit means, 
                                                                    // 0:LimitSpeed, 1:DriveAllow, 2:ForbidDrive, 3:LoadGoods, 4:UploadGoods
    DWORD                   dwAlarmDetail;                          // alarm description, by bit means,
                                                                    // 0:DriveIn, 1:DriveOut, 2:Overspeed, 3:SpeedClear
    NET_BUS_STATE           emState;                                // if trigger event by schedules time
    DWORD                   dwDriverNo;                             // driver no.
    DWORD                   dwEnclosureID;                          // fence ID
    DWORD                   dwLimitSpeed;                           // speed limit
    DWORD                   dwCurrentSpeed;                         // current speed
    NET_TIME_EX             stuTime;                                // current time
    NET_GPS_STATUS_INFO     stuGPSStatusInfo;                       // GPS info
} ALARM_ENCLOSURE_ALARM_INFO;

// mobile door status 
typedef NET_ACCESS_CTL_STATUS_TYPE NET_VEHICLE_DOOR_STATUS;

// mobile unlock event , corresponding to event type DH_VEHICLE_DOOR_OPEN
typedef struct tagALARM_VEHICLE_DOOR_OPEN_INFO 
{
    DWORD                   dwSize;
    NET_VEHICLE_DOOR_STATUS emStatus;           // door status 
    int                     nDoor;              // door no., 1:front door,2:middle door,3:rear door
    NET_TIME                stuTime;            // event time, UTC
    int                     nTime;              // used to confirm  event used time, UTC, unit is second
    NET_GPS_STATUS_INFO     stuGPSStatusInfo;   // GPSinfo 
    EM_VEHICLE_DATA_TYPE    emDataType;         // event  data  type 
    BOOL                    bNeedConfirm;       // confirm or not, via call CLIENT_BusConfirm Eventport to confirm
}ALARM_VEHICLE_DOOR_OPEN_INFO;

//The current event, the corresponding event type  DH_ALARM_BUS_CUR_MILEAGE
typedef struct tagALARM_BUS_CUR_MILEAGE_INFO 
{
    DWORD                       dwSize;
    BOOL                        bNeedConfirm;           // Whether need confirm, confirm it by CLIENT_BusConfirmEvent
    int                         nTime;                  // Time for confirming the event, UTC, The unit is in seconds
    EM_VEHICLE_DATA_TYPE        emDataType;             // The type of event data
    NET_TIME                    stuTime;                // Event time, UTC
    NET_GPS_STATUS_INFO         stuGPSStatusInfo;       // GPS information, only longitude and latitude /speed and direction angle valid
    NET_TIME                    stuStartTime;           // The beginning of the current period of time, UTC
    NET_GPS_STATUS_INFO         stuStartGPSStatusInfo;  // The informations of the GPS on the beginning of the current period of time
	unsigned int                nMileage;               // Number of miles the current period, unit:0.1km
	char						szDriverID[32];			// Driver ID
}ALARM_BUS_CUR_MILEAGE_INFO;

// The current consumption situation, A corresponding event type DH_ALARM_BUS_CUR_OIL
typedef struct tagALARM_BUS_CUR_OIL_INFO 
{
    DWORD                       dwSize;
    BOOL                        bNeedConfirm;           // Whether need confirm, confirm it by CLIENT_BusConfirmEvent
    int                         nTime;                  // Time for confirmmingevent, UTC, unit:seconds
    EM_VEHICLE_DATA_TYPE        emDataType;             // The type of the event data
    NET_TIME                    stuTime;                // Event time, UTC
    NET_GPS_STATUS_INFO         stuGPSStatusInfo;       // GPS information, only longitude and latitude /speed and direction angle valid
    NET_TIME                    stuStartTime;           // The begining time of the current, UTC
    NET_GPS_STATUS_INFO         stuStartGPSStatusInfo;  // The GPS informations at the beginning time of the current, only longitude and latitude /speed and direction angle valid
    unsigned int                nCurOil;                // Current oil, unit: 0.1L
    unsigned int                nOilTankage;            // Tank capacity, unit: 0.1L
    int                         nOilChange;             // The changes oil of current time, unit: 0.1L, Positive means refuel, Negative means oil consumption
    char                        szCarNO[DH_MAX_PLATE_NUMBER_LEN]; // plate
}ALARM_BUS_CUR_OIL_INFO;

// Low oil alarm events, Corresponding event type DH_ALARM_BUS_LOW_OIL
typedef struct tagALARM_BUS_LOW_OIL_INFO 
{
    DWORD                       dwSize;
    BOOL                        bNeedConfirm;           // Whether need confirm, confirm it by CLIENT_BusConfirmEvent
    int                         nTime;                  // Time for confirming the event, UTC, The unit is in seconds
    EM_VEHICLE_DATA_TYPE        emDataType;             // The type of the event data
    NET_TIME                    stuTime;                // Event time, UTC
    NET_GPS_STATUS_INFO         stuGPSStatusInfo;       // GPS information, only longitude and latitude /speed and direction angle valid
    unsigned int                nCurOil;                // Current oil, unit: 0.1L
    unsigned int                nOilLine;               // Oil threshold, unit: 0.1L
    unsigned int                nOilTankage;            // Tank capacity, unit: 0.1L
    char                        szCarNO[DH_MAX_PLATE_NUMBER_LEN]; // plate
}ALARM_BUS_LOW_OIL_INFO;

// Steal oil alarm events, Corresponding evnet type DH_ALARM_BUS_STEAL_OIL
typedef struct tagALARM_BUS_STEAL_OIL_INFO 
{
    DWORD                       dwSize;
    BOOL                        bNeedConfirm;           // Whether need confirm, confirm it by CLIENT_BusConfirmEvent
    int                         nTime;                  // Time for confirming the event, UTC, The unit is in seconds
    EM_VEHICLE_DATA_TYPE        emDataType;             // The type of the event data
    NET_TIME                    stuTime;                // Event time, UTC
    NET_GPS_STATUS_INFO         stuGPSStatusInfo;       // GPS information, only longitude and latitude /speed and direction angle valid
    unsigned int                nCurOil;                // Current oil, unit: 0.1L
    unsigned int                nOilTankage;            // Tank capacity, unit: 0.1L
    char                        szCarNO[DH_MAX_PLATE_NUMBER_LEN]; // plate
}ALARM_BUS_STEAL_OIL_INFO;

// Circuit shift event,vehicle demand, Corresponding to DH_ALARM_BUS_CIRCUIT_SHIFT
typedef struct tagALARM_BUS_CIRCUIT_SHIFT_INFO
{
	BOOL                        bNeedConfirm;           // Whether need confirm, confirm it by CLIENT_BusConfirmEvent
	unsigned int                nTime;                  // Time for confirming the event, UTC, The unit is in seconds
	NET_GPS_STATUS_INFO         stuGPSStatusInfo;       // GPS information, only longitude and latitude /speed and direction angle valid
	NET_TIME                    stuTime;                // Event time, UTC
	BYTE						byReserved[1024];		// Reserved
}ALARM_BUS_CIRCUIT_SHIFT_INFO;

// Route overtime,escort vehicle demand,Corresponding to DH_ALARM_BUS_ROUTE_OVERTIME
typedef struct tagALARM_BUS_ROUTE_OVERTIME_INFO
{
	BOOL                        bNeedConfirm;           // Whether need confirm, confirm it by CLIENT_BusConfirmEvent
	unsigned int                nTime;                  // Time for confirming the event, UTC, The unit is in seconds
	NET_GPS_STATUS_INFO         stuGPSStatusInfo;       // GPS information, only longitude and latitude /speed and direction angle valid
	NET_TIME                    stuTime;                // Event time, UTC
	BYTE						byReserved[1024];		// Reserved
}ALARM_BUS_ROUTE_OVERTIME_INFO;

// Vehicle Carry Alarm, slag machine demand, Corresponding to DH_ALARM_BUS_VEHICLE_CARRY_ALARM
typedef struct tagALARM_BUS_VEHICLE_CARRY_ALARM_INFO 
{
    int							nAction;                // Event Action, 0: heavy load, 1: empty load
	BOOL                        bNeedConfirm;           // Whether need confirm, confirm it by CLIENT_BusConfirmEvent
	unsigned int                nTime;                  // Time for confirming the event, UTC, The unit is in seconds
	NET_GPS_STATUS_INFO         stuGPSStatusInfo;       // GPS information, only longitude and latitude /speed and direction angle valid
	NET_TIME                    stuTime;                // Event time, UTC
	BYTE						byReserved[1024];		// Reserved
} ALARM_BUS_VEHICLE_CARRY_ALARM_INFO;

// Vehicle Paulin Alarm, slag machine demand, Corresponding to DH_ALARM_BUS_VEHICLE_PAULIN_ALARM
typedef struct tagALARM_BUS_VEHICLE_PAULIN_ALARM_INFO
{
	int							nAction;                // Event Action, 0: paulin open 1: paulin close
	BOOL                        bNeedConfirm;           // Whether need confirm, confirm it by CLIENT_BusConfirmEvent
	unsigned int                nTime;                  // Time for confirming the event, UTC, The unit is in seconds
	NET_GPS_STATUS_INFO         stuGPSStatusInfo;       // GPS information, only longitude and latitude /speed and direction angle valid
	NET_TIME                    stuTime;                // Event time, UTC
	BYTE						byReserved[1024];		// Reserved
} ALARM_BUS_VEHICLE_PAULIN_ALARM_INFO;

// Vehicle Lift Alarm, slag machine demand, Corresponding to DH_ALARM_BUS_VEHICLE_LIFT_ALARM
typedef struct tagALARM_BUS_VEHICLE_LIFT_ALARM_INFO
{
	int							nAction;                // Event Action, 0: lift, 1: flat
	BOOL                        bNeedConfirm;           // Whether need confirm, confirm it by CLIENT_BusConfirmEvent
	unsigned int                nTime;                  // Time for confirming the event, UTC, The unit is in seconds
	NET_GPS_STATUS_INFO         stuGPSStatusInfo;       // GPS information, only longitude and latitude /speed and direction angle valid
	NET_TIME                    stuTime;                // Event time, UTC
	BYTE						byReserved[1024];		// Reserved
} ALARM_BUS_VEHICLE_LIFT_ALARM_INFO;

// order Bus status input structure
typedef struct tagNET_IN_BUS_ATTACH
{
    DWORD                   dwSize;
    fBusStateCallBack       cbBusState;                             // status call function
    LDWORD                  dwUser;                                 // user data
}NET_IN_BUS_ATTACH;

// order Bus status output structure
typedef struct tagNET_OUT_BUS_ATTACH
{
    DWORD                dwSize;
}NET_OUT_BUS_ATTACH;

// extention module alarm channel info
typedef struct tagNET_EXALARMCHANNELS_INFO
{
    DWORD               dwSize;
    int                 nExAlarmBoxNum;                             // extension alarm box channel no.
    int                 nChannelNum;                                // ths channelno. On alarm box
    char                szChannelName[DH_MAX_EXALARMCHANNEL_NAME_LEN];// alarm channel name 
} NET_EXALARMCHANNELS_INFO;

// CLIENT_QueryDevState port input parameter
typedef struct tagNET_EXALARMCHANNELS
{
    DWORD                       dwSize;
    int                         nExAlarmInCount;                    // extension  module alarm input channel quantity, need user search
    int                         nRetExAlarmInCount;                 // extension  module alarm input channel return quantity
    NET_EXALARMCHANNELS_INFO*   pstuExAlarmInInfo;                  // extension  module alarm input channel info
																	// the space application by the user, apply to sizeof(NET_EXALARMCHANNELS_INFO)*nExAlarmInCount
	int                         nExAlarmOutCount;                   // extension  module alarm output channel quantity, need user to search
    int                         nRetExAlarmOutCount;                // extension  module alarm output channel return quantity
    NET_EXALARMCHANNELS_INFO*   pstuExAlarmOutInfo;                 // extension  module alarm output channel info
																	// the space application by the user, apply to sizeof(NET_EXALARMCHANNELS_INFO)*nExAlarmOutCount
} NET_EXALARMCHANNELS;

// activate zone info
typedef struct tagNET_ACTIVATEDDEFENCEAREA_INFO
{
    DWORD                       dwSize;
    int                         nChannel;                           // zone channel no.
    NET_TIME                    stuActivationTime;                  // zone activation time 
}NET_ACTIVATEDDEFENCEAREA_INFO;
// CLIENT_QueryDevState port input parameter
typedef struct tagNET_ACTIVATEDEFENCEAREA
{
    DWORD                       dwSize;
    int                         nAlarmInCount;                      // search local alarm input channel quantity,  need use to specify
    int                         nRetAlarmInCount;                   // local alarm input channel actual activation quantity
    NET_ACTIVATEDDEFENCEAREA_INFO* pstuAlarmInDefenceAreaInfo;      // local alarm input channel info
																	// the space application by the user,apply to sizeof(NET_ACTIVATEDDEFENCEAREA_INFO)*nAlarmInCount
    int                         nExAlarmInCount;                    // search extension module alarm input quantity. Use specify
    int                         nRetExAlarmInCount;                 // extension  module alarm input channel actual activation quantity
    NET_ACTIVATEDDEFENCEAREA_INFO* pstuExAlarmInDefenceAreaInfo;    // extension  module alarm input channel info
																	// the space application by the user,apply to sizeof(NET_ACTIVATEDDEFENCEAREA_INFO)*nExAlarmInCount
}NET_ACTIVATEDDEFENCEAREA;

// access control status type
typedef enum tagEM_NET_DOOR_STATUS_TYPE
{
    EM_NET_DOOR_STATUS_UNKNOWN,
    EM_NET_DOOR_STATUS_OPEN,                            // door unlock
    EM_NET_DOOR_STATUS_CLOSE,                           // door lock
    EM_NET_DOOR_STATUS_BREAK,                           // door abnormal unlock
}EM_NET_DOOR_STATUS_TYPE;

// access control status info(CLIENT_QueryDevState port input parameter)
typedef struct tagNET_DOOR_STATUS_INFO
{
    DWORD                       dwSize;
    int                         nChannel;               // access control channel no.
    EM_NET_DOOR_STATUS_TYPE     emStateType;            // access control status info
}NET_DOOR_STATUS_INFO;

// CLIENT_QueryRecordCount port input parameter
typedef struct _NET_IN_QUEYT_RECORD_COUNT_PARAM
{
    DWORD                       dwSize;                 // structure size
    LLONG                       lFindeHandle;           // search handle
}NET_IN_QUEYT_RECORD_COUNT_PARAM;

// CLIENT_QueryRecordCount port output parameter
typedef struct _NET_OUT_QUEYT_RECORD_COUNT_PARAM
{
    DWORD                       dwSize;                 // structure size
    int                         nRecordCount;           // device return record item
}NET_OUT_QUEYT_RECORD_COUNT_PARAM;

// analog alarm input channel info
typedef struct tagNET_ANALOGALARM_CHANNELS_INFO 
{
    DWORD               dwSize;
    int                 nSlot;                          	// root address, 0 means local channel, 1 means connection to 1st serial extention channel, 2,3...and so on
    int                 nLevel1;                        	// 1st level cascading address, means connection to no.nSlot serial no.nLevel1 detector, from 0
    int                 nLevel2;                        	// 2nd level cascading address,means cascading address, means connection to no.nLevel1 node no.nLevel2 detector, from 0, -1 means inexist
    char                szName[DH_COMMON_STRING_128];   	// channel name 
	char				szSenseMethod[DH_COMMON_STRING_32];	// Sensor sensing mode
	BYTE				byIsNull;							// Distinguish weather the channel is empty, 0 is not vacant, 1 is vacant
}NET_ANALOGALARM_CHANNELS_INFO;

// analog alarm input channel mapping relation (correspondingDH_DEVSTATE_ANALOGALARM_CHANNELS command)
typedef struct tagNET_ANALOGALARM_CHANNELS 
{
    DWORD                          dwSize;
    int                            nMaxAnalogAlarmChannels; // max channel
    int                            nRetAnalogAlarmChannels; // return channel
    NET_ANALOGALARM_CHANNELS_INFO* pstuChannelInfo;         // channel info, userallocate memory, apply to sizeof(NET_ANALOGALARM_CHANNELS_INFO)*nMaxAnalogAlarmChannels
	int							   nVideoChannel;			// specify the video channel number
}NET_ANALOGALARM_CHANNELS;

// sensor data info
typedef struct tagNET_ANALOGALARM_SENSE_INFO 
{
    DWORD                   dwSize;
    int                     nChannelID;                     // channel no.(from 0)
    NET_SENSE_METHOD        emSense;                        // sensor type
    float                   fData;                          // sensor value
    NET_TIME                stuTime;                        // collection time
    int                     nStatus;                        // data status, -1:unknown,0:normal,1data invalid(over measure),
                                                            // 2: over threshold1,3: over threshold 2,4: over threshold 3,5: over threshold 4,
                                                            // 6:below threshold1,7: below threshold 2,8: below threshold 3,9: below threshold 4
    NET_GPS_STATUS_INFO     stuGpsSatus;                    // GPS status 
    int                     nUint;                          // Unit of the sensor value, it is valid when emSense is the following value
                                                            // NET_SENSE_TEMP, refer to NET_TEMPERATURE_UNIT for the value. 
	int						nVideoChannel;					// video channel
}NET_ANALOGALARM_SENSE_INFO;

//subscribe analog alarm channel data callback function original
typedef void (CALLBACK *fAnalogAlarmDataCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_ANALOGALARM_SENSE_INFO* pInfo, int nBufLen, LDWORD dwUser);
// CLIENT_AttachAnalogAlarmData() port input parameter
typedef struct tagNET_IN_ANALOGALARM_DATA 
{
    DWORD                       dwSize;
    int                         nChannelId;                 // from 0, -1 means all channels
    fAnalogAlarmDataCallBack    cbCallBack;                 // data callback function
    LDWORD                      dwUser;                     // user custom parameter

}NET_IN_ANALOGALARM_DATA;

// CLIENT_AttachAnalogAlarmData()port output parameter
typedef struct tagNET_OUT_ANALOGALARM_DATA 
{
    DWORD    dwSize;
}NET_OUT_ANALOGALARM_DATA;

// order  record change port definition
#define DH_MAX_RECORD_INSERT_NUM              128
#define DH_MAX_RECORD_DELETE_NUM              128
#define DH_MAX_RECORD_UPDATE_NUM              128

typedef struct tagNET_RECORDUPDATER_INFO
{
    DWORD           dwSize;
    int             nInsertNum;                   // record info , inserted  record number 
    int             nInsertNumberList[DH_MAX_RECORD_INSERT_NUM];  // means new record  index       
    int             nDeleteNum;                   // record info , deleted record number 
    int             nDeleteNumberList[DH_MAX_RECORD_DELETE_NUM];  // means deleted record  index , -1 means delete all record     
    int             nUpdateNum;                   // record info , updated record number 
    int             nUpdateNumberList[DH_MAX_RECORD_UPDATE_NUM];  // means updated record  index      
}NET_RECORDUPDATER_INFO;

//order record change port 
typedef void (CALLBACK *fRecordUpdaterCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_RECORDUPDATER_INFO* pInfo, int nBufLen, LDWORD dwUser);

// CLIENT_AttachRecordUpdater()port input parameter 
typedef struct tagNET_IN_RECORDUPDATER_DATA
{
    DWORD               dwSize;
    EM_NET_RECORD_TYPE  emType;           // record  set info type 
    fRecordUpdaterCallBack   cbRecordUpdater;         // record update call function
    LDWORD              dwUser;           // user defnition parameter 
}NET_IN_RECORDUPDATER_DATA;

// CLIENT_AttachRecordUpdater()port  output parameter 
typedef struct tagNET_OUT_RECORDUPDATER_DATA
{
    DWORD               dwSize;
}NET_OUT_RECORDUPDATER_DATA;


// search device supported sensor type 
// CLIENT_QueryDevState port DH_DEVSTATE_GET_SENSORLIST  command parameter
#define MAX_SUPPORT_SENSORTYPE_NUM    128                   // max supported sensor device type

typedef struct tagNET_SENSOR_LIST 
{
    DWORD       dwSize;
    int         nSupportSensorNum;                          // return sensor device type
    char        szSensorList[MAX_SUPPORT_SENSORTYPE_NUM][DH_COMMON_STRING_64];
}NET_SENSOR_LIST;

// CLIENT_QueryDevLogCount get log item input parameter
typedef struct tagNET_IN_GETCOUNT_LOG_PARAM
{
    DWORD                       dwSize;
    QUERY_DEVICE_LOG_PARAM      stuQueryCondition;          // search record filter
} NET_IN_GETCOUNT_LOG_PARAM;

// CLIENT_QueryDevLogCount get log item output parameter
typedef struct tagNET_OUT_GETCOUNT_LOG_PARAM
{
    DWORD                       dwSize;
    int                         nLogCount;                  // log quantity(device return)
} NET_OUT_GETCOUNT_LOG_PARAM;

// SDK callback
typedef int (CALLBACK *fSDKLogCallBack)(const char* szLogBuffer, unsigned int nLogSize, LDWORD dwUser);

// SDK global log print
typedef struct tagLogSetPrintInfo
{
    DWORD           dwSize;
    BOOL            bSetFilePath;                           // reset log path
    char            szLogFilePath[MAX_LOG_PATH_LEN];        // log path(default"./sdk_log/sdk_log.log")
    BOOL            bSetFileSize;                           // reset log size
    unsigned int    nFileSize;                              // each log file size(default size 10240), unit:KB
    BOOL            bSetFileNum;                            // reset log file number
    unsigned int    nFileNum;                               // log file quantity(default size 10)
    BOOL            bSetPrintStrategy;                      // reset log print strategy
    unsigned int    nPrintStrategy;                         // log out strategy, 0: output to file(defualt); 1:output to window
	BYTE			byReserved[4];							// Byte alignment
	fSDKLogCallBack	cbSDKLogCallBack;						// log callback, (default NULL)
	LDWORD			dwUser;									// UserData
}LOG_SET_PRINT_INFO;

//////////////////////////////////////////////////////////////////////////
//       Low Rate Wireless Personal Area Network low speed wireless private network begin
//////////////////////////////////////////////////////////////////////////

// Wireless Device Type
typedef enum tagNET_WIRELESS_DEVICE_TYPE
{
	NET_WIRELESS_DEVICE_TYPE_UNKNOWN = 0,				
	NET_WIRELESS_DEVICE_TYPE_KEYBOARD,			// Wireless keyboard
	NET_WIRELESS_DEVICE_TYPE_DEFENCE,			// Wireless zone 
	NET_WIRELESS_DEVICE_TYPE_REMOTECONTROL,		// Wireless remote control 
	NET_WIRELESS_DEVICE_TYPE_MAGNETOMER,		// Wireless door sensor 
	NET_WIRELESS_DEVICE_TYPE_ALARMBELL,			// Wireless alarm bell
	NET_WIRELESS_DEVICE_TYPE_SWITCHER,          // Wireless switcher
    NET_WIRELESS_DEVICE_TYPE_SMARTLOCK,         // Wireless smart lock
    NET_WIRELESS_DEVICE_TYPE_REPEATER,          // Wireless Repeater
} NET_WIRELESS_DEVICE_TYPE;

// Wireless Device Mode
typedef enum tagEM_WIRELESS_DEVICE_MODE
{
    EM_WIRELESS_DEVICE_MODE_UNKNOWN = 0,               
    EM_WIRELESS_DEVICE_MODE_NORMAL,                // Normal  
    EM_WIRELESS_DEVICE_MODE_POLLING,               // Polling    It only to be valid when emType is NET_WIRELESS_DEVICE_TYPE_REMOTECONTROL
} EM_WIRELESS_DEVICE_MODE;

// the type of sense method
typedef enum tagEM_CODEID_SENSE_METHOD_TYPE
{
    EM_CODEID_SENSE_METHOD_TYPE_UNKOWN,         // Unknown
    EM_CODEID_SENSE_METHOD_TYPE_DOOR_MAGNETISM, // Door Magnetism
    EM_CODEID_SENSE_METHOD_TYPE_GAS_SENSOR,     // Gas Sensor
    EM_CODEID_SENSE_METHOD_TYPE_CURTAIN_SENSOR, // Curtain Sensor
    EM_CODEID_SENSE_METHOD_TYPE_MOBILE_SENSOR,  // Mobile Sensor
    EM_CODEID_SENSE_METHOD_TYPE_PASSIVEINFRA,   // Passive Infrared Sensor
    EM_CODEID_SENSE_METHOD_TYPE_URGENCY_BUTTON, // Urgency Button
    EM_CODEID_SENSE_METHOD_TYPE_SMOKING_SENSOR, // Smoking Sensor
    EM_CODEID_SENSE_METHOD_TYPE_DOUBLEMETHOD,   // DoubleMethod(Infrare+Microwave)
    EM_CODEID_SENSE_METHOD_TYPE_WATER_SENSOR,   // Water Sensor
    EM_CODEID_SENSE_METHOD_TYPE_THREEMETHOD,    // Three Sensor
}EM_CODEID_SENSE_METHOD_TYPE;

#define DH_WIRELESS_DEVICE_SERIAL_NUMBER_MAX_LEN 32    // the max length of wireless device SN

// Code info
typedef struct tagNET_CODEID_INFO
{
	DWORD						dwSize;
	TP_U64	                    nWirelessId;					   // Wireless ID no.
	NET_WIRELESS_DEVICE_TYPE	emType;							   // Wireless device type
	char						szName[DH_USER_NAME_LENGTH];	   // Username
	BOOL						bEnable;						   // Enable this device
    char                        szCustomName[DH_COMMON_STRING_64]; // Custom Name
    int                         nChannel;                          // It only to be valid when emType is NET_WIRELESS_DEVICE_TYPE_DEFENCE
    EM_WIRELESS_DEVICE_MODE     emMode;                            // Wireless Device Mode.
    EM_CODEID_SENSE_METHOD_TYPE emSenseMethod;                     // The sense method
    char                        szSerialNumber[DH_WIRELESS_DEVICE_SERIAL_NUMBER_MAX_LEN]; // Wireless Device SN
	UINT                       nTaskID;                          // Task ID
    char                        szRoomNo[64];                     // Room number of intelligent lock
	DWORD                       nMaxFingerprints;                  // fingerprint number: 0 indicates unsupported fingerprints
    DWORD                       nMaxCards;                         // cards number: 0 indicates unsupported cards
    DWORD                       nMaxPwd;                           // password number: 0 indicates unsupported password

}NET_CODEID_INFO;

// Code error type
typedef enum tagNET_CODEID_ERROR_TYPE
{	
	NET_CODEID_ERROR_TYPE_RIGHT = 0,			// Code correct
	NET_CODEID_ERROR_TYPE_ALREADYEXIST,			// Exists
	NET_CODEID_ERROR_TYPE_OTHER,				// Other error
} NET_CODEID_ERROR_TYPE;

// Order wireless code info call function origin, lAttachHandle is CLIENT_AttachLowRateWPAN return valud
typedef void (CALLBACK *fAttachLowRateWPANCB) (LLONG lLoginID, LLONG lAttachHandle, NET_CODEID_INFO* stuBuf, NET_CODEID_ERROR_TYPE emError, LDWORD dwUser);

// CLIENT_AttachLowRateWPAN() input parameter
typedef struct tagNET_IN_ATTACH_LOWRATEWPAN
{
	DWORD					dwSize;
	fAttachLowRateWPANCB	cbAttachLowRateWPANCB;         // Code data call
	LDWORD					dwUser;                        // User Data
}NET_IN_ATTACH_LOWRATEWPAN;

// CLIENT_AttachLowRateWPAN() output parameter
typedef struct tagNET_OUT_ATTACH_LOWRATEWPAN
{
	DWORD		        dwSize;
}NET_OUT_ATTACH_LOWRATEWPAN;

// Delete specific wireless device
// CLIENT_ControlDevice port DH_CTRL_LOWRATEWPAN_REMOVE command parameter
typedef struct tagNET_CTRL_LOWRATEWPAN_REMOVE
{
	DWORD					dwSize;
	TP_U64			        nWirelessId;				// Wireless device ID
    char                    szSerialNumber[DH_WIRELESS_DEVICE_SERIAL_NUMBER_MAX_LEN]; // Wireless device SN
}NET_CTRL_LOWRATEWPAN_REMOVE;

// Delete all wireless device
// CLIENT_ControlDevice port DH_CTRL_LOWRATEWPAN_REMOVEALL command parameter
typedef struct tagNET_CTRL_LOWRATEWPAN_REMOVEALL
{
	DWORD					dwSize;
}NET_CTRL_LOWRATEWPAN_REMOVEALL;

// Modify wireless device info
// CLIENT_ControlDevice port DH_CTRL_LOWRATEWPAN_MODIFY command parameter
typedef struct tagNET_CTRL_LOWRATEWPAN_MODIFY
{
	DWORD					dwSize;
	NET_CODEID_INFO			stuCodeIDInfo;			// According to CodeIDInfo CodeID, modify its UserandEnable indo, cannot modify others
}NET_CTRL_LOWRATEWPAN_MODIFY;

//Setting the working mode of the detector
//CLIENT_ControlDevice port DH_CTRL_LOWRATEWPAN_SETWORKMODE command parameter
typedef struct tagNET_IN_CTRL_LOWRATEWPAN_SETWORKMODE
{
	DWORD                   dwSize;
	int                     nMode;                 //mode 0 :power saving mode,  1 : working mode

}NET_IN_CTRL_LOWRATEWPAN_SETWORKMODE;

// car pass status
typedef enum tagEM_CARPASS_STATUS
{
	EM_CARPASS_STATUS_UNKNOWN,     // Unknown status     
	EM_CARPASS_STATUS_CARPASS,     // car pass status
	EM_CARPASS_STATUS_NORMAL,      // no car status
}EM_CARPASS_STATUS;

//Set park info, corresponding DH_CTRL_SET_PARK_INFO command parameter
typedef struct tagNET_CTRL_SET_PARK_INFO
{
	DWORD				   dwSize;
	char				   szPlateNumber[MAX_PLATE_NUMBER_LEN];         // Plate number
	unsigned int		   nParkTime;									// park time,Unit:minute
	char				   szMasterofCar[MAX_MASTER_OF_CAR_LEN];		// Master of car
	char				   szUserType[MAX_USER_TYPE_LEN];				// User type,not general,Used in entrance capture machine
																		// monthlyCardUser means monthly card user,yearlyCardUser means yearly card user,longTimeUser means long time user/VIP,casualUser means casual user/Visitor
	unsigned int		   nRemainDay;									// Remain day
	char				   szParkCharge[MAX_PARK_CHARGE_LEN];			// Park charge
	unsigned int		   nRemainSpace;								// Remain space
	unsigned int		   nPassEnable;									// 0:car is not allowed to pass,1:car is allowed to pass
	NET_TIME			   stuInTime;									// car in time
	NET_TIME			   stuOutTime;									// car out time
	EM_CARPASS_STATUS	   emCarStatus;									// car pass status
	char				   szCustom[MAX_CUSTOM_LEN];					// custom field,default:null
	char				   szSubUserType[MAX_SUB_USER_TYPE_LEN];		// Sub user type of szUserType
	char				   szRemarks[MAX_REMARKS_LEN];					// Remarks info
    char                   szResource[MAX_RESOURCE_LEN];                // Resource file(video or picture) video support:mp4; picture support:BMP/jpg/JPG/jpeg/JPEG/png/PNG
}NET_CTRL_SET_PARK_INFO;

// clear the statistics for the period and start again from 0
// corresponding DH_CTRL_CLEAR_SECTION_STAT command parameter
typedef struct tagNET_CTRL_CLEAR_SECTION_STAT_INFO
{
	DWORD                   dwSize;
	int						nChannel;		// channel ID
} NET_CTRL_CLEAR_SECTION_STAT_INFO;

// Get code successful total items
typedef struct tagNET_GET_CODEID_COUNT
{
	DWORD				dwSize;
	int					nCodeIDCount;		// Code successful total items
}NET_GET_CODEID_COUNT;

// Get code info
typedef struct tagNET_GET_CODEID_LIST
{
	DWORD				dwSize;
	int					nStartIndex;			// Start index symbol, start first search may set to 0
	int					nQueryNum;				// The gotten code items, this value issmaller than or equal to capacity set nMaxPageSize field valud
	int					nRetCodeIDNum;			// Actual returned code items
	NET_CODEID_INFO*	pstuCodeIDInfo;			// Get code content, memory is allocated by user, cannot be lower than nQueryNum*sizeof(NET_CODEID_INFO)
}NET_GET_CODEID_LIST;

// add code info
typedef struct tagNET_CTRL_LOWRATEWPAN_ADD
{
	DWORD dwSize;
	NET_CODEID_INFO stuCodeIDInfo;             // code info data
}NET_CTRL_LOWRATEWPAN_ADD;

// wireless device online state
typedef enum tagEM_WIRELESS_DEVICE_ONLINE_STATE
{   
    EM_WIRELESS_DEVICE_STATE_UNKNOWN = 0,      // unknown
    EM_WIRELESS_DEVICE_STATE_OUTLINE,          // outline
    EM_WIRELESS_DEVICE_STATE_ONLINE,           // online
} EM_WIRELESS_DEVICE_ONLINE_STATE;

// wireless device power state
typedef enum tagEM_WIRELESS_DEVICE_POWER_STATE
{   
    EM_WIRELESS_DEVICE_POWER_UNKNOWN = 0,      // unknown
    EM_WIRELESS_DEVICE_POWER_NORMAL,           // normal
    EM_WIRELESS_DEVICE_POWER_LOW,              // low
} EM_WIRELESS_DEVICE_POWER_STATE;

// wireless device info
typedef struct tagNET_WIRELESS_DEVICE_INFO
{
    char                                szSerialNumber[DH_WIRELESS_DEVICE_SERIAL_NUMBER_MAX_LEN]; // device serial NO
    EM_WIRELESS_DEVICE_ONLINE_STATE     emOnlineState;          // online state of device: 0-unknown, 1-outline, 2-online 
    EM_WIRELESS_DEVICE_POWER_STATE      emPowerState;           // current power state of device: 0-unknown power, 1-normal power, 2-low power
    BYTE                                byReserved[128];        // reserved
}NET_WIRELESS_DEVICE_INFO;

// get wireless devices info
typedef struct tagNET_GET_WIRELESS_DEVICE_STATE
{
    DWORD               dwSize;
    int                 nStartIndex;            // Start index symbol, start first search may set to 0, 
    int                 nQueryNum;              // The gotten device state items, this value is smaller than or equal to capacity set nMaxPageSize field value
    int                 nRetQueryNum;           // Actually returned items, smaller than nQueryNum
    NET_WIRELESS_DEVICE_INFO *pstuDeviceInfo;   // Get state content, memory is allocated by user, cannot be lower than nQueryNum*sizeof(NET_WIRELESS_DEVICE_INFO)
}NET_GET_WIRELESS_DEVICE_STATE;

// the state of redundance power
typedef enum tagEM_REDUNDANCE_POWER_STATE
{   
    EM_REDUNDANCE_POWER_STATE_UNKNOWN = 0,       // Unknown
    EM_REDUNDANCE_POWER_STATE_ON,                // On
    EM_REDUNDANCE_POWER_STATE_OFF,               // Off
    EM_REDUNDANCE_POWER_STATE_ON_FAULT,          // on fault
} EM_REDUNDANCE_POWER_STATE;

#define MAX_REDUNDANCE_POWER_NUM 16              // the max count of redundance power    

// get redundance power info
typedef struct tagNET_GET_REDUNDANCE_POWER_INFO
{
    DWORD                     dwSize;                                   // size in bytes of this struct
    int                       nPowerNum;                                // the num of power
    EM_REDUNDANCE_POWER_STATE emPowerState[MAX_REDUNDANCE_POWER_NUM];   // the array of power state
}NET_GET_REDUNDANCE_POWER_INFO;

// accessory tamper state
typedef enum tagNET_EM_ACCESSORY_TAMPER_STATE
{
    NET_EM_ACCESSORY_TAMPER_UNKNOWN,                    // unknown
    NET_EM_ACCESSORY_TAMPER_ON,                         // on
    NET_EM_ACCESSORY_TAMPER_OFF,                        // off
}NET_EM_ACCESSORY_TAMPER_STATE;

// door state
typedef enum tagNET_EM_DOOR_STATE
{
    NET_EM_DOOR_STATE_UNKNOWN,                          // unknown
    NET_EM_DOOR_STATE_ON,                               // on
    NET_EM_DOOR_STATE_OFF,                              // off   
}NET_EM_DOOR_STATE;

// online state
typedef enum tagNET_EM_ONLINE_STATE
{
    NET_EM_ONLINE_STATE_UNKNOWN,                        // unknown
    NET_EM_ONLINE_STATE_OFFLINE,                        // off-line
    NET_EM_ONLINE_STATE_ONLINE,                         // on-line
}NET_EM_ONLINE_STATE;

// alarm state
typedef enum tagNET_EM_ALARM_STATE
{
    NET_EM_ALARM_STATE_UNKNOWN = -1,                    // unknown
    NET_EM_ALARM_STATE_NORMAL,                          // normal
    NET_EM_ALARM_STATE_ALARM,                           // alarm
}NET_EM_ALARM_STATE;

// return status info
typedef struct tagNET_STATUS_INFO
{
    char                            szSN[MAX_COMMON_STRING_32];     // accessory serial number
    UINT                            nPercent;                       // percentage of battery capacity,0~100
    float                           fVolt;                          // battery capacity,unit:volt
    UINT                            nIntensity;                     // wireless signal intensity level, 0~5
    UINT                            nSignal;                        // wireless signal intensity, dbm, 0~120
    NET_EM_ACCESSORY_TAMPER_STATE   emAccessoryTamperState;         // accessory tamper state
    NET_EM_DOOR_STATE               emDoorState;                    // door state
    char                            szName[MAX_COMMON_STRING_32];   // accessory name
    NET_EM_ONLINE_STATE             emOnlineState;                  // on-line state
    NET_EM_ALARM_STATE              emAlarmState;                   // alarm state,only for door state and waterlogging state; 
                                                                    // invalid for infrared equal pulse alarm
    char                            szVersion[MAX_COMMON_STRING_16];// accessory version
}NET_STATUS_INFO;

// get accessory status
typedef struct tagNET_GET_ACCESSORY_STATUS
{
    DWORD                       dwSize;                         // struct size
    int                         nSNNum;                         // num of accessory SN arr(if nSNNum is 0,return all accessory status)
    char                        szSN[56][MAX_COMMON_STRING_32]; // accessory SN arr, one-dimensional array 
    int                         nStatusNum;                     // num of status info arr
    NET_STATUS_INFO             stStatusInfo[56];				// status info arr
}NET_GET_ACCESSORY_STATUS;

// test mail input,  DH_CTRL_TEST_MAIL control type of CLIENT_ControlDeviceEx
typedef struct tagNET_IN_TEST_MAIL
{
    DWORD dwSize;
}NET_IN_TEST_MAIL;

// test mail output, DH_CTRL_TEST_MAIL control type of CLIENT_ControlDeviceEx
typedef struct tagNET_OUT_TEST_MAIL
{
    DWORD dwSize;
}NET_OUT_TEST_MAIL;

// control smart switch input , DH_CTRL_CONTROL_SMART_SWITCH control type of CLIENT_ControlDeviceEx 
typedef struct tagNET_IN_CONTROL_SMART_SWITCH
{
    DWORD                       dwSize;
    char                        szSerialNumber[DH_WIRELESS_DEVICE_SERIAL_NUMBER_MAX_LEN]; // serial number
    BOOL                        bEnable; 	// TRUE - switch on, FALSE - switch off
    int                         nDelayTime; // delay time ,  equal to zero means immediately. unit: min
}NET_IN_CONTROL_SMART_SWITCH;

// control smart switch output , DH_CTRL_CONTROL_SMART_SWITCH control type of CLIENT_ControlDeviceEx 
typedef struct tagNET_OUT_CONTROL_SMART_SWITCH
{
    DWORD                       dwSize;
}NET_OUT_CONTROL_SMART_SWITCH;

// coaxial IO control type
typedef enum tagEM_COAXIAL_CONTROL_IO_TYPE
{
	EM_COAXIAL_CONTROL_IO_TYPE_UNKNOWN,				// unknown
	EM_COAXIAL_CONTROL_IO_TYPE_LIGHT,				// white light
	EM_COAXIAL_CONTROL_IO_TYPE_SPEAKER,				// speak audio
} EM_COAXIAL_CONTROL_IO_TYPE;

// coaxial IO control switch
typedef enum tagEM_COAXIAL_CONTROL_IO_SWITCH
{
	EM_COAXIAL_CONTROL_IO_SWITCH_UNKNOWN,			// unknown
	EM_COAXIAL_CONTROL_IO_SWITCH_OPEN,				// open
	EM_COAXIAL_CONTROL_IO_SWITCH_CLOSE,				// close
} EM_COAXIAL_CONTROL_IO_SWITCH;

// coaxial IO control tragger mode
typedef enum tagEM_COAXIAL_CONTROL_IO_TRIGGER_MODE
{
	EM_COAXIAL_CONTROL_IO_TRIGGER_MODE_UNKNOWN,			// unknown
	EM_COAXIAL_CONTROL_IO_TRIGGER_MODE_LINKAGE_TRIGGER,	// lingage tragger
	EM_COAXIAL_CONTROL_IO_TRIGGER_MODE_MANUAL_TRIGGER,	// manual tragger
} EM_COAXIAL_CONTROL_IO_TRIGGER_MODE;

// coaxial IO info
typedef struct tagNET_COAXIAL_CONTROL_IO_INFO
{
	EM_COAXIAL_CONTROL_IO_TYPE			emType;				// coaxial IO type
	EM_COAXIAL_CONTROL_IO_SWITCH		emSwicth;			// coaxial IO switch
	EM_COAXIAL_CONTROL_IO_TRIGGER_MODE	emMode;				// coaxial IO tragger mode
	BYTE								byReserved[128];	// reserved
} NET_COAXIAL_CONTROL_IO_INFO;

// max count of coaxial IO control
#define	MAX_COAXIAL_CONTROL_IO_COUNT	8

// control coaxial control IO input , DH_CTRL_COAXIAL_CONTROL_IO control type of CLIENT_ControlDeviceEx 
typedef struct tagNET_IN_CONTROL_COAXIAL_CONTROL_IO
{
	DWORD							dwSize;									// Structure size
	int								nChannel;								// channel 
	int								nInfoCount;								// count of coaxial IO control info 
	NET_COAXIAL_CONTROL_IO_INFO		stInfo[MAX_COAXIAL_CONTROL_IO_COUNT];	// coaxial IO control info
} NET_IN_CONTROL_COAXIAL_CONTROL_IO;

// control coaxial control IO output , DH_CTRL_COAXIAL_CONTROL_IO control type of CLIENT_ControlDeviceEx 
typedef struct tagNET_OUT_CONTROL_COAXIAL_CONTROL_IO
{
	DWORD							dwSize;									// Structure size
} NET_OUT_CONTROL_COAXIAL_CONTROL_IO;


//////////////////////////////////////////////////////////////////////////
//       Low Rate Wireless Personal Area Network end
//////////////////////////////////////////////////////////////////////////

// Analog channel data search(corresponding  DH_DEVSTATE_ANALOGALARM_DATA command)
typedef struct tagNET_GET_ANALOGALARM_DATA 
{
    DWORD                       dwSize;
    int                         nChannelID;     // Analog channel no. to search(start from 0)
    NET_ANALOGALARM_SENSE_INFO  stuInfo;        // Get analog channel data
}NET_GET_ANALOGALARM_DATA;

// Monitor control and data collection device type
typedef enum tagEM_NET_SCADA_DEV_TYPE
{
    EM_NET_SCADA_DEV_TYPE_UNKNOWN = 0,                         // Unknown
    EM_NET_SCADA_DEV_TYPE_ALL,                                 // All-type device
    EM_NET_SCADA_DEV_TYPE_UPS,                                 // UPS
} EM_NET_SCADA_DEV_TYPE;

// Monitor control and data collection device spot path info input parameter, search criteria
typedef struct tagNET_IN_SCADA_POINT_LIST_INFO 
{
    DWORD                           dwSize;
    char                            szDevType[DH_COMMON_STRING_64]; // Device type
}NET_IN_SCADA_POINT_LIST_INFO;

#define MAX_SCADA_POINT_LIST_INDEX          8               // Max SCADADev config subscript number , as max channel

// Spot chart path info
typedef struct tagNET_SCADA_POINT_LIST
{
    DWORD                           dwSize;
    int               nIndexValidNum;                    // Valid config subscript number 
    int               nIndex[MAX_SCADA_POINT_LIST_INDEX];// SCADADev config config subscript value , start from 0
    char              szPath[DH_COMMON_STRING_256];      // chart complete path
}NET_SCADA_POINT_LIST;

#define MAX_SCADA_POINT_LIST_INFO_NUM       256               // max spot path number 
#define MAX_SCADA_POINT_LIST_ALARM_INFO_NUM 256				  // max spot chart alarm number

// Monitor control and data collection device spot chart path info output parameter, search result
typedef struct tagNET_OUT_SCADA_POINT_LIST_INFO 
{
    DWORD                           dwSize;
    int                             nList;                  // Valid spot chart path info number 
    NET_SCADA_POINT_LIST            stuList[MAX_SCADA_POINT_LIST_INFO_NUM];// spot chart path info
}NET_OUT_SCADA_POINT_LIST_INFO;

// Monitor control and data collection device spot chart path info, (corresponding to DH_DEVSTATE_SCADA_POINT_LIST command )
typedef struct tagNET_SCADA_POINT_LIST_INFO 
{
    DWORD                           dwSize;
    NET_IN_SCADA_POINT_LIST_INFO    stuIn;                  // search criteria 
    NET_OUT_SCADA_POINT_LIST_INFO   stuOut;                 // search result 
}NET_SCADA_POINT_LIST_INFO;

// Spot type
typedef enum tagEM_NET_SCADA_POINT_TYPE
{
    EM_NET_SCADA_POINT_TYPE_UNKNOWN = 0,                       // unknown
    EM_NET_SCADA_POINT_TYPE_ALL,                               // all type
    EM_NET_SCADA_POINT_TYPE_YC,                                // analog input
    EM_NET_SCADA_POINT_TYPE_YX,                                // switch input
    EM_NET_SCADA_POINT_TYPE_YT,                                // analog output
    EM_NET_SCADA_POINT_TYPE_YK,                                // switch ouput
} EM_NET_SCADA_POINT_TYPE;

// SCADA monitor spot search criteria 
typedef struct tagNET_IN_SCADA_INFO 
{
    DWORD                   dwSize;
    EM_NET_SCADA_POINT_TYPE emPointType;                    // spot type to search
}NET_IN_SCADA_INFO;

#define MAX_SCADA_YX_NUM                128                 // max yx type spot number
#define MAX_SCADA_YC_NUM                128                 // max yc type spot number
#define MAX_SCADA_POINT_INFO_NUM        8                   // max spot chart number

// Spot chart info 
typedef struct tagNET_SCADA_POINT_INFO 
{
    DWORD                   dwSize;
    char                    szDevName[DH_COMMON_STRING_64]; // device name
    int                     nYX;                            // valid count of YX type spot in anYX
    unsigned int            anYX[MAX_SCADA_YX_NUM];         // value of YX type spots
    int                     nYC;                            // valid count of YC type spot in afYC
    float                   afYC[MAX_SCADA_YC_NUM];         // value of YC type spots
}NET_SCADA_POINT_INFO;

// SCADA monitor spot search result 
typedef struct tagNET_OUT_SCADA_INFO 
{
    DWORD                   dwSize;
    int                     nPointInfoNum;                  // valid spot chart number 
    NET_SCADA_POINT_INFO    stuPointInfo[MAX_SCADA_POINT_INFO_NUM];// spot chart info
}NET_OUT_SCADA_INFO;

// Monitor control and data collection device spot chart path monitor spot info (corresponding to DH_DEVSTATE_SCADA_INFO command )
typedef struct tagNET_SCADA_INFO
{
    DWORD                   dwSize;
    NET_IN_SCADA_INFO       stuIn;                          // search criteria
    NET_OUT_SCADA_INFO      stuOut;                         // search result
}NET_SCADA_INFO;

// SCADA capacity type
typedef enum tagEM_NET_SCADA_CAPS_TYPE
{
    EM_NET_SCADA_CAPS_TYPE_UNKNOWN,
    EM_NET_SCADA_CAPS_TYPE_ALL,                                // all type
    EM_NET_SCADA_CAPS_TYPE_DEV,                                // DevInfo
} EM_NET_SCADA_CAPS_TYPE;

// Monitor control and data collection device spot chart path capacity info search criteria 
typedef struct tagNET_IN_SCADA_CAPS
{
    DWORD                   dwSize;
    EM_NET_SCADA_CAPS_TYPE  emType;                         // search type
} NET_IN_SCADA_CAPS;

#define MAX_NET_SCADA_CAPS_TYPE (16)
#define MAX_NET_SCADA_CAPS_NAME (16)

// Monitor control and data collection device spot chart path type capacity info 
typedef struct tagNET_OUT_SCADA_CAPS_ITEM
{
    DWORD                   dwSize;
    char                    szDevType[DH_COMMON_STRING_32];    	// device type
    int                     nValidName;                         // valid device name number
    char                    szDevName[MAX_NET_SCADA_CAPS_NAME][DH_COMMON_STRING_32];// unique device names
} NET_OUT_SCADA_CAPS_ITEM;

// Monitor control and data collection device spot chart path capacity info search result 
typedef struct tagNET_OUT_SCADA_CAPS
{
    DWORD                   dwSize;
    int                     nValidType;                         // valid device type number 
    NET_OUT_SCADA_CAPS_ITEM stuItems[MAX_NET_SCADA_CAPS_TYPE];  // Max 16 types 
} NET_OUT_SCADA_CAPS;

// Monitor control and data collection device spot chart path capacity info (corresponding to DH_DEVSTATE_SCADA_CAPS command )
typedef struct tagNET_SCADA_CAPS
{
    DWORD                   dwSize;
    NET_IN_SCADA_CAPS       stuIn;                          // search criteria 
    NET_OUT_SCADA_CAPS      stuOut;                         // search result 
} NET_SCADA_CAPS;

// spot info(queried by device id, sensor id)
typedef struct tagNET_SCADA_POINT_BY_ID_INFO 
{
    DWORD                   dwSize;
    EM_NET_SCADA_POINT_TYPE emType;                         // spot type
    char                    szID[DH_COMMON_STRING_64];      // id
    int                     nMeasuredVal;                   // measured value, valid if spot type is YX
    float                   fMeasureVal;                    // measured value, valid if spot type is YC
    int                     nSetupVal;                      // setup value, valid if spot type is YK
    float                   fSetupVal;                      // setup value, valid if spot type is YT
    int                     nStatus;                        // data status, -1:unknown, 0:normal, 1:alarm level1, 2:alarm level2, 3:alarm level3, 4:alarm level4, 5:operation event, 6:invalid data
    NET_TIME                stuTime;                        // collect time
}NET_SCADA_POINT_BY_ID_INFO;

#define MAX_SCADA_ID_OF_SENSOR_NUM  128                     // Max count of spot id

// get spot info by sensor id, spot id(corresponding to DH_DEVSTATE_SCADA_INFO_BY_ID)
typedef struct tagNET_SCADA_INFO_BY_ID
{
    DWORD                   dwSize;
    char                    szSensorID[DH_COMMON_STRING_64];// input param, sensor ID
    int                     nIDs;                           // input param, valid count of spot id in szIDs
    char                    szIDs[MAX_SCADA_ID_OF_SENSOR_NUM][DH_COMMON_STRING_64];// input param, spot IDs
	BOOL					bIsHandle;						// input param, return data is handle or not(Filter useless data.etc).Handle:true, not handle:false
    int                     nMaxCount;                      // input param, count of NET_SCADA_POINT_BY_ID_INFO in pstuInfo
    int                     nRetCount;                      // output param, returned count of NET_SCADA_POINT_BY_ID_INFO from device, may be larger than nMaxCount
    NET_SCADA_POINT_BY_ID_INFO* pstuInfo;                   // input/output param, user allocates the memory, apply to sizeof(NET_SCADA_POINT_BY_ID_INFO)*nMaxCount
}NET_SCADA_INFO_BY_ID;

// scada device id info
typedef struct tagNET_SCADA_DEVICE_ID_INFO 
{
    char                    szDeviceID[DH_COMMON_STRING_64];// device id
    char                    szDevName[DH_COMMON_STRING_64]; // device name, the same as "szDevName" in CFG_SCADA_DEV_INFO
    BYTE                    reserve[1024];
}NET_SCADA_DEVICE_ID_INFO;

// query scada device IDs(corresponding to DH_DEVSTATE_SCADA_DEVICE_LIST)
typedef struct tagNET_SCADA_DEVICE_LIST
{
    DWORD                       dwSize;
    int                         nMax;                       // count of NET_SCADA_DEVICE_ID_INFO in pstuDeviceIDInfo
    int                         nRet;                       // returned count of NET_SCADA_DEVICE_ID_INFO from device, may be larger than nMax
    NET_SCADA_DEVICE_ID_INFO*   pstuDeviceIDInfo;           // scada device id info, user allocates the memory,apply to sizeof(NET_SCADA_DEVICE_ID_INFO)*nMax
}NET_SCADA_DEVICE_LIST;

// monitor spot info 
typedef struct tagNET_SCADA_NOTIFY_POINT_INFO
{
    DWORD                       dwSize; 
    char                        szDevName[DH_COMMON_STRING_64];     // device name , and getInfo Get name identical
    EM_NET_SCADA_POINT_TYPE     emPointType;                        // spot type 
    char                        szPointName[DH_COMMON_STRING_64];   // spot name, and spot chart take value identical
    float                       fValue;                             // value, valid if spot type is YC
    int                         nValue;                             // value, valid if spot type is YX
    char                        szFSUID[DH_COMMON_STRING_64];       // FSUIID(Field Supervision Unit), device itself
    char                        szID[DH_COMMON_STRING_64];          // spot ID
    char                        szSensorID[DH_COMMON_STRING_64];    // sensor ID
    NET_TIME_EX                 stuCollectTime;                     // collect time
} NET_SCADA_NOTIFY_POINT_INFO;

// monitor spot info list
typedef struct tagNET_SCADA_NOTIFY_POINT_INFO_LIST
{
    DWORD                           dwSize;
    int                             nList;                        // monitor spot info number 
    NET_SCADA_NOTIFY_POINT_INFO     stuList[MAX_SCADA_POINT_LIST_INFO_NUM]; // monitor spot info
} NET_SCADA_NOTIFY_POINT_INFO_LIST;

// order monitor spot info  callback prototype
typedef void (CALLBACK *fSCADAAttachInfoCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_SCADA_NOTIFY_POINT_INFO_LIST *pInfo, int nBufLen, LDWORD dwUser);

// CLIENT_SCADAAttachInfo()'s input param
typedef struct tagNET_IN_SCADA_ATTACH_INFO
{
    DWORD                           dwSize;
    fSCADAAttachInfoCallBack        cbCallBack;                 // callback
    EM_NET_SCADA_POINT_TYPE         emPointType;                // spot type
    LDWORD                          dwUser;                     // user's param
} NET_IN_SCADA_ATTACH_INFO;

// CLIENT_SCADAAttachInfo()'s output param
typedef struct tagNET_OUT_SCADA_ATTACH_INFO
{
    DWORD    dwSize;
} NET_OUT_SCADA_ATTACH_INFO;

//////////////////////////////////////////////////////////////////////////
#define MAX_SCADA_ID_NUM                            1024    // max number of spot id

// spot threshold info
typedef struct tagNET_SCADA_ID_THRESHOLD_INFO 
{
    DWORD                   dwSize;
    EM_NET_SCADA_POINT_TYPE emPointType;                // spot type
    char                    szID[DH_COMMON_STRING_32];  // spot ID
    float                   fThreshold;                 // threshold to trigger alarm
    float                   fAbsoluteValue;             // absolute value of threshold
    float                   fRelativeValue;             // relative value of threshold
    int                     nStatus;                    // data state, -1:unknown, 0:normal, 1:alarm level 1, 2:alarm level 2, 3:alarm level 3, 4:alarm level 4, 5:operation event, 6:invalid data
}NET_SCADA_ID_THRESHOLD_INFO;

// CLIENT_SCADAGetThreshold's input param
typedef struct tagNET_IN_SCADA_GET_THRESHOLD 
{
    DWORD           dwSize;
    char            szDeviceID[DH_COMMON_STRING_64];                // device id
    int             nIDs;                                           // valid spot count
    char            szIDs[MAX_SCADA_ID_NUM][DH_COMMON_STRING_32];   // spot IDs to query
}NET_IN_SCADA_GET_THRESHOLD;

// CLIENT_SCADAGetThreshold's output param
typedef struct tagNET_OUT_SCADA_GET_THRESHOLD 
{
    DWORD                           dwSize;
    int                             nMax;               // number user malloced, unit:sizeof(NET_SCADA_ID_THRESHOLD_INFO)
    int                             nRet;               // return number, unit:sizeof(NET_SCADA_ID_THRESHOLD_INFO)
    NET_SCADA_ID_THRESHOLD_INFO*    pstuThresholdInfo;  // spot threshold info, user malloc the memory,apply to sizeof(NET_SCADA_ID_THRESHOLD_INFO)*nMax
}NET_OUT_SCADA_GET_THRESHOLD;

//////////////////////////////////////////////////////////////////////////
// CLIENT_SCADASetThreshold's input param
typedef struct tagNET_IN_SCADA_SET_THRESHOLD 
{
    DWORD                           dwSize;
    char                            szDeviceID[DH_COMMON_STRING_64];// device id
    int                             nMax;               // count of user malloced, unit: sizeof(NET_SCADA_ID_THRESHOLD_INFO)
    NET_SCADA_ID_THRESHOLD_INFO*    pstuThresholdInfo;  // spots threshold info, user malloc the memory,apply to sizeof(NET_SCADA_ID_THRESHOLD_INFO)*nMax
}NET_IN_SCADA_SET_THRESHOLD;

// CLIENT_SCADASetThreshold's output param
typedef struct tagNET_OUT_SCADA_SET_THRESHOLD 
{
    DWORD           dwSize;
    int             nSuccess;                                           // valid count of successfully set id
    char            szSuccessID[MAX_SCADA_ID_NUM][DH_COMMON_STRING_32]; // IDs that set successfully
    int             nFail;                                              // valid count of failed set id
    char            szFailID[MAX_SCADA_ID_NUM][DH_COMMON_STRING_32];    // IDs that set failed
}NET_OUT_SCADA_SET_THRESHOLD;

//////////////////////////////////////////////////////////////////////////
// CLIENT_StartFindSCADA's input param
typedef struct tagNET_IN_SCADA_START_FIND 
{
    DWORD           dwSize;
    NET_TIME        stuStartTime;                   // start time, must provide
    BOOL            bEndTime;                       // to set the end time, TRUE: must provide stuEndTime, FLASE: do not limit the end time
    NET_TIME        stuEndTime;                     // end time
    char            szDeviceID[DH_COMMON_STRING_64];// DeviceID, must provide
    char            szID[DH_COMMON_STRING_32];      // spot ID, must provide
	int				nIDsNum;						// IDs count
	char			szIDs[32][DH_COMMON_STRING_32]; // spot ID, extend
}NET_IN_SCADA_START_FIND;

// CLIENT_StartFindSCADA's output param
typedef struct tagNET_OUT_SCADA_START_FIND 
{
    DWORD           dwSize;
    DWORD           dwTotalCount;                   // total count matching the finding condition
}NET_OUT_SCADA_START_FIND;

// CLIENT_DoFindSCADA's input param
typedef struct tagNET_IN_SCADA_DO_FIND 
{
    DWORD                       dwSize;
    int                         nStartNo;           // start number
    int                         nCount;             // number to query
}NET_IN_SCADA_DO_FIND;

// CLIENT_DoFindSCADA's output param
typedef struct tagNET_OUT_SCADA_DO_FIND 
{
    DWORD                       dwSize;
    int                         nRetNum;            // return number
    NET_SCADA_POINT_BY_ID_INFO* pstuInfo;           // result, user malloc the memroy, apply to sizeof(NET_SCADA_POINT_BY_ID_INFO)*nMaxNum
    int	                        nMaxNum;            // number of user malloced, unit: sizeof(NET_SCADA_POINT_BY_ID_INFO)
}NET_OUT_SCADA_DO_FIND;

// spot alarm event info
typedef struct tagNET_SCADA_NOTIFY_POINT_ALARM_INFO
{
    DWORD           dwSize;
    char            szDevID[DH_COMMON_STRING_16];               // device ID
    char            szPointID[DH_COMMON_STRING_128];            // spot ID
    BOOL            bAlarmFlag;                                 // alarm flag
    NET_TIME        stuAlarmTime;                               // alarm time
    int	            nAlarmLevel;                                // alarm level, 0~6, 
    int             nSerialNo;                                  // alarm number
    char            szAlarmDesc[DH_COMMON_STRING_128];          // alarm descriptioin
} NET_SCADA_NOTIFY_POINT_ALARM_INFO;

// spot alarm event list info
typedef struct tagNET_SCADA_NOTIFY_POINT_ALARM_INFO_LIST
{
    DWORD                               dwSize;
    int	                                nList;                                          // spot alarm event number
    NET_SCADA_NOTIFY_POINT_ALARM_INFO   stuList[MAX_SCADA_POINT_LIST_ALARM_INFO_NUM];   // spot alarm event info
} NET_SCADA_NOTIFY_POINT_ALARM_INFO_LIST;

// spot alarm event info callback prototype
typedef void (CALLBACK *fSCADAAlarmAttachInfoCallBack)(LLONG lAttachHandle, NET_SCADA_NOTIFY_POINT_ALARM_INFO_LIST *pInfo, int nBufLen, LDWORD dwUser);

// CLIENT_SCADAAlarmAttachInfo()'s input param
typedef struct tagNET_IN_SCADA_ALARM_ATTACH_INFO
{
    DWORD                           dwSize;
    fSCADAAlarmAttachInfoCallBack   cbCallBack;                 // callback
    LDWORD                          dwUser;	                    // user's param
} NET_IN_SCADA_ALARM_ATTACH_INFO;

// CLIENT_SCADAAlarmAttachInfo()'s output param
typedef struct tagNET_OUT_SCADA_ALARM_ATTACH_INFO
{
    DWORD                       dwSize;
} NET_OUT_SCADA_ALARM_ATTACH_INFO;

// spot param and value info to be set
typedef struct tagNET_SCADA_POINT_SET_INFO
{
    DWORD                       dwSize;
    EM_NET_SCADA_POINT_TYPE	    emType;                         // spot type, only support YK,YT
    char                        szPointID[DH_COMMON_STRING_64];	// spot ID
    int	                        nSetupVal;                      // value, if emType is YK
    float                       fSetupVal;                      // value, if emType is YT
} NET_SCADA_POINT_SET_INFO;

// set scada spot param and value,CLIENT_SetSCADAInfo()'s input param
typedef struct tagNET_IN_SCADA_POINT_SET_INFO_LIST
{
    DWORD                       dwSize;
    char                        szDevID[DH_COMMON_STRING_32];           // device ID
    int	                        nPointNum;                              // spot number
    NET_SCADA_POINT_SET_INFO    stuList[MAX_SCADA_ID_OF_SENSOR_NUM];    // spot info to set
} NET_IN_SCADA_POINT_SET_INFO_LIST;

// set scada spot param and value,CLIENT_SetSCADAInfo()'s output param
typedef struct tagNET_OUT_SCADA_POINT_SET_INFO_LIST
{
    DWORD                   dwSize;
    int                     nSuccess;                                                       // valid count of spot that set ok
    char                    szSuccessID[MAX_SCADA_ID_OF_SENSOR_NUM][DH_COMMON_STRING_32];   // spot list that set ok
    int                     nFail;                                                          // valid count of spot that set failed
    char                    szFailID[MAX_SCADA_ID_OF_SENSOR_NUM][DH_COMMON_STRING_32];      // spot list that set failed
} NET_OUT_SCADA_POINT_SET_INFO_LIST;


// get current sub system enable status(corresponding DH_DEVSTATE_GET_ALARM_SUBSYSTEM_ACTIVATESTATUS)
typedef struct tagNET_GET_ALARM_SUBSYSTEM_ACTIVATE_STATUES
{
	DWORD				dwSize;
	int					nChannelId;			// sub system no.
	BOOL				bActive;			// sub system enable status, , TRUE  means enable,FALSE means disable
}NET_GET_ALARM_SUBSYSTEM_ACTIVATE_STATUES;

// alarm sub system activation setup parameter(correspondingDH_CTRL_ALARM_SUBSYSTEM_ACTIVE_SET command)
typedef struct tagNET_CTRL_ALARM_SUBSYSTEM_SETACTIVE 
{
	DWORD				dwSize;
	int					nChannelId;			// sub system no.
	BOOL				bActive;			// sub system enable status ,TRUE means enable, FALSE means disable
}NET_CTRL_ALARM_SUBSYSTEM_SETACTIVE;

// Forbid open strobe param(corresponding to  DH_CTRL_FORBID_OPEN_STROBE)
typedef struct tagNET_CTRL_FORBID_OPEN_STROBE
{
    DWORD               dwSize;             
    int                 nChannelID;        // channel no.    
    int                 nTime;             // forbid open gateway duration, unit:s, as after this operation corresponding to time cannot open device gateway 
}NET_CTRL_FORBID_OPEN_STROBE;

#define MAX_PLATENUMBER_LEN    64           // max palte no length
// open gateway parameter(corresponding to DH_CTRL_OPEN_STROBE command)
typedef struct tagNET_CTRL_OPEN_STROBE
{
	DWORD				dwSize;
	int					nChannelId;			                	// channel no., when nChannelId is -1,denotes unused channel no. and single channel device
	char				szPlateNumber[MAX_PLATENUMBER_LEN];		// plate no.
}NET_CTRL_OPEN_STROBE;

// asynchronism open gateway callback function
// nError :0 means query success, 1 means memory application failure, 2 means timeout, 3 means equipment return data validation is not through, 4 means send query request failed
typedef void (CALLBACK *fOpenStrobeCallBack)(LLONG lLoginID, NET_CTRL_OPEN_STROBE stuOpenStrobe, int nError, LDWORD dwUser);


// asynchronism open gateway parameter(corresponding to DH_CTRL_OPEN_STROBE command)
typedef struct tagNET_CTRL_OPEN_STROBE_ASYN
{
    DWORD					dwSize;								// struct size
	NET_CTRL_OPEN_STROBE	stuOpenStrobe;						// open gateway parameter
	fOpenStrobeCallBack		cbCallBack;							// data callback function
	LDWORD					dwUser;								// user data
	int						nWaitTime;							// Wait time
} NET_CTRL_OPEN_STROBE_ASYN;

// close gateway parameter(corresponding to DH_CTRL_CLOSE_STROBE command)
typedef struct tagNET_CTRL_CLOSE_STROBE
{
    DWORD               dwSize;
    int                 nChannelId;                         // channel no.
}NET_CTRL_CLOSE_STROBE;

// Force breaking rule parameter(corresponding to DH_CTRL_FORCE_BREAKING command)
typedef struct tagNET_CTRL_FORCE_BREAKING
{
	DWORD               dwSize;
    int                 nChannelId;                         // channel no.
	int                 nLaneMask;                          // lane mask
	DWORD               dwBreakingType;                     // breaking type, the type of intelligent analysis event in dhnetsdk.h               
}NET_CTRL_FORCE_BREAKING;

// playback refuse listening parameter(corresponding to DH_CTRL_TALKING_REFUSE command)
typedef struct tagNET_CTRL_TALKING_REFUSE 
{
    DWORD           dwSize;
    int             nChannelID;                 // talk channel no.
}NET_CTRL_TALKING_REFUSE;

// the state of remote talk control
typedef enum tagEM_REMOTETALK_CTRL_STATE
{
    EM_REMOTETALK_CTRL_STATE_UNKNOWN = 0,                                // unknown
    EM_REMOTETALK_CTRL_STATE_INVITE,                                     // invite talk
}EM_REMOTETALK_CTRL_STATE;

// the information of remote talk control (corresponding to DH_CTRL_REMOTE_TALK command)
typedef struct tagNET_CTRL_REMOTETALK_PARAM
{
    DWORD                       dwSize;                 // size of this structure
    EM_REMOTETALK_CTRL_STATE    emAction;               // the state of remote talk control
}NET_CTRL_REMOTETALK_PARAM;


// parking reservation status
typedef enum tagEM_NET_ORDER_STATE
{
    EM_NET_ORDER_STATE_UNKNOWN,
    EM_NET_ORDER_STATE_FREE,                            // Free
    EM_NET_ORDER_STATE_ORDERED,                         // Ordered
}EM_NET_ORDER_STATE;

// parking reservation status info
typedef struct tagNET_ORDER_STATE_INFO
{
    DWORD               dwSize;
    unsigned int        nLane;                          // parking no.
    EM_NET_ORDER_STATE  emOrderState;                   // reservation status
}NET_ORDER_STATE_INFO;

// set parking reservation status parameter(corresponding to DH_CTRL_SET_ORDER_STATE command)
typedef struct tagNET_CTRL_SET_ORDER_STATE
{
    DWORD                   dwSize;
    NET_ORDER_STATE_INFO*   pOrderStateInfo;              // parking reservation info,user allocation space,apply to sizeof(NET_ORDER_STATE_INFO)*nStateCount
    unsigned int            nStateCount;                  // valid reservation number
}NET_CTRL_SET_ORDER_STATE;

// Parking lot entrance/exit controller LED roll screen subtitle speed
typedef enum tagNET_ECK_LED_SPEED_TYPE 
{
    NET_ECK_LED_SPEED_UNKNOWN = 0,
    NET_ECK_LED_SPEED_LOW,                              // Slow
    NET_ECK_LED_SPEED_NORMAL,                           // Normal
    NET_ECK_LED_SPEED_HIGH,                             // Fast
}NET_ECK_LED_SPEED_TYPE;

// Parking lot entrance/exit controller LED setup parameter DH_CTRL_ECK_LED_SET
typedef struct tagNET_CTRL_ECK_LED_SET_PARAM 
{
    DWORD                   dwSize;
    NET_ECK_LED_SPEED_TYPE  emLEDSpeed;                 // Subtitle rolling speed
    int                     nCount;                     // Valid display times, range 0-255, 0 means permanent
    char                    szCustomData[DH_COMMON_STRING_512];// LED rolling screen initial characters, 0-256 bytes
}NET_CTRL_ECK_LED_SET_PARAM;

#define NET_MAX_ECK_PANEL_NUM  12                            // the max num of content

//the type of content
typedef enum tagEM_NET_ECK_PANEL_TYPE
{
	EM_NET_ECK_PANEL_TYPE_INTCHAR,                           // integer.char.nlank
	EM_NET_ECK_PANEL_TYPE_IMAGE,                             // image
	EM_NET_ECK_PANEL_TYPE_ARROWS,                            // arrows
}EM_NET_ECK_PANEL_TYPE;

//whether bold
typedef enum tagEM_NET_ECK_PANEL_ISBOLD
{

	EM_NET_ECK_PANEL_ISBOLD_FALSE,                           // not bold
	EM_NET_ECK_PANEL_ISBOLD_TRUE,                            // bold
}EM_NET_ECK_PANEL_ISBOLD;

//color
typedef enum tagEM_NET_ECK_PANEL_COLOR
{
	EM_NET_ECK_PANEL_COLOR_UNKNOWN,                          // unknown
	EM_NET_ECK_PANEL_COLOR_RED,                              // red
	EM_NET_ECK_PANEL_COLOR_GREEN,                            // green 
	EM_NET_ECK_PANEL_COLOR_YELLOW,                           // yellow
}EM_NET_ECK_PANEL_COLOR;

//arrows direction
typedef enum tagEM_NET_ECK_PANEL_DIRECTION
{
	EM_NET_ECK_PANEL_DIRECTION_UNKNOWN,                      // unknown
	EM_NET_ECK_PANEL_DIRECTION_LEFT,                         // left
	EM_NET_ECK_PANEL_DIRECTION_UP,                           // up
	EM_NET_ECK_PANEL_DIRECTION_RIGHT,                        // right
}EM_NET_ECK_PANEL_DIRECTION;

//icon
typedef enum tagEM_NET_ECK_PANEL_ICON
{
	EM_NET_ECK_PANEL_ICON_UNKNOWN,                           // unknown
	EM_NET_ECK_PANEL_ICON_CLOSE,                             // close
}EM_NET_ECK_PANEL_ICON;

//content
typedef struct tagNET_ECK_PANEL_CONTENT
{
	EM_NET_ECK_PANEL_TYPE        emType;                     // the type of content, required
	EM_NET_ECK_PANEL_ISBOLD      emBold;                     // whether bold, required
	EM_NET_ECK_PANEL_COLOR       emColor;                    // color, required
	EM_NET_ECK_PANEL_DIRECTION   emDirection;                // arrows direction, choosable, valid when Type is 2
	EM_NET_ECK_PANEL_ICON        emIcon;                     // icon, choosable, valid when Type is 1
	WORD                         nText;                      // text,only support one char,just Unicode, unsupport chinese character, choosable,valid when Type is 0
	BYTE                         byReserved[1022];            // reserved type   
}NET_ECK_PANEL_CONTENT;

//set guiding panel content(DH_CTRL_ECK_GUIDINGPANEL_CONTENT)
typedef struct tagNET_CTRL_ECK_GUIDINGPANEL_CONTENT 
{
	DWORD                   dwSize;                          // structure size
	int                     nPanelNum;                       // the num of content
	NET_ECK_PANEL_CONTENT   stuContentInfo[NET_MAX_ECK_PANEL_NUM];// content
}NET_CTRL_ECK_GUIDINGPANEL_CONTENT;


// Intelligent parking system entrance/exit device IC card user type
typedef enum tagNET_ECK_IC_CARD_USER_TYPE
{
    NET_ECK_IC_CARD_USER_UNKNOWN,
    NET_ECK_IC_CARD_USER_ALL,                           // all type
    NET_ECK_IC_CARD_USER_TEMP,                          // Temporary user
    NET_ECK_IC_CARD_USER_LONG,                          // Long-term user
    NET_ECK_IC_CARD_USER_ADMIN,                         // admin
    NET_ECK_IC_CARD_USER_BLACK_LIST,                    // black list
}NET_ECK_IC_CARD_USER_TYPE;

//Intelligent parking lot system entrance/exit device abnormal pass car record type
typedef enum tagNET_ECK_CAR_PASS_FLAG
{
    NET_ECK_CAR_PASS_FLAG_NORMAL = 0,                   // Normal
    NET_ECK_CAR_PASS_FLAG_ABNORMAL = 1,                 // Abnormal
    NET_ECK_CAR_PASS_FLAG_ALL,                          // All
} NET_ECK_CAR_PASS_FLAG;

// Intelligent parking system entrance/exit device IC card info
typedef struct tagNET_ECK_IC_CARD 
{
    DWORD                   dwSize;
    DWORD                   dwCard;                     // card no.
    NET_ECK_IC_CARD_USER_TYPE emUserType;               // User type
}NET_ECK_IC_CARD;

#define NET_MAX_ECK_IC_CARD_IMPORT_NUM      50          // Intelligent parking system entrance/exit device max inport IC card quantity

// Intelligent parking system entrance/exit deviceIC card info import parameter DH_CTRL_ECK_IC_CARD_IMPORT
typedef struct tagNET_CTRL_ECK_IC_CARD_IMPORT_PARAM
{
    DWORD               dwSize;
    int                 nCardNum;                       // IC card quantity
    NET_ECK_IC_CARD     stuCardInfo[NET_MAX_ECK_IC_CARD_IMPORT_NUM];// IC card info
}NET_CTRL_ECK_IC_CARD_IMPORT_PARAM;

// Intelligent parking system entrance/exit deviceIC card info sync info parameter DH_CTRL_ECK_SYNC_IC_CARD
typedef struct tagNET_CTRL_ECK_SYNC_IC_CARD_PARAM
{
    DWORD               dwSize;
    int                 nCount;                         // Client IC card info quantity
}NET_CTRL_ECK_SYNC_IC_CARD_PARAM;

#define ECK_SCREEN_NUM_MAX (8)                         // The largest number of screens entrance and exits intelligent parking system 
// Set parking informations on the entrance and exits on the intelligent parking system DH_CTRL_ECK_SET_PARK_INFO
typedef struct tagNET_CTRL_ECK_SET_PARK_INFO_PARAM
{
    DWORD           dwSize;
    int             nScreenNum;                             // Screen numbers, not exceeding  ECK_SCREEN_NUM_MAX
    int             nScreenIndex[ECK_SCREEN_NUM_MAX];       // Screen series , every element means the screen series
    int             nFreeParkNum[ECK_SCREEN_NUM_MAX];       // Corresponding to the free parking number under the screen adminstration
                                                            // The length and the subscript accordance with nScreenIndex, every element means the free parking }NET_CTRL_ECK_SET_PARK_INFO_PARAM;
}NET_CTRL_ECK_SET_PARK_INFO_PARAM;

// fingerprint collection (corresponding to DH_CTRL_CAPTURE_FINGER_PRINT command )
typedef struct tagNET_CTRL_CAPTURE_FINGER_PRINT 
{
    DWORD      dwSize;
    int        nChannelID;                      // access control no.(start from 0)
    char       szReaderID[DH_COMMON_STRING_32]; // card reader ID
}NET_CTRL_CAPTURE_FINGER_PRINT;

typedef enum tagEM_ACCESS_PASSWORD_TYPE
{
    EM_ACCESS_PASSWORD_OPENDOOR=1,                 // open door password
    EM_ACCESS_PASSWORD_ALARM,                      // alarm password
}EM_ACCESS_PASSWORD_TYPE;

// reset password (corresponding to DH_CTRL_ACCESS_RESET_PASSWORD of CLIENT_ControlDevice)
typedef struct tagNET_CTRL_ACCESS_RESET_PASSWORD 
{
    DWORD                           dwSize;                                 // struct size
    int                             nChannelID;                             // access control No.(start from 0)
    EM_ACCESS_PASSWORD_TYPE         emType;                                 // password type
    char                            szUserID[MAX_COMMON_STRING_32];         // user ID
    char                            szNewPassword[MAX_COMMON_STRING_32];    // new password
}NET_CTRL_ACCESS_RESET_PASSWORD;

// call lift command
typedef enum tagEM_CALLLIFT_CMD
{
    EM_CALLLIFT_CMD_UNKNOWN =-1,      // unknown
    EM_CALLLIFT_CMD_ANY_FLOOR = 0,    // call lift to one floor and open any other floors 
    EM_CALLLIFT_CMD_DEST_FLOOR,       // call lift to one floor, user can only enter dest floor
    EM_CALLLIFT_CMD_CARD_UP,          // call lift to one floor, need to swipe card, default lift running up
    EM_CALLLIFT_CMD_AUTO_FLOOR,       // call lift to one floor, not need to press button, lift will automatically run to dest floor
    EM_CALLLIFT_CMD_CARD_DOWN,        // call lift to one floor, need to swipe card, default lift running down
}EM_CALLLIFT_CMD;

// call lift action
typedef enum tagEM_CALLLIFT_ACTION
{
    EM_CALLLIFT_ACTION_UNKNOWN =-1,            // unknown
    EM_CALLLIFT_ACTION_USER_UNLOCK_CALL = 0,   // user opens unit door lock through intercom and calls lift to the unit door
    EM_CALLLIFT_ACTION_USER_DIRECT_CALL,       // user calls lift directly to his floor
    EM_CALLLIFT_ACTION_USER_REDIRECT_CALL,     // user calls lift from one floor to another
    EM_CALLLIFT_ACTION_DIRECT_UNLOCK_CALL,     // user opens unit door lock directly and calls lift to the unit door
}EM_CALLLIFT_ACTION;

// access control - call lift(corresponding to DH_CTRL_ACCESS_CALL_LIFT of CLIENT_ControlDevice)
typedef struct tagNET_CTRL_ACCESS_CALL_LIFT
{
    DWORD				    dwSize;
    int                     nChannelID;                          // channel ID
    char                    szSrcFloor[MAX_COMMON_STRING_16];    // source floor(floor number+room number)
    char                    szDestFloor[MAX_COMMON_STRING_16];   // dest floor(floor number+room number)
    EM_CALLLIFT_CMD         emCallLiftCmd;                       // call lift command
    EM_CALLLIFT_ACTION      emCallLiftAction;                    // call lift action  
	char					szUserID[16];						 // User ID
}NET_CTRL_ACCESS_CALL_LIFT;

// Hang up video phone(Corresponding DH_CTRL_VTP_DISCONNECT)
typedef struct tagNET_CTRL_VTP_DISCONNECT 
{
    DWORD                   dwSize;
    const char*             szTargetID;                     // The device ID to be forward , NULL means don't forward
    EM_NET_VTP_CALL_TYPE    emCallType;                     // Call type
    char                    szCallID[DH_COMMON_STRING_128]; // Intercom unique identifier}NET_CTRL_VTP_DISCONNECT;
}NET_CTRL_VTP_DISCONNECT;

// client(video talk phone) ack type
typedef enum tagNET_EM_VTP_ACK
{
    NET_EM_VTP_OK,                              // client calls right after get the event
    NET_EM_VTP_BUSY,                            // client busy, do not call
}NET_EM_VTP_ACK;

// client(video talk phone) divert ack
typedef struct tagNET_CTRL_VTP_DIVERTACK
{
    DWORD                   dwSize;
    EM_NET_VTP_CALL_TYPE    emCallType;                     // Calling type to query
    const char*             szCallID;                       // Unique ID for calling
    NET_EM_VTP_ACK          emAck;                          // Client's ack
}NET_CTRL_VTP_DIVERTACK;

// The operation model of remote multimedia files
typedef enum tagNET_EM_SPEAK_FILE_ACTION
{
    NET_EM_SPEAK_FILE_ACTION_UPDATE = 0,                    // Update the original file
    NET_EM_SPEAK_FILE_ACTION_ADD,                           // Added files
    NET_EM_SPEAK_FILE_ACTION_DEL,                           // Delete files
}NET_EM_SPEAK_FILE_ACTION;

// The operation informations of the remote multimedia files 
typedef struct tagNET_SPEAK_FILE_INFO
{
    DWORD                       dwSize;
    char                        szFilePath[MAX_PATH];       // File path, use the address setted up by CFG_CMD_NASEX firstly    NET_EM_SPEAK_FILE_ACTION    emAction;                   // Operation type, operation for the files appointed by szFilePath 
    NET_EM_SPEAK_FILE_ACTION    emAction;                   // The operation model of remote multimedia files
    BOOL                        bSave;                      // Whether update or save the files in local device 
}NET_SPEAK_FILE_INFO;

#define MAX_SPEAK_FILE_NUM      32                          // The max number of the files for remote

// Update the files for remote
typedef struct tagNET_CTRL_UPDATE_FILES
{
    DWORD                   dwSize;
    DWORD                   dwFileNum;                      // The valid file number
    NET_SPEAK_FILE_INFO     stuFileInfo[MAX_SPEAK_FILE_NUM];// The multimedia file information
}NET_CTRL_UPDATE_FILES;


// (corresponding to DH_CTRL_RAINBRUSH_MOVEONCE)
typedef struct tagNET_CTRL_RAINBRUSH_MOVEONCE
{
    DWORD           dwSize;
    int             nChannel;       // Rain-brush channel
}NET_CTRL_RAINBRUSH_MOVEONCE;

// (corresponding to DH_CTRL_RAINBRUSH_MOVECONTINUOUSLY)
typedef struct tagNET_CTRL_RAINBRUSH_MOVECONTINUOUSLY
{
    DWORD           dwSize;
    int             nChannel;       // Rain-brush channel
    unsigned int    nInterval;      // Interval
}NET_CTRL_RAINBRUSH_MOVECONTINUOUSLY;

// (corresponding to DH_CTRL_RAINBRUSH_STOPMOVE)
typedef struct tagNET_CTRL_RAINBRUSH_STOPMOVE
{
    DWORD           dwSize;
    int             nChannel;       // Rain-brush channel
}NET_CTRL_RAINBRUSH_STOPMOVE;

// (corresponding to DH_CTRL_ALARM_ACK)
typedef struct tagNET_CTRL_ALARM_ACK
{
    DWORD                   dwSize;
    int                     nEventID;   // Event ID
}NET_CTRL_ALARM_ACK;

// video talk peer invite ack type
typedef enum tagNET_EM_VTP_INVITEACK_TYPE
{
    NET_EM_VTP_INVITEACK_TYPE_UNKNOWN = 0,               // unknown
    NET_EM_VTP_INVITEACK_TYPE_BUSY                       // busy type
}NET_EM_VTP_INVITEACK_TYPE;

// video talk peer invite ack
typedef struct tagNET_CTRL_VTP_INVITEACK
{
    DWORD                         dwSize;
    int                           nChnId;               // Channel No. It is to mark bidirectional talk unit. 
    NET_EM_VTP_INVITEACK_TYPE     emAck;                // after the client receives the Invite event,notify its status to device
}NET_CTRL_VTP_INVITEACK;

////////////////////////////////system task subscription//////////////////////////////////////////
// zone status
typedef struct __NET_PARTITION_STATE
{
    DWORD             dwSize;
    int               nStatus;                  // zone status, 0-normal, 1-error 
    double            dbTotalSize;              // zone total capacity, byte is unit
    double            dbRemainSize;             // free capacity, byte is unit
    
}NET_PARTITION_STATE;

// HDD status
typedef struct __NET_HDD_STATE
{
    DWORD             dwSize; 
    int               nState;                   // HDD status, 0-normal, 1-error   
    double            dbTotalSize;              // HDD total capacity, byte is unit
    NET_PARTITION_STATE stuPartitions[DH_MAX_STORAGE_PARTITION_NUM]; // zone status
    int               nPartitionNum;              // zone quantity
}NET_HDD_STATE;

// channel status
typedef struct __NET_CHANNLE_STATE
{
    DWORD             dwSize;
    BYTE              byRecState;               // record status, 1-record, 0-close
    BYTE              byVideoInState;           // video input status, 1-video in, 0-no video  
    BYTE              byReserved[2];            // text align
}NET_CHANNLE_STATE;

// PAD/DVR connection state type
typedef enum tagNET_PAD_CONNECT_STATE
{
    NET_PAD_CONNECT_STATE_UNKNOWN,             // unknown
    NET_PAD_CONNECT_STATE_UNCONNECTED,         // unconnected
    NET_PAD_CONNECT_STATE_CONNECTED,           // connected
} NET_PAD_CONNECT_STATE;

// Home key state
typedef enum tagNET_HOME_STATE
{
    NET_HOME_STATE_UNKNOWN,                    // unknown
    NET_HOME_STATE_UNPRESSED,                  // unpressed
    NET_HOME_STATE_PRESSED,                    // pressed
} NET_HOME_STATE;

// device self-check info
typedef struct __NET_SELFCHECK_INFO
{
    DWORD             dwSize;
    int               nAlarmIn;                 // alarm input channel number
    int               nAlarmOut;                // alarm output channel number  
    NET_TIME          stuTime;                  // report time
    char              szPlateNo[DH_MAX_PLATE_NUMBER_LEN]; // plate
    char              szICCID[DH_MAX_SIM_LEN];  // SIM card no.
    BYTE              byOrientation;            // position status, 0-not position, 1-position 
    BYTE              byACCState;               // ACC status, 0-close, 1-open
    BYTE              byConstantElecState;      // power on, 0-normal, 1-disconnect, 2-less pressure, 3-over pressure
    BYTE              byAntennaState;           // channel signal status, 0-normal, 1-unknown failure, 2-disaonnect, 3-short circuit
    
    // external device status
    BYTE              byReportStation;          // station announcer status, 0-disconnect, 1-normal, 2-abnormal
    BYTE              byControlScreen;          // dispatch status, 0-disconnect, 1-normal, 2-abnormal
    BYTE              byPOS;                    // POS status, 0-disconnect, 1-normal, 2-abnormal
    BYTE              byCoinBox;                // box status, 0-disconnect, 1-normal, 2-abnormal
    
    // capacity set
    BOOL              bTimerSnap;               // schedule snapshot, TRUE-support, FALSE-not support
    BOOL              bElectronEnclosure;       // e-fence, TRUE-support, FALSE-not support
    BOOL              bTeleUpgrade;             // remote upgrade, TRUE-support, FALSE-not support   
    
    NET_HDD_STATE     stuHddStates[DH_MAX_DISKNUM]; //HDD status
    int               nHddNum;                  // HDD quantity
    
    NET_CHANNLE_STATE* pChannleState;           // CLIENT_AttachMission interface,channel status, is a group,  memoryis applied by sdk internally, released by sdk intenally
												// CLIENT_GetSelfCheckInfo interface,output param,memory is applied by the user,apply to sizeof(NET_CHANNLE_STATE)*nChannelMax
	int               nChannleNum;              // channel quantity
    int               nChannelMax;              // pChannleState max counts mallcoed by caller
    NET_PAD_CONNECT_STATE         emConnState;  // PAD/DVR connection state
    NET_HOME_STATE                emHomeState;  // Home key state
	char              szICCIDExInfo[DH_COMMON_STRING_256];  // Extend SIM card no.
	BYTE              by3GState;                // 3G/4G State, 0-disconnect, 1-connect, 2-module not find
	BYTE              byWifiState;              // Wifi State, 0-disconnect, 1-connect, 2-module not find
	BYTE              byGpsState;               // Gps State, 0-disconnect, 1-connect, 2-module not find
	BYTE              byBlackBoxState;          // BlackBox State, 0-disconnect, 1-normal
	int               nCpuUsage;                // CPU Usage, percent
	int               nTemperature;             // Device inner temperature, Celsius
}NET_SELFCHECK_INFO;

typedef void (CALLBACK *fMissionInfoCallBack)(LLONG lAttachHandle, DWORD dwType, void* pMissionInfo, void* pReserved, LDWORD dwUserData);

typedef enum EM_MISSION_TYPE
{
    NET_MISSION_TYPE_UNKOWN,                    // unknown
    NET_MISSION_TYPE_SELFCHECK,                 // device self-check, corresponding structure  NET_SELFCHECK_INFO
}EM_MISSION_TYPE;

//CLIENT_AttachMissionport input parameter
typedef struct __NET_IN_ATTACH_MISSION_PARAM
{
    DWORD             dwSize;
    EM_MISSION_TYPE   emMissionType;            // task type
    fMissionInfoCallBack cbMissionInfofunc;     // task info callback function
    LDWORD            dwUser;                   // user data 
}NET_IN_ATTACH_MISSION_PARAM;

// CLIENT_DetachMissionport output parameter
typedef struct NET_OUT_ATTACH_MISSION_PARAM
{
    DWORD             dwSize;
    LLONG             lAttachHandle;           // subscribe handle
}NET_OUT_ATTACH_MISSION_PARAM;

#define MAX_EVENT_TO_CONFIRM_NUM    8    // max to confirm event number 

//to confirm event info 
typedef struct tagNET_EVENT_INFO_TO_CONFIRM 
{
    DWORD           dwSize;
    DWORD           dwEventType;        // event type , corresponding to CLIENT_AttachBusStateport event type 
    NET_TIME        stuTime;            // event time, UTC
    LONG            lTime;              // event time, UTC, unit is second
}NET_EVENT_INFO_TO_CONFIRM;

// vehicle emergency alarm confirm input parameter 
typedef struct tagNET_IN_BUS_CONFIRM_EVENT 
{
    DWORD           dwSize;
    int             nEvent;             // to confirm event valid quantity
    NET_EVENT_INFO_TO_CONFIRM  stuEventInfo[MAX_EVENT_TO_CONFIRM_NUM];// to confirm event info 
}NET_IN_BUS_CONFIRM_EVENT;

// vehicle emergency alarm confirm  output parameter 
typedef struct tagNET_OUT_BUS_CONFIRM_EVENT 
{
    DWORD           dwSize;
}NET_OUT_BUS_CONFIRM_EVENT;

// CLIENT_SetDevicePosition interface parameter input 
typedef struct tagNET_IN_SET_DEVICE_POSITION
{
    DWORD                   dwSize;                             // Struture size. Must fill in when initialization 
    char                    szPosition[DH_COMMON_STRING_512];   // Address info 
}NET_IN_SET_DEVICE_POSITION;

// CLIENT_SetDevicePosition interface paramter output
typedef struct tagNET_OUT_SET_DEVICE_POSITION
{
    DWORD                   dwSize;                             // Structure size. Must fill in when initialization
}NET_OUT_SET_DEVICE_POSITION;

// CLIENT_GetDevicePosition interface paramter input
typedef struct tagNET_IN_GET_DEVICE_POSITION
{
    DWORD                   dwSize;                             // Structure size. Must fill in when initialization
}NET_IN_GET_DEVICE_POSITION;

// CLIENT_GetDevicePosition interface paramter output
typedef struct tagNET_OUT_GET_DEVICE_POSITION
{
    DWORD                   dwSize;                             // Structure size. Must fill in when initialization
    char                    szPosition[DH_COMMON_STRING_512];   // Address info 
}NET_OUT_GET_DEVICE_POSITION;

// CLIENT_SnapPictureByEvent interface paramter input
typedef struct tagNET_IN_SNAP_BY_EVENT 
{
    DWORD                   dwSize;                             // Struture size. Must fill in when initialization
    int                     nChannel;                           // Video channel No. Begins with 0. 
    DWORD                   dwEventID;                          // Refer to event type of CLIENT_RealLoadPicEx
}NET_IN_SNAP_BY_EVENT;

// CLIENT_SnapPictureByEvent interface paramter output
typedef struct tagNET_OUT_SNAP_BY_EVENT 
{
    DWORD                   dwSize;                             // Struture size. Must fill in when initialization
}NET_OUT_SNAP_BY_EVENT;
// CLIENT_StartQueryLog input parameter
typedef struct tagNET_IN_START_QUERYLOG
{
    DWORD               dwSize;
} NET_IN_START_QUERYLOG;

// CLIENT_StartQueryLog ouput parameter
typedef struct tagNET_OUT_START_QUERYLOG
{
    DWORD               dwSize;
}NET_OUT_START_QUERYLOG;

// Detail info of log
typedef struct tagNET_LOG_MESSAGE
{
    DWORD               dwSize;
    char				szLogMessage[DH_COMMON_STRING_1024];    // detailed info
} NET_LOG_MESSAGE;

// Info of log
typedef struct tagNET_LOG_INFO
{
    DWORD               dwSize;
    NET_TIME            stuTime;                        // time 
    char                szUserName[DH_COMMON_STRING_32];// operator
    char                szLogType[DH_COMMON_STRING_128];// type
    NET_LOG_MESSAGE	    stuLogMsg;                      // detailed info
} NET_LOG_INFO;

// CLIENT_QueryNextLog input parameter
typedef struct tagNET_IN_QUERYNEXTLOG
{
    DWORD               dwSize;
    int                 nGetCount;      // count of log item try to query
}NET_IN_QUERYNEXTLOG;

// CLIENT_QueryNextLog ouput parameter
typedef struct tagNET_OUT_QUERYNEXTLOG
{
    DWORD               dwSize;
    int                 nMaxCount;      // count of log item malloced by user, should be NET_IN_GETNEXTLOG*nGetCount
    NET_LOG_INFO*       pstuLogInfo;    // buffer for log item malloced by user, should be nMaxCount*sizeof(NET_LOG_INFO)
    int                 nRetCount;      // return count of log item
}NET_OUT_QUERYNEXTLOG;

// Asynchronous callback function registered equipment prototype (when nError back to 11, reserved fields reserved for int type parameters and used to invoke the CLIENT_StartLoginEx landed the port)
typedef void (CALLBACK *fHaveLogin)(LLONG lLoginID, char *pchDVRIP, LONG nDVRPort, BOOL bOnline, NET_DEVICEINFO_Ex stuDeviceInfo, int nError, LDWORD dwUser, void *reserved);

// CLIENT_StartLoginEx  input parameter
typedef struct tagNET_IN_STARTLOGINEX 
{
    DWORD               dwSize;
    const char*         szIp;           // device ip
    DWORD               dwPort;         // login port
    const char*         szName;         // username
    const char*         szPwd;          // password
    fHaveLogin          cbLogin;        // login result call
    LDWORD              dwUser;         // call user parameter
}NET_IN_STARTLOGINEX;

// CLIENT_StartLoginEx output parameter
typedef struct tagNET_OUT_STARTLOGINEX 
{
    DWORD       dwSize;
}NET_OUT_STARTLOGINEX;

// the protocol type of device
typedef enum tagEM_DEV_PROTOCOL_TYPE
{
	EM_DEV_PROTOCOL_UNKNOWN,			// unknown
	EM_DEV_PROTOCOL_V2,					// private v2
	EM_DEV_PROTOCOL_V3,					// private v3
	EM_DEV_PROTOCOL_ONVIF,				// onvif
	EM_DEV_PROTOCOL_GENERAL,			// general
	EM_DEV_PROTOCOL_GB28181,			// GB28181
	EM_DEV_PROTOCOL_EHOME,				// ehome
	EM_DEV_PROTOCOL_HIKVISION,          // HIKVISION
	EM_DEV_PROTOCOL_BSCP,				// BSCP
} EM_DEV_PROTOCOL_TYPE;

// video splicing operation type
typedef enum tagNET_VIDEOJOIN_OPERATE_TYPE
{
    NET_VIDEOJOIN_GET_STATUS,               // get splicing status, corresponding to  NET_IN_VIDEOJOIN_GET_STATUS and NET_OUT_VIDEOJOIN_GET_STATUS
    NET_VIDEOJOIN_GET_CALIBRATE_POINTS,     // get calibrate point , corresponding to  tagNET_IN_VIDEOJOIN_GET_CALIBRATE_POINTS and  tagNET_OUT_VIDEOJOIN_GET_CALIBRATE_POINTS
    NET_VIDEOJOIN_CALIBRATE,                // mark ,  corresponding to  NET_IN_VIDEOJOIN_CALIBRATE and NET_OUT_VIDEOJOIN_CALIBRATE
}NET_VIDEOJOIN_OPERATE_TYPE;

// video splicing status
typedef enum tagNET_VIDEOJOIN_STATUS
{
    NET_VIDEOJOIN_STATUS_UNKNOWN,               // unknow
    NET_VIDEOJOIN_STATUS_NOTSTART,              // not started
    NET_VIDEOJOIN_STATUS_DOING,                 // running
    NET_VIDEOJOIN_STATUS_FINISH,                // complate
}NET_VIDEOJOIN_STATUS;

// video splicing mark mode
typedef enum tagNET_VIDEOJOIN_MODE
{
    NET_VIDEOJOIN_MODE_UNKNOWN,                 // unknow
    NET_VIDEOJOIN_MODE_AUTO,                    // auto
    NET_VIDEOJOIN_MODE_MANUAL,                  // manual
}NET_VIDEOJOIN_MODE;

// CLIENT_OperateVideoJoin input parameter, corresponding to NET_VIDEOJOIN_GET_STATUS
typedef struct tagNET_IN_VIDEOJOIN_GET_STATUS
{
    DWORD           dwSize;
}NET_IN_VIDEOJOIN_GET_STATUS;

// CLIENT_OperateVideoJoin output parameter, corresponding to NET_VIDEOJOIN_GET_STATUS
typedef struct tagNET_OUT_VIDEOJOIN_GET_STATUS
{
    DWORD           dwSize;
    NET_VIDEOJOIN_STATUS emStatus;              // splicing status
}NET_OUT_VIDEOJOIN_GET_STATUS;

// camera mark pair, means one pair of marks
typedef struct tagNET_POINT_PAIR 
{
    DH_POINT        stuPoints[POINT_NUM_IN_PAIR];           // camera mark
}NET_POINT_PAIR;

// video splicing mark group, each group means two channels and multiple mark pairs
typedef struct tagNET_VIDEOJOIN_POINT_GROUP
{
    DWORD           dwSize;
    int             nPointPairNum;                          // mark quantity
    NET_POINT_PAIR  stuPointPairs[MAX_POINT_PAIR_NUM];      // mark
    int             nChannels[CHANNEL_NUM_IN_POINT_GROUP];  // video channel no., via data mark to correspond , mark 0 channel corresponding to NET_POINT_PAIR mark 0 point
}NET_VIDEOJOIN_POINT_GROUP;

// CLIENT_OperateVideoJoin input parameter, corresponding to NET_VIDEOJOIN_GET_CALIBRATE_POINTS
typedef struct tagNET_IN_VIDEOJOIN_GET_CALIBRATE_POINTS
{
    DWORD           dwSize;
}NET_IN_VIDEOJOIN_GET_CALIBRATE_POINTS;

// CLIENT_OperateVideoJoin output parameter, corresponding to NET_VIDEOJOIN_GET_CALIBRATE_POINTS
typedef struct tagNET_OUT_VIDEOJOIN_GET_CALIBRATE_POINTS
{
    DWORD               dwSize;
    NET_VIDEOJOIN_MODE  emMode;                                 // mark mode
    int                 nPointGroupNum;                         // mark point quantity
    NET_VIDEOJOIN_POINT_GROUP stuPointGroups[MAX_POINT_GROUP_NUM]; // mark pointgroup, under manual mode is valid
}NET_OUT_VIDEOJOIN_GET_CALIBRATE_POINTS;

// CLIENT_OperateVideoJoin input parameter, corresponding to NET_VIDEOJOIN_CALIBRATE
typedef struct tagNET_IN_VIDEOJOIN_CALIBRATE
{
    DWORD               dwSize;
    NET_VIDEOJOIN_MODE  emMode;                                 // mark mode
    int                 nPointGroupNum;                         // mark point group quantity
    NET_VIDEOJOIN_POINT_GROUP stuPointGroups[MAX_POINT_GROUP_NUM]; // mark pointgroup, manual mode valid
}NET_IN_VIDEOJOIN_CALIBRATE;

// CLIENT_OperateVideoJoin output mode, corresponding to NET_VIDEOJOIN_CALIBRATE
typedef struct tagNET_OUT_VIDEOJOIN_CALIBRATE
{
    DWORD           dwSize;
}NET_OUT_VIDEOJOIN_CALIBRATE;

// Get screen window info input parameter , corresponding to NET_SPLIT_OPERATE_GET_SCENE
typedef struct tagNET_IN_SPLIT_GET_SCENE 
{
    DWORD           dwSize;
    int             nChannel;               // output channel no. or cubeless video wall virtual channel no., pszCompositeIDis NULL, it is valid 
    const char*     pszCompositeID;         // cubeless video wall ID
}NET_IN_SPLIT_GET_SCENE;

// Get  screen window info  output parameter , corresponding to NET_SPLIT_OPERATE_GET_SCENE
typedef struct tagNET_OUT_SPLIT_GET_SCENE 
{
    DWORD           dwSize;
    DH_SPLIT_SCENE  stuScene;               // window info 
}NET_OUT_SPLIT_GET_SCENE;

// tv wall tour status 
typedef enum tagEM_NET_WM_TOUR_STATUS
{
    EM_NET_WM_TOUR_STATUS_UNKNOWN,          // unknown 
    EM_NET_WM_TOUR_STATUS_START,            // touring
    EM_NET_WM_TOUR_STATUS_STOP,             // tour stop
} EM_NET_WM_TOUR_STATUS;

// tv wall scheme tour status info 
typedef struct tagNET_WM_TOUR_STATUS_INFO 
{
    DWORD          dwSize;
    EM_NET_WM_TOUR_STATUS  emStatus;        // tour status 
    DH_MONITORWALL_SCENE  stuScene;         // scheme info 
} NET_WM_TOUR_STATUS_INFO;

// tv wall scheme tour status call function origin, lAttachHandle is CLIENT_MonitorWallAttachTour return value 
typedef void (CALLBACK *fMonitorWallTourStatusCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_WM_TOUR_STATUS_INFO* pstStatus, void* reserved, LDWORD dwUser);

// CLIENT_MonitorWallAttachTour port input parameter 
typedef struct tagNET_IN_WM_ATTACH_TOUR 
{
    DWORD       dwSize;
    int       	nMonitorWallID;             // tv wall ID
    fMonitorWallTourStatusCallBack cbStatus;// tour status  call function 
    LDWORD     	dwUser;                     // tour status call parameter 
} NET_IN_WM_ATTACH_TOUR;

// CLIENT_MonitorWallAttachTour port  output parameter 
typedef struct tagNET_OUT_WM_ATTACH_TOUR 
{
    DWORD      dwSize;
} NET_OUT_WM_ATTACH_TOUR;

// CLIENT_SnapManagerConfirmUpload port input parameter
typedef struct tagNET_IN_SNAP_MANAGER_CONFIRM_UPLOAD
{
    DWORD           dwSize;
    char            szFilePath[DH_COMMON_STRING_256];       // File path, used for SN of picture
    BOOL            bResult;                                // If picture upload is complete
}NET_IN_SNAP_MANAGER_CONFIRM_UPLOAD;

// CLIENT_SnapManagerConfirmUpload port output parameter
typedef struct tagNET_OUT_SNAP_MANAGER_CONFIRM_UPLOAD
{
    DWORD           dwSize;
}NET_OUT_SNAP_MANAGER_CONFIRM_UPLOAD;

// Video phone status informations
typedef struct tagNET_VTP_CALL_STATE_INFO 
{
    DWORD                       dwSize;
    char                        szNumber[DH_COMMON_STRING_128]; // Call number
    char                        szCallID[DH_COMMON_STRING_128]; // Intercom unique identifier
    EM_NET_VTP_CALL_STATE_TYPE  emCallState;                    // Call status
}NET_VTP_CALL_STATE_INFO;

// The callback function prototypes of subscribe to video phone
typedef void (CALLBACK *fVTPCallStateCallBack)(LLONG lAttachHandle, NET_VTP_CALL_STATE_INFO *pInfo, int nBufLen, LDWORD dwUser);

// Input parameter about the status informations of subscribe to video phone
typedef struct tagNET_IN_VTP_CALL_STATE_ATTACH 
{
    DWORD                       dwSize;
    EM_NET_VTP_CALL_TYPE        emCallType;                     // The call type for checking
    fVTPCallStateCallBack       cbCallState;                    // The callback function
    LDWORD                      dwUser;                         // user's param
    const char*                 szTargetID;                     // The device ID for forward, NULL means not formard
}NET_IN_VTP_CALL_STATE_ATTACH;

// The output parameter of the status information of subscribes to video phone
typedef struct tagNET_OUT_VTP_CALL_STATE_ATTACH 
{
    DWORD                       dwSize;
}NET_OUT_VTP_CALL_STATE_ATTACH;


//////////////////////////////////////////////////////////////////////////
// ABILITY INFO
//////////////////////////////////////////////////////////////////////////

// Check the buses route CLIENT_CheckBusLine()input parameter
typedef struct tagNET_IN_CHECK_BUS_LINE 
{
    DWORD           dwSize;
    char            szLineID[DH_COMMON_STRING_32];          // Line marking
    char            szDesignation[DH_COMMON_STRING_32];     // Line serial number
    NET_LINE_DIRECTION  emDirection;                        // Line direction
    int             nSiteCount;                             // The total stations number on the route
    char            szDirectionName[DH_COMMON_STRING_32];   // Name of the line firection
    char            szVersion[DH_COMMON_STRING_32];         // Line version number
}NET_IN_CHECK_BUS_LINE;


// The status type of the bus line whether to update
typedef enum tagNET_BUS_LINE_UPDATE_TYPE
{
    NET_BUS_LINE_UPDATE_UNKNOWN = 0,
    NET_BUS_LINE_UPDATE_UPDATED,                            // Need update
    NET_BUS_LINE_UPDATE_NOT_UPDATED,                        // Not update
}NET_BUS_LINE_UPDATE_TYPE;

// Check the bus routeCLIENT_CheckBusLine()output parameter
typedef struct tagNET_OUT_CHECK_BUS_LINE
{
    DWORD           dwSize;
    char            szDeviceID[DH_COMMON_STRING_32];        // device ID
    char            szLineID[DH_COMMON_STRING_32];          // Line marking
    NET_BUS_LINE_UPDATE_TYPE emUpdate;                      // Indicator for whether need to update the status
}NET_OUT_CHECK_BUS_LINE;
#define MAX_SITE_GPS_POINT_NUM                      64      // Describe the bus stops the largest GPS point

// The shape type of the bus station
typedef enum tagNET_SITE_AREA_TYPE
{
    NET_SITE_AREA_ENCLOSURE = 0,                            // Type of the fence
    NET_SITE_AREA_CIRCLE,                                   // Circular
}NET_SITE_AREA_TYPE;

//  Inflection Point Information of Corresponding Lines
typedef struct tagNET_FLEXION_INFO
{
	int				nLimitDistance;							// Judging the Limited Distance of Line Offsetunitm
	int				nPointArrayNum;							// Inflection point Num
	GPS_POINT		stuPoint[MAX_SITE_GPS_POINT_NUM];		// Inflection point 
	BYTE			byReserved[1024];						// Reserved
}NET_FLEXION_INFO;

// Inflection Point Information of Corresponding Lines
typedef struct tagNET_BUS_SITE_INFO
{
    DWORD           dwSize;
    char            szLineID[DH_COMMON_STRING_32];          // Line marking
    int             nSiteCount;                             // Total number of the stations
    NET_LINE_DIRECTION  emDirection;                        // Line direction, Don't allow to fill NET_LINE_DIRECTION_UNKNOWN
    int             nStopSequence;                          // Station serial number
    char            szSiteID[DH_COMMON_STRING_32];          // Station ID
    char            szSiteName[DH_COMMON_STRING_32];        // Station name, you can use szSiteNameEx to input a longer name
    NET_SITE_AREA_TYPE emAreaType;                          // Station type
    int             nGPSPointNum;                           // valid GPS points number
    GPS_POINT       stuPoint[MAX_SITE_GPS_POINT_NUM];       // Station GPS information
    int             nRadius;                                // Radius of the station, unit: meter, valid only for the circulai
    int             nSpeedLimit;                            // Station speed limit, unit: km/H
    int             nDriveTime;                             // Time for the last station to current, unit:minute
    int             nTicketPrice;                           // Filp fares
    DH_TSECT        stuPowerSchedule[DH_TSCHE_DAY_NUM][DH_TSCHE_SEC_NUM]; // Time table, The first dimension of each element means ~ on Saturday and Sunday ,holidays
    char            szDesignation[DH_COMMON_STRING_64];     // Line serial number
    char            szDirectionName[DH_COMMON_STRING_64];   // Line direction name
    char            szVersion[DH_COMMON_STRING_32];
    BOOL            bUseExName;                             // Use new site name flag
    char            szSiteNameEx[DH_COMMON_STRING_128];     // site name with 128 bytes
	NET_FLEXION_INFO	stuInflexionInfos;					// Inflection Point Information of Corresponding Lines
}NET_BUS_SITE_INFO;

#define MAX_BUS_STOP_NUM                            32      // The max number of  the stations in a bus line

// Issue bus line CLIENT_DispatchBusLineInfo()Interface input parameters
typedef struct tagNET_IN_DISPATCH_BUS_LINE_INFO 
{
    DWORD           dwSize;
    int             nBusStopNum;                            // The number of bus line stations
    NET_BUS_SITE_INFO   stuStopInfo[MAX_BUS_STOP_NUM];      // The information of the bus line
}NET_IN_DISPATCH_BUS_LINE_INFO;

// Issue bus line  CLIENT_DispatchBusLineInfo()Interface output parameters
typedef struct tagNET_OUT_DISPATCH_BUS_LINE_INFO 
{
    DWORD           dwSize;
}NET_OUT_DISPATCH_BUS_LINE_INFO;

// Issue bus line CLIENT_DispatchBusLineInfoEx()Interface input parameters
typedef struct tagNET_IN_DISPATCH_BUS_LINE_INFO_EX 
{
	DWORD				dwSize;
	int					nBusStopNum;                            // The number of bus line stations
	NET_BUS_SITE_INFO   *pstuStopInfo;							// The information of the bus line,memory is applied by the user,apply to sizeof(NET_BUS_SITE_INFO)*nBusStopNum
}NET_IN_DISPATCH_BUS_LINE_INFO_EX;

// Issue bus line  CLIENT_DispatchBusLineInfoEx()Interface output parameters
typedef struct tagNET_OUT_DISPATCH_BUS_LINE_INFO_EX 
{
	DWORD           dwSize;
}NET_OUT_DISPATCH_BUS_LINE_INFO_EX;

// Vehicle operation dispatching CLIENT_BusSchedule()Interface input parameters
typedef struct tagNET_IN_BUS_SCHEDULE_INFO 
{
    DWORD               dwSize;
    char                szLineID[DH_COMMON_STRING_64];      // Operating line identification
    NET_LINE_DIRECTION  emDirection;                        // Operating line direction
    NET_TIME_EX         stuStartTime;                       // Departure time 

}NET_IN_BUS_SCHEDULE_INFO;

// Vehicle operation dispatching CLIENT_BusSchedule()Interface output parameters
typedef struct tagNET_OUT_BUS_SCHEDULE_INFO 
{
    DWORD           dwSize;
}NET_OUT_BUS_SCHEDULE_INFO;

// Vehicle scheduling plan information
typedef struct tagNET_BUS_WORK_PLAN 
{
    DWORD               dwSize;
    char                szID[DH_COMMON_STRING_32];          // Scheduling record only, Up to 16 characters
    NET_TIME_EX         stuTime;                            // Departure time 
    char                szDriverName[DH_COMMON_STRING_64];  // The driver name
    char                szStartSite[DH_COMMON_STRING_64];   // Starting station name
    char                szEndSite[DH_COMMON_STRING_64];     // The terminal point name
    BOOL                bRunning;                           // Operation state, TRUE: run, FALSE:stop
}NET_BUS_WORK_PLAN;

// Issued by the vehicle scheduling plan CLIENT_DispatchWorkPlan Interface input parameters
typedef struct tagNET_IN_BUS_DISPATCH_WORK_PLAN 
{
    DWORD               dwSize;
    NET_BUS_WORK_PLAN   stuWorkPlan;                        // Vehicle scheduling plan information }NET_IN_BUS_DISPATCH_WORK_PLAN;
}NET_IN_BUS_DISPATCH_WORK_PLAN;

// Issued by the vehicle scheduling plan CLIENT_DispatchWorkPlan Interface output parameters
typedef struct tagNET_OUT_BUS_DISPATCH_WORK_PLAN 
{
    DWORD               dwSize;
}NET_OUT_BUS_DISPATCH_WORK_PLAN;

// Thermal image color 
typedef enum tagNET_THERMO_COLORIZATION 
{
    NET_THERMO_COLORIZATION_UNKNOWN,                        // Unknown 
    NET_THERMO_COLORIZATION_WHITE_HOT,                      // White 
    NET_THERMO_COLORIZATION_BLACK_HOT,                      // Black
    NET_THERMO_COLORIZATION_IRONBOW2,                       // Iron 
    NET_THERMO_COLORIZATION_ICEFIRE,                        // Icefire
	NET_THERMO_COLORIZATION_FUSION,                         // Fusion
	NET_THERMO_COLORIZATION_RAINBOW,                        // Rainbow
	NET_THERMO_COLORIZATION_GLOBOW,                         // Globow
	NET_THERMO_COLORIZATION_IRONBOW1,                       // Ironbow1
	NET_THERMO_COLORIZATION_SEPIA,                          // Sepia
	NET_THERMO_COLORIZATION_COLOR1,                         // Color1
	NET_THERMO_COLORIZATION_COLOR2,                         // Color2
	NET_THERMO_COLORIZATION_RAIN,                           // Rain
	NET_THERMO_COLORIZATION_RED_HOT,                        // RedHot
	NET_THERMO_COLORIZATION_GREEN_HOT,                      // GreenHot
} NET_THERMO_COLORIZATION;

// Thermal ROI mode 
typedef enum tagNET_THERMO_ROI 
{
    NET_THERMO_ROI_UNKNOWN,                                 // Unknown 
    NET_THERMO_ROI_FULL_SCREEN,                             // Full-screen 
    NET_THERMO_ROI_SKY,                                     // Top
    NET_THERMO_ROI_GROUND,                                  // Middle
    NET_THERMO_ROI_HORIZONTAL,                              // Bottom
    NET_THERMO_ROI_CENTER_75,                               // Center point 75%
    NET_THERMO_ROI_CENTER_50,                               // Center point 50%
    NET_THERMO_ROI_CENTER_25,                               // Center point 25%
    NET_THERMO_ROI_CUSTOM,                                  // Customized 
} NET_THERMO_ROI;

// Thermal mode 
typedef enum tagNET_THERMO_MODE 
{
    NET_THERMO_MODE_UNKNOWN,                                // Unknown
    NET_THERMO_MODE_DEFAULT,                                // Default
    NET_THERMO_MODE_INDOOR,                                 // Indoor 
    NET_THERMO_MODE_OUTDOOR,                                // Outdoor 
} NET_THERMO_MODE;

// Thermal optimized region 
typedef struct tagNET_THERMO_GRAPHY_OPT_REGION 
{
    BOOL                bOptimizedRegion;                   // Enable optimized region or not 
    int                 nOptimizedROIType;                  // Optimized region type. Please refer to NET_THERMO_ROI
    int                 nCustomRegion;                      // Customized region amount 
    NET_RECT            stCustomRegions[64];                // Customized region. Valid only when nOptimizedROIType is NET_THERMO_ROI_CUSTOM 
    char                Reserved[256];
} NET_THERMO_GRAPHY_OPTREGION;

// Thermal info 
typedef struct tagNET_THERMO_GRAPHY_INFO 
{
    int                         nBrightness;                // brightness
    int                         nSharpness;                 // Sharpness
    int                         nEZoom;                     // Zoom 
    int                         nThermographyGamma;         // Gamma value 
    int                         nColorization;              // Color. Refer to NET_THERMO_COLORIZATION
    int                         nSmartOptimizer;            // Optimized indicator 
    NET_THERMO_GRAPHY_OPTREGION stOptRegion;                // Optimized region 
    int                         nAgc;                       // Auto gain control 
    int                         nAgcMaxGain;                // Max auto gain
    int                         nAgcPlateau;                // Gain balance 
    char reserved[244];
} NET_THERMO_GRAPHY_INFO;

// CLIENT_QueryDevInfo port NET_QUERY_DEV_THERMO_GRAPHY_PRESET command to input parameter  
typedef struct tagNET_IN_THERMO_GET_PRESETINFO 
{
    DWORD               dwSize;
    int                 nChannel;                           // channel number
    NET_THERMO_MODE     emMode;                             // mode
} NET_IN_THERMO_GET_PRESETINFO;

// CLIENT_QueryDevInfo port NET_QUERY_DEV_THERMO_GRAPHY_PRESET command to output parameter
typedef struct tagNET_OUT_THERMO_GET_PRESETINFO 
{
    DWORD                       dwSize;
    NET_THERMO_GRAPHY_INFO      stInfo;                     // thermal info
} NET_OUT_THERMO_GET_PRESETINFO;

// CLIENT_QueryDevInfo port_QUERY_DEV_THERMO_GRAPHY_EXTSYSINFO command to input parameter
typedef struct tagNET_IN_THERMO_GET_EXTSYSINFO
{
    DWORD               dwSize;
    int                 nChannel;                           // channel number
} NET_IN_THERMO_GET_EXTSYSINFO;

// CLIENT_QueryDevInfo port  NET_QUERY_GET_LINKCHANNELS command to input parameter
typedef struct tagNET_IN_GET_LINKCHANNELS
{	
    DWORD               dwSize;
    int                 nChannel;	                        // channel number, check if there is related video channel in this video channel number
} NET_IN_GET_LINKCHANNELS;

#define NET_LINKCHANNEL_MAX     512                         // max linked video channel count
#define NET_LINKGROUP_MAX       64                          // max linked video channel group count

// CLIENT_QueryDevInfo port NET_QUERY_GET_LINKCHANNELS command to output parameter
typedef struct tagNET_OUT_GET_LINKCHANNELS
{	
    DWORD               dwSize;
    int                 nLinkedCnt;                         // related  number of video channel number
    int                 nLinked[NET_LINKCHANNEL_MAX];	    // related video channel number, including request channel number
} NET_OUT_GET_LINKCHANNELS;

// input param of CLIENT_QueryDevInfo according to NET_QUERY_GET_ALLLINKCHANNELS
typedef struct tagNET_IN_GET_ALLLINKCHANNELS
{	
    DWORD               dwSize;
} NET_IN_GET_ALLLINKCHANNELS;

// output param of CLIENT_QueryDevInfo according to NET_QUERY_GET_ALLLINKCHANNELS
typedef struct tagNET_OUT_GET_ALLLINKCHANNELS
{	
    DWORD               dwSize;
    int                 nGroupCnt;                                              // linked video channel group count in
    int                 nLinkedCnt[NET_LINKGROUP_MAX];                          // linked video channel counts in a group
    int                 nLinked[NET_LINKGROUP_MAX][NET_LINKCHANNEL_MAX];	    // linked video channel group info
                                                                                // first dimension: channel group, second dimension: video channel number
} NET_OUT_GET_ALLLINKCHANNELS;

// CLIENT_QueryDevInfo port NET_QUERY_GET_CAMERA_STATE command to input parameter
typedef struct tagNET_IN_GET_CAMERA_STATEINFO
{
    DWORD               dwSize;
    BOOL                bGetAllFlag;                                // if it is to check all the cameras status, if the member is TRUE, then nChannels member is unnecessary to set.
    int                 nValidNum;                                  // the member is valid when bGetAllFlag is FALSE, which means valid number of nChannels member
    int                 nChannels[DH_MAX_CAMERA_CHANNEL_NUM];       // The member is valid when bGetAllFlag is FALSE, it is to fill in the channel numbers in turn which needs inquiry. 
} NET_IN_GET_CAMERA_STATEINFO;

typedef enum tagEM_CAMERA_STATE_TYPE
{
    EM_CAMERA_STATE_TYPE_UNKNOWN,       // unknown 
    EM_CAMERA_STATE_TYPE_CONNECTING,    // connecting
    EM_CAMERA_STATE_TYPE_CONNECTED,     // connected
    EM_CAMERA_STATE_TYPE_UNCONNECT,     // unconnected
    EM_CAMERA_STATE_TYPE_EMPTY,         // channel is not configured, no info
    EM_CAMERA_STATE_TYPE_DISABLE,       // channel is configured, but it is forbidden. 
}EM_CAMERA_STATE_TYPE;

typedef struct tagNET_CAMERA_STATE_INFO
{
    int                     nChannel;           // camera channel number, -1 means invalid channel number
    EM_CAMERA_STATE_TYPE    emConnectionState;  // connection state
    char                    szReserved[1024];   // byte reserved
}NET_CAMERA_STATE_INFO;

// CLIENT_QueryDevInfo port NET_QUERY_GET_CAMERA_STATE command to output parameter
typedef struct tagNET_OUT_GET_CAMERA_STATEINFO 
{
    DWORD                       dwSize;
    int                         nValidNum;              // valid number of camera channel state, returned by sdk
    int                         nMaxNum;                // max number of array, filled in by user
    NET_CAMERA_STATE_INFO*      pCameraStateInfo;       // camera channel info array, distributed by user,apply to sizeof(NET_CAMERA_STATE_INFO)*nMaxNum
} NET_OUT_GET_CAMERA_STATEINFO;

// CLIENT_QueryDevInfo port NET_QUERY_GET_REMOTE_CHANNEL_AUDIO_ENCODE command to input parameter
typedef struct tagNET_IN_GET_REMOTE_CHANNEL_AUDIO_ENCODEINFO
{
    DWORD               dwSize;
    int                 nChannel;                                   // channel number
    int                 nStreamType;                                // stream type, 0: main stream; 1: sub stream 1; 2: sub stream 2; 3: sub stream 3; 4: talk stream
} NET_IN_GET_REMOTE_CHANNEL_AUDIO_ENCODEINFO;

// CLIENT_QueryDevInfo port NET_QUERY_GET_REMOTE_CHANNEL_AUDIO_ENCODE command to output parameter
typedef struct tagNET_OUT_GET_REMOTE_CHANNEL_AUDIO_ENCODEINFO
{
    DWORD                       dwSize;
    int                         nValidNum;                                  // valid number of audio coding
    DHDEV_TALKDECODE_INFO       stuListAudioEncode[MAX_AUDIO_ENCODE_NUM];   // audio coding list
} NET_OUT_GET_REMOTE_CHANNEL_AUDIO_ENCODEINFO;

// API CLIENT_QueryDevInfo  NET_QUERY_GET_COMM_PORT_INFO in param
typedef struct tagNET_IN_GET_COMM_PORT_INFO
{
    DWORD               dwSize;
} NET_IN_GET_COMM_PORT_INFO;

// API CLIENT_QueryDevInfo NET_QUERY_GET_COMM_PORT_INFO out param
//port type
typedef enum tagEM_COMM_PORT_TYPE_INFO
{
    EM_COMM_PORT_TYPE_UNKNOW = 0    ,
    EM_COMM_PORT_TYPE_RS232         ,
    EM_COMM_PORT_TYPE_RS485         ,
    EM_COMM_PORT_TYPE_RS422         ,
    EM_COMM_PORT_TYPE_RS485_422     ,
}EM_COMM_PORT_TYPE_INFO;

//port info
typedef struct  tagNET_COMM_PORT_INFO
{
    EM_COMM_PORT_TYPE_INFO  emCommPortType;     //Port Type
    int                     nCommPortNum;       //Port Number
    BYTE                    bReserved[1024];    //reserved bytes
}NET_COMM_PORT_INFO;

#define MAX_COMM_PORT_NUM       8
typedef struct tagNET_OUT_GET_COMM_PORT_INFO
{
    DWORD                       dwSize;
    int                         nPortInfosNum;                          //Port Infos Number
    NET_COMM_PORT_INFO          stCommPortInfos[MAX_COMM_PORT_NUM];     //Port Info
} NET_OUT_GET_COMM_PORT_INFO;

// external system info
typedef struct tagNET_THERMO_SYSINFO 
{
    char                szSerialNumber[64];                 // serial number
    char                szSoftwareVersion[64];              // software version
    char                szFirmwareVersion[64];              // firmware version
    char                szLibVersion[64];                   // library version
    char                reserved[256];
} NET_THERMO_SYSINFO;

// CLIENT_QueryDevInfo port NET_QUERY_DEV_THERMO_GRAPHY_EXTSYSINFO command to output parameter
typedef struct tagNET_OUT_THERMO_GET_EXTSYSINFO
{
    DWORD                       dwSize;
    NET_THERMO_SYSINFO          stInfo;                     // external system info
} NET_OUT_THERMO_GET_EXTSYSINFO;

// CLIENT_QueryDevInfo port NET_QUERY_DEV_THERMO_GRAPHY_OPTREGION command to input parameter
typedef struct tagNET_IN_THERMO_GET_OPTREGION
{
    DWORD               dwSize;
    int                 nChannel;                           // channel nunmber
} NET_IN_THERMO_GET_OPTREGION;

// CLIENT_QueryDevInfo port NET_QUERY_DEV_THERMO_GRAPHY_OPTREGION command to output parameter
typedef struct tagNET_OUT_THERMO_GET_OPTREGION
{
    DWORD                       dwSize;
    NET_THERMO_GRAPHY_OPTREGION stInfo;                     // optimize area info
} NET_OUT_THERMO_GET_OPTREGION;


// CLIENT_QueryDevInfo interface, input param of NET_QUERY_GET_VIDEOOUTPUTCHANNELS
typedef struct tagNET_IN_GET_VIDEOOUTPUTCHANNELS
{
    DWORD               dwSize;             // dwSize must be initialized,dwSize is sizeof(NET_IN_GET_VIDEOOUTPUTCHANNELS)
} NET_IN_GET_VIDEOOUTPUTCHANNELS;

// CLIENT_QueryDevInfo interface NET_QUERY_GET_VIDEOOUTPUTCHANNELS command to output parameter
typedef struct tagNET_OUT_GET_VIDEOOUTPUTCHANNELS
{
    DWORD               dwSize;             // dwSize must be initialized,dwSize is sizeof(NET_OUT_GET_VIDEOOUTPUTCHANNELS)
    int                 nMaxLocal;          // max local output channels,including mainboard and pluggable sub card channel
} NET_OUT_GET_VIDEOOUTPUTCHANNELS;


// CLIENT_QueryDevInfo interface NET_QUERY_GET_VIDEOINFO command to input parameter
typedef struct tagNET_IN_GET_VIDEOINFO
{
    DWORD               dwSize;             // dwSize must be initialized,dwSize is sizeof(NET_IN_GET_VIDEOINFO)
} NET_IN_GET_VIDEOINFO;

// Video channel state
typedef enum  tagNET_VIDEOCHANNEL_STATE
{
    NET_VIDEOCHANNEL_STATE_UNKNOWN,        // unknown state
    NET_VIDEOCHANNEL_STATE_IDLE,           // idle 
    NET_VIDEOCHANNEL_STATE_PLAY,           // play
    NET_VIDEOCHANNEL_STATE_MONITOR,        // monitor
    NET_VIDEOCHANNEL_STATE_TOUR,           // tour
} NET_VIDEOCHANNEL_STATE;

// video channel info
typedef struct tagNET_VIDEOCHANNELINFO
{
    BOOL                         bEnable;                // the state of channel enable, if state is true,GB28181 protocol will appear channel to server.
    NET_VIDEOCHANNEL_STATE       emVideoChannelState;    // video channel state
    int                          nNetflow;               // net flow(unit: kbps)
    int                          nBitrate;               // bit rate(unit: kbps)
    int                          nFrame;                 // Frame
    CAPTURE_SIZE                 emResolution;           // resolution
    BYTE                         byReserved[512];        // reserve 
} NET_VIDEOCHANNELINFO;


// CLIENT_QueryDevInfo interface NET_QUERY_GET_VIDEOINFO command to output param
typedef struct tagNET_OUT_GET_VIDEOINFO
{
    DWORD                    dwSize;                // dwSize must be initialized,dwSize is sizeof(NET_OUT_GET_VIDEOINFO)
    int                      nVideoInfoNum;         // the video info num which user need to gain,gain from 0 by user
    NET_VIDEOCHANNELINFO*    pNetVideoChannelInfo;  // the list of net video channel info,user malloc memory,the list num is in keeping with nVideoInfoNum, memory size is sizeof(NET_VIDEOCHANNELINFO)*nVideoInfoNum
    int                      nRetVideoInfoNum;      // return video info num actually by SDK
} NET_OUT_GET_VIDEOINFO;



// CLIENT_ControlDeviceEx port NET_CTRL_DEV_THERMO_GRAPHY_ENSHUTTER command to input parameter
typedef struct tagNET_IN_THERMO_EN_SHUTTER
{
    DWORD               dwSize;
    int                 nChannel;                           // channel number
    BOOL                bEnable;                            // switch shutter, TRUE on, FALSE off
} NET_IN_THERMO_EN_SHUTTER;

// CLIENT_ControlDeviceEx port NET_CTRL_DEV_THERMO_GRAPHY_ENSHUTTER command to output parameter
typedef struct tagNET_OUT_THERMO_EN_SHUTTER
{
    DWORD               dwSize;
} NET_OUT_THERMO_EN_SHUTTER;

// CLIENT_ControlDeviceEx port DH_CTRL_THERMO_DO_FFC command to input parameter
typedef struct tagNET_IN_THERMO_DO_FFC
{
	DWORD               dwSize;								// dwSize must be initialized,dwSize is sizeof(NET_IN_THERMO_DO_FFC)
	int                 nChannel;                           // channel number(binocular thermal camera filling in thermal channel:1)
} NET_IN_THERMO_DO_FFC;

// CLIENT_ControlDeviceEx port DH_CTRL_THERMO_DO_FFC command to output parameter
typedef struct tagNET_OUT_THERMO_DO_FFC
{
	DWORD               dwSize;								// dwSize must be initialized,dwSize is sizeof(NET_OUT_THERMO_DO_FFC)
} NET_OUT_THERMO_DO_FFC;

// CLIENT_ControlDeviceEx port DH_CTRL_THERMO_FIX_FOCUS command to input parameter(only binocular thermal camera works)
typedef struct tagNET_IN_THERMO_FIX_FOCUS
{
	DWORD               dwSize;								// dwSize must be initialized,dwSize is sizeof(NET_IN_THERMO_FIX_FOCUS)
	int					anLinkVideoChannel[2];              // focus correlation channle number([0]:channel,[1]:thermal channel)
	double				dSpeed;								// focus speed, effective range 0~1(vaild for thermal channel)
} NET_IN_THERMO_FIX_FOCUS;

// CLIENT_ControlDeviceEx port DH_CTRL_THERMO_FIX_FOCUS command to output parameter(only binocular thermal camera works)
typedef struct tagNET_OUT_THERMO_FIX_FOCUS
{
	DWORD               dwSize;								// dwSize must be initialized,dwSize is sizeof(NET_OUT_THERMO_FIX_FOCUS)
} NET_OUT_THERMO_FIX_FOCUS;

// CLIENT_GetDevCaps port NET_THERMO_GRAPHY_CAPS command to input parameter
typedef struct tagNET_IN_THERMO_GETCAPS
{
    DWORD               dwSize;
    int                 nChannel;                           // channel number
} NET_IN_THERMO_GETCAPS;

// CLIENT_GetDevCaps port NET_THERMO_GRAPHY_CAPS command to output parameter
typedef struct tagNET_OUT_THERMO_GETCAPS
{
    DWORD               dwSize;
    DWORD               dwModes;                            // supported preset mode mask
    DWORD               dwColorization;                     // preset colorization mode mask
    DWORD               dwROIModes;                         // preset ROI mode mask
    RANGE               stBrightness;                       // brightness ability
    RANGE               stSharpness;                        // sharpness ability
    RANGE               stEZoom;                            // zoom ability
    RANGE               stThermographyGamma;                // Gamma ability
    RANGE               stSmartOptimizer;                   // optimize parameter ability
	NET_FFCPERIOD_RANGE stFFCPeriod;                        // flat field correction ability
} NET_OUT_THERMO_GETCAPS;

// CLIENT_GetDevCaps port NET_RADIOMETRY_CAPS command to input parameter
typedef struct tagNET_IN_RADIOMETRY_GETCAPS
{
    DWORD               dwSize;
    int                 nChannel;                           // channel number
} NET_IN_RADIOMETRY_GETCAPS;

// temperature measurement mode type
typedef enum tagNET_RADIOMETRY_METERTYPE 
{
    NET_RADIOMETRY_METERTYPE_UNKNOWN,
    NET_RADIOMETRY_METERTYPE_SPOT,                          // spot
    NET_RADIOMETRY_METERTYPE_LINE,                          // line
    NET_RADIOMETRY_METERTYPE_AREA,                          // area
} NET_RADIOMETRY_METERTYPE;

// total number ability of spot, line and area
typedef struct tagNET_RADIOMETRY_TOTALNUM 
{
    DWORD               dwMaxNum;                           // max support number
    DWORD               dwMaxSpots;                         // max number of spot
    DWORD               dwMaxLines;                         // max number of line
    DWORD               dwMaxAreas;                         // max number of area
    char reserved[32]; 
} NET_RADIOMETRY_TOTALNUM;

// CLIENT_GetDevCaps port NET_RADIOMETRY_CAPS command to output parameter
typedef struct tagNET_OUT_RADIOMETRY_GETCAPS
{
    DWORD                       dwSize;
    NET_RADIOMETRY_TOTALNUM     stTotalNum;                 // total number abllity of spot, line and area
    DWORD                       dwMaxPresets;               // max number of temperature measurement preset
    DWORD                       dwMeterType;                // type mask of temperature measurement mode, refer to NET_RADIOMETRY_METERTYPE 
    RANGE                       stObjectEmissivity;         // emissivity related ability
    RANGE                       stObjectDistance;           // distance related ability
    RANGE                       stReflectedTemperature;     // reflected temperature related ability
    RANGE                       stRelativeHumidity;         // relative humidity related ability
    RANGE                       stAtmosphericTemperature;   // atmospheric temperature related ability
    int                         nStatisticsMinPeriod;       // min storage data interval of temperature measuring point statistics function, unit is second.
    float                       fIsothermMaxTemp;           // color code bar max temperature value
    float                       fIsothermMinTemp;           // color code bar min temperature value
} NET_OUT_RADIOMETRY_GETCAPS;

// temperature measurement info
typedef struct tagNET_RADIOMETRYINFO
{
    int                 nMeterType;                         // return to temperature measurement type, refer to NET_RADIOMETRY_METERTYPE 
    int                 nTemperUnit;                        // temperature unit (currently configured temperature unit), refer to NET_TEMPERATURE_UNIT 
    float               fTemperAver;                        // only return to this field when it is spot temperature or average temperature
    float               fTemperMax;                         // max temperature 
    float               fTemperMin;                         // min temperature 
    float               fTemperMid;                         // middle temperature value        
    float               fTemperStd;                         // standard deviation value
    char                reserved[64];
} NET_RADIOMETRYINFO;

// acquire thermal condition of temperature measurement   
typedef struct tagNET_RADIOMETRY_CONDITION
{
    int                 nPresetId;                          // preset number        
    int                 nRuleId;                            // rule number  
    int                 nMeterType;                         // temperature measurement type, refer to NET_RADIOMETRY_METERTYPE 
    char                szName[64];                         // name of temperature measurement, select from the name of temperature measurement configured rule
    int                 nChannel;                           // channel number
    char                reserved[256];
} NET_RADIOMETRY_CONDITION;

// CLIENT_QueryDevInfo port NET_QUERY_DEV_RADIOMETRY_POINT_TEMPER command to input parameter
typedef struct tagNET_IN_RADIOMETRY_GETPOINTTEMPER
{
    DWORD               dwSize;
    int                 nChannel;                           // channel number
    DH_POINT            stCoordinate;                       // temperature measurement spot coordinate, coordinate value 0~8192 
} NET_IN_RADIOMETRY_GETPOINTTEMPER;

// CLIENT_QueryDevInfo port NET_QUERY_DEV_RADIOMETRY_POINT_TEMPER command to output parameter
typedef struct tagNET_OUT_RADIOMETRY_GETPOINTTEMPER
{
    DWORD               dwSize;
    NET_RADIOMETRYINFO  stPointTempInfo;                    // acquire the parameter value of temperature measurement spot
} NET_OUT_RADIOMETRY_GETPOINTTEMPER;

// CLIENT_QueryDevInfo port NET_QUERY_DEV_RADIOMETRY_TEMPER command to input parameter
typedef struct tagNET_IN_RADIOMETRY_GETTEMPER
{
    DWORD                       dwSize;
    NET_RADIOMETRY_CONDITION    stCondition;                // acquire the temperature condition of temperature measurement 
} NET_IN_RADIOMETRY_GETTEMPER;

// CLIENT_QueryDevInfo port NET_QUERY_DEV_RADIOMETRY_TEMPER command to output parameter
typedef struct tagNET_OUT_RADIOMETRY_GETTEMPER
{
    DWORD               dwSize;
    NET_RADIOMETRYINFO  stTempInfo;                         // acquire parameter value of temperature measurement
} NET_OUT_RADIOMETRY_GETTEMPER;

// CLIENT_ControlDeviceEx port NET_CTRL_DEV_RADIOMETRY_SETOSDMARK command to input parameter
typedef struct tagNET_IN_RADIOMETRY_SETOSDMARK
{
    DWORD                       dwSize;
    NET_RADIOMETRY_CONDITION    stCondition;                // it needs to set the matching condition of osd temperature measurement 
} NET_IN_RADIOMETRY_SETOSDMARK;

// CLIENT_ControlDeviceEx port NET_CTRL_DEV_RADIOMETRY_SETOSDMARK command to output parameter
typedef struct tagNET_OUT_RADIOMETRY_SETOSDMARK
{
    DWORD               dwSize;
} NET_OUT_RADIOMETRY_SETOSDMARK;

//radiometry period
typedef enum tagEM_RADIOMETRY_PERIOD
{
	EM_RADIOMETRY_PERIOD_UNKNOWN,			 // unknown
    EM_RADIOMETRY_PERIOD_5  = 5,             // 5minutes,default
	EM_RADIOMETRY_PERIOD_10 = 10,            // 10minutes
	EM_RADIOMETRY_PERIOD_15 = 15,            // 15minutes
	EM_RADIOMETRY_PERIOD_30 = 30,            // 30minutes
}EM_RADIOMETRY_PERIOD;

// CLIENT_StartFind port NET_FIND_RADIOMETRY command to input parameter
typedef struct tagNET_IN_RADIOMETRY_STARTFIND
{   
    DWORD                  dwSize;
    NET_TIME               stStartTime;                       // query start time
    NET_TIME               stEndTime;                         // query end time
    int                    nMeterType;                        // query type
    int                    nChannel;                          // channel number
    EM_RADIOMETRY_PERIOD   emPeriod;                          // query period
} NET_IN_RADIOMETRY_STARTFIND;

// CLIENT_StartFind port NET_FIND_RADIOMETRY command to output parameter
typedef struct tagNET_OUT_RADIOMETRY_STARTFIND
{   
    DWORD               dwSize;
    int                 nFinderHanle;                      // acquired query handle
    int                 nTotalCount;                       // total number of result which conforms to the query condition
} NET_OUT_RADIOMETRY_STARTFIND;

#define NET_RADIOMETRY_DOFIND_MAX 32

// CLIENT_DoFind port NET_FIND_RADIOMETRY command to input parameter
typedef struct tagNET_IN_RADIOMETRY_DOFIND
{   
    DWORD               dwSize;
    int                 nFinderHanle;                      // query handle
    int                 nBeginNumber;                      // index number of query begin
    int                 nCount;                            // the number of query, max is NET_IN_RADIOMETRY_DOFIND_MAX 
} NET_IN_RADIOMETRY_DOFIND;

// return to query result
typedef struct tagNET_RADIOMETRY_QUERY
{
    NET_TIME            stTime;                            // record time
    int                 nPresetId;                         // preset number
    int                 nRuleId;                           // rule number
    char                szName[64];                        // query name
	DH_POINT            stCoordinate;                      // query temperature measurement coordinate(Recommend stcoordinates)
    int                 nChannel;                          // channel number
    NET_RADIOMETRYINFO  stTemperInfo;                      // temperature measurement info, currently nTemperMid, nTemperStd member invalid
	DH_POINT            stCoordinates[8];				   // query temperature measurement coordinate
	int					nCoordinateNum;					   // Query the number of temperature point coordinates returned
	char                reserved[220];
} NET_RADIOMETRY_QUERY;

// CLIENT_DoFind port_FIND_RADIOMETRY command to output parameter
typedef struct tagNET_OUT_RADIOMETRY_DOFIND
{   
    DWORD                       dwSize;
    int                         nFound;                             // actual query spot number
    NET_RADIOMETRY_QUERY        stInfo[NET_RADIOMETRY_DOFIND_MAX];  // temperature statistics info 
} NET_OUT_RADIOMETRY_DOFIND;

// CLIENT_StopFind port_FIND_RADIOMETRY command to input parameter
typedef struct tagNET_IN_RADIOMETRY_STOPFIND
{   
    DWORD               dwSize;
    int                 nFinderHanle;                       // query handle 
} NET_IN_RADIOMETRY_STOPFIND;

// CLIENT_StopFind port_FIND_RADIOMETRY command to output parameter
typedef struct tagNET_OUT_RADIOMETRY_STOPFIND
{   
    DWORD               dwSize;
} NET_OUT_RADIOMETRY_STOPFIND;

// thermal temperature measurement spot alarm result value type 
typedef enum tagNET_RADIOMETRY_RESULT 
{
    NET_RADIOMETRY_RESULT_UNKNOWN,
    NET_RADIOMETRY_RESULT_VAL,                  // concrete value 
    NET_RADIOMETRY_RESULT_MAX,                  // max
    NET_RADIOMETRY_RESULT_MIN,                  // min
    NET_RADIOMETRY_RESULT_AVR,                  // average
    NET_RADIOMETRY_RESULT_STD,                  // standard
    NET_RADIOMETRY_RESULT_MID,                  // middle
    NET_RADIOMETRY_RESULT_ISO,                  // ISO
    NET_RADIOMETRY_RESULT_DIFF,                 // difference
    NET_RADIOMETRY_RESULT_SLOPE,                // slope
} NET_RADIOMETRY_RESULT;

// thermal temperature measurement spot alarm condition 
typedef enum tagNET_RADIOMETRY_ALARMCONTION 
{
    NET_RADIOMETRY_ALARMCONTION_UNKNOWN,
    NET_RADIOMETRY_ALARMCONTION_BELOW,          // below
    NET_RADIOMETRY_ALARMCONTION_MATCH,          // equal 
    NET_RADIOMETRY_ALARMCONTION_ABOVE,          // above
} NET_RADIOMETRY_ALARMCONTION;

// temperature unit
typedef enum tagNET_TEMPERATURE_UNIT
{
    NET_TEMPERATURE_UNIT_UNKNOWN,
    NET_TEMPERATURE_UNIT_CENTIGRADE,                // Centigrade
    NET_TEMPERATURE_UNIT_FAHRENHEIT,                // Fahrenheit
} NET_TEMPERATURE_UNIT;

// thermal temperature measurement spot temperature abnormity alarm 
typedef struct tagALARM_HEATIMG_TEMPER_INFO
{
    char                szName[64];                         // temperature abnormal spot name, select from the temperature measurement rule config
    int                 nAlarmId;                           // alarm number    
    int                 nResult;                            // alarm result value nValue type, refer to enumeration NET_RADIOMETRY_RESULT 
    int                 nAlarmContion;                      // alarm condition, refer to enumeration NET_RADIOMETRY_ALARMCONTION 
    float               fTemperatureValue;                  // alarm temperature value 
    int                 nTemperatureUnit;                   // temperature unit (currently configured temperature unit), refer to NET_TEMPERATURE_UNIT 
    DH_POINT            stCoordinate;                       // alarm spot coordinate, relative coordinate system, value is 0~8191 
    int                 nPresetID;                          // preset
    int                 nChannel;                           // channel number
    int                 nAction;                            // 0:start 1: stop
	DH_POLY_POINTS      stuAlarmCoordinates;				// alarm coordinates, the type is spot or line or polygon. replace stCoordinate field  
	char                reserved[156];
} ALARM_HEATIMG_TEMPER_INFO;

// thermal kindling point alarm 
typedef struct tagALARM_FIREWARNING_INFO
{
    int                 nPresetId;                          // deprecated, to get same info, use event DH_ALARM_FIREWARNING_INFO instead
    int                 nState;                             // 0-start, 1-stop 
    DH_RECT             stBoundingBox;                      // deprecated, to get same info, use event DH_ALARM_FIREWARNING_INFO instead 	
    int                 nTemperatureUnit;                   // deprecated, to get same info, use event DH_ALARM_FIREWARNING_INFO instead 
    float               fTemperature;                       // deprecated, to get same info, use event DH_ALARM_FIREWARNING_INFO instead 
    unsigned            nDistance;                          // deprecated, to get same info, use event DH_ALARM_FIREWARNING_INFO instead
	GPS_POINT           stGpsPoint;                         // deprecated, to get same info, use event DH_ALARM_FIREWARNING_INFO instead
    int                 nChannel;                           // channel id
	BOOL				bIsLeaveFireDetect;					// Whether it belongs to off post fire point detection item (TRUE: Yes FALSE: No)   
	char                reserved[248];
} ALARM_FIREWARNING_INFO;

//PTZ control coordinate unit 
typedef struct tagPTZ_POSITION_UNIT
{
    int                  nPositionX;                        // PTZ horizontal angle,effective range[0,3599]
    int                  nPositionY;                        // PTZ vertical angle,effective range[-1800,1800]
    int                  nZoom;                             // PTZ aperture magnification,the effective range[0,128]
    char                 szReserve[32];                     // Reserved
}PTZ_POSITION_UNIT;

// firewarning info
typedef struct tagNET_FIREWARNING_INFO
{
    int                 nPresetId;                          // preset number is selected from the temperature measurement rule config refer to CFG_RADIOMETRY_RULE_INFO
    NET_RECT            stuBoundingBox;                     // kindling point rectangular box 
    int                 nTemperatureUnit;                   // temperature unit (currently configured temperature unit), refer to NET_TEMPERATURE_UNIT 
    float               fTemperature;                       // max spot temperature value provided by same frame detection and differential detection 
    UINT            	nDistance;                          // kindling point distance, unit is meter, 0 means invalid
    GPS_POINT           stuGpsPoint;                        // kindling point longitude and latitude
    PTZ_POSITION_UNIT   stuPTZPosition;                     // PTZ Info
    float               fAltitude;                          // Altitude(unit: metre)
	UINT				nThermoHFOV;						// Uint32 Thermo horizontal visual
	UINT				nThermoVFOV;						// Uint32 Thermo vertical visual
	UINT				nFSID;								// Uint32 Fire status id
    BYTE                reserved[196];
}NET_FIREWARNING_INFO;


// firewarning event info
typedef struct tagALARM_FIREWARNING_INFO_DETAIL
{
    int                     nChannel;                                           // channel id
    int                     nWarningInfoCount;                                  // warning info count
    NET_FIREWARNING_INFO    stuFireWarningInfo[MAX_FIREWARNING_INFO_NUM];       // warning info
    BYTE                    reserved[256];
}ALARM_FIREWARNING_INFO_DETAIL;

// face overheating
typedef struct tagALARM_FACE_OVERHEATING_INFO
{
    int                     nRelativeId;                          // picture id of face,refer to NET_FACE_INFO->nRelativeID
    int                     nTemperatureUnit;                     // temperature unit (currently configured temperature unit), refer to NET_TEMPERATURE_UNIT
    float                   fTemperature;                         // temperature value of the face     
    int                     nChannelID;                           // channel id
    BYTE                    reserved[124];
}ALARM_FACE_OVERHEATING_INFO;

// sensor status
typedef enum tagEM_SENSOR_ABNORMAL_STATUS
{
    NET_SENSOR_ABNORMAL_STATUS_UNKNOWN,
    NET_SENSOR_ABNORMAL_STATUS_SHORT,                              // short
    NET_SENSOR_ABNORMAL_STATUS_BREAK,                              // break
    NET_SENSOR_ABNORMAL_STATUS_INTRIDED,                           // intrided
}EM_SENSOR_ABNORMAL_STATUS;

//event type (DH_ALARM_SENSOR_ABNORMAL) 
typedef struct tagALARM_SENSOR_ABNORMAL_INFO
{
    int                                 nAction;                   // 0:start 1:stop
    int                                 nChannelID;                // channel id
    NET_TIME_EX                         stuTime;                   // UTC time
    EM_SENSOR_ABNORMAL_STATUS           emStatus;                  // sensor status
    BYTE                                byReserved[128];
}ALARM_SENSOR_ABNORMAL_INFO;

// heat map metadata info 
typedef struct tagNET_RADIOMETRY_METADATA
{
    int                 nHeight;                            // height 
    int                 nWidth;                             // width 
    int                 nChannel;                           // channel 
    NET_TIME            stTime;                             // acquire data time
    int                 nLength;                            // data size
    char                szSensorType[64];                   // module type
    int                 nUnzipParamR;                       // uncompressing parameter R 
    int                 nUnzipParamB;                       // uncompressing parameter B
    int                 nUnzipParamF;                       // uncompressing parameter F
    int                 nUnzipParamO;                       // uncompressing parameter O
    char                Reserved[256];
} NET_RADIOMETRY_METADATA;

// heat map data 
typedef struct tagNET_RADIOMETRY_DATA
{
    NET_RADIOMETRY_METADATA     stMetaData;                 // metadata
    BYTE*                       pbDataBuf;                  // heat map data buffer (for compressed data, it is temperature data of each pixel inside, it can use metadata info to compress)
    DWORD                       dwBufSize;                  // heat map data buffer size
    char                        reserved[512];
} NET_RADIOMETRY_DATA;

//////////////////////////////////////////////////////////////////////////
/// \fn temperature distribution data state callback function 
/// \brief 
/// \param  LLONG lAttachHandle [OUT] subscription handle, CLIENT_RadiometryAttach returned value
/// \param  NET_RADIOMETRY_DATA* pBuf [OUT] heat map data info
/// \param  int nBufLen [OUT] state info length
/// \param  param  LDWORD dwUser user data
/// \return none
///////////////////////////////////////////////////////////////////////////
typedef void (CALLBACK *fRadiometryAttachCB)(LLONG lAttachHandle, NET_RADIOMETRY_DATA* pBuf, int nBufLen, LDWORD dwUser);

// CLIENT_RadiometryAttach input parameter
typedef struct tagNET_IN_RADIOMETRY_ATTACH
{
    DWORD               dwSize;
    int                 nChannel;                           // video channel number -1, it means all
    fRadiometryAttachCB cbNotify;                           // state callback function pointer
    LDWORD              dwUser;                             // user data 
} NET_IN_RADIOMETRY_ATTACH;

// CLIENT_RadiometryAttach output parameter
typedef struct tagNET_OUT_RADIOMETRY_ATTACH
{
    DWORD               dwSize;
} NET_OUT_RADIOMETRY_ATTACH;

// subscribe temperature distribution data (heat map), user malloc and free memory of pInParam and pOutParam
CLIENT_NET_API LLONG CALL_METHOD CLIENT_RadiometryAttach(LLONG lLoginID, const NET_IN_RADIOMETRY_ATTACH* pInParam, NET_OUT_RADIOMETRY_ATTACH* pOutParam, int nWaitTime);

// cancel subscribing temperature distribution data, lAttachHandle is the returned value of CLIENT_RadiometryAttach
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RadiometryDetach(LLONG lAttachHandle);

// CLIENT_RadiometryFetch input parameter
typedef struct tagNET_IN_RADIOMETRY_FETCH
{
    DWORD               dwSize;
    int                 nChannel;                           // channel number, channel number needs to be in accordance with subscription, -1 excluded
} NET_IN_RADIOMETRY_FETCH;

// CLIENT_RadiometryFetch output parameter
typedef struct tagNET_OUT_RADIOMETRY_FETCH 
{
    DWORD               dwSize;
    int                 nStatus;                            // 0: unknown, 1: free, 2: acquiring heat map
} NET_OUT_RADIOMETRY_FETCH;

// inform to start acquiring heat map data,user malloc and free memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RadiometryFetch(LLONG lLoginID, const NET_IN_RADIOMETRY_FETCH* pInParam, NET_OUT_RADIOMETRY_FETCH* pOutParam, int nWaitTime);

// CLIENT_GetHeatMapsDirectly input parameter
typedef struct tagNET_IN_GET_HEATMAPS_INFO
{
    DWORD                       dwSize;								// struct size
    int                         nChannel;                           // Channel id
} NET_IN_GET_HEATMAPS_INFO;

// CLIENT_GetHeatMapsDirectly output parameter
typedef struct tagNET_OUT_GET_HEATMAPS_INFO 
{
    DWORD                       dwSize;
    NET_RADIOMETRY_METADATA     stMetaData;                 // Meta data
    DWORD				        dwMaxDataBufLen;			// The size of pbDataBuf, allocated by user
    BYTE				        *pbDataBuf;					// The buffer of heatmap data(The data has been compressed, each pixel represents temperature,can extract the data use meta data), allocated by user
    DWORD				        dwRetDataBufLen;			// The actual data size
	BYTE              	        byReserved[4];            	// Byte alignment
} NET_OUT_GET_HEATMAPS_INFO;

CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetHeatMapsDirectly(LLONG lLoginID, const NET_IN_GET_HEATMAPS_INFO* pInParam, NET_OUT_GET_HEATMAPS_INFO* pOutParam, int nWaitTime);


// radiometry data unachieving and conversion
/// \brief 
/// \param  pRadiometryData [IN] radiometry data, obtained from fRadiometryAttachCB 
/// \param  pGrayImg [IN, OUT] unachieved data, which is a grayscale image
///			you can pass NULL if this is not needed
///         you must ensure that the buffer is enough (no less than 'pixel number'*sizeof(unsigned short))
///         for each pixel, there is an unsigned short value representing the grayscale value (range: 0 ~ 16383)
///         and the ordering is top-left pixels in low memory address and lower-right pixels in high memory address 
/// \param  pTempForPixels [IN, OUT] The temperature buffer for each pixel can not be empty
///			otherwise,it will fail to return
///         you must ensure that the buffer is enough (no less than 'pixel number'*sizeof(float))
///         for each pixel, there is a float value representing temperature at pixel position, in centigrade
///         and the ordering is top-left pixels in low memory address and lower-right pixels in high memory address 
/// \return TRUE for success, FALSE for failure
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RadiometryDataParse(const NET_RADIOMETRY_DATA* pRadiometryData, unsigned short* pGrayImg, float* pTempForPixels);

// CLIENT_GetRadiometryYImage input parameter
typedef struct tagNET_IN_RADIOMETRY_Y_IMAGE
{
    DWORD                       dwSize;
    int                         nChannel;                               // channel id
}NET_IN_RADIOMETRY_Y_IMAGE;

// CLIENT_GetRadiometryYImage output parameter
typedef struct tagNET_OUT_RADIOMETRY_Y_IMAGE
{   
    DWORD                       dwSize;
    UINT                        nWidth;                                 // the width of image
    double                      PTS;                                    // timestamp (unit is millisecond)
    UINT                        nHeight;                                // the height of image
    char*                       pbDataBuf;                              // Y Date buffer(user alloc this memory, size is nBufLen)
    int                         nBufLen;                                // pbDataBuf max len
    int                         nBufRet;                                // pbDataBuf len
}NET_OUT_RADIOMETRY_Y_IMAGE;

// Get Y Image of thermal camera
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetRadiometryYImage(LLONG lLoginID, const NET_IN_RADIOMETRY_Y_IMAGE* pInParam, NET_OUT_RADIOMETRY_Y_IMAGE* pOutParam,int nWaitTime);

// CLIENT_GetRadiometryCurrentHotColdSpotInfo input parameter
typedef struct tagNET_IN_RADIOMETRY_CURRENTHOTCOLDSPOT_INFO
{
	DWORD					dwSize;
	int						nChannel;			// channel id:(Only thermal imaging channels are effective)
} NET_IN_RADIOMETRY_CURRENTHOTCOLDSPOT_INFO;

// Cold(minimum)and hot(maximum) point information
typedef struct tagNET_RADIOMETRY_CURRENTHOTCOLDSPOT_INFO
{
	NET_POINT				stuHotPoint;		// Hot spot coordinates, range0~8191
	NET_POINT				stuColdPoint;		// Cooling point coordinates, range0~8191
	float					fHotSpotValue;		// Hot spot temperaturemaximum Temperature
	float					fColdSpotValue;		// Cold Point Temperature ValueMinimum Temperature
	int						nTemperatrueUnit;	// Unit of temperature:0 degrees Celsius, 1 degrees Fahrenheit
	BYTE					byReserved[256];	// Reserved byte
} NET_RADIOMETRY_CURRENTHOTCOLDSPOT_INFO;

// CLIENT_GetRadiometryCurrentHotColdSpotInfo out parameter
typedef struct	tagNET_OUT_RADIOMETRY_CURRENTHOTCOLDSPOT_INFO
{
	DWORD										dwSize;
	NET_RADIOMETRY_CURRENTHOTCOLDSPOT_INFO		stuCurrentHotColdSpotInfo;	//Current cold(minimum) and hot(maximum)point imformation of thermal imagimg
} NET_OUT_RADIOMETRY_CURRENTHOTCOLDSPOT_INFO;

// Obtaining the imformation of current cold(minimum)and hot(maximum)points in thermal imaging
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RadiometryGetCurrentHotColdSpotInfo(LLONG lLoginID, const NET_IN_RADIOMETRY_CURRENTHOTCOLDSPOT_INFO* pInParam, NET_OUT_RADIOMETRY_CURRENTHOTCOLDSPOT_INFO* pOutParam, int nWaitTime);

#define MAX_RADIOMETRY_TEMPER_NUM  32          // max radiometry temper number
#define MAX_COORDINATE_NUM  8                  // max coordinate number

// radiometry query type
typedef enum tagEM_RADIOMETRY_QUERY_TYPE 
{
    EM_RADIOMETRY_QUERY_TYPE_UNKNOWN,                       // unknown
    EM_RADIOMETRY_QUERY_TYPE_SPOT,                          // spot
    EM_RADIOMETRY_QUERY_TYPE_AREA,                          // area
    EM_RADIOMETRY_QUERY_TYPE_LINE,                          // line
} EM_RADIOMETRY_QUERY_TYPE;

// temper info
typedef struct tagNET_QUERY_TEMPER_INFO
{
    float               fTemperAve;                         // average temper
    float               fTemperMax;                         // max temper 
    float               fTemperMin;                         // min temper
    BYTE                byReserved[128];                    // reserved
} NET_QUERY_TEMPER_INFO;

// radiometry query result info
typedef struct tagNET_RADIOMETRY_QUERY_INFO
{
    NET_TIME                     stuTime;                            // record time
    int                          nPresetId;                          // preset id
    int                          nRuleId;                            // rule id
    EM_RADIOMETRY_QUERY_TYPE     emQueryType;                        // query type
    char                         szName[MAX_COMMON_STRING_64];       // query name
    NET_POINT                    stuCoordinate[MAX_COORDINATE_NUM];  // query temperature measurement coordinate
    int                          nChannel;                           // channel number
    NET_TEMPERATURE_UNIT         emTemperatureUnit;                  // temperature unit
    NET_QUERY_TEMPER_INFO        stuQueryTemperInfo;                 // temper info
    BYTE                         byReserved[256];                    // reserved
} NET_RADIOMETRY_QUERY_INFO;

// radiometry temper data
typedef struct tagNET_RADIOMETRY_TEMPER_DATA
{
    int                         nRadiometryTemperNum;                                         // radiometry temper info number
    NET_RADIOMETRY_QUERY_INFO   stuRadiometryTemperInfo[MAX_RADIOMETRY_TEMPER_NUM];           // radiometry temper info
    BYTE                        byReserved[512];                                              // reserved
} NET_RADIOMETRY_TEMPER_DATA;

//////////////////////////////////////////////////////////////////////////
/// \fn radiometry temper data state callback function 
/// \brief 
/// \param  LLONG lAttachTemperHandle [OUT] subscription handle, CLIENT_RadiometryAttachTemper returned value
/// \param  NET_RADIOMETRY_TEMPER_DATA* pBuf [OUT] radiometry temper data
/// \param  int nBufLen [OUT] state info length
/// \param  param  LDWORD dwUser user data
/// \return none
///////////////////////////////////////////////////////////////////////////
typedef void (CALLBACK *fRadiometryAttachTemperCB)(LLONG lAttachTemperHandle, NET_RADIOMETRY_TEMPER_DATA* pBuf, int nBufLen, LDWORD dwUser);

// CLIENT_RadiometryAttachTemper input parameter
typedef struct tagNET_IN_RADIOMETRY_ATTACH_TEMPER
{
    DWORD                        dwSize;                             // struct size
    int                          nChannel;                           // channel number
    fRadiometryAttachTemperCB    cbNotify;                           // state callback function pointer
    LDWORD                       dwUser;                             // user data
} NET_IN_RADIOMETRY_ATTACH_TEMPER;

// CLIENT_RadiometryAttachTemper output parameter
typedef struct tagNET_OUT_RADIOMETRY_ATTACH_TEMPER
{
    DWORD               dwSize;                                      // struct size
} NET_OUT_RADIOMETRY_ATTACH_TEMPER;

// subscribe radiometry temper data, user malloc and free memory of pInParam and pOutParam
CLIENT_NET_API LLONG CALL_METHOD CLIENT_RadiometryAttachTemper(LLONG lLoginID, const NET_IN_RADIOMETRY_ATTACH_TEMPER* pInParam, NET_OUT_RADIOMETRY_ATTACH_TEMPER* pOutParam, int nWaitTime);

// cancel subscribing radiometry temper data, lAttachTemperHandle is the returned value of CLIENT_RadiometryAttachTemper
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RadiometryDetachTemper(LLONG lAttachTemperHandle);

//////////////////////////////////////////////////////////////////////////
// query the information of flux
//////////////////////////////////////////////////////////////////////////

// input parameter for flux information
typedef struct tagNET_IN_SIM_CARD_FLUX_INFO
{	
	DWORD dwSize;                 // size of this struct
	int nCardIndex;               // sim number, start from zero
}NET_IN_SIM_CARD_FLUX_INFO;

#define NET_FLUX_RECORD_MAX_NUM 7      // the max count for information of flux

// information of flux structure
typedef struct tagNET_SIM_CARD_FLUX_RECORD
{	
	NET_TIME stuDate;            // date
	UINT nDaySendFlux;           // the up flux on that day, unit:0.1kb
	UINT nDayRecvFlux;           // the down flux on that day, unit:0.1kb
	BYTE byReserved[512];        // reserved bytes

}NET_SIM_CARD_FLUX_RECORD;

// output parameter for flux information
typedef struct tagNET_OUT_SIM_CARD_FLUX_INFO
{
	DWORD dwSize;                                        // size of this struct        
	UINT nTotalFlux;                                     // the total flux, unit: 0.1kb  
	UINT nSendFlux;                                      // the up flux, unit: 0.1kb 
	UINT nRecvFlux;                                      // the down flux, unit: 0.1kb
	NET_TIME stuTime;                                    // the date of writing in the total flux
	int nRecordNum;                                      // the number of records, this value must LE NET_RECORD_MAX_NUM
	NET_SIM_CARD_FLUX_RECORD stuRecord[NET_FLUX_RECORD_MAX_NUM];  // the records of the last seven days
	UINT nLastMonthTotalFlux;                                     // the total flux of last month , unit: 0.1kb

}NET_OUT_SIM_CARD_FLUX_INFO;

// get the flux informattion of the sim card,user malloc memory of pNetDataIn and pNetDataOut
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSimCardFlux(LLONG lLoginID,const NET_IN_SIM_CARD_FLUX_INFO* pNetDataIn,NET_OUT_SIM_CARD_FLUX_INFO* pNetDataOut,int nWaitTime );

// set the work mode of door,user malloc memory of pNetDataIn and pNetDataOut
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDoorWorkMode(LLONG lLoginID,const NET_IN_CTRL_ACCESS_SET_DOOR_WORK_MODE* pNetDataIn,NET_OUT_CTRL_ACCESS_SET_DOOR_WORK_MODE* pNetDataOut,int nWaitTime );

// control the cabin's led,please refer to emType to ensure structure,then ensure memory size
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ControlCabinLED(LLONG lLoginID, EM_CABIN_LED_CONTROL_TYPE emType,const void *pInParam, void* pOutParam, int nWaitTime );


#define NET_SELECT_UPDATE_LOCK_MAX_NUM 32               // the max selection count when updating lock

// intput param for smart lock's channel info
typedef struct tagNET_IN_SELECT_UPDATE_LOCK_INFO
{
    DWORD dwSize;
    int nChannelNum;                                    // count of selected smart locks
    int nChannel[NET_SELECT_UPDATE_LOCK_MAX_NUM];       // array of selected smart lock channels
}NET_IN_SELECT_UPDATE_LOCK_INFO;

// output param for smart lock's channel info
typedef struct tagNET_OUT_SELECT_UPDATE_LOCK_INFO
{
    DWORD dwSize;   
}NET_OUT_SELECT_UPDATE_LOCK_INFO;

// select the smart lock(s) by channel(s),user malloc memory of pNetDataIn and pNetDataOut
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SelectLockToUpdate(LLONG lLoginID,const NET_IN_SELECT_UPDATE_LOCK_INFO* pNetDataIn,NET_OUT_SELECT_UPDATE_LOCK_INFO* pNetDataOut,int nWaitTime );

typedef enum tagEM_AUTHORITY_SUB_TYPE
{
    EM_AUTHORITY_SUB_TYPE_UNKNOWN,                            // Unknown
    EM_AUTHORITY_SUB_TYPE_SHUT_DOWN,                          // shut down device
    EM_AUTHORITY_SUB_TYPE_MONITOR,                            // monitor for all channel
    EM_AUTHORITY_SUB_TYPE_MONITOR_FOR_CHANNEL,                // monitor for some channel
    EM_AUTHORITY_SUB_TYPE_REPLAY,                             // replay for all channel
    EM_AUTHORITY_SUB_TYPE_REPLAY_FOR_CHANNEL,                 // replay for some channel
    EM_AUTHORITY_SUB_TYPE_BACKUP,                             // back up record file
    EM_AUTHORITY_SUB_TYPE_MHARDISK,                           // manage the hard disk
    EM_AUTHORITY_SUB_TYPE_MPTZ,                               // manage the PTZ(invalided if HasPtz is false)
    EM_AUTHORITY_SUB_TYPE_ACCOUNT,                            // account
    EM_AUTHORITY_SUB_TYPE_QUERY_LOG,                          // query log
    EM_AUTHORITY_SUB_TYPE_DEL_LOG,                            // delete log 
    EM_AUTHORITY_SUB_TYPE_SYS_UPDATE,                         // update system
    EM_AUTHORITY_SUB_TYPE_AUTO_MAINTAIN,                      // auto maintain
    EM_AUTHORITY_SUB_TYPE_GENERAL_CONF,                       // general config
    EM_AUTHORITY_SUB_TYPE_ENCODE_CONF,                        // encode config
    EM_AUTHORITY_SUB_TYPE_RECORD,                             // record file
    EM_AUTHORITY_SUB_TYPE_RECORD_CONF,                        // record config
    EM_AUTHORITY_SUB_TYPE_COM_CONF,                           // com config
    EM_AUTHORITY_SUB_TYPE_NET_CONF,                           // net config
    EM_AUTHORITY_SUB_TYPE_ALARM,                              // alarm I/O config
    EM_AUTHORITY_SUB_TYPE_ALARM_CONF,                         // alarm config
    EM_AUTHORITY_SUB_TYPE_VIDEO_CONFIG,                       // video config
    EM_AUTHORITY_SUB_TYPE_PTZ_CONFIG,                         // PTZ config
    EM_AUTHORITY_SUB_TYPE_OUTPUT_CONFIG,                      // video output config
    EM_AUTHORITY_SUB_TYPE_VIDEO_INPUT_CONFIG,                 // video input config
    EM_AUTHORITY_SUB_TYPE_DEFAULT_CONFIG,                     // default config
    EM_AUTHORITY_SUB_TYPE_BK_CONFIG,                          // backup config
    EM_AUTHORITY_SUB_TYPE_INTELLI_CONFIG,                     // intelli config
    EM_AUTHORITY_SUB_TYPE_REMOTE_DEVICE,                      // add or remove remote device
    EM_AUTHORITY_SUB_TYPE_ATM_POS,                            // atm
    EM_AUTHORITY_SUB_TYPE_OFFLINE_LOGINED_USER,               // kick user
    EM_AUTHORITY_SUB_TYPE_AUDIO_AUTH,                         // audio
    EM_AUTHORITY_SUB_TYPE_SPOT_SET,                           // set spot
    EM_AUTHORITY_SUB_TYPE_TVSET,                              // set tc
    EM_AUTHORITY_SUB_TYPE_IPSAN,                              // manage IPSAN
    EM_AUTHORITY_SUB_TYPE_CONFIG,                             // config
    EM_AUTHORITY_SUB_TYPE_ARMING,                             // arming
    EM_AUTHORITY_SUB_TYPE_DISARM,                             // disarming
    EM_AUTHORITY_SUB_TYPE_BYPASS,                             // bypass
    EM_AUTHORITY_SUB_TYPE_BYPASS_PARTIAL,                     // bypass fo some channel
    EM_AUTHORITY_SUB_TYPE_ALARM_BELL,                         // alarm bell
    EM_AUTHORITY_SUB_TYPE_ALARM_CONFIRM_PARTIAL,              // alarm config for some channel
    EM_AUTHORITY_SUB_TYPE_DEFENCE_CONFIG_PARTIAL,             // defence config for some channel
    EM_AUTHORITY_SUB_TYPE_ALARM_OUT_PARITAL,                  // alarm output config for some channel
    EM_AUTHORITY_SUB_TYPE_TALK,                               // talk
    EM_AUTHORITY_SUB_TYPE_WIRELESS_CONFIG,                    // wireless config
    EM_AUTHORITY_SUB_TYPE_MOBILE_CONFIG,                      // mobile config
    EM_AUTHORITY_SUB_TYPE_AUDIO_DETECT_CONFIG,                // audio detection config
    EM_AUTHORITY_SUB_TYPE_NET_PREVIEW_FOR_CHANNEL,            // net preview for some channel

    EM_AUTHORITY_SUB_TYPE_REBOOT,                             // reboot
    EM_AUTHORITY_SUB_TYPE_SYS_LENS,                           // system lens
    EM_AUTHORITY_SUB_TYPE_RAIN_BRUSH_CONFIG,                  // rain brush config
    EM_AUTHORITY_SUB_TYPE_LIGHTING_CONFIG,                    // lighting config
    EM_AUTHORITY_SUB_TYPE_ACCESS_CONTROL,                     // access control for all channel
    EM_AUTHORITY_SUB_TYPE_ACCESS_CONTROL_PARTIAL,             // access control for some channel
    EM_AUTHORITY_SUB_TYPE_DECODE_TOUR,                        // decode tour
    EM_AUTHORITY_SUB_TYPE_VIDEO_OUT,                          // video out
    EM_AUTHORITY_SUB_TYPE_PTZ_FOR_CHANNEL,                    // ptz for some channel
    EM_AUTHORITY_SUB_TYPE_MODIFY_LANGUANGE,                   // modify languange
    EM_AUTHORITY_SUB_TYPE_MODIFY_VIDEO,                       // modify video
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_CONTROL,              // course record control
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_SCHEDULE,             // course record schedule
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_MODIFY_SCHEDULE,      // course record modify schedule
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_INTELL_PARAM,         // course record intell param
    EM_AUTHORITY_SUB_TYPE_CAMERA_PERIPHERAL,                  // camera peripheral
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_DOWNLOAD_MEDIA_FILE,  // course record download media file
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_MODIFY_MEDIA_FILE,    // course record modify media file
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_DELETE_MEDIA_FILE,    // course record delete media file
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_BACKUP_TO_USB,        // course record backup to usb
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_BACKUP_TO_FTP,        // course record backup to ftp
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_EXPORT_ACCONUT,       // course record export account
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_QUERY_ACCOUNT,        // course record query account
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_MODIFY_ACCOUNT,       // course record modify account
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_RESET_PASSWORD,       // course record reset password
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_AUTHORITY,            // course record authority
}EM_AUTHORITY_SUB_TYPE;

typedef enum tagEM_AUTHORITY_MAIN_TYPE
{
    EM_AUTHORITY_MAIN_TYPE_UNKNOWN,            // Unknown
    EM_AUTHORITY_MAIN_TYPE_AUTH_USER_MAG,      // user manage
    EM_AUTHORITY_MAIN_TYPE_AUTH_SYS_CFG,       // system config
    EM_AUTHORITY_MAIN_TYPE_AUTH_OFFLINE_USER,  // offline user
    EM_AUTHORITY_MAIN_TYPE_AUTH_DF_UD,         // default and update
    EM_AUTHORITY_MAIN_TYPE_AUTH_PTZ_CTR,       // ptz control
    EM_AUTHORITY_MAIN_TYPE_AUTH_SYS_INFO,      // system info
    EM_AUTHORITY_MAIN_TYPE_AUTH_MANU_CTR,      // manual control
    EM_AUTHORITY_MAIN_TYPE_AUTH_BACKUP,        // back up file
    EM_AUTHORITY_MAIN_TYPE_AUTH_COLOR_SET,     // color set
    EM_AUTHORITY_MAIN_TYPE_AUTH_STORE_CFG,     // store config
    EM_AUTHORITY_MAIN_TYPE_AUTH_EVENT_CFG,     // event config
    EM_AUTHORITY_MAIN_TYPE_AUTH_NET_CFG,       // net config
    EM_AUTHORITY_MAIN_TYPE_AUTH_RMT_DEVICE,    // remote device
    EM_AUTHORITY_MAIN_TYPE_AUTH_DEL_LOG,       // delete log
    EM_AUTHORITY_MAIN_TYPE_AUTH_SHUTDOWN,      // shut down device
}EM_AUTHORITY_MAIN_TYPE;

#define NET_AUTHORITY_CLASS_MAX_NUM 256      // the max num for authority type

// authority info 
typedef struct tagNET_AUTH_CLASSIFY_INFO
{	    
    EM_AUTHORITY_MAIN_TYPE  emMainAuthority;    // the main authority
    EM_AUTHORITY_SUB_TYPE   emSubAuthority;     // the sub authority
    int                     nChannel;           // the channel
                                                // it is valid only when the emSubAuthority is EM_AUTHORITY_SUB_TYPE_MONITOR_FOR_CHANNEL,
                                                // EM_AUTHORITY_SUB_TYPE_REPLAY_FOR_CHANNEL,EM_AUTHORITY_SUB_TYPE_NET_PREVIEW_FOR_CHANNEL or EM_AUTHORITY_SUB_TYPE_PTZ_FOR_CHANNEL.

    BYTE                    byReserved[128];    // reserved
}NET_AUTH_CLASSIFY_INFO;

// input param for authority info
typedef struct tagNET_IN_GET_AUTHORITY_INFO_LIST
{
    DWORD dwSize;
}NET_IN_GET_AUTHORITY_INFO_LIST;

// output param for authority info
typedef struct tagNET_OUT_GET_AUTHORITY_INFO_LIST
{
    DWORD dwSize;
    int nRetAuthInfoCount;                                          // the returen num of authority info
    NET_AUTH_CLASSIFY_INFO stuAuthInfo[NET_AUTHORITY_CLASS_MAX_NUM];// the data of authority info

}NET_OUT_GET_AUTHORITY_INFO_LIST;

// get the list of authority info,user malloc memory of pNetDataIn and pNetDataOut
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetAuthClassifyList(LLONG lLoginID,const NET_IN_GET_AUTHORITY_INFO_LIST* pNetDataIn,NET_OUT_GET_AUTHORITY_INFO_LIST* pNetDataOut,int nWaitTime );

//////////////////////////////////////////////////////////////////////////
// Capability Information
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
//	Search Type
typedef enum
{
	ABILITY_DYNAMIC_CONNECT = 1,        // dynamic connect capacity,corrresponding type is BOOL
	ABILITY_WATERMARK_CFG = 17,			// Watermark configuration capacity,the coresponding structure is DH_WATERMAKE_EN
	ABILITY_WIRELESS_CFG = 18,			// wireless  configuration capacity,the coresponding structure is DH_WIRELESS_EN
	ABILITY_DEVALL_INFO = 26,			// Device capacity list,the coresponding structure is DH_DEV_ENABLE_INFO 
	ABILITY_CARD_QUERY = 0x0100,		// Card number search capacity,the coresponding structure is DH_CARD_QUERY_EN 
	ABILITY_MULTIPLAY = 0x0101,			// Multiple-window preview capacity,the coresponding structure is  DH_MULTIPLAY_EN
	ABILITY_QUICK_QUERY_CFG = 0x0102,	// Fast query configuration Capabilities,the coresponding structure is DH_QUICK_QUERY_CFG_EN
	ABILITY_INFRARED = 0x0121,			// Wireless alarm capacity ,the coresponding structure is DH_WIRELESS_ALARM_INFO
	ABILITY_TRIGGER_MODE = 0x0131,		// Alarm activation mode function,corresponding type is int
	ABILITY_DISK_SUBAREA = 0x0141,		// Network hard disk partition,the coresponding structure is DH_DISK_SUBAREA_EN
	ABILITY_DSP_CFG = 0x0151,			// Query DSP Capabilities,the coresponding structure is DH_DSP_CFG
	ABILITY_STREAM_MEDIA = 0x0161,		// Query SIP,RTSP Capabilities,the coresponding structure is DH_STREAM_MEDIA_EN
	ABILITY_INTELLI_TRACKER = 0x0171,   // Search intelligent track capability,the coresponding structure is DH_INTELLI_TRACKER_EN
} DH_SYS_ABILITY;

//////////////////////////////////////////////////////////////////////////
//	The function list device supported 
enum 
{
	EN_FTP = 0,						// FTP bitwise, 1: send out record file;  2: Send out snapshot file
	EN_SMTP,						// SMTP bitwise,1: alarm send out text mail 2: Alarm send out image3:support HealthMail
	EN_NTP,							// NTP	 Bitwise:1:Adjust system time 
	EN_AUTO_MAINTAIN,				// Auto maintenance  Bitwise:1:reboot 2:close  3:delete file
	EN_VIDEO_COVER,					// Privacy mask Bitwise  :1:multiple-window privacy mask 
	EN_AUTO_REGISTER,				// Auto registration	Bitwise:1:SDK auto log in after registration 
	EN_DHCP,						// DHCP	Bitwise 1:DHCP
	EN_UPNP,						// UPNP	Bitwise 1:UPNP
	EN_COMM_SNIFFER,				// COM sniffer  Bitwise :1:CommATM
	EN_NET_SNIFFER,					// Network sniffer Bitwise : 1:NetSniffer
	EN_BURN,						// Burn function Bitwise 1:Search burn status 
	EN_VIDEO_MATRIX,				// Video matrix Bitwise  1:Support video matrix or not 2:Support SPOT video matrix or not
	EN_AUDIO_DETECT,				// Video detection Bitwise :1:Support video detection or not 
	EN_STORAGE_STATION,				// Storage position Bitwise:1:Ftp server (Ips) 2:SBM 3:NFS 16:DISK 17:Flash disk 
	EN_IPSSEARCH,					// IPS storage search  Bitwise  1:IPS storage search 	
	EN_SNAP,						// Snapshot Bitwise  1:Resoluiton 2:Frame rate 3:Snapshoot  4:Snapshoot file image; 5:Image quality 
	EN_DEFAULTNIC,					// Search default network card search  Bitwise  1:Support
	EN_SHOWQUALITY,					// Image quality configuration time in CBR mode 1:support 
	EN_CONFIG_IMEXPORT,				// Configuration import& emport function capacity.  Bitwise   1:support 
	EN_LOG,							// Support search log page by page or not. Bitwise 1:support 
	EN_SCHEDULE,					// Record setup capacity. Bitwise  1:Redandunce  2:Pre-record 3:Record period
	EN_NETWORK_TYPE,				// Network type. Bitwise 1:Wire Network 2:Wireless Network 3:CDMA/GPRS,4:CDMA/GPRS multi network card
	EN_MARK_IMPORTANTRECORD,		// Important record. Bitwise 1:Important record mark
	EN_ACFCONTROL,					// Frame rate control activities. Bitwise 1:support frame rate control activities;2:support timing alarm type activate frame rate control(it does not support dynamic detection), this ability mutually exclusive with ACF ability.
	EN_MULTIASSIOPTION,				// Multiple-channel extra stream. Bitwise:1:support three channel extra stream
	EN_DAVINCIMODULE,				// Component modules bitwise: 1.Separate processing the schedule 2.Standard I franme Interval setting
	EN_GPS,                         // GPS function bitwise:1:Gps locate function,2:GPS Retransmit	
	EN_MULTIETHERNET,				// Support multi net card query   bitwise: 1: support
	EN_LOGIN_ATTRIBUTE,             // Login properties   bitwise: 1: support query login properties  
	EN_RECORD_GENERAL,				// Recording associated  bitwise: 1:Normal recording; 2:Alarm recording; 
									// 3:Motion detection recording;  4:Local storage; 5: Network storage ;  
									// 6:Redundancy storage;  7:Local emergency storage
	EN_JSON_CONFIG,					// Whether support Json configuration, bitwise: 1: support Json
	EN_HIDE_FUNCTION,				// Hide function:bitwise::1,hide PTZ function
	EN_DISK_DAMAGE,                 // Harddisk damage information support ability: bitwise:1,harddisk damage information
	EN_PLAYBACK_SPEED_CTRL,			// Support playback network transmission speed control, bitwise::1 support playback acceleration 
	EN_HOLIDAYSCHEDULE,				// Support holiday period setup : bitwise:1,Support holiday period setup 
	EN_FETCH_MONEY_TIMEOUT,			// ATM fetch money overtime
	EN_BACKUP_VIDEO_FORMAT,			// Device backup support format. DAV, ASF
	EN_QUERY_DISK_TYPE,             // backup disk type query
	EN_CONFIG_DISPLAY_OUTPUT,       // backup device output of display (such as VGA) configuration, by bit: 1: configuration on tour of frame segmentation 
	EN_SUBBITRATE_RECORD_CTRL,      // backup extra stream control configuration, by bit: 1-extra stream control configuration
	EN_IPV6,                        // backup IPV6 configuration, by bit:1-IPV6 configuration
   	EN_SNMP,                        // SNMP
	EN_QUERY_URL,                   // back up query device's URL info, by bit: 1-query device's config URL info
	EN_ISCSI,						// ISCSI
	EN_RAID,						// Raid
	EN_HARDDISK_INFO,				// Support disk info query
	EN_PICINPIC,                    // support picture in pictu,by bit:1,set; 2,preview , record , query record , download record
	EN_PLAYBACK_SPEED_CTRL_SUPPORT, // same to EN_PLAYBACK_SPEED_CTRL
	EN_LF_XDEV,						// support LF-X series of 24, 32, 64 channels, label their encode ability with sepcial calculation, by bit 1: able;
	EN_DSP_ENCODE_CAP,				// support F5 DSP encode
	EN_MULTICAST,                   // support different multicast config for different channel
	EM_NET_LIMIT,   				// query the limit ability of net, bitwise,1-limit size of net send code stream,2-user operate data encrypt,4-config data encrypt,8-config data encrypt extend, 16-face DB import and export encrypt 
	EM_COM422, 						// serial port 422
	EM_PROTOCAL_FRAMEWORK,			// support three generations of framework agrement or not(need actualize listMethod(),listService()),by F6 to visit
	EM_WRITE_DISK_OSD,				// write disk OSD overlying ,bitwise, 1-write disk OSD overlying configuration
	EM_DYNAMIC_MULTI_CONNECT,		// dynamic multi-connect,bitise,1-request reply video data
	EM_CLOUDSERVICE,  				// cloud service,bitwise,1- support private cloud service
	EM_RECORD_INFO,					// Video Information Report, by bit. 1-Active video information report, 2-Frame numbers inquiry support
	EN_DYNAMIC_REG,                 // Active Register Support, by bit. 1- Dynamic active register support. 2-IP and port allow 0 when SDK ask a dynamic link in active register
	EM_MULTI_PLAYBACK,              // Multi-channel Preview and Playback, by bit. 1-Multi-channel preview and playback support.
	EN_ENCODE_CHN,					// Encoding Channel, by bit. 1- Audio-only channel support
    EN_SEARCH_RECORD,               // Record search, by bit, 1-support sync search record, 2-support 3rd generation protocol search record
    EN_UPDATE_MD5,                  // Support MD5 check after update file send finish, 1- support MD5   2-support 3rd generation protocol upgrade
	EN_PROTOCOL3ToF6,               // protocol3 to F6, 1-support log 2.restore config by configManager.deleteFile protocol
	EN_COMPOSECHANNEL,				// Compose Channel, 1-RemotePreview
	EN_PLAYBACK,					// PlayBack ability 1-secondary analyse
};
typedef struct 
{
	DWORD IsFucEnable[512];			// Function list capacity set. Corresponding to the above mentioned enumeration. Use bit to represent sub-function.
} DH_DEV_ENABLE_INFO;

//////////////////////////////////////////////////////////////////////////
//Card number search function structure 
typedef struct 
{
	char		IsCardQueryEnable;
	char		iRev[3];
} DH_CARD_QUERY_EN;

//////////////////////////////////////////////////////////////////////////
//	Wireless capacity structure 
typedef struct 
{
	char		IsWirelessEnable;
	char		iRev[3];
} DH_WIRELESS_EN;

//////////////////////////////////////////////////////////////////////////
//	Image watermark capacity structure 
typedef struct 
{
	char		isSupportWM;		// 1:Support; 0 Do not support
	char		supportWhat;		// 0:Characrer watermark; 1:Image watermark; 2:Support character watermark and image watermark at the same time.
	char		reserved[2];
} DH_WATERMAKE_EN;

//////////////////////////////////////////////////////////////////////////
//	Multiple-window preview capacity structure 
typedef struct  
{
	int			nEnable;				// 1:Support;  0 :Do not support 
	DWORD		dwMultiPlayMask;		// Multiple-window preview mask 
	char		reserved[4];			// Reserved 
} DH_MULTIPLAY_EN;

//////////////////////////////////////////////////////////////////////////
//	Wireless alarm capacity structure 
typedef struct  
{
	BOOL		bSupport;				// Support or not 
	int			nAlarmInCount;			// Input amount
	int			nAlarmOutCount;			// Output amount 
	int			nRemoteAddrCount;		// Remote control amount 
	BYTE		reserved[32];
}DH_WIRELESS_ALARM_INFO;

//////////////////////////////////////////////////////////////////////////
// Network hard disk partition capacity structure
typedef struct 
{
	BOOL		bSupported;				// Support or not
	int			nSupportNum;			// Support the number of disk partition
	BYTE		bReserved[32];
} DH_DISK_SUBAREA_EN;

// DSP capabilities query ,use when DSP capabilities algorithm with ID 2.
typedef struct  
{
	BYTE bMainFrame[32];				//Use the resolution enumeration value (CAPTURE_SIZE) as index, the main code stream corresponds to the max resolution it support, if do not support, the value should be 0.
	BYTE bExtraFrame_1[32];				//Extra code stream1,use the same method as: bMainFrame
	BYTE bReserved[128];				//obligate for extra code stream 2 and 3.		
}DH_DSP_CFG_ITEM;

typedef struct  
{
	int nItemNum;						//Valid number of DH_DSP_CFG_ITEM, equals to channel number
	DH_DSP_CFG_ITEM	stuDspCfgItem[32];	//Main code stream Information
	BYTE bReserved[128];				//Retain
}DH_DSP_CFG; 

//////////////////////////////////////////////////////////////////////////
//	Fast query configuration capabilities struct 
typedef struct 
{
	char		IsQuickQueryEnable;    //1 is device support configuration command go back easily,please set enough configuration time to ensure reading the configuration in narrowband. Recommended for 60S
	char		iRev[3];
} DH_QUICK_QUERY_CFG_EN;

typedef struct  
{
	int			nStreamType;			// 0,null 1,SIP 2,RTSP
	BYTE		bReserved[16];			// Reserved
} DH_STREAM_MEDIA_EN;

//Search intelligent speed dome track capability 
typedef struct
{
	char		IsIntelliTrackerEnable;	// Has intelligent speed dome track capability if it is more than 0
	BYTE		bReserved[3];
}DH_INTELLI_TRACKER_EN;

#define NET_MAX_COMPOSITE_CHANNEL       256                 // Max number of composite channel 

// The input parameters of Getting Composite caps, corresponding to NET_COMPOSITE_CAPS
typedef struct tagNET_IN_COMPOSITE_CAPS 
{
    DWORD           dwSize;
    int             nChannelCount;                          // Channel count
    int             nChannels[NET_MAX_COMPOSITE_CHANNEL];   // Channel list
    int             nLayoutX;                               // window count of horizontal
    int             nLayoutY;                               // window count of vertical
} NET_IN_COMPOSITE_CAPS;

// The output parameters of Getting Composite caps, corresponding to NET_COMPOSITE_CAPS
typedef struct tagNET_OUT_COMPOSITE_CAPS 
{
    DWORD           dwSize;
    int             nSplitModeCount;                        // number of split mode 
    DH_SPLIT_MODE   emSplitModes[DH_MAX_SPLIT_MODE_NUM];    // list of split mode 
    int             nMaxFreeWindow;                         // max number of free window
} NET_OUT_COMPOSITE_CAPS;

#define MAX_REGISTER_ID_LEN       (256)
#define MAX_APP_ID_LEN            (256)
#define MAX_URL_LEN               (1024)
#define MAX_IOS_CERTIFICATE_LEN   (1024 * 14)
#define MAX_IOS_SECRET_KEY_LEN    (512)
#define MAX_MOBILE_CHANNEL_NUM    (256)

// Mobile server type
typedef enum tagEM_MOBILE_SERVER_TYPE
{
    EM_MOBILE_SERVER_TYPE_UNKNOWN,             // Unknown
    EM_MOBILE_SERVER_TYPE_APPLE,               // Apple
    EM_MOBILE_SERVER_TYPE_ANDROID,             // Android
    EM_MOBILE_SERVER_TYPE_SDKCLOUD,            // Private_CLOUD
} EM_MOBILE_SERVER_TYPE;

// Push server config info
typedef struct tagNET_PUSH_SERVER_INFO
{
    char                            szAddress[MAX_URL_LEN];                    // ip address
    int                             nPort;                                     // port
} NET_PUSH_SERVER_INFO;

// Event sub code type
typedef enum tagEM_EVENT_SUB_CODE
{
    EM_EVENT_SUB_CODE_UNKNOWN = -1,            // Unknown
    EM_EVENT_SUB_CODE_LOSS,                    // Loss
    EM_EVENT_SUB_CODE_COVER,                   // Cover
    EM_EVENT_SUB_CODE_FROZEN,                  // Frozen
    EM_EVENT_SUB_CODE_LIGHT,                   // Light
    EM_EVENT_SUB_CODE_DARK,                    // Dark
    EM_EVENT_SUB_CODE_SCENECHANGE,             // SceneChange
} EM_EVENT_SUB_CODE;

// Subscrbie info
typedef struct tagNET_SUBSCRIBE_INFO
{
    int                             nCode;                                     // Event code
    EM_EVENT_SUB_CODE               emSubCode;                                 // Sub Event code, invaild when it is EM_EVENT_SUB_CODE_UNKNOWN
    int                             nChnNum;                                   // channel number 
    int                             nIndexs[MAX_MOBILE_CHANNEL_NUM];           // channel aggregate
    char                            szNumber[DH_COMMON_STRING_16];             // effective when attach "CallNoAnswered " 
                                                                               // no responsion number (pushing notify to mobile when device call to these number)
    char                            szSound[DH_COMMON_STRING_64];              // played sound file when receiving event 
    char                            szIndexsExt[DH_COMMON_STRING_32][DH_COMMON_STRING_16];     //channel aggregate extension
} NET_SUBSCRIBE_INFO;

// Push gateway type
typedef enum tagEM_PUSH_GATEWAY_TYPE
{
    EM_PUSH_GATEWAY_TYPE_UNKNOWN,              // Unknown
    EM_PUSH_GATEWAY_TYPE_APPLE_PUSH,           // ApplePush
    EM_PUSH_GATEWAY_TYPE_ANDROID_SDKPUSH,      // AndroidPrivatePush
    EM_PUSH_GATEWAY_TYPE_ANDROID_JPUSH,        // AndroidJPush
    EM_PUSH_GATEWAY_TYPE_ANDROID_GCM,          // AndroidGCM
} EM_PUSH_GATEWAY_TYPE;

// Mobile push notification, use RegisterID to subscribe
typedef struct tagNET_MOBILE_PUSH_NOTIFY
{
    DWORD                           dwSize;
    char                            szRegisterID[MAX_REGISTER_ID_LEN];         // register ID, 
    EM_MOBILE_SERVER_TYPE           emServerType;                              // server type 
    int                             nPeriodOfValidity;                         // Period Of Validity
    char                            szAuthServerAddr[MAX_URL_LEN];             // Android server address
    int                             nAuthServerPort;                           // Android server port 
    char                            szPushServerAddr[MAX_URL_LEN];             // push server address 
    int                             nPushServerPort;                           // push server port
    NET_PUSH_SERVER_INFO            stuPushServerMain;                         // push server config 
    NET_PUSH_SERVER_INFO            stuPushRedirectServer;                     // Push Redirect Server config
    char                            szDevName[DH_COMMON_STRING_64];            // Device name
    char                            szDevID[DH_COMMON_STRING_64];              // Device ID
    char                            szUser[DH_COMMON_STRING_64];               // User name
    char                            szPassword[DH_COMMON_STRING_64];           // Password
    char                            szCertificate[MAX_IOS_CERTIFICATE_LEN];    // Certificate
    char                            szSecretKey[MAX_IOS_SECRET_KEY_LEN];       // Secret Key
    int                             nSubScribeMax;                             // max number of subscribe 
    int                             nSubScribeNum;                             // number of subscribe
    NET_SUBSCRIBE_INFO             *pstuSubscribes;                            // subscribe info, user malloc memory,apply to sizeof(NET_SUBSCRIBE_INFO)*nSubScribeMax
} NET_MOBILE_PUSH_NOTIFY;

// Delete mobile push notification, CLIENT_DelMobilePushNotify's input param
typedef struct tagNET_MOBILE_PUSH_NOTIFY_DEL
{
    DWORD                           dwSize;
    char                            szRegisterID[MAX_REGISTER_ID_LEN];         // Register ID
} NET_MOBILE_PUSH_NOTIFY_DEL;

// Mobile push notification config,  use RegisterID + AppID to subscribe
typedef struct tagNET_MOBILE_PUSH_NOTIFY_CFG
{
    DWORD                           dwSize;
    char                            szRegisterID[MAX_REGISTER_ID_LEN];         // Register ID
    char                            szAppID[MAX_APP_ID_LEN];                   // AppID
    EM_MOBILE_SERVER_TYPE           emServerType;                              // Server Type
    EM_PUSH_GATEWAY_TYPE            emPushGatewayType;                         // Push Gateway Type
    int                             nPeriodOfValidity;                         // Period Of Validity
    char                            szAuthServerAddr[MAX_URL_LEN];             // Android server address
    int                             nAuthServerPort;                           // Android server port 
    char                            szPushServerAddr[MAX_URL_LEN];             // push server address
    int                             nPushServerPort;                           // push server port
    char                            szDevName[DH_COMMON_STRING_64];            // device name
    char                            szDevID[DH_COMMON_STRING_64];              // device ID
    char                            szUser[DH_COMMON_STRING_64];               // User
    char                            szPassword[DH_COMMON_STRING_64];           // Password
    char                            szCertificate[MAX_IOS_CERTIFICATE_LEN];    // Certificate
    char                            szSecretKey[MAX_IOS_SECRET_KEY_LEN];       // Secret Key
    int                             nSubScribeMax;                             // max number of subscribe 
    int                             nSubScribeNum;                             // number of subscribe 
    NET_SUBSCRIBE_INFO             *pstuSubscribes;                            // subscribe info, user malloc memory, apply to sizeof(NET_SUBSCRIBE_INFO)*nSubScribeMax
    NET_PUSH_SERVER_INFO            stuPushServerMain;                         // push server config info
    NET_PUSH_SERVER_INFO            stuPushRedirectServer;                     // push redirect server config info
} NET_MOBILE_PUSH_NOTIFY_CFG;

// Delete mobile push notification config, CLIENT_DelMobilePushNotify's input param
typedef struct tagNET_MOBILE_PUSH_NOTIFY_CFG_DEL
{
    DWORD                           dwSize;
    char                            szRegisterID[MAX_REGISTER_ID_LEN];         // Register ID
    char                            szAppID[MAX_APP_ID_LEN];                   // AppID
} NET_MOBILE_PUSH_NOTIFY_CFG_DEL;

//  APP filter login optimize type,operate |
typedef enum tagEM_OPTTYPE_MOBILE_TYPE
{
    OPTTYPE_MOBILE_DEVICE_ATTR    =0x00000001,			// device info
    OPTTYPE_MOBILE_DEVICE_SN      =0x00000002,			// device sequence
    OPTTYPE_MOBILE_DISK_INFO      =0x00000004,			// hard info
    OPTTYPE_MOBILE_DIGITAL_NUM    =0x00000008,			// digital num
    OPTTYPE_MOBILE_ALARM_IO       =0x00000010,			// Alarm IO number
    OPTTYPE_MOBILE_DEVICE_ABILITY =0x00000020,			// Device ability
	OPTTYPE_MOBILE_STATE_SOFTWARE =0x00001000,			// query software APP option
}EM_OPTTYPE_MOBILE_TYPE;

// NetSDK optimize type
typedef enum tagEM_OPTIMIZE_TYPE
{
    EM_OPT_TYPE_DEFAULT     = 0,       // default to do nothing
    EM_OPT_TYPE_MOBILE_V1   = 1,       // optimized for mobileconflict with the EM_OPT_TYPE_MOBILE_OPTION option 
    EM_OPT_TYPE_P2P_NETPARAM_V1 = 2,   // the set for P2P network param,  pParam's type is  NET_PARAM*
	EM_OPT_TYPE_MOBILE_OPTION   = 3,   // conflict with the EM_OPT_TYPE_MOBILE_V1 option 
	                                   //  mobile optimize option, value type int, bit value from low to high, see Enum EM_OPTTYPE_MOBILE_TYPE
}EM_OPTIMIZE_TYPE;

typedef struct tagNET_IN_MOTIONMATCH_PARAM
{
    DWORD                 dwSize;                   // structure size, dwSize needs to make valuation as sizeof(NET_IN_MOTIONMATCH_PARAM) 
    BOOL                  bFileName;                // if filename can be used as valid query condition, if the filename is valid, then it doesn't need to fill in file info (stRecordInfo) 
    char                  szFileName[MAX_PATH];     // file name 
    NET_RECORDFILE_INFO   stuRecordInfo;            // file info 
    int                   nRegionNum;               // number of vertex in rule detection area
    DH_POINT              stuRegion[DH_MAX_DETECT_REGION_NUM];    // rule detection area, x-coordinate 0~21, y-coordinate 0~17
} NET_IN_MOTIONMATCH_PARAM;

typedef struct tagNET_TIME_BEGIN_END
{
    NET_TIME              stuBegin;                 // begin
    NET_TIME              stuEnd;                   // end
} NET_TIME_BEGIN_END;

#define NET_SMART_SEARTCH_TIME_SECTION_MAX (128)

typedef struct tagNET_OUT_MOTIONMATCH_PARAM
{
    DWORD                 dwSize;                   // structure size, dwSize needs to make valuation as sizeof(NET_OUT_MOTIONMATCH_PARAM) 
    int                   nTimeNum;                 // queried time quantum number
    NET_TIME_BEGIN_END    stuTime[NET_SMART_SEARTCH_TIME_SECTION_MAX];   // time quantum
} NET_OUT_MOTIONMATCH_PARAM;

// CLIENT_SnapPictureToFile port input parameter
typedef struct tagNET_IN_SNAP_PIC_TO_FILE_PARAM 
{
    DWORD       dwSize;
    SNAP_PARAMS stuParam;               // snapshot parameter, mode field is only snapshot for once, fail to support timed or continuous snapshot; except mobile DVR, other devices only support snapshot frequency of one snapshot per second
    char        szFilePath[MAX_PATH];   // write in file address
}NET_IN_SNAP_PIC_TO_FILE_PARAM;

// CLIENT_SnapPictureToFile port output parameter
typedef struct tagNET_OUT_SNAP_PIC_TO_FILE_PARAM 
{
    DWORD       dwSize;
    char*       szPicBuf;               // picture content, user memory allocation, memory size is dwPicBufLen
    DWORD       dwPicBufLen;            // picture content memory size, unit: byte
    DWORD       dwPicBufRetLen;         // returned picture size, unit:byte
}NET_OUT_SNAP_PIC_TO_FILE_PARAM;

//alarm event type DH_ALARM_BUS_SHARP_TURN (vehicle sharp turn event) corresponding data description info
typedef struct tagALARM_BUS_SHARP_TURN_INFO
{
    DWORD               dwSize;
    NET_GPS_STATUS_INFO stuGPSStatusInfo;       // GPS info 
} ALARM_BUS_SHARP_TURN_INFO;

//alarm event type DH_ALARM_BUS_SCRAM (vehicle scram event) corresponding data description info 
typedef struct tagALARM_BUS_SCRAM_INFO
{
    DWORD               dwSize;
    NET_GPS_STATUS_INFO stuGPSStatusInfo;       // GPS info 
} ALARM_BUS_SCRAM_INFO;

//alarm event type DH_ALARM_BUS_SHARP_ACCELERATE (vehicle sharp accelerate event) corresponding data description info
typedef struct tagALARM_BUS_SHARP_ACCELERATE_INFO
{
    DWORD               dwSize;
    NET_GPS_STATUS_INFO stuGPSStatusInfo;       // GPS info 
    NET_TIME_EX			stuTime;				// Event occurrence time
} ALARM_BUS_SHARP_ACCELERATE_INFO;

//alarm event type DH_ALARM_BUS_SHARP_DECELERATE(vehicle sharp decelerate event) corresponding data description info 
typedef struct tagALARM_BUS_SHARP_DECELERATE_INFO
{
    DWORD               dwSize;
    NET_GPS_STATUS_INFO stuGPSStatusInfo;       // GPS info 
    NET_TIME_EX			stuTime;				// Event occurrence time
} ALARM_BUS_SHARP_DECELERATE_INFO;


//access control card data operation type               
typedef enum tagNET_ACCESS_ACTION_TYPE        
{       
    NET_ACCESS_ACTION_TYPE_UNKNOWN  = 0,    // unknown               
    NET_ACCESS_ACTION_TYPE_INSERT   = 1,    // insert              
    NET_ACCESS_ACTION_TYPE_UPDATE   = 2,    // update              
    NET_ACCESS_ACTION_TYPE_REMOVE   = 3,    // remove               
}NET_ACCESS_ACTION_TYPE;   
        
//access control card data operation event        
typedef struct tagALARM_ACCESS_CARD_OPERATE_INFO       
{       
    DWORD                   dwSize;       
    NET_ACCESS_ACTION_TYPE  emActionType;                    // access control card data operation type               
    char                    szCardNo[DH_MAX_CARDINFO_LEN];   // access control card number               
    NET_THREE_STATUS_BOOL   emResult;                        // operation result, -1 is unknown, 0 is failure, 1 is success       
    int                     nChannelID;                      // channel ID, start from 0
    char                    szCredentialHolder[16];          // Credential Holder
    NET_ACCESS_METHOD		emType;                          // user type
    char                    szSerialNum[32];                 // Serial Number
    int                     nIndex;                          // index of opendoor method 
	int						nTaskID;						 // Task ID
}ALARM_ACCESS_CARD_OPERATE_INFO;

// alarm event typeDH_EVENT_TAKENAWAYDETECTION (object move event) corresponding data description info  
typedef struct tagALARM_TAKENAWAY_DETECTION_INFO
{
    DWORD               dwSize;    
    int                 nChannelID;                     // channel number
    double              PTS;                            // timestamp (unit is millisecond)
    NET_TIME_EX         UTC;                            // event occurrence time
    int                 nEventID;                       // event ID 
    int                 nEventAction;                   // event action, 0 means pulse event, 1 means continuity event begins, 2 means continuity event ends

    int                 nOccurrenceCount;               // rule triggered occurrence times
    int                 nLevel;                         // event level, GB30147 requirement item, o hint, 1 general, 2 alarm
	short				nPreserID;						// Event triggered preset period, starting from 1 (no unknown)
	char				szPresetName[64];				// Preset name for event triggered
} ALARM_TAKENAWAY_DETECTION_INFO;

// alarm event type DH_EVENT_VIDEOABNORMALDETECTION (video abnormity event) corresponding data description info
typedef struct tagALARM_VIDEOABNORMAL_DETECTION_INFO
{
    DWORD               dwSize;    
    int                 nChannelID;                     // channel number
    double              PTS;                            // timestamp (unit is millisecond)
    NET_TIME_EX         UTC;                            // event occurrence time 
    int                 nEventID;                       // event ID
    int                 nEventAction;                   // event type, 0 means pulse event, 1 means continuity event begins, 2 means continuity event ends

    int                 nType;                          // detection type, 0-video loss, 1-video tampering, 2-image freeze, 3-over brightness, 4-over darkness, 5-scene change
                                                        // 6-stripe detection, 7-noise detection, 8- color cast detection, 9-video fuzziness detection, 10-contrast abnormity detection 
                                                        // 11-Video motion, 12-video flicker, 13-video color, 14- defocus detection, 15-overexposure detection
    int                 nValue;                         // detection value, the higher the value, the poorer the video quality
    int                 nOccurrenceCount;               // occurrence times of rule trigger
} ALARM_VIDEOABNORMAL_DETECTION_INFO;

// Alarm event type DH_EVENT_LOCALALARM (external alarm event) corresponding data description info
typedef struct tagALARM_LOCAL_ALARM_INFO
{
    DWORD               dwSize;    
    int                 nChannelID;                     // channel number
    double              PTS;                            // timestamp (unit is millisecond)
    NET_TIME_EX         UTC;                            // Event occurrence time 
    int                 nEventID;                       // Event ID
    int                 nEventAction;                   // Event action, 0 means pulse event, 1 means continuous event begin, 2 means continuous event end;

    int                 nSenseType;                     // sensor type
    int                 nDefenceAreaType;               // protection area type, refer to EM_NET_DEFENCE_AREA_TYPE 
} ALARM_LOCAL_ALARM_INFO;

// Type of triggeing motion detection
typedef enum tagEM_MOTION_DETECT_TYPE
{
	EM_MOTION_DETECT_UNKNOWN,			// unknown
	EM_MOTION_DETECT_HUMAN,				// human
	EM_MOTION_DETECT_VEHICLE,			// vechicle
	EM_MOTION_DETECT_HUMAN_AND_VEHICLE,	// human and vechicle
} EM_MOTION_DETECT_TYPE;

// Region info of motion detection
typedef struct tagNET_MOTIONDETECT_REGION_INFO
{
	UINT			nRegionID;					// region ID
	char			szRegionName[64];			// region name
	BYTE        	bReserved[508];				// reserved
} NET_MOTIONDETECT_REGION_INFO;

// alarm event type DH_EVENT_MOTIONDETECT (video motion detection event) corresponding data description info
typedef struct tagALARM_MOTIONDETECT_INFO
{
    DWORD               dwSize;    
    int                 nChannelID;                     // channel number
    double              PTS;                            // timestamp (unit is millisecond)
    NET_TIME_EX         UTC;                            // event occurrence time
    int                 nEventID;                       // event ID
    int                 nEventAction;                   // event action, 0 means pulse event, 1 means continuous event begin, 2 means continuous event end;

	UINT							nRegionNum;			// count of region
	NET_MOTIONDETECT_REGION_INFO	stuRegion[32];		// region info of motion detection
	BOOL							bSmartMotionEnable;	// smart motion detection is enable or not
	UINT							nDetectTypeNum;		// count of triggeing motion detection type
	EM_MOTION_DETECT_TYPE			emDetectType[32];	// triggeing motion detection type, nRegionNum0one-to-one correspondence with stuRegion if nRegionNum is biger than 0;
														// the type is the first value of emDetectType if nRegionNum is 0
} ALARM_MOTIONDETECT_INFO;

// object info of smart motion detection about human
typedef struct tagNET_SMARTDETECT_HUMAN_OBJECT
{
	UINT				nHumanID;					// object ID about human
	NET_RECT			stuRect;					// rect of human
	BYTE        	    bReserved[508];				// reserved
} NET_SMARTDETECT_HUMAN_OBJECT;

// alarm event type DH_ALARM_SMARTMOTION_HUMAN (smart video motion detection event about human) corresponding data description info
typedef struct tagALARM_SMARTMOTION_HUMAN_INFO
{
    int                 nChannelID;                     // channel number
    NET_TIME_EX         UTC;                            // event occurrence time
    double              PTS;                            // timestamp (unit is millisecond)
    int                 nEventID;                       // event ID
    int                 nEventAction;                   // event action, 0 means pulse event, 1 means continuous event begin, 2 means continuous event end;

	NET_MOTIONDETECT_REGION_INFO	stuSmartRegion[32];	// region info of smart motion detection
	UINT							nSmartRegionNum;	// count of smart motion detection region
	UINT							nHumanObjectNum;	// count of smart motion detection objects about human
	NET_SMARTDETECT_HUMAN_OBJECT	stuHumanObject[64];	// object info of smart motion detection about human
	BYTE        					bReserved[1024];		// reserved
} ALARM_SMARTMOTION_HUMAN_INFO;

// object info of smart motion detection about vehicle
typedef struct tagNET_SMARTDETECT_VEHICLE_OBJECT
{
	UINT				nVehicleID;					// object ID about vehicle
	NET_RECT			stuRect;					// rect of vehicle
	BYTE        	    bReserved[508];				// reserved
} NET_SMARTDETECT_VEHICLE_OBJECT;

// alarm event type DH_ALARM_SMARTMOTION_VEHICLE (smart video motion detection event about vehicle) corresponding data description info
typedef struct tagALARM_SMARTMOTION_VEHICLE_INFO
{
    int                 nChannelID;                     	// channel number
    NET_TIME_EX         UTC;                            	// event occurrence time
    double              PTS;                            	// timestamp (unit is millisecond)
    int                 nEventID;                       	// event ID
    int                 nEventAction;                   	// event action, 0 means pulse event, 1 means continuous event begin, 2 means continuous event end;

	NET_MOTIONDETECT_REGION_INFO	stuSmartRegion[32];		// region info of smart motion detection
	UINT							nSmartRegionNum;		// count of smart motion detection region
	UINT							nVehicleObjectNum;		// count of smart motion detection objects about vehicle
	NET_SMARTDETECT_VEHICLE_OBJECT	stuVehicleObject[64];	// object info of smart motion detection about vehicle
	BYTE        					bReserved[1024];			// reserved
} ALARM_SMARTMOTION_VEHICLE_INFO;

// alarm event type DH_ALARM_POLICE_CHECK (police sign in/out event) corresponding data description info
typedef struct tagALARM_POLICE_CHECK_INFO
{
    DWORD               dwSize;
    int                 nChannelID;                     // channel number
    double              PTS;                            // timestamp (unit is millisecond)
    NET_TIME_EX         UTC;                            // event occurrence time
    int                 nEventID;                       // Event ID
    int                 nEventAction;                   // Event action 

    char                szId[32];                       // sign in person ID number
    char                szName[32];                     // sign in person name, UTF8
    int                 nSignType;                      // type, refer to NET_DRIVER_CHECK_TYPE 
    NET_GPS_STATUS_INFO stuGPSStatusInfo;               // GPS info 
    char                szComment[1024];                // comment info 
} ALARM_POLICE_CHECK_INFO;

// alarm event type DH_ALARM_NEW_FILE (new file event) corresponding data description info
typedef struct tagALARM_NEW_FILE_INFO
{
    DWORD           dwSize;
    int             nChannel;                           // snapshot channel number
    int             nEventID;                           // event ID
    DWORD           dwEvent;                            // event type
    int             FileSize;                           // file size, unit is byte
    int             nIndex;                             // event source channel 
    DWORD           dwStorPoint;                        // storage point
    char            szFileName[DH_COMMON_STRING_128];   // file name
}ALARM_NEW_FILE_INFO;


// the status type of PTZ
typedef enum tagEM_PTZ_STATUS_TYPE
{
    EM_PTZ_STATUS_UNKNOW,                    // unknown
    EM_PTZ_STATUS_NORMAL,                    // nomal
    EM_PTZ_STATUS_PANOC_FAILED,              // PanOCFailed
    EM_PTZ_STATUS_TILEOC_FAILED,             // TileOCFailed
    EM_PTZ_STATUS_OC_FAILED                  // OCFailed
} EM_PTZ_STATUS_TYPE;


// the info of Ptz Diagnoses(DH_ALARM_PTZ_DIAGNOSES)
typedef struct tagALARM_PTZ_DIAGNOSES_INFO
{
	int 				nChannel;			// video channel
	NET_TIME_EX			UTC;				// the time when event happen
	EM_PTZ_STATUS_TYPE	emPtzStat;			// the status of PTZ
	BYTE                Reserved[512];
} ALARM_PTZ_DIAGNOSES_INFO;

// event type DH_ALARM_FLASH_LIGHT_FAULT (FlashLightFault event) corresponding data description info
typedef struct tagALARM_FLASH_LIGHT_FAULT_INFO
{
    double              PTS;                            // PTS(ms)
    NET_TIME_EX         UTC;                            // the event happen time
    int                 nEventAction;                   // Envet Action, 1-start,2-stop
    int                 nLightNum;                      // flash light number
    int                 nDevID[MAX_FLASH_LIGHT_NUM];    // the fault flash light ID
    int                 nLane;                          // lane number
    BYTE			    bReserved[512];				    // reserved
}ALARM_FLASH_LIGHT_FAULT_INFO;

// event DH_ALARM_STROBOSCOPIC_LIGTHT_FAULT (StroboscopicLightFault event) corresponding data description info
typedef struct tagALARM_STROBOSCOPIC_LIGTHT_FAULT_INFO
{
    double              PTS;                                // PTS(ms)
    NET_TIME_EX         UTC;                                // the event happen time
    int                 nEventAction;                       // Envet Action, 1-start,2-stop
    int                 nLightNum;                          // stroboscopic light num 
    int                 nDevID[MAX_STROBOSCOPIC_LIGHT_NUM]; // the fault stroboscopic light ID
    int                 nLane;                              // lane number
    BYTE			    bReserved[512];				        // reserved
}ALARM_STROBOSCOPIC_LIGTHT_FAULT_INFO;

// upper limit type
typedef enum tagEM_UPPER_LIMIT_TYPE
{
    EM_UPPER_LIMIT_TYPE_UNKNOWN,                             // unknow
    EM_UPPER_LIMIT_TYPE_ENTER_OVER,                          // "EnterOver"
    EM_UPPER_LIMIT_TYPE_EXIT_OVER,                           // "ExitOver"
    EM_UPPER_LIMIT_TYPE_INSIDE_OVER,                         // "InsideOver"
} EM_UPPER_LIMIT_TYPE;

// event type DH_ALARM_HUMAM_NUMBER_STATISTIC 
typedef struct tagALARM_NUMBER_STATISTIC_INFO 
{
    double              PTS;                            // PTS(ms)
    NET_TIME_EX         UTC;                            // event time
    int                 nEventAction;                   // Envet Action, 1-start,2-stop
    int                 nNumber;                        // the number of object which is in the area
    int                 nEnteredNumber;                 // entered object number
    int                 nExitedNumber;                  // exited object number
	EM_UPPER_LIMIT_TYPE emUpperLimitType;               // upper limit type(EnterOver, ExitOver, InsideOver)
	int                 nChannelID;                     // Channel id
    BYTE                reserved[508];                  // reserved
}ALARM_HUMAN_NUMBER_STATISTIC_INFO;

typedef struct tagALARM_VIDEOUNFOCUS_INFO
{
    int                 nEventAction;                   // event action, 0 means pulse event, 1 means continuous event begin, 2 means continuous event end
    int                 nChannel;                       // channel id
    BYTE                reserved[60];                   // reserved
}ALARM_VIDEOUNFOCUS_INFO;
// status
typedef enum tagEM_DEFENCEMODE
{
    EM_DEFENCEMODE_UNKNOWN,             // "unknown"   
    EM_DEFENCEMODE_ARMING,              // "Arming"    
    EM_DEFENCEMODE_DISARMING,           // "Disarming" 
}EM_DEFENCEMODE;

//Trigger mode
typedef enum tagEM_ARMMODECHANGE_TRIGGERMODE
{
	EM_ARMMODECHANGE_TRIGGERMODE_UNKNOWN,			//Unknown
		EM_ARMMODECHANGE_TRIGGERMODE_NET,			//Net user
		EM_ARMMODECHANGE_TRIGGERMODE_KEYBOARD,		//Keyboard
		EM_ARMMODECHANGE_TRIGGERMODE_REMOTECONTROL,	//Remote
}EM_ARMMODECHANGE_TRIGGERMODE;

//Defence area type
typedef enum tagEM_ARMMODECHANGE_DEFENCEAREATYPE
{
	EM_ARMMODECHANGE_DEFENCEAREATYPE_UNKNOWN,		//Unknown
		EM_ARMMODECHANGE_DEFENCEAREATYPE_INTIME,	//Intime
		EM_ARMMODECHANGE_DEFENCEAREATYPE_DELAY,		//Delay
		EM_ARMMODECHANGE_DEFENCEAREATYPE_FULLDAY,	//Fullday
		EM_ARMMODECHANGE_DEFENCEAREATYPE_FOLLOW,	//Follow
		EM_ARMMODECHANGE_DEFENCEAREATYPE_MEDICAL,	//Medical
		EM_ARMMODECHANGE_DEFENCEAREATYPE_PANIC,		//Panic
		EM_ARMMODECHANGE_DEFENCEAREATYPE_FIRE,		//Fime
		EM_ARMMODECHANGE_DEFENCEAREATYPE_FULLDAYSOUND,	//Full day sound
		EM_ARMMODECHANGE_DEFENCEAREATYPE_FULLDAYSILENT,	//Full day silent
		EM_ARMMODECHANGE_DEFENCEAREATYPE_ENTRANCE1,		//Entrance1
		EM_ARMMODECHANGE_DEFENCEAREATYPE_ENTRANCE2,		//Entrance2
		EM_ARMMODECHANGE_DEFENCEAREATYPE_INSIDE,		//Inside
		EM_ARMMODECHANGE_DEFENCEAREATYPE_OUTSIDE,		//OutSide
		EM_ARMMODECHANGE_DEFENCEAREATYPE_PEOPLEDETECT,	//People detect
}EM_ARMMODECHANGE_DEFENCEAREATYPE;

// event type DH_ALARM_DEFENCE_ARMMODECHANGE (Defence arming status change event)
typedef struct tagALARM_DEFENCE_ARMMODECHANGE_INFO 
{
    EM_DEFENCEMODE       emDefenceStatus;              //status
    int                  nDefenceID;                   //DefenceID
    NET_TIME_EX          stuTime;                      //the event happen time

	EM_ARMMODECHANGE_TRIGGERMODE 		emTriggerMode;		//Trigger mode
	EM_ARMMODECHANGE_DEFENCEAREATYPE	emDefenceAreaType;	//Defence area type
	int									nID;				//Remote control ID, Keyboard address
	int 				 nAlarmSubSystem;			//Subsystem ID
	char   				 szName[64];				//Defence area name
	char				 szNetClientAddr[64];		//User IP or net address

    BYTE                 reserved[368];                //reserverd
}ALARM_DEFENCE_ARMMODECHANGE_INFO;

// status
typedef enum tagEM_SUBSYSTEMMODE
{
    EM_SUBSYSTEMMODE_UNKNOWN,             // "unknown"   
    EM_SUBSYSTEMMODE_ACTIVE,              // "active"    
    EM_SUBSYSTEMMODE_INACTIVE,            // "inactive"  
    EM_SUBSYSTEMMODE_UNDISTRIBUTED,       // "undistributed" 
    EM_SUBSYSTEMMODE_ALLARMING,           // "AllArming" 
    EM_SUBSYSTEMMODE_ALLDISARMING,        // "AllDisarming" 
    EM_SUBSYSTEMMODE_PARTARMING,          // "PartArming" 
}EM_SUBSYSTEMMODE;


//Subsystem trigger mode
typedef enum tagEM_SUBSYSTEM_ARMMODECHANGE_TRIGGERMODE
{
	EM_SUBSYSTEM_ARMMODECHANGE_TRIGGERMODE_UNKNOWN,			//unknown
	EM_SUBSYSTEM_ARMMODECHANGE_TRIGGERMODE_NET,				//net user
	EM_SUBSYSTEM_ARMMODECHANGE_TRIGGERMODE_KEYBOARD,		//ketboard
	EM_SUBSYSTEM_ARMMODECHANGE_TRIGGERMODE_REMOTECONTROL,	//remote control
}EM_SUBSYSTEM_ARMMODECHANGE_TRIGGERMODE;


// event type DH_ALARM_SUBSYSTEM_ARMMODECHANGE (Subsystem arming status change event)
typedef struct tagALARM_SUBSYSTEM_ARMMODECHANGE_INFO 
{
    EM_SUBSYSTEMMODE    emSubsystemMode;            //status (support report AllArming, AllDisarming, PartArming)
    NET_TIME_EX         UTC;                        //the event happen time
    char                szSubSystemname[64];        //subsystem name
    int                 nSubSystemID;               //SubSystemID

	EM_SUBSYSTEM_ARMMODECHANGE_TRIGGERMODE	emTriggerMode;  //trigger mode
    int				nID;									//keyboard or remote address
    char				szNetClientAddr[64];				//net user ip or net address

    BYTE                reserved[440];              //reserved
}ALARM_SUBSYSTEM_ARMMODECHANGE_INFO;

// infrared detection information event (Corresponding ALARM_RFID_INFO)
typedef struct tagALARM_RFID_INFO
{
    int                         nAction;                // 0:start 1:stop
    int                         nIndex;                 // channel ID
    NET_TIME_EX                 stuEventTime;           // event time
    int                         nValidCount;            // RFID  valid number of RFID 
    char                        szRfid[10][12];         // RFID array
}ALARM_RFID_INFO;

//event type DH_ALARM_SMOKE_DETECTION
typedef struct tagALARM_SMOKE_DETECTION_INFO
{
    int                 nAction;                        // 0:start 1:stop
    char                szName[128];                    // event name
    double              PTS;                            // PTS(ms)
    NET_TIME_EX         stuTime;                        // event time
	int					nChannel;						// channel ID
	int					nEventID;						// event ID
	
	int                 nDetectRegionNum;                           // rule detect region's point number
	DH_POINT            stuDetectRegion[DH_MAX_DETECT_REGION_NUM];  // rule detect region
	BYTE                reserved[36];                  // reserved                        
}ALARM_SMOKE_DETECTION_INFO;

// event type DH_ALARM_PHONECALL_DETECT
typedef struct tagALARM_PHONECALL_DETECT_INFO
{
	int                 nAction;                        // Event operation. 0=pulse event.1=continues event begin. 2=continues event stop
	char                szName[128];                    // event name
	BYTE                reserved1[4];                   // reserved 
	double              PTS;                            // PTS(ms)
	NET_TIME_EX         stuTime;                        // event time
	int					nChannel;						// channel ID
	int					nEventID;						// event ID
	
	int                 nDetectRegionNum;                           // rule detect region's point number
	DH_POINT            stuDetectRegion[DH_MAX_DETECT_REGION_NUM];  // rule detect region
	BYTE                reserved[128];                  // reserved      
} ALARM_PHONECALL_DETECT_INFO;

// The date type of Event
typedef enum tagNET_EM_EVENT_DATA_TYPE
{
	NET_EN_EVENT_DATA_TYPE_UNKNOWN,									// Unknown
	NET_EN_EVENT_DATA_TYPE_REAL,									// Real data
	NET_EN_EVENT_DATA_TYPE_ALARM,									// Alarm data
}NET_EM_EVENT_DATA_TYPE;

// event type DH_ALARM_FLOATINGOBJECT_DETECTION
typedef struct tagALARM_FLOATINGOBJECT_DETECTION_INFO
{
	int                 nAction;                        // Event operation. 0=pulse event.1=continues event begin. 2=continues event stop
	BYTE                reserved1[4];					// reserved 
	char                szName[128];                    // event name
	double              PTS;                            // PTS(ms)
	NET_TIME_EX         UTC;							// event time
	int					nChannel;						// channel ID
	int					nEventID;						// event ID

	int					nPresetID;						// Preset ID
	char				szPresetName[64];				// Preset name
	BOOL				bExistFloatingObject;			// Whether there is floating object?
	NET_EM_EVENT_DATA_TYPE		emEventType;			// Event type
	float				fCurrentRatio;					// The current proportion of flotage(relative to detection area) Unit:%, Range[0, 100]
	float				fAlarmThreshold;				// The alarm threshold of proportion, Range[0, 100]

	NET_POINT           stuDetectRegion[DH_MAX_DETECT_REGION_NUM]; // The point list of rule detect region
	int                 nDetectRegionNum;                   // The point number of rule detect region

	BYTE                byReserved[1020];                 // Reserved      
} ALARM_FLOATINGOBJECT_DETECTION_INFO;

// Water level status
typedef enum tagNET_EM_WATER_LEVEL_STATUS
{
	NET_EM_WATER_LEVEL_STATUS_UNKNOWN,									// Unknown
	NET_EM_WATER_LEVEL_STATUS_NORMAL,									// Normal water level
	NET_EM_WATER_LEVEL_STATUS_HIGH,										// Higher than alarm threshold
	NET_EM_WATER_LEVEL_STATUS_LOW,										// lower than alarm threshold
}NET_EM_WATER_LEVEL_STATUS;

// The color of water ruler
typedef enum tagNET_EM_WATER_RULER_COLOR
{
	NET_EM_WATER_RULER_COLOR_UNKNOW,									// Unknown
	NET_EM_WATER_RULER_COLOR_BLUE,										// Blue
	NET_EM_WATER_RULER_COLOR_RED,										// Red
}NET_EM_WATER_RULER_COLOR;

// Water ruler information
typedef struct tagNET_WATER_RULER
{
	NET_EM_WATER_RULER_COLOR	emRulerColor;							// The color of water ruler
	char						szRulerNum[128];						// The ID of water ruler
	float						fWaterLevel;							// Water level(if there has splice ruler, it equal to base value plus current value, Unitm)
	BYTE						byReserved[512];						// Reserved
}NET_WATER_RULER;

// Event type DH_ALARM_WATER_LEVEL_DETECTION 
typedef struct tagALARM_WATER_LEVEL_DETECTION_INFO
{
	int                 		nAction;                        // Event operation. 0=pulse event.1=continues event begin. 2=continues event stop
	BYTE                		reserved1[4];					// reserved 
	char                		szName[128];                    // event name
	double              		PTS;                            // PTS(ms)
	NET_TIME_EX         		UTC;							// event time
	int							nChannel;						// channel ID
	int							nEventID;						// event ID
	int							nPresetID;						// Preset ID
	char						szPresetName[64];				// Preset name
	char						szObjectUUID[48];				// Object ID
	NET_EM_EVENT_DATA_TYPE		emEventType;					// Event data type
	NET_EM_WATER_LEVEL_STATUS	emStatus;						// Water status
	NET_WATER_RULER				stuWaterRuler;					// Water ruler information
	BYTE						byReserved[1024];               // reserved     
} ALARM_WATER_LEVEL_DETECTION_INFO;

// Event type DH_ALARM_LOW_SPEED
typedef struct tagALARM_LOW_SPEED_INFO
{
	int                 nAction;                        // Event operation. 0=pulse event.1=continues event begin. 2=continues event stop
	int					nChannel;						// channel ID
	char                szName[128];                    // event name
	double              PTS;                            // PTS(ms)
	NET_TIME_EX         UTC;							// event time
	int					nEventID;						// event ID
	BYTE				byReserved[256];				// reserved
} ALARM_LOW_SPEED_INFO;

// Event type DH_ALARM_TRAFFIC_VEHICLEINOUT
typedef struct tagALARM_TRAFFIC_VEHICLEINOUT_INFO
{
	int                 nAction;                        // Event operation. 0=pulse event.1=continues event begin. 2=continues event stop
	int					nChannel;						// channel ID
	char                szName[128];                    // event name
	double              PTS;                            // PTS(ms)
	NET_TIME_EX         UTC;							// event time
	int					nEventID;						// event ID
	
	int					nLane;							// Lane
	UINT				nRoadwayNumber;					// Custom lane
	int					nVehicleInOut;					// The state of vehicle, 0 leave lane 1 into lane 
	BYTE				byReserved[1024];				// reserved
} ALARM_TRAFFIC_VEHICLEINOUT_INFO;

// Event type DH_ALARM_TRAFFIC_JUNCTION
typedef struct tagALARM_TAFFIC_JUNCTION_INFO
{
	int					nAction;									// Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
	int                 nChannelID;                                 // Channel ID
	char                szName[128];                                // Event name
	BYTE                byMainSeatBelt;                             // main driver, seat, safety belt , 1-fastened, 2-unfastened
	BYTE                bySlaveSeatBelt;                            // co-drvier, seat, safety belt, 1-fastened, 2-unfastened
	BYTE                byVehicleDirection;                         // Current snapshot is head or rear, see  EM_VEHICLE_DIRECTION
	BYTE                byOpenStrobeState;                          // Open status, see EM_OPEN_STROBE_STATE 
	BYTE				byReserved1[4];								// Align
	double              PTS;                                        // PTS(ms)
	NET_TIME_EX         UTC;                                        // the event happen time
	int                 nEventID;                                   // Event ID
	DH_MSG_OBJECT       stuObject;                                  // have being detected object
	int                 nLane;                                      // road number
	DWORD               dwBreakingRule;                             // BreakingRule's mask,first byte: crash red light; 
	                                                    			// secend byte:break the rule of driving road number; 
	                                                    			// the third byte:converse; the forth byte:break rule to turn around;
																	// the five byte:traffic jam; the six byte:traffic vacancy; 
																	// the seven byte: Overline; defalt:trafficJunction   

	NET_TIME_EX         RedLightUTC;                                // the begin time of red light
	DH_EVENT_FILE_INFO  stuFileInfo;                                // event file info
	int                 nSequence;                                  // snap index,such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	int                 nSpeed;                                     // car's speed (km/h)               
	BYTE                byDirection;                                // Intersection direction 1 - denotes the forward 2 - indicates the opposite
	BYTE                byLightState;                               // LightState means red light status:0 unknown,1 green,2 red,3 yellow
	BYTE                byReserved2;                                 // reserved
	BYTE                byImageIndex;                               // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	DH_MSG_OBJECT       stuVehicle;                                 // vehicle info
	DWORD               dwSnapFlagMask;                             // flag(by bit),see NET_RESERVED_COMMON
	DH_RESOLUTION_INFO  stuResolution;                              // picture resolution
	char                szRecordFile[DH_COMMON_STRING_128];         // Alarm corresponding original video file information
	EVENT_JUNCTION_CUSTOM_INFO   stuCustomInfo;                     // custom info
	BYTE                byPlateTextSource;                          // the source of plate text, 0:Local,1:Server
	BYTE                byReserved3[3];                              // Reserved bytes
	NET_GPS_INFO        stuGPSInfo;                                 // GPS info ,use in mobile DVR/NVR

	BYTE                byNoneMotorInfo;                            // specified the person info of none motor
																	// 1 means 11 fields followed is valid
	BYTE                byBag;                                      // 0-unknown 1-no bag   2-bag
	BYTE                byUmbrella;                                 // 0-unknown 1-no umbrella   2-Umbrella
	BYTE                byCarrierBag;                               // 0-unknown 1-no carrierBag 2-carrierBag    
	BYTE                byHat;                                      // 0-unknown 1-no hat 2-hat       
	BYTE                byHelmet;                                   // 0-unknown 1-no helmet 2-helmet  
	BYTE                bySex;                                      // 0-unknown 1-man 2-woman
	BYTE                byAge;                                      // age
	NET_COLOR_RGBA      stuUpperBodyColor;                          // upper body color
	NET_COLOR_RGBA      stuLowerBodyColor;                          // lower body color
	BYTE                byUpClothes;                                // upper clothes 0:unknown 1:long sleeve 2:short sleeve 3:trousers 4:breeches 5:skirt 6:vest 7:minipants 8:miniskirt
	BYTE                byDownClothes;                              // lower clothes 0:unknown 1:long sleeve 2:short sleeve 3:trousers 4:breeches 5:skirt 6:vest 7:minipants 8:miniskirt 

	NET_EXTENSION_INFO  stuExtensionInfo;                           // Extension info
	BYTE                byReserved4[22];								// Reserved bytes
	int                 nTriggerType;                               // Trigger Type:0 vehicle inspection device, 1 radar, 2 video, 3 RSU
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // Traffic vehicle info
	DWORD               dwRetCardNumber;                            // Card Number
	EVENT_CARD_INFO     stuCardInfo[DH_EVENT_MAX_CARD_NUM];         // Card information   
	EVENT_COMM_INFO     stCommInfo;                                 // public info 

	BOOL				bNonMotorInfoEx;							// Non-motor info enable
	VA_OBJECT_NONMOTOR  stuNonMotor;								// Non-motor information
	BYTE				byReserved[2048];							// Reserved
} ALARM_TAFFIC_JUNCTION_INFO;

// alarm of door control(corresponding to DH_ALARM_DOOR_CONTROL)
typedef struct tagALARM_DOOR_CONTROL_INFO
{
	int                 			nChannelID;                         	// channel
    int								nAction;								// Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    char                			szName[128];                         	// Event name
    double              			PTS;                                	// PTS(ms)
    NET_TIME_EX         			UTC;                                	// The event happen time
    UINT                			nEventID;                           	// Event ID

	EM_OPEN_DOOR_METHOD				emOpenDoorMethod;						// Open door method
	EM_OPEN_DOOR_STATE				emOpenDoorState;						// Open door state
	char							szSourceID[32];							// Source UUID
																			// The format is as followsFront 2:%d%d:01-video,02-picture,03-file,99-other;
																			// Middle 14:YYYYMMDDhhmmss:year,month,day,hour,minute,second;Last 5:%u%u%u%u%uobject IDas 00001
	BYTE			    			byReserved[1024];			        	// Reserved
} ALARM_DOOR_CONTROL_INFO;

// status
typedef enum tagNET_EM_ARM_STATUS
{
	EM_ARM_STATUS_UNKNOWN,													// Unknown
	EM_ARM_STATUS_DELAY,													// Delay
	EM_ARM_STATUS_ARMING,													// Arming
	EM_ARM_STATUS_DISARMING,												// Disarming
}NET_EM_ARM_STATUS;

// alarm of arm state(corresponding to DH_ALARM_ARMSTATE)
typedef struct tagALARM_ARMSTATE_INFO
{
	int                 			nChannelID;                         	// channel
    int								nAction;								// Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    char                			szName[128];                         	// Event name
    double              			PTS;                                	// PTS(ms)
    NET_TIME_EX         			UTC;                                	// The event happen time
    UINT                			nEventID;                           	// Event ID
	NET_EM_ARM_STATUS				emStatus;								// status
}ALARM_ARMSTATE_INFO;

// alarm of Law EnforcementInfo (corresponding to DH_ALARM_LAW_ENFORCEMENT_INFO)
typedef struct tagALARM_LAW_ENFORCEMENT_INFO
{
    int						nAction;									// Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;  
	NET_GPS_STATUS_INFO		stuGPSStatus;								// GPS information 
	char					szUserID[32];								// User ID logged in at local alarm
	char					szUserName[128];							// User name logged in at local alarm
	BYTE					byRserved[4];			                    // byte alignment  
} ALARM_LAW_ENFORCEMENT_INFO;

// alarm of congestion detection(corresponding to DH_ALARM_CONGESTION_DETECTION)
typedef struct tagALARM_CONGESTION_DETECTION_INFO
{
	int                 			nChannelID;                                 // channel id
	int								nAction;									// 0:pulse 1:start 2:stop
	char                			szName[128];                                // name
	double              			PTS;                                        // PTS,unit:ms
	NET_TIME_EX         			UTC;                                        // UTC
	DH_EVENT_FILE_INFO				stuFileInfo;								// file information
	EM_CLASS_TYPE					emClassType;								// class type
	UINT                			nEventID;                           		// event ID
	UINT							nRuleID;									// rule id
	int 							nPresetID;									// preset ID
	char							szPresetName[64];							// preset name
	UINT							nAlarmMask;									// The mask of alarm, bit0 whether has jam alarm; bit1 whether has queue alarm
	UINT							nVehicleQuantity;							// The number of vehicles in jam
	UINT							nQueueLength;								// The number of vehicles in queue
	int								nDetectRegionNum;							// The number of stuDetectRegion
	DH_POINT						stuDetectRegion[32];						// The region of alarm occur
	BYTE			    			byReserved[1024];			        		// Reserved
}ALARM_CONGESTION_DETECTION_INFO;

// alarm of vehicle limit detection(corresponding to H_ALARM_VEHICLELIMIT_DETECTION)
typedef struct tagALARM_VEHICLELIMIT_DETECTION_INFO
{
	int                 			nChannelID;                                 // channel id
	int								nAction;									// 0:pulse 1:start 2:stop
	char                			szName[128];                                // name
	double              			PTS;                                        // PTS,unit:ms
	NET_TIME_EX         			UTC;                                        // UTC
	DH_EVENT_FILE_INFO				stuFileInfo;								// file information
	EM_CLASS_TYPE					emClassType;								// class type
	UINT                			nEventID;                           		// event ID
	UINT							nRuleID;									// rule id
	int 							nPresetID;									// preset ID
	char							szPresetName[64];							// preset name
	UINT							nVehicleQuantity;							// The number of vehicles in jam
	int								nDetectRegionNum;							// The number of stuDetectRegion
	DH_POINT						stuDetectRegion[32];						// The region of alarm occur
	BYTE			    			byReserved[1024];			        		// Reserved
}ALARM_VEHICLELIMIT_DETECTION_INFO;

// GPS info
typedef struct tagLAMP_GPS_INFO
{
    DWORD                           dwLatitude;                                 // Latitude
    DWORD                           dwLongitude;                                // Longitude
    int                             nNumOfSatellite;                            // satellite number
    BYTE                            byReserved[4];                              // Reserved
} LAMP_GPS_INFO;

// is device offline
typedef enum tagEM_IS_OFF_LINE
{
    EM_IS_OFF_LINE_UNKNOWN = -1,                                                // unknown
    EM_IS_OFF_LINE_NORMAL,                                                      // normal
    EM_IS_OFF_LINE_EXCEPTION,                                                   // exception
} EM_IS_OFF_LINE;

// is voltage fault  
typedef enum tagEM_IS_VOLTAGE_FAULT
{
    EM_IS_VOLTAGE_FAULT_UNKNOWN = -1,                                           // unknown
    EM_IS_VOLTAGE_FAULT_NORMAL,                                                 // normal
    EM_IS_VOLTAGE_FAULT_EXCEPTION,                                              // exception
} EM_IS_VOLTAGE_FAULT;

// is current fault
typedef enum tagEM_IS_CURRENT_FAULT
{
    EM_IS_CURRENT_FAULT_UNKNOWN = -1,                                           // unknown
    EM_IS_CURRENT_FAULT_NORMAL,                                                 // normal
    EM_IS_CURRENT_FAULT_EXCEPTION,                                              // exception
} EM_IS_CURRENT_FAULT;

// bright state
typedef enum tagEM_BRIGHT_STATE
{
    EM_BRIGHT_STATE_UNKNOWN = -1,                                               // unknown
    EM_BRIGHT_STATE_OFF,                                                        // bright state is off
    EM_BRIGHT_STATE_ON,                                                         // bright state is on
} EM_BRIGHT_STATE;

// work mode
typedef enum tagEM_LAMP_STATUS_WORK_MODE
{
    EM_LAMP_STATUS_WORK_MODE_UNKNOWN,                                           // unknown
    EM_LAMP_STATUS_WORK_MODE_DHRS_STROBOSCOPIC_LAMP,                            // RS485 stroboscopic lamp
    EM_LAMP_STATUS_WORK_MODE_DHRS_STEADY_LAMP,                                  // RS485 steady lamp
    EM_LAMP_STATUS_WORK_MODE_DHRS_FLASH_LAMP,                                   // RS485 flash lamp
} EM_LAMP_STATUS_WORK_MODE; 

// stroboscopic mode
typedef enum tagEM_STROBOSCOPIC_MODE
{
    EM_STROBOSCOPIC_MODE_UNKNOWN = -1,                                          // unknown
    EM_STROBOSCOPIC_MODE_ACTIVE,                                                // active
    EM_STROBOSCOPIC_MODE_PASSIVE,                                               // passive
} EM_STROBOSCOPIC_MODE;

// stroboscopic lamp parameter
typedef struct tagSTROBOSCOPIC_LAMP_PARAM
{
    EM_STROBOSCOPIC_MODE            emStroboscopicMode;                         // stroboscopic mode
    UINT                            nStayTime;                                  // stay time, [0,2^32)s
    UINT                            nFrequency;                                 // frequency,Hz
    UINT                            nBrightLevel;                               // bright level, 1~20
    UINT                            nPulseWidth;                                // pulse width, (0,4]ms
    BYTE                            byReserved[36];                             // reserved
} STROBOSCOPIC_LAMP_PARAM;

// trigger mode
typedef enum tagEM_TRIGGER_MODE
{
    EM_TRIGGER_MODE_UNKNOWN = -1,                                               // unknown
    EM_TRIGGER_MODE_EDGE,                                                       // edge
    EM_TRIGGER_MODE_PWM,                                                        // pwm
} EM_TRIGGER_MODE;

// flash lamp parameter
typedef struct tagFLASH_LAMP_PARAM 
{
    EM_TRIGGER_MODE                 emTriggerMode;                              // trigger mode
    UINT                            nTriggerCount;                              // trigger count, [0,2^32)
    UINT                            nFlashCount;                                // flash count, [0,2^32)
    UINT                            nPulseWidth;                                // pulse width, (0~4]ms
    UINT                            nPulseWidthDetectThreshold;                 // oulse width detect threshold, 1~4
    UINT                            nErrorDetectThreshold;                      // error detect threshold, 3~8
    BYTE                            byReserved[32];                             // reserved
} FLASH_LAMP_PARAM ;

// steady lamp parameter
typedef struct tagSTEADY_LAMP_PARAM
{
    UINT                            nBrightLevel;                               // bright level, 1~20
    BYTE                            byReserved[60];                             // reserved 
} STEADY_LAMP_PARAM;

// lamp status
typedef struct tagLAMP_STATUS_INFO
{             
    UINT                            nPort;                                      // port
    UINT                            nAddress;                                   // DHRS lamp address, 0~15
    char                            szSoftwareVersion[128];                     // software version
    char                            szDeviceID[32];                             // device id
    LAMP_GPS_INFO                   stuGPS;                                     // GPS info
    EM_IS_OFF_LINE                  emIsOffline;                                // is device offline
    EM_IS_VOLTAGE_FAULT             emIsVoltageFault;                           // is voltage fault       
    EM_IS_CURRENT_FAULT             emIsCurrentFault;                           // is current fault
    EM_BRIGHT_STATE                 emBrightState;                              // bright state
    UINT                            nPower;                                     // power, 0~65536999
    UINT                            nTemperature;                               // temperature, 0~25599
    UINT                            nPhotoSensitivity;                          // photosensitivity, 0~4095
    UINT                            nAmbientBrightnessThreshold;                // ambient brightness threshold ,1~6
    EM_LAMP_STATUS_WORK_MODE        emWorkMode;                                 // work mode
    STROBOSCOPIC_LAMP_PARAM         stuStroboscopicLampParam;                   // stroboscopic lamp parameter
    FLASH_LAMP_PARAM                stuFlashLampParam;                          // flash lamp parameter
    STEADY_LAMP_PARAM               stuSteadyLampParam;                         // steady lamp parameter
    BYTE                            byReserved[64];                             // reserved 
} LAMP_STATUS_INFO;

// alarm of traffic lamp work state(Corresponding to ALARM_TRAFFIC_LAMP_WORK_STATE_INFO)
typedef struct tagALARM_TRAFFIC_LAMP_WORK_STATE_INFO
{
    NET_TIME_EX                     UTC;                                        // UTC
    UINT                            nUTCMS;                                     // UTCMS
    int                             nChannelID;                                 // channel id
    int                             nLampStatusNum;                             // lamp status number
    LAMP_STATUS_INFO                stuLampStatus[8];                           // lamp status
    BYTE                            byReserved[256];                            // reserved
} ALARM_TRAFFIC_LAMP_WORK_STATE_INFO;

// alarm of traffic parking timeout (corresponding to DH_ALARM_TRAFFIC_PARKING_TIMEOUT)
typedef struct tagALARM_TRAFFIC_PARKING_TIMEOUT_INFO
{
	int                 				nChannelID;                         	// channel id
	int									nAction;								// 0:pulse 1:start 2:stop
	NET_TIME_EX         				UTC;                                	// UTC
	NET_TIME							stuInParkTime;							// Entry time
	NET_TIME							stuOutParkTime;							// Leave time
	UINT								nParkingTime;							// Parking time, Unit:s
	BYTE			    				byReserved[1024];			        	// Reserved
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO	stuTrafficCar;							// TrafficCar information
}ALARM_TRAFFIC_PARKING_TIMEOUT_INFO;


// Corresponding to data block description of event type DH_ALARM_TICKET_INFO_REPORT(ticket info report)
typedef struct tagALARM_TICKET_INFO_REPORT
{
	int                         nChannelID;                         // Channel ID
	int                         nAction;                            // Event action, 0: Pulse, 1: Start, 2: Stop	
	double                      PTS;                                // Timestamp (in milliseconds)
	NET_TIME_EX                 UTC;                                // Time for the event occurred
	int							nEventID;                           // Event ID
	int							nOpenFlag;							// open door flag. 0:open door,else not
	BYTE						byReserved[4];						// reserved
	char						szPassengerName[256];				// name
	char						szCitizenID[32];					// citizen id
	NET_TIME					stuDriveTime;						// drive time
	char						szDestination[256];			// arrival station
	char						szScheduleID[64];					// schedule
}ALARM_TICKET_INFO_REPORT;


// alarm of Law EnforcementInfo (corresponding to DH_ALARM_LAW_ENFORCEMENT_INFO)
// patient detection type
typedef enum TagEM_PATIENTDETECTION_TYPE
{
    EM_PATIENTDETECTION_TYPE_UNKNOWN,                   // unknown
    EM_PATIENTDETECTION_TYPE_CROSS_REGION,              // someone cross region 
    EM_PATIENTDETECTION_TYPE_LIGHT_OFF,                 // light off
    EM_PATIENTDETECTION_TYPE_STOP_DETECTION,            // stop detection    
    EM_PATIENTDETECTION_TYPE_START_DETECTION,           // start detection
	EM_PATIENTDETECTION_TYPE_ESCAPE,                    // patient escape
	EM_PATIENTDETECTION_TYPE_ESCAPE_RELEASE,            // Release the patient escape
}EM_PATIENTDETECTION_TYPE;

// event type DH_ALARM_PATIENTDETECTION
typedef struct tagALARM_PATIENTDETECTION_INFO
{
    BYTE                        bEventAction;           // event action,0 pulse,1 durable events begin, 2 durable events end
    NET_TIME                    stuTime;                // event time
    EM_PATIENTDETECTION_TYPE    emDetectionType;        // detection type
    BYTE                        byReserved[256];        // reserved 
}ALARM_PATIENTDETECTION_INFO;

// radar high speed detection (DH_ALARM_RADAR_HIGH_SPEED)
typedef struct tagALARM_RADAR_HIGH_SPEED_INFO
{
    NET_TIME_EX                 stuTime;                    // event time
    float                       fSpeed;                     // speed(unit:km/h)
	char						szPlateNumber[16];			// plate 
    BYTE                        byReserved[1008];           // reserved 
}ALARM_RADAR_HIGH_SPEED_INFO;

// Polling Alarm  (DH_ALARM_POLLING_ALARM)
typedef struct tagALARM_POLLING_ALARM_INFO
{
    NET_TIME_EX                 stuTime;                    // event time
    BYTE                        byReserved[1024];           // reserved 
}ALARM_POLLING_ALARM_INFO;

// Traffic Strobe State
typedef enum tagEM_TRAFFICSTROBE_STATUS
{
    NET_TRAFFICSTROBE_STATUS_UNKNOWN,
	NET_TRAFFICSTROBE_STATUS_CLOSE_COMPLETE,                               // Traffic Strobe closed
	NET_TRAFFICSTROBE_STATUS_OPEN_COMPLETE,                                // Traffic Strobe opened
	NET_TRAFFICSTROBE_STATUS_NOT_CLOSE_COMPLETE,                           // Traffic Strobe not complete closed
	NET_TRAFFICSTROBE_STATUS_NOT_OPEN_COMPLETE,							   // Traffic Strobe not complete opened
} EM_TRAFFICSTROBE_STATUS;

// Traffic Strobe State info ( DH_ALARM_TRAFFICSTROBESTATE )
typedef struct tagALARM_TRAFFICSTROBESTATE_INFO
{
	BYTE                        bEventAction;               // Event Action,0=Impluse Event,1=Continued Event Start,2=Continued Event End;
    NET_TIME                    stuTime;                    // Alarm event time
	int                         nChannelID;                 // Channel No.
    EM_TRAFFICSTROBE_STATUS		emStatus;                   // Traffic Strobe State
    BYTE                        byReserved[1024];           // reserved 
}ALARM_TRAFFICSTROBESTATE_INFO;

// Paste detection info (Corresponding to DH_ALARM_PASTE_DETECTION)
typedef struct tagALARM_PASTE_DETECTION_INFO
{
    int                     nChannelID;                                 // ChannelId
    char                    szName[128];                                // event name
    double                  PTS;                                        // PTS(ms)
    NET_TIME_EX             UTC;                                        // the event happen time
    DH_MSG_OBJECT           stuObject;                                  // have being detected object
    int                     nDetectRegionNum;                           // rule detect region's point number
    DH_POINT                stuDetectRegion[DH_MAX_DETECT_REGION_NUM];  // rule detect region
    DH_MSG_HANDLE_EX        stuEventHandler;                            // Handle method
    BYTE                    bEventAction;                               // Event Action,0=Impluse Event,1=Continued Event Start,2=Continued Event End;
    BYTE                    bReserved[1023];                            // reserved
}ALARM_PASTE_DETECTION_INFO;

// TemperatureDifference Between Rule (DH_ALARM_BETWEENRULE_TEMP_DIFF)
typedef struct tagALARM_BETWEENRULE_DIFFTEMPER_INFO
{
    int                 nAction;                        // 0:start 1:stop
    int                 nOsdId;                         // config of TemperatureDifference OSD(OSDId)
    int                 nChannelID;                     // channel id
    NET_RADIOMETRY_ALARMCONTION     emAlarmContion;     // alarm condition
    int                 nRuleId1;                       // ThermometryRule1,refer to CFG_RADIOMETRY_RULE_INFO
    int                 nRuleId2;                       // ThermometryRule2,refer to CFG_RADIOMETRY_RULE_INFO
    float               fDiffValue;                     // Difference value between rules
    int                 nTemperatureUnit;               // TemperatureUnit,refer to NET_TEMPERATURE_UNIT
    UINT                nPresetID;                      // Preset id
    BYTE                reserved[128];                  // reserved  
}ALARM_BETWEENRULE_DIFFTEMPER_INFO;

// hotspot warning(DH_ALARM_HOTSPOT_WARNING)
typedef struct tagALARM_HOTSPOT_WARNING_INFO
{
    int                 nAction;                        // 0:start 1:stop
    int                 nChannelID;                     // channel id
    DH_POINT            stuCoordinate;                  // hotspot point,  0~8192
    float               fHotSpotValue;                  // hotspot value
    int                 nTemperatureUnit;               // temperature unit,refer to NET_TEMPERATURE_UNIT
}ALARM_HOTSPOT_WARNING_INFO;

// coldspot warning(DH_ALARM_COLDSPOT_WARNING)
typedef struct tagALARM_COLDSPOT_WARNING_INFO
{
    int                 nAction;                        // 0:start 1:stop
    int                 nChannelID;                     // channel id
    DH_POINT            stuCoordinate;                  // coldspot point,  0~8192
    float               fColdSpotValue;                 // coldspot value
    int                 nTemperatureUnit;               // temperature unit,refer to NET_TEMPERATURE_UNIT
}ALARM_COLDSPOT_WARNING_INFO;

// flow meter info (DH_ALARM_FLOW_METER)
typedef struct tagALARM_FLOW_METER_INFO 
{
    DWORD                   dwSize;
    float                   fInstantRate;                       // Instant Rate m/s
    float                   fInstantFlow;                       // Instant Flow m^3/h
    float                   fTotalFlow;                         // Total Flow m^3
    float                   fCurDayFlow;                        // Current day Flow m^3
    UINT                    unCurDayWorkingTime;                // Working time of current day ,unit: minute
    UINT                    unTotalWorktingTime;                // Working time in total, unit: minute
    NET_GPS_STATUS_INFO     stuGPS;                             // GPS information
    float                   fCurTemp;                           // the current temperature of the device, unit: Celsius degree
} ALARM_FLOW_METER_INFO;

// type of drop frame
typedef enum tagEM_BUF_DROP_FRAME_TYPE
{
    EM_BUF_DROP_FRAME_UNKOWN = 0,                       // frame type:unkonw
    EM_BUF_DROP_FRAME_DEVBUF,                           // frame type:main stream
    EM_BUF_DROP_FRAME_EXTBUF,                           // frame type:extra stream
    EM_BUF_DROP_FRAME_NETBUF,                           // frame type:net main stream 
    EM_BUF_DROP_FRAME_EXTRA1NETBUF                      // frame type:net extra1 stream
}EM_BUF_DROP_FRAME_TYPE;

// Video recond buffer drop frame event(DH_ALARM_BUF_DROP_FRAME)
typedef struct tagALARM_BUF_DROP_FRAME_INFO
{
    int                         nAction;                // 0:start 1:stop
    EM_BUF_DROP_FRAME_TYPE      emDropFrameType;        // type of drop frame
    BYTE                        reserved[1024];         // reserved
}ALARM_BUF_DROP_FRAME_INFO;


// Switch with master and slave (DH_ALARM_DCSSWITCH)
typedef struct tagALARM_DCSSWITCH_INFO
{
    int                         nAction;                // 0:start 1:stop
    char                        strMasterIP[32];        // Master device IP
    char                        strSlaveIP[32];         // Slave device IP
    NET_TIME_EX                 stuStartTime;           // the time when start switch
    BYTE                        reserved[1024];         // reserved
}ALARM_DCSSWITCH_INFO;

// Abnormal event when master broad'version and slave broad'version different (DH_ALARM_DOUBLE_DEV_VERSION_ABNORMAL)
typedef struct tagALARM_DOUBLE_DEV_VERSION_ABNORMAL_INFO
{
    int                         nAction;                // 0:start 1:stop
    char                        strMasterVer[64];       // master broad's version(when nAction is 0, this data is efficient)
    char                        strSlaveVer[64];        // slave broad's version(when nAction is 0, this data is efficient)
    BYTE                        reserved[1024];         // reserved
}ALARM_DOUBLE_DEV_VERSION_ABNORMAL_INFO;

// Radar connect state
typedef enum tagEM_RADAR_CONNECT_STATE
{
    EM_RADAR_CONNECT_STATE_UNKNOWN,     // unknown
    EM_RADAR_CONNECT_STATE_NORMAL,      // normal
    EM_RADAR_CONNECT_STATE_EXCEPTION,   // exception
}EM_RADAR_CONNECT_STATE;

// Radar connect state information event (DH_ALARM_RADAR_CONNECT_STATE)
typedef struct tagALARM_RADAR_CONNECT_STATE_INFO
{
    EM_RADAR_CONNECT_STATE      emRadarConnectState;    // Radar connect state
    BYTE                        reserved[1024];         // reserved
}ALARM_RADAR_CONNECT_STATE_INFO;

// Object type of high toss detection
typedef enum tagEM_HIGHTOSS_ACTION_TYPE
{
    EM_HIGHTOSS_ACTION_UNKNOWN,         // Unknown
    EM_HIGHTOSS_ACTION_APPEAR,          // New object appearing in the detection area for the first time or not confirmed in the physical separation action during tracking
    EM_HIGHTOSS_ACTION_MOVE,            // Moving, object are being tracked normally
    EM_HIGHTOSS_ACTION_STAY,            // Object stop moving. This object will not appear in the next frame object list, and restore in the object list after moving.
    EM_HIGHTOSS_ACTION_REMOVE,          // If the object is removed from the original area, or covered, or tracking fails, the removed object ID will not be automatically deleted, and it is possible for the object to reappear and be used again
    EM_HIGHTOSS_ACTION_DISAPPEAR,       // Moving outside the tracking area, or reaching the upper limit of the algorithm to track objects , the disappeared object ID will no longer appear
    EM_HIGHTOSS_ACTION_SPLIT,           // Separated from other objects, it can be used to detect objects left behind. Association ID means separated from the object corresponding to this ID
    EM_HIGHTOSS_ACTION_MERGE,           // Merging to other objects can be used to check object preservation. Association ID means merging to the corresponding object with this ID
    EM_HIGHTOSS_ACTION_RENAME,          // If the algorithm is unable to determine whether an object in the separation action is the same as the original object, a new object should be created first, and then renamed to the old object ID after the evidence is sufficient. The associated ID represents the new ID temporarily used
} EM_HIGHTOSS_ACTION_TYPE;

// Object info of high toss
typedef struct tagNET_HIGHTOSS_OBJECT_INFO
{
    UINT                            nObjectID;              // Object ID
    EM_HIGHTOSS_ACTION_TYPE         emObjAction;            // Object action
    NET_RECT                        stuBoundingBox;         // Bounding box
    UINT                            nConfidence;            // Confidence
    EM_ANALYSE_OBJECT_TYPE          emObjectType;           // Object type
    BYTE                            byReserved[2048];		// Reserved
} NET_HIGHTOSS_OBJECT_INFO;

// Alarm of high toss detection (Corresponding to DH_ALARM_PASTE_DETECTION)
typedef struct tagALARM_HIGH_TOSS_DETECT_INFO
{
	int                         nChannelID;                         // ChannelId
	int                         nAction;                            // Event Action,0=Impluse Event,1=Continued Event Start,2=Continued Event End;	
	double                      PTS;                                // PTS(ms)
	NET_TIME_EX                 UTC;                                // The event happen time
	BYTE                        byReserved1[4];                     // Alignment
	int					        nEventID;                           // Event ID

    UINT                        nObjNum;                            // Object number
    NET_HIGHTOSS_OBJECT_INFO    stuObjInfos[50];                    // Object info
    BYTE                        byReserved[1024];                   // Reserved
}ALARM_HIGH_TOSS_DETECT_INFO;

//CLIENT_SetMarkFileByTime input parameter
typedef enum tagEM_MARKFILE_MODE
{
	EM_MARK_FILE_BY_TIME_MODE,                              // add lock for record by time mode 
	EM_MARK_FILE_BY_NAME_MODE,                              // add lock for record by file mode 
}EM_MARKFILE_MODE;
typedef enum tagEM_MARKFILE_NAMEMADE_TYPE
{
	EM_MARKFILE_NAMEMADE_DEFAULT,							// default:need user pass record file name parameter szFilename
	EM_MARKFILE_NAMEMADE_JOINT,								// way of  file name split joint:pass the disk number ,pass the start cluster number,not need pass record file name
}EM_MARKFILE_NAMEMADE_TYPE;
//CLIENT_SetMarkFileByTimeEx input parameter
// Record file information
typedef struct tagNET_IN_SET_MARK_FILE
{
	DWORD               dwSize; 
	EM_MARKFILE_MODE	                    emLockMode;								// mode of lock for record,
	EM_MARKFILE_NAMEMADE_TYPE				emFileNameMadeType;						// way of create file name 
    int					nChannelID;								// channel ID
    char									szFilename[MAX_PATH];	                // file name
    unsigned int        nFramenum;								// the total number of file frames
    unsigned int        nSize;									// File length 
    NET_TIME            stuStartTime;							// Start time 
    NET_TIME            stuEndTime;								// End time 
    unsigned int        nDriveNo;								// HDD number
    unsigned int        nStartCluster;							// Initial cluster number
    BYTE                byRecordFileType;						// Recorded file type  0:general record;1:alarm record ;2:motion detection;3:card number record ;4:image 
    BYTE                byImportantRecID;						// 0:general record 1:Important record
    BYTE                byHint;									// Document Indexing
    BYTE                byRecType;								// 0-main stream record 1-sub1 stream record 2-sub2 stream record 3-sub3 stream record
} NET_IN_SET_MARK_FILE;
typedef struct tagNET_OUT_SET_MARK_FILE
{
    DWORD               dwSize; 
} NET_OUT_SET_MARK_FILE;
typedef struct tagNET_IN_SET_MARK_FILE_BY_TIME
{
    DWORD               dwSize;
    int                 nChannel;                             //the channel ID you want to lock, begin at 0, when the filed is -1,  it means all channels
    NET_TIME_EX         stuStartTime;                         //start time
    NET_TIME_EX         stuEndTime;                           //end time
    BOOL                bFlag;                                //action tag 	true : tag, false : clear
} NET_IN_SET_MARK_FILE_BY_TIME;

//CLIENT_SetMarkFileByTimeEx output parameter
typedef struct tagNET_OUT_SET_MARK_FILE_BY_TIME
{
    DWORD               dwSize; 
} NET_OUT_SET_MARK_FILE_BY_TIME;

//CLIENT_GetMarkInfo input parameter
typedef struct tagNET_IN_GET_MARK_INFO
{
    DWORD               dwSize;
} NET_IN_GET_MARK_INFO;

//CLIENT_GetMarkInfo output parameter 
typedef struct tagNET_OUT_GET_MARK_INFO
{
    DWORD               dwSize;
    int                 nTotalSpace;  //total capacity (unit M)
    int                 nMarkSpace;   //locked capacity of the video unit M 
} NET_OUT_GET_MARK_INFO;

//remove anti-submarine alarm input parameter 
typedef struct tagNET_IN_CLEAR_REPEAT_ENTER
{
    char         szCardNO[DH_MAX_CARDINFO_LEN];         // user card number
    BYTE         bReserved[1024];
}NET_IN_CLEAR_REPEAT_ENTER;

//remove anti-submarine alarm output parameter 
typedef struct tagNET_OUT_CLEAR_REPEAT_ENTER
{
    BYTE         bReserved[1024];
}NET_OUT_CLEAR_REPEAT_ENTER;

// alarm event type DH_ALARM_RECORD_LOSS (video loss event) corresponding data description info 
typedef struct tagALARM_RECORD_LOSS_INFO
{
    int                 nChannelID;                     // channel number
    int                 nEventAction;                   // event action, 0:pulse, 1:start
    char                szIP[DH_MAX_IPADDR_LEN_EX];     // video loss device IP
    int                 nPort;                          // video loss device port 
    BYTE                byReserved[1024];               // reserve
} ALARM_RECORD_LOSS_INFO;

// alarm event type DH_ALARM_VIDEO_FRAME_LOSS (video frame loss event) corresponding data description info
typedef struct tagALARM_VIDEO_FRAME_LOSS_INFO
{
    int                 nChannelID;                     // channel number
    int                 nEventAction;                   // event action, 0:Pulse,1:Start, 2: Stop 
    char                szIP[DH_MAX_IPADDR_LEN_EX];     // frame loss device IP 
    int                 nPort;                          // video loss device port 
    BYTE                byReserved[1024];               // reserve
} ALARM_VIDEO_FRAME_LOSS_INFO;

// alarm event type DH_ALARM_RECORD_VOLUME_FAILURE (disk volume abnormal) corresponding data description info 
typedef struct tagALARM_RECORD_VOLUME_FAILURE_INFO
{
    int                 nChannelID;                     // channel number
    int                 nEventAction;                   // event action, 0:Pulse, 1: Start, 2: Stop
    BYTE                byReserved[1024];               // reserve
} ALARM_RECORD_VOLUME_FAILURE_INFO;

// event type DH_EVENT_SNAP_UPLOAD (picture uploading finish event) corresponding data description info 
typedef struct tagEVENT_SNAP_UPLOAD_INFO
{
    int                 nChannelID;                     // channel number
    int                 nEventAction;                   // event action, 0: Pulse, 1: Start, 2: Stop
    BOOL                bSnapResult;                    // if the picture is uploaded successfully
    char                szFilePath[MAX_PATH];           // uploaded local picture name 
    BYTE                byReserved[1024];               // reserve 
}EVENT_SNAP_UPLOAD_INFO;

// alarm event type DH_ALARM_UPLOADPIC_FAILCOUNT (failed data number during uploading) corresponding data description info 
typedef struct tagALARM_UPLOADPIC_FAILCOUNT_INFO
{
    int                 nFailCount;                     // upload failure number
    BYTE                byReserved[1024];               // reserve
} ALARM_UPLOADPIC_FAILCOUNT_INFO;

// alarm event type DH_ALARM_HUMAN_INSIDE(Human inside) corresponding data description info
typedef struct tagALARM_HUMAN_INSIDE_INFO
{
    int                 nChannelID;                     // channel number
    int                 nEventAction;                   // event action, -1: unknown, 0: start, 1: stop
    int                 nHumanNumber;                   // Human number inside
    NET_TIME            stuUtcTime;                     // event time
    BYTE                byReserved[1000];               // reserve  
} ALARM_HUMAN_INSIDE_INFO;

// alarm event type DH_ALARM_HUMAN_TUMBLE_INSIDE(someone tumbles inside) corresponding data description info
typedef struct tagALARM_HUMAN_TUMBLE_INSIDE_INFO
{
    int                 nChannelID;                     // channel number
    int                 nEventAction;                   // event action, -1: unknown, 0: start, 1: stop
    NET_TIME            stuUtcTime;                     // event time
    BYTE                byReserved[1000];               // reserve
} ALARM_HUMAN_TUMBLE_INSIDE_INFO;

// alarm event type DH_ALARM_DISABLE_LOCKIN(Lock entry trigger event) corresponding data description info
typedef struct tagALARM_DISABLE_LOCKIN_INFO
{
    int                 nChannelID;                     // channel number
    NET_TIME            stuUtcTime;                     // event time
    BYTE                byReserved[1000];               // reserve
} ALARM_DISABLE_LOCKIN_INFO;


// alarm event type DH_ALARM_DISABLE_LOCKOUT(Lock go out trigger)  corresponding data description info
typedef struct tagALARM_DISABLE_LOCKOUT_INFO
{
    int                 nChannelID;                     // channel number
    NET_TIME            stuUtcTime;                     // event time
    BYTE                byReserved[1000];               // reserve
} ALARM_DISABLE_LOCKOUT_INFO;

//CLIENT_GetOperatorName input parameter 
typedef struct tagNET_IN_GET_OPERATOR_NAME
{
    BYTE                byReserved[1024];               // reserve
} NET_IN_GET_OPERATOR_NAME;

//CLIENT_GetOperatorName output parameter 
typedef struct tagNET_OUT_GET_OPERATOR_NAME
{
    char                szOpearatorName[DH_COMMON_STRING_64]; // operator username 
    BYTE                byReserved[1024];                     // reserve 
} NET_OUT_GET_OPERATOR_NAME;

// CLIENT_GetSelfCheckInfo input param
typedef struct tagNET_IN_GET_SELTCHECK_INFO
{
    DWORD               dwSize;                  // caller must initializes it before using, should be sizeof (NET_IN_GET_SELTCHECK_INFO)
} NET_IN_GET_SELTCHECK_INFO;

//IVS event type EVENT_IVS_PTZ_PRESET(PTZ turn to preset enet)data description
typedef struct tagDEV_EVENT_ALARM_PTZ_PRESET_INFO
{
    int                 nChannelID;                                 // channel id
    char                szName[DH_EVENT_NAME_LEN];                  // event name
    char                bReserved1[4];                              // keep align
    double              PTS;                                        // PTS
    NET_TIME_EX         UTC;                                        // event time
    int                 nEventID;                                   // event ID
    ///////////////////////////////up is common//////////////////////////////
    char                szPresetName[PTZ_PRESET_NAME_LEN];          // preset name
    PTZ_SPEED_UNIT      stuPos;                                     // preset ptz
    int                 nPresetID;                                  // preset id
    BYTE                bReserved[1024];                            // reserved
} DEV_EVENT_ALARM_PTZ_PRESET_INFO;

//IVS event type EVENT_IVS_RFID_INFO(event of infrared detect info)data description
typedef struct tagDEV_EVENT_ALARM_RFID_INFO
{
    int                 nChannelID;                                 // channel id
    char                szName[DH_EVENT_NAME_LEN];                  // event name
    char                bReserved1[4];                              // keep align
    double              PTS;                                        // PTS
    NET_TIME_EX         UTC;                                        // event time
    int                 nEventID;                                   // event ID
    ///////////////////////////////up is common//////////////////////////////
    int                 nAction;                                    // 0:start 1:stop
    int                 nValidCount;                                // the valid number of RFID identifier's array
    char                szRfid[10][12];                             // the array of RFID identifier
    BYTE                bReserved[1024];                            // reserved
} DEV_EVENT_ALARM_RFID_INFO;

// 
typedef struct tagNET_CAR_WEIGTH_INFO
{
	unsigned int		nAxleNum;									// Axle number
	unsigned int		nMaxAxleDistance;							// Max Distance of axle, unit(mm).
    unsigned int        nAxleWeightInfo[MAX_AXLE_NUM];              // Weight of each axle,unit(Kg)
    unsigned int        nAxleDistanceInfo[MAX_AXLE_NUM-1];          // The Distance between the alxe, unit(mm)
    unsigned int        nOverWeight;                                // Over weight info, unit(kg).
    BYTE                byReserved[512];                            // Reserved
}NET_CAR_WEIGHT_INFO;

// IVS evnent EVENT_IVS_QSYTRAFFICCARWEIGHT
typedef struct tagDEV_EVENT_QSYTRAFFICCARWEIGHT_INFO  
{
    NET_CAR_WEIGHT_INFO	                stCarWeightInfo;			// Car weight information
    DEV_EVENT_TRAFFICJUNCTION_INFO      stJunctionInfo;             // Traffic Junctioin information
}DEV_EVENT_QSYTRAFFICCARWEIGHT_INFO;

//the info of plate
typedef struct tagNET_PLATE_INFO
{
	char						szFrontPlateNumber[DH_MAX_PLATE_NUMBER_LEN];	// the number of front plate
	EM_NET_PLATE_COLOR_TYPE		emFrontPlateColor;								// the color of front plate
	char						szBackPlateNumber[DH_MAX_PLATE_NUMBER_LEN];		// the number of back plate
	EM_NET_PLATE_COLOR_TYPE		emBackPlateColor;								// the color of back plate
	BYTE						bReserved[1024];								// Reserved 
} NET_PLATE_INFO;

// the pic's snap time info from the front and back traffic gate
typedef struct tagNET_SNAP_TIME_INFO
{
    NET_TIME_EX stFrontGateSnapTime;    // the snapshot time info from the front traffic gate
    NET_TIME_EX stBackGateSnapTime;     // the snapshot time info from the back traffic gate
    BYTE  bReserved[128];       // Reserved bytes
}NET_SNAP_TIME_INFO;


// IVS event type EVENT_IVS_TRAFFIC_COMPAREPLATE(compare plate event)data description
typedef struct tagDEV_EVENT_TRAFFIC_COMPAREPLARE_INFO
{
	int					nChannelID;							// channel ID
	char				szName[DH_EVENT_NAME_LEN];			// event name
	int                 nTriggerType;                   	// Trigger Type, 0 vehicle inspection device, 1 radar, 2 video
	double				dbPTS;								// PTS(ms)
	NET_TIME_EX			stuUTC;								// the event happen time
	int					nEventID;							// event id

	DH_MSG_OBJECT		stuObject;							// have being detected object
	DH_MSG_OBJECT		stuVehicle;							// vehicle	info
	DH_EVENT_FILE_INFO  stuFileInfo;                        // event file info
	int					nMark;								// for marking the snap frame
	int					nSource;							// the source address of video analysis
	int					nFrameSequence;						// video frame number
	int					nSpeed;								// the speed of this car(unit:km/h)
	int					nLane;								// the corresponding lane nubmer
	int					nSequence;							// snap index,such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;         // Traffic vehicle info
	NET_PLATE_INFO		stuPlateInfo;						// the plate info
	EVENT_COMM_INFO     stCommInfo;                         // public info
	DWORD               dwSnapFlagMask;	                	// flag(by bit),see NET_RESERVED_COMMON
    NET_SNAP_TIME_INFO  stSnapTimeInfo;                     // the pic's snap time info from the front and back traffic gate
	BYTE				bReserved[820];					    // Reserved 
} DEV_EVENT_TRAFFIC_COMPAREPLATE_INFO;


typedef struct tagDEV_EVENT_SHOOTING_SCORE_RECOGNITION_INFO
{
    int							nChannelID;									// channel ID
    char						szName[DH_EVENT_NAME_LEN];					// event name
    double						dbPTS;										// PTS(ms)
    NET_TIME_EX					stuUTC;										// time of occurrence
    int							nEventID;									// event ID
    DH_EVENT_FILE_INFO			stuFileInfo;								// event file info
    BYTE						bEventAction;								// event action,0 pulse,1 durable events begin, 2 durable events end
	DH_POINT					stuDetectRegion;							// rule detect region
	int							nValidBulletHolesNum;						// bullet holes number
	NET_BULLET_HOLES_INFO       stuBulletHolesInfo[DH_MAX_BULLET_HOLES];	// detect bullet holes info 
    BYTE						byImageIndex;								// Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD						dwSnapFlagMask;								// flag(by bit),see NET_RESERVED_COMMON    
    BYTE						bReserved[1024];							// Reserved
} DEV_EVENT_SHOOTING_SCORE_RECOGNITION_INFO;


// IVS event type EVENT_IVS_TRAFFIC_TRANSFINITE(traffic transfinite event)data description
typedef struct tagDEV_EVENT_TRAFFIC_TRANSFINITE_INFO
{
    int							nChannelID;									// channel ID
    char						szName[DH_EVENT_NAME_LEN];					// event name
    double						dbPTS;										// PTS(ms)
    NET_TIME_EX					stuUTC;										// time of occurrence
    int							nEventID;									// event ID
    DH_EVENT_FILE_INFO			stuFileInfo;								// event file info
    BYTE						bEventAction;								// event action,0 pulse,1 durable events begin, 2 durable events end
	
	char						szPlateNumber[16];							// plate number
    char                        szTime[20];									// transfinite time
	double						dbLong;										// length, unit:meter
    double						dbWidth;									// width, unit:meter
	double						dbHeight;									// Height, unit: meter
	char						szViolationCode[16];						// violate code
	char						szDescribe[132];						    // violate describe
	
    BYTE						byImageIndex;								// Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD						dwSnapFlagMask;								// flag(by bit),see NET_RESERVED_COMMON    
    BYTE						bReserved[4096];							// Reserved
} DEV_EVENT_TRAFFIC_TRANSFINITE_INFO;

// information of the picture 
typedef struct tagDEV_EVENT_TRAFFIC_FCC_IMAGE 
{
	DWORD                dwOffSet;                      // current picture file's offset in the binary file, byte
	DWORD                dwLength;						// current picture file's size, byte
	WORD                 wWidth;                        // picture width, pixel
	WORD                 wHeight;                       // picture high, pixel
}DEV_EVENT_TRAFFIC_FCC_IMAGE;

//information of the object
typedef struct tagDEV_EVENT_TRAFFIC_FCC_OBJECT
{
	DEV_EVENT_TRAFFIC_FCC_IMAGE	stuImage;							// information of car picture
}DEV_EVENT_TRAFFIC_FCC_OBJECT;

//EVENT_IVS_TRAFFIC_FCC_INFO
typedef struct tagDEV_EVENT_TRAFFIC_FCC_INFO
{
	int                 nChannelID;                                 // channel ID
    char                szName[DH_EVENT_NAME_LEN];                  // event name
    DWORD				nTriggerID;									// Trigger ID
    double              PTS;                                        // PTS(ms)
    NET_TIME_EX         UTC;                                        // the event happen time
    int                 nEventID;                                   // event id
	///////////////////////////////up is common//////////////////////////////

	DWORD				dwNum;										// fuel truck nozzle number
	DWORD				dwLitre;									// refuel volume: 0.01 litre
	EM_REFUEL_TYPE		emType;										// refuel type {"98#","97#","95#","93#","90#","10#","5#","0#","-10#","-20#","-35#","-50#"}
	DWORD				dwMoney;									// refuel money spend: 0.01 RMB
	char				szPlateNumber[DH_COMMON_STRING_16];			// car number: "2016-05-23 10:31:17"
	char				szTime[DH_COMMON_STRING_32];				// Event occurrence time 
	DEV_EVENT_TRAFFIC_FCC_OBJECT	stuObject;						// information of car picture
	BYTE				bReserved[1024];							// Reserved
}DEV_EVENT_TRAFFIC_FCC_INFO;

typedef enum tagEM_PARKINGSPACE_STATUS
{
    EM_PARKINGSPACE_STATUS_UNKNOWN,
    EM_PARKINGSPACE_STATUS_BUSY,                            // busy
    EM_PARKINGSPACE_STATUS_FREE,                            // free
    EM_PARKINGSPACE_STATUS_OVERLINE,                        // overline
}EM_PARKINGSPACE_STATUS;

// Parking information matting
typedef struct tagNET_FEATUREPIC_AREA
{
	int					nRetCount;									// Return  coordinate count	
	DH_POINT			stuFeaturePicArea[10];						// Parking information coordinate  matting							
	BYTE				bReserved[256];					            // Reserved	
}NET_FEATUREPIC_AREA;

typedef struct tagDEV_EVENT_TRAFFIC_ANALYSE_PRESNAP_INFO
{
    int                 nChannelID;                                 // channel id
    char                szName[128];                                // envent name
    char                bReserved1[4];                              // keep align
    double              PTS;                                        // Time stamp (unit:ms)
    NET_TIME_EX         stuTime;                                    // Event occurrence time 
    int                 nEventID;                                   // Event ID
    int                 nGroupID;                                   // nGroupID event group ID. The nGroupID is the same for the snap process of the same object 
    int                 nCountInGroup;                              // nCountInGroup snap amount of one event group 
    int                 nIndexInGroup;                              // IndexInGroup snap SN of one event group
    DH_MSG_OBJECT       stuObject;                                  // plate info
    DH_MSG_OBJECT       stuVehicle;                                 // Vehicle info 
    int					nMark;								        // for marking the snap frame
    int					nSource;							        // the source address of video analysis
    int					nFrameSequence;						        // video frame number
    int					nLane;								        // the corresponding lane nubmer 
    int					nSequence;							        // snap index,such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // Traffic vehicle info
    EM_PARKINGSPACE_STATUS   emParkingSpaceStatus;                  // all parking space status
    EVENT_COMM_INFO     stCommInfo;                                 // public info
	EM_PARKINGSPACE_STATUS   emCurParkingSpaceStatus;				// Parking spaces corresponding to the current parking spaces
	NET_FEATUREPIC_AREA		 stuParkingInfo;						// Parking information to support the existing matting coordinates, 4 vertices, the absolute coordinates, the range is determined by the resolution of the picture
    DH_RESOLUTION_INFO       stuResolution;                         // Image resolution
	BYTE				bReserved[716];					        	// Reserved
}DEV_EVENT_TRAFFIC_ANALYSE_PRESNAP_INFO;

//IVS event type NEAR_DISTANCE_DETECTION(near distance detection event)data description
typedef struct tagDEV_EVENT_NEAR_DISTANCE_DETECTION_INFO
{
    int                 nChannelID;                                 // channel ID
    char                szName[DH_EVENT_NAME_LEN];                  // event name
    char                bReserved1[4];                              // keep align
    double              PTS;                                        // PTS(ms)
    NET_TIME_EX         UTC;                                        // time of occurrence
    int                 nEventID;                                   // event ID
    ///////////////////////////////up is common//////////////////////////////
    int                 nAction;                                    // event action, 0: Pulse, 1: Start, 2: Stop
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // intelli comm info
    BYTE                bReserved[2048];                            // reserved
} DEV_EVENT_NEAR_DISTANCE_DETECTION_INFO;


// Corresponding to data block description of event type EVENT_IVS_FLOATINGOBJECT_DETECTION (FloatingObjectDetection)
typedef struct tagDEV_EVENT_FLOATINGOBJECT_DETECTION_INFO
{
	int                 nChannelID;                         // Channel ID
	int					nAction;							// Event action, 0: Pulse, 1: Start, 2: Stop
	char                szName[128];                        // Evnet name
	double              PTS;                                // Timestamp (in milliseconds)
	NET_TIME_EX         UTC;                                // Time for the event occurred
	int                 nEventID;                           // Event ID
	DH_EVENT_FILE_INFO  stuFileInfo;                        // Event corresponding to file information
	NET_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM]; // The point list of rule detect region
	int                 nDetectRegionNum;                   // The point number of rule detect region
	int                 nImageIndex;                        // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	DWORD               dwSnapFlagMask;                     // snapshot mark (by bit), see NET_RESERVED_COMMON   
	int                 nSourceIndex;                       // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];           // the source device's sign(exclusive),field said local device does not exist or is empty
	UINT        		nOccurrenceCount;                   // event trigger accumilated times 
	int                 nObjectNum;                         // have being detected objects number
	DH_MSG_OBJECT       stuObjects[HDBJ_MAX_OBJECTS_NUM];	// have being detected objects
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // Intelli comm info  
	char				szPresetName[64];					// Preset name
	BOOL				bExistFloatingObject;				// Whether there is floating object?
	NET_EM_EVENT_DATA_TYPE		emEventType;				// Data type
	float				fCurrentRatio;						// The current proportion of flotage(relative to detection area) Unit:%, Range[0, 100]
	float				fAlarmThreshold;					// The alarm threshold of proportion, Range[0, 100]
	NET_INTELLIGENCE_IMAGE_INFO	stuOriginalImage;			// Original image information
	NET_INTELLIGENCE_IMAGE_INFO	stuSceneImage;				// Scene image information
	BYTE                byReserved[3956];                   // Reserved
} DEV_EVENT_FLOATINGOBJECT_DETECTION_INFO;

// Corresponding to data block description of event type EVENT_IVS_WATER_LEVEL_DETECTION (WaterLevelDetection)
typedef struct tagDEV_EVENT_WATER_LEVEL_DETECTION_INFO
{
	int							nChannelID;										// Channel ID
	int							nAction;										// Event action, 0: Pulse, 1: Start, 2: Stop
	char						szName[MAX_EVENT_NAME];							// Evnet name
	double						PTS;											// Timestamp (in milliseconds)
	NET_TIME_EX					UTC;											// Time for the event occurred
	int							nEventID;										// Event ID

	DH_EVENT_FILE_INFO			stuFileInfo;									// Event corresponding to file information
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                             // Intelligent common information 
	char						szPresetName[64];								// Preset name
	char						szObjectUUID[48];								// Object ID
	NET_EM_EVENT_DATA_TYPE		emEventType;									// Event type
	NET_EM_WATER_LEVEL_STATUS	emStatus;										// Water level status
	NET_WATER_RULER				stuWaterRuler;									// Ruler of water level  
	NET_INTELLIGENCE_IMAGE_INFO	stuOriginalImage;								// Original image
	NET_INTELLIGENCE_IMAGE_INFO	stuSceneImage;									// Snap picture of snapped by camera in minimum of focal length 

	BYTE						byReserved[1024];                               // Reserved
}DEV_EVENT_WATER_LEVEL_DETECTION_INFO;

// Corresponding to data block description of event type EVENT_IVS_SHIP_DETECTION (ShipDetection)
typedef struct tagDEV_EVENT_SHIP_DETECTION_INFO
{
	int                 nChannelID;                         // Channel ID
	int					nAction;							// Event action, 0: Pulse, 1: Start, 2: Stop
	char                szName[128];                        // Evnet name
	double              PTS;                                // Timestamp (in milliseconds)
	NET_TIME_EX         UTC;                                // Time for the event occurred
	int                 nEventID;                           // Event ID
	DH_EVENT_FILE_INFO  stuFileInfo;                        // Event corresponding to file information
	NET_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM]; // The point list of rule detect region
	int                 nDetectRegionNum;                   // The point number of rule detect region
	int                 nImageIndex;                        // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	DWORD               dwSnapFlagMask;                     // snapshot mark (by bit), see NET_RESERVED_COMMON     
	int                 nSourceIndex;                       // the source device's index,-1 means data in invalid
	NET_CROSSREGION_DIRECTION_INFO emDirection;             // Direction
	NET_CROSSREGION_ACTION_INFO    emActionType;            // Action
	char                szSourceDevice[MAX_PATH];           // the source device's sign(exclusive),field said local device does not exist or is empty
	UINT        		nOccurrenceCount;                   // event trigger accumilated times 
	int                 nTrackLineNum;                             // object moving track's point number
	NET_POINT            stuTrackLine[DH_MAX_TRACK_LINE_NUM];// object moving track
	DH_MSG_OBJECT       stuObject;                          // Object detected
	DH_MSG_OBJECT		stuObjects[HDBJ_MAX_OBJECTS_NUM];		// have being detected objects
	int                 nObjectNum;                     	// have being detected objects number
	int                 nTrackNum;                      	// track line number
	DH_POLY_POINTS      stuTrackInfo[HDBJ_MAX_OBJECTS_NUM];	// track lines info
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // Intelli common information
	char				szPresetName[64];					// Preset name
	BOOL				bExistShip;							// Whether there is ship?
	BYTE                bReserved[4096];                     // Reserved
} DEV_EVENT_SHIP_DETECTION_INFO;


// Corresponding to data block description of event type EVENT_IVS_HOLD_UMBRELLA (HoldUmbrella)
typedef struct tagDEV_EVENT_HOLD_UMBRELLA_INFO
{
    int                 nChannelID;                         // Channel ID
    int					nAction;							// Event action, 0: Pulse, 1: Start, 2: Stop
    char                szName[128];                        // Event name
    double              PTS;                                // Timestamp (in milliseconds)
    NET_TIME_EX         UTC;                                // Time for the event occurred
    UINT                nEventID;                           // Event ID
    DH_EVENT_FILE_INFO	stuFileInfo;						// Event corresponding to file information
    NET_POINT           DetectRegion[DH_MAX_DETECT_REGION_NUM]; // The point list of rule detect region
    int                 nDetectRegionNum;                   // The point number of rule detect region
    DH_MSG_OBJECT       stuObjects[HDBJ_MAX_OBJECTS_NUM];	// Object detected
    int                 nObjectNum;                         // have being detected objects
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // Intelligent common information
    char				szPresetName[64];					// Preset name
    UINT                nViolationDuration;                 // Duration of violation of law,unit:second,default value 0 is meaningless
    char				szSourceID[32];						// Correlate event ID, events arising from same object or picture could have same correlate event ID
	DWORD               dwSnapFlagMask;                     // flag(by bit),see NET_RESERVED_COMMON    
    BYTE                bReserved[4092];                    // Reserved
} DEV_EVENT_HOLD_UMBRELLA_INFO;

// Corresponding to data block description of event type EVENT_IVS_GARBAGE_EXPOSURE (GarbageExposure)
typedef struct tagDEV_EVENT_GARBAGE_EXPOSURE_INFO
{
    int                 nChannelID;                         // Channel ID
    int					nAction;							// Event action, 0: Pulse, 1: Start, 2: Stop
    char                szName[128];                        // Event name
    double              PTS;                                // Timestamp (in milliseconds)
    NET_TIME_EX         UTC;                                // Time for the event occurred
    UINT                nEventID;                           // Event ID
    DH_EVENT_FILE_INFO	stuFileInfo;						// Event corresponding to file information
    NET_POINT           DetectRegion[DH_MAX_DETECT_REGION_NUM]; // The point list of rule detect region
    int                 nDetectRegionNum;                   // The point number of rule detect region
    DH_MSG_OBJECT       stuObjects[HDBJ_MAX_OBJECTS_NUM];	// Object detected
    int                 nObjectNum;                         // have being detected objects
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // Intelligent common information
    char				szPresetName[64];					// Preset name
    UINT                nViolationDuration;                 // Duration of violation of law,unit:second,default value 0 is meaningless
    char				szSourceID[32];						// Correlate event ID, events arising from same object or picture could have same correlate event ID
	DWORD               dwSnapFlagMask;                     // flag(by bit),see NET_RESERVED_COMMON      
    BYTE                bReserved[4092];                    // Reserved
} DEV_EVENT_GARBAGE_EXPOSURE_INFO;

// Corresponding to data block description of event type EVENT_IVS_DUSTBIN_OVER_FLOW (DustbinOverflow)
typedef struct tagDEV_EVENT_DUSTBIN_OVER_FLOW_INFO
{
    int                 nChannelID;                         // Channel ID
    int					nAction;							// Event action, 0: Pulse, 1: Start, 2: Stop
    char                szName[128];                        // Event name
    double              PTS;                                // Timestamp (in milliseconds)
    NET_TIME_EX         UTC;                                // Time for the event occurred
    UINT                nEventID;                           // Event ID
    DH_EVENT_FILE_INFO	stuFileInfo;						// Event corresponding to file information
    NET_POINT           DetectRegion[DH_MAX_DETECT_REGION_NUM]; // The point list of rule detect region
    int                 nDetectRegionNum;                   // The point number of rule detect region
    DH_MSG_OBJECT       stuObjects[HDBJ_MAX_OBJECTS_NUM];	// Object detected
    int                 nObjectNum;                         // have being detected objects
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // Intelligent common information
    char				szPresetName[64];					// Preset name
    UINT                nViolationDuration;                 // Duration of violation of law,unit:second,default value 0 is meaningless
    char				szSourceID[32];						// Correlate event ID, events arising from same object or picture could have same correlate event ID
	DWORD               dwSnapFlagMask;                     // flag(by bit),see NET_RESERVED_COMMON  
    BYTE                bReserved[4092];                    // Reserved
} DEV_EVENT_DUSTBIN_OVER_FLOW_INFO;

// Corresponding to data block description of event type EVENT_IVS_DOOR_FRONT_DIRTY (DoorFrontDirty)
typedef struct tagDEV_EVENT_DOOR_FRONT_DIRTY_INFO
{
    int                 nChannelID;                         // Channel ID
    int					nAction;							// Event action, 0: Pulse, 1: Start, 2: Stop
    char                szName[128];                        // Event name
    double              PTS;                                // Timestamp (in milliseconds)
    NET_TIME_EX         UTC;                                // Time for the event occurred
    UINT                nEventID;                           // Event ID

    DH_EVENT_FILE_INFO	stuFileInfo;						// Event corresponding to file information
    NET_POINT           DetectRegion[DH_MAX_DETECT_REGION_NUM]; // The point list of rule detect region
    int                 nDetectRegionNum;                   // The point number of rule detect region
    DH_MSG_OBJECT       stuObjects[HDBJ_MAX_OBJECTS_NUM];	// Object detected
    int                 nObjectNum;                         // have being detected objects
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // Intelligent common information
    char				szPresetName[64];					// Preset name
    char				szShopAddress[256];					// Address of shop
    UINT                nViolationDuration;                 // Duration of violation of law,unit:second,default value 0 is meaningless
    char				szSourceID[32];						// Correlate  event ID, events arising from same object or picture could have same correlate event ID
	DWORD               dwSnapFlagMask;                     // flag(by bit),see NET_RESERVED_COMMON
    BYTE                bReserved[4092];                    // Reserved
} DEV_EVENT_DOOR_FRONT_DIRTY_INFO;

// The type of trigger of helmet detection event 
typedef enum tagEM_HELMET_EVENT_TYPE
{
    EM_UNKNOWN_TYPE,
    EM_NOT_WEAR_HELMET,         // Not wear helmet 
}EM_HELMET_EVENT_TYPE;

// Corresponding to data block description of event type EVENT_IVS_HELMET_DETECTION (HelmetDetection)
typedef struct tagDEV_EVENT_HELMET_DETECTION_INFO
{
    int                     nChannelID;                         // Channel ID
    int					    nAction;							// Event action, 0: Pulse, 1: Start, 2: Stop
    char                    szName[128];                        // Event name
    double                  PTS;                                // Timestamp (in milliseconds)
    NET_TIME_EX             UTC;                                // Time for the event occurred   
    EM_CLASS_TYPE		    emClassType;						// class type
    UINT                    nEventID;                           // Event ID
    UINT                    nRuleID;                            // Rule ID
    int                     nObjectID;			                // Object ID
    DH_EVENT_FILE_INFO	    stuFileInfo;						// Event corresponding to file information
    EM_HELMET_EVENT_TYPE    emHelmetEventType ;                 // The type of trigger of helmet detection event 
    HUMAN_IMAGE_INFO        stuHumanImage;                      // Human trait image
    SCENE_IMAGE_INFO        stuSceneImage;                      // Scene image
}DEV_EVENT_HELMET_DETECTION_INFO;

// Mask infromation
typedef struct tagNET_CFG_MASK_INFO
{
	UINT					nOffset;							// The offset of mask in binary data
	UINT					nLength;							// The length of mask data,Unit:Byte
	BYTE					byReserved[1016];
}NET_CFG_MASK_INFO;

// Corresponding to data block description of event type EVENT_IVS_DEPOSIT_DETECTION (DepositDetection)
typedef struct tagDEV_EVENT_DEPOSIT_DETECTION_INFO
{
    int                 nChannelID;                         // Channel ID
    int					nAction;							// Event action, 0: Pulse, 1: Start, 2: Stop
    char                szName[128];                        // Event name
    double              PTS;                                // Timestamp (in milliseconds)
    NET_TIME_EX         UTC;                                // Time for the event occurred   
    DH_EVENT_FILE_INFO	stuFileInfo;						// Event corresponding to file information
    UINT                nEventID;                           // Event ID
    int                 nDetectRegionNum;                    // The point number of rule detect region
    NET_POINT           DetectRegion[DH_MAX_DETECT_REGION_NUM]; // The point list of rule detect region
    char                szRegionName[64];                   // RegionName
    UINT                nStackThreshold;                    // Percentage of packages accumulated
    UINT                nGridState;                         // Lattice state 0:unknown 1:empty  2:half 3:full 4:house full     
    NET_INTELLIGENCE_IMAGE_INFO  stuSceneImage;             // Scene image
    NET_INTELLIGENCE_IMAGE_INFO  stuDepositImage;           // Lattice image
    BYTE			    byReserved[1024];			        // Reserved for image info
	NET_CFG_MASK_INFO	stuMask;							// Mask information
}DEV_EVENT_DEPOSIT_DETECTION_INFO;

// Corresponding to data block description of event type EVENT_IVS_DEPOSIT_DETECTION
typedef struct tagDEV_EVENT_HOTSPOT_WARNING_INFO
{
	int                 nChannelID;                         // Channel ID
	int					nAction;							// 0:Pulse 1:Start 2:Stop
	char                szName[128];                        // Event name
	double              PTS;                                // Timestamp (in milliseconds)
	NET_TIME_EX         UTC;                                // Time for the event occurred  
	DH_EVENT_FILE_INFO	stuFileInfo;						// Event corresponding to file information
	UINT                nEventID;                           // Event ID

    DH_POINT				stuPoint;						// Hot spot coordinate,Range: 0~8192
    float					fHotSpotValue;                  // Spot temprature
    NET_TEMPERATURE_UNIT    nTemperatureUnit;               // Temperature unit
    BYTE					byReserved[256];				// Reserved
}DEV_EVENT_HOTSPOT_WARNING_INFO;

// classroom action type
typedef enum tagEM_CLASSROOM_ACTION
{
	EM_CLASSROOM_ACTION_UNKNOWN,			// unknown
	EM_CLASSROOM_ACTION_PLAY_PHONE,			// play phone
	EM_CLASSROOM_ACTION_HANDSUP,			// hands up
	EM_CLASSROOM_ACTION_LISTEN,				// listen
	EM_CLASSROOM_ACTION_READ_WRITE,			// read and write 
	EM_CLASSROOM_ACTION_TABLE,				// on table
} EM_CLASSROOM_ACTION;

// Corresponding to data block description of event type EVENT_IVS_CLASSROOM_BEHAVIOR (classroom dehavior detect)
typedef struct tagDEV_EVENT_CLASSROOM_BEHAVIOR_INFO
{
	int                 			nChannelID;                         		// Channel ID
    int								nAction;									// Event action, 0: Pulse, 1: Start, 2: Stop
    char                			szName[128];                         		// Event name
    double              			PTS;                                		// Timestamp (in milliseconds)
    NET_TIME_EX         			UTC;                                		// Time for the event occurred   
    UINT                			nEventID;                           		// Event ID
    DH_EVENT_FILE_INFO				stuFileInfo;								// Event corresponding to file information

	EM_CLASS_TYPE		            emClassType;								// Class type
	UINT							nRuleID;									// Rule ID
	UINT							nObjectID;									// Object ID
	UINT							nSequence;									// Sequence
	EM_CLASSROOM_ACTION				emClassroomAction;							// Classroom action
	NET_POINT           			stuDetectRegion[DH_MAX_DETECT_REGION_NUM]; 	// The point list of rule detect region
	int                 			nDetectRegionNum;                   		// The point number of rule detect region
	UINT							nPresetID;									// Preset ID
	char							szPresetName[64];							// Preset name
	char							szSerialUUID[22];							// Serial UUID
																				// The format is as followsFront 2:%d%d:01-video,02-picture,03-file,99-other;
																				// Middle 14:YYYYMMDDhhmmss:year,month,day,hour,minute,second;Last 5:%u%u%u%u%uobject IDas 00001
	BYTE			    			byReserved1[2];								// For align
    DH_RECT             			stuBoundingBox;                        		// Bounding box
    NET_INTELLIGENCE_IMAGE_INFO		stuSceneImage;           					// Scene image
    NET_INTELLIGENCE_IMAGE_INFO    	stuFaceImage;         						// Face image
    NET_FACE_ATTRIBUTE_EX			stuFaceAttributes;							// Face attributes
    BYTE			    			byReserved[1024];			        		// Reserved
} DEV_EVENT_CLASSROOM_BEHAVIOR_INFO;


// Corresponding to data block description of event type EVENT_IVS_VEHICLE_DISTANCE_NEAR (safe driving vehicle distance near)
typedef struct tagDEV_EVENT_VEHICLE_DISTANCE_NEAR_INFO
{
    int                 nAction;                                    // action of event, 0 means pulse event,1 means continuous event's begin,2means continuous event's end
    NET_TIME_EX         UTC;                                        // time of  event occurrence
    NET_GPS_STATUS_INFO stuGPSStatusInfo;                           // GPS info
    char                szDriverID[32];                             // driver ID
    char                szVideoPath[256];                           // ftp path for assocated video
    BYTE                bReserved[736];                             // reserved
} DEV_EVENT_VEHICLE_DISTANCE_NEAR_INFO;

// Corresponding to data block description of event type EVENT_IVS_TRAFFIC_DRIVER_ABNORMAL (traffic driver abnormal)
typedef struct tagDEV_EVENT_TRAFFIC_DRIVER_ABNORMAL_INFO
{
    int                 nChannelID;                                // channel ID
    int					nAction;							       // action of event, 0 means pulse event,1 means continuous event's begin,2means continuous event's end
    NET_GPS_STATUS_INFO stuGPSStatusInfo;                          // GPS info
    NET_TIME_EX         UTC;							           // time of  event occurrence
    char                szVideoPath[256];                          // ftp path for assocated video
    BYTE                bReserved[768];                            // reserved
} DEV_EVENT_TRAFFIC_DRIVER_ABNORMAL_INFO;

// Corresponding to data block description of event type EVENT_IVS_TRAFFIC_DRIVER_CHANGE (traffic driver change)
typedef struct tagDEV_EVENT_TRAFFIC_DRIVER_CHANGE_INFO
{
    int                 nChannelID;                                // channel ID
    int					nAction;							       // action of event, 0 means pulse event,1 means continuous event's begin,2means continuous event's end
    NET_GPS_STATUS_INFO stuGPSStatusInfo;                          // GPS info
    NET_TIME_EX         UTC;							           // time of  event occurrence
    char                szPrevDriverID[MAX_COMMON_STRING_32];      // previous driver ID
    char                szCurDriverID[MAX_COMMON_STRING_32];       // current driver ID
    char                szVideoPath[256];                          // ftp path for assocated video
    BYTE                bReserved[768];                            // reserved
} DEV_EVENT_TRAFFIC_DRIVER_CHANGE_INFO;

// The state of helmet
typedef enum tagEM_WORK_HELMET_STATE
{
	EM_HELMET_STATE_UNKNOWN,		// Unknown
	EM_HELMET_STATE_NOTWEAR,		// No helmet
	EM_HELMET_STATE_WEAR,			// Wear helmet
} EM_WORK_HELMET_STATE;

// Attribute of helmet
typedef struct tagNET_HELMET_ATTRIBUTE
{
	EM_WORK_HELMET_STATE			emHelmetState;								// The state of helmet
	EM_CLOTHES_COLOR				emHelmetColor;								// Color of helmet
	BYTE			    			byReserved[1024];			        		// Reserved
} NET_HELMET_ATTRIBUTE;

// The state of work clothes
typedef enum tagEM_WORKCLOTHES_STATE
{
	EM_WORKCLOTHES_STATE_UNKNOWN,		// Unknown
	EM_WORKCLOTHES_STATE_NOTWEAR,		// No work clothes
	EM_WORKCLOTHES_STATE_WEAR,			// Wear work clothes
} EM_WORKCLOTHES_STATE;

// Attribute of work clothes
typedef struct tagNET_WORKCLOTHES_ATTRIBUTE
{
	EM_WORKCLOTHES_STATE			emWorkClothesState;							// The state of work clothes
	EM_CLOTHES_COLOR				emWorkClothColor;							// Color of work clothes
	BYTE			    			byReserved[1024];			        		// Reserved
} NET_WORKCLOTHES_ATTRIBUTE;

// Corresponding to data block description of event type EVENT_IVS_WORKCLOTHES_DETECT (work clothes(helmet/clothes)detection)
typedef struct tagDEV_EVENT_WORKCLOTHES_DETECT_INFO
{
	int                 			nChannelID;                         		// Channel ID
    int								nAction;									// Event action, 0: Pulse, 1: Start, 2: Stop
    char                			szName[128];                         		// Event name
    double              			PTS;                                		// Timestamp (in milliseconds)
    NET_TIME_EX         			UTC;                                		// Time for the event occurred   
    UINT                			nEventID;                           		// Event ID

	EM_CLASS_TYPE				    emClassType;								// Class type
	UINT							nRuleID;									// Rule ID
	UINT							nObjectID;									// Object ID
	UINT							nGroupID;									// Event group ID,A detection of multiple workclothes detectionat the same nGroupID
	UINT							nCountInGroup;								// the captured workclothes number within an event group,A detection of multiple workclothes detection at the same nCountInGroup
	UINT							nIndexInGroup;								// capture Index of an event group,starting from 1
    SCENE_IMAGE_INFO				stuSceneImage;           					// Scene image info
    HUMAN_IMAGE_INFO    			stuHumanImage;         						// Human image info
    NET_HELMET_ATTRIBUTE			stuHelmetAttribute;							// Helmet attribute
    NET_WORKCLOTHES_ATTRIBUTE		stuWorkClothesAttribute;					// Work clothes attribute
    BYTE			    			byReserved[1024];			        		// Reserved
} DEV_EVENT_WORKCLOTHES_DETECT_INFO;


// Security gate person pass direction
typedef enum tagEM_SECURITYGATE_PERSON_PASS_DIRECTION
{
	EM_SECURITYGATE_PERSON_PASS_DIRECTION_UNKNOWN = 0,								// Unknown
	EM_SECURITYGATE_PERSON_PASS_DIRECTION_IN,										// in
	EM_SECURITYGATE_PERSON_PASS_DIRECTION_OUT,										// out
}EM_SECURITYGATE_PERSON_PASS_DIRECTION;

// Security gate person alarm level
typedef enum tagEM_SECURITYGATE_ALARM_LEVEL
{
	EM_SECURITYGATE_ALARM_LEVEL_UNKNOWN = 0,										// Unknown
	EM_SECURITYGATE_ALARM_LEVEL_NON,												// no alarm
	EM_SECURITYGATE_ALARM_LEVEL_LOW,												// low level alarm
	EM_SECURITYGATE_ALARM_LEVEL_MIDDLE,												// middle level alarm
	EM_SECURITYGATE_ALARM_LEVEL_HIGH,												// high level alarm
}EM_SECURITYGATE_ALARM_LEVEL;

// Position of security gate alarm
typedef enum tagEM_SECURITYGATE_ALARM_POSITION
{
    EM_SECURITYGATE_ALARM_POSITION_UNKNWON       = -1,       // unknown
    EM_SECURITYGATE_ALARM_POSITION_LEFT_1,                   // left 1
    EM_SECURITYGATE_ALARM_POSITION_LEFT_2,                   // left 2
    EM_SECURITYGATE_ALARM_POSITION_LEFT_3,                   // left 3
    EM_SECURITYGATE_ALARM_POSITION_LEFT_4,                   // left 4
    EM_SECURITYGATE_ALARM_POSITION_LEFT_5,                   // left 5
    EM_SECURITYGATE_ALARM_POSITION_LEFT_6,                   // left 6
    EM_SECURITYGATE_ALARM_POSITION_MIDDLE_1,                 // middle 1
    EM_SECURITYGATE_ALARM_POSITION_MIDDLE_2,                 // middle 2
    EM_SECURITYGATE_ALARM_POSITION_MIDDLE_3,                 // middle 3
    EM_SECURITYGATE_ALARM_POSITION_MIDDLE_4,                 // middle 4
    EM_SECURITYGATE_ALARM_POSITION_MIDDLE_5,                 // middle 5
    EM_SECURITYGATE_ALARM_POSITION_MIDDLE_6,                 // middle 6
    EM_SECURITYGATE_ALARM_POSITION_RIGHT_1,                  // right 1
    EM_SECURITYGATE_ALARM_POSITION_RIGHT_2,                  // right 2
    EM_SECURITYGATE_ALARM_POSITION_RIGHT_3,                  // right 3
    EM_SECURITYGATE_ALARM_POSITION_RIGHT_4,                  // right 4
    EM_SECURITYGATE_ALARM_POSITION_RIGHT_5,                  // right 5
    EM_SECURITYGATE_ALARM_POSITION_RIGHT_6,                  // right 6
} EM_SECURITYGATE_ALARM_POSITION;

// Corresponding to data block description of event type EVENT_IVS_SECURITYGATE_PERSONALARM (security gate person alarm)
typedef struct tagDEV_EVENT_SECURITYGATE_PERSONALARM_INFO
{
    int                                         nChannelID;                         // Channel id
    int                                         nAction;                            // Event action, 0: Pulse, 1: Start, 2: Stop
    char                                        szName[DH_EVENT_NAME_LEN];          // Event name
    double                                      PTS;                                // Timestamp (in milliseconds)
    NET_TIME_EX                                 UTC;                                // Time for the event occurred   
    UINT                                        nEventID;                           // Event ID
    EM_SECURITYGATE_PERSON_PASS_DIRECTION       emDirection;                        // Direction
    EM_SECURITYGATE_ALARM_LEVEL                 emAlarmLevel;                       // Alarm level
    int                                         nChannelIn;                         // In channel
    int                                         nChannelOut;                        // Out channel
    NET_INTELLIGENCE_IMAGE_INFO                 stuImageInfo;                       // Face image info
    UINT                                        nAlarmPositionNum;                  // Count of alarm position
    EM_SECURITYGATE_ALARM_POSITION              emAlarmPosition[18];                // Position of alarm
    BYTE                                        bReserved[1020];                    // Reserved
}DEV_EVENT_SECURITYGATE_PERSONALARM_INFO;

// human info
typedef struct tagNET_HUMAN
{
    NET_RECT            stuBoundingBox;						// bounding box(8192 coordinate system)
    UINT                nObjectID;                          // Object ID
    BYTE                bReserved[252];                     // reserved
}NET_HUMAN;

// Corresponding to data block description of event type EVENT_IVS_STAY_ALONE_DETECTION
typedef struct tagDEV_EVENT_STAY_ALONE_DETECTION_INFO
{
    int                 nChannelID;                                 // channel ID
    int					nAction;							        // 0:Pulse 1:Start 2:Stop
    char                szName[DH_EVENT_NAME_LEN];                  // Event name
    double              PTS;                                        // timestamp (in milliseconds)
    EM_CLASS_TYPE		emClassType;						        // class type
    NET_TIME_EX         UTC;                                        // time for the event occurred 
    int                 UTCMS;                                      // UTC corresponds to milliseconds
    int                 nEventID;                                   // event ID
    NET_HUMAN           stuHuman;                                   // human info
    SCENE_IMAGE_INFO_EX stuSceneImage;                              // scene image
    int                 nDetectRegionNum;                           // detect region number
    DH_POINT            stuDetectRegion[DH_MAX_DETECT_REGION_NUM];  // detect region
    BYTE                byReserved[1024];                           // reserved
}DEV_EVENT_STAY_ALONE_DETECTION_INFO;

// Corresponding to data block description of event type EVENT_IVS_TRAFFIC_ROAD_BLOCK (traffic road block detection)
typedef struct tagDEV_EVENT_TRAFFIC_ROAD_BLOCK_INFO
{
    int                 nChannelID;                                // Channel ID
    int					nAction;							       // Event action, 0: Pulse, 1: Start, 2: Stop
    char                szName[128];                         	   // Event name
    double              PTS;                                	   // Timestamp (in milliseconds)
    NET_TIME_EX         UTC;                                	   // Time for the event occurred   
    UINT                nEventID;                           	   // Event ID

    DH_EVENT_FILE_INFO	stuFileInfo;							   // Event file info
    NET_RECT			stuBoundingBox;						       // Bounding box
    UINT                nLane;                                     // Lane number
    EVENT_COMM_INFO     stCommInfo;                                // Common info
    DWORD               dwSnapFlagMask;                            // flag(by bit),see NET_RESERVED_COMMON
    BYTE                bReserved[4092];                           // Reserved
} DEV_EVENT_TRAFFIC_ROAD_BLOCK_INFO;

// Corresponding to data block description of event type EVENT_IVS_TRAFFIC_ROAD_CONSTRUCTION (traffic road block construction)
typedef struct tagDEV_EVENT_TRAFFIC_ROAD_CONSTRUCTION_INFO
{
    int                 nChannelID;                                // Channel ID
    int					nAction;							       // Event action, 0: Pulse, 1: Start, 2: Stop
    char                szName[128];                         	   // Event name
    double              PTS;                                	   // Timestamp (in milliseconds)
    NET_TIME_EX         UTC;                                	   // Time for the event occurred   
    UINT                nEventID;                           	   // Event ID

    DH_EVENT_FILE_INFO	stuFileInfo;							   // Event file info
    NET_RECT			stuBoundingBox;						       // Bounding box
    UINT                nLane;                                     // Lane number
    EVENT_COMM_INFO     stCommInfo;                                // Common info
    DWORD               dwSnapFlagMask;                            // flag(by bit),see NET_RESERVED_COMMON
    BYTE                bReserved[4092];                           // Reserved
} DEV_EVENT_TRAFFIC_ROAD_CONSTRUCTION_INFO;

// Work action state of work state detection
typedef enum tagEM_WORKACTION_STATE
{
	EM_WORKACTION_STATE_UNKNOWN,			// Unknown
	EM_WORKACTION_STATE_NO_WORKER,			// No worker
	EEM_WORKACTION_STATE_SINGLE_WORKER,		// Single worker
	EM_WORKACTION_STATE_NORED_VEST,			// No red vest
} EM_WORKACTION_STATE;

// Corresponding to data block description of event type EVENT_IVS_WORKCLOTHES_DETECT (work state detection)
typedef struct tagDEV_EVENT_WORKSTATDETECTION_INFO
{
	int                 			nChannelID;                         		// Channel ID
    int								nAction;									// Event action, 0: Pulse, 1: Start, 2: Stop
    char                			szName[128];                         		// Event name
    double              			PTS;                                		// Timestamp (in milliseconds)
    NET_TIME_EX         			UTC;                                		// Time for the event occurred   
    UINT                			nEventID;                           		// Event ID

	EM_CLASS_TYPE				    emClassType;								// Class type
	UINT							nRuleID;									// Rule ID
	UINT							nObjectID;									// Object ID
	UINT							nWorkActionNum;								// Count of work action state
	EM_WORKACTION_STATE				emWorkAction[32];							// Info of work action
	SCENE_IMAGE_INFO				stuSceneImage;           					// Scene image info
	BYTE			    			byReserved[1024];			        		// Reserved
} DEV_EVENT_WORKSTATDETECTION_INFO;



// Face attribute   
typedef struct tagNET_FACE_ATTRIBUTES
{
    int                             nAngle[3];              // The angle of snap face picture(pitch angle,Yaw angle, roll angle ). Default value is[999,999,999],which means invalid
    UINT                            nFaceQuality;           // The quality of face,value range is  0 to 10000
    int                             nFaceAlignScore;        // The socre of face align ,value range is 0 to 10000; -1 means invalid
    BYTE			    			byReserved[36];	        // Reserved
}NET_FACE_ATTRIBUTES;

// Feature info
typedef struct tagNET_FEATURE_VECTOR_INFO
{
    char                            szFeatureVersion[32];   // Feature version
    EM_FEATURE_ERROR_CODE           emFeatureErrCode;       // The error code of modeling failed 
    NET_FEATURE_VECTOR              stuFeatureVector;       // The info of feature picture offset and length
    NET_FACE_ATTRIBUTES             stuFaceAttribute;       // Face attribute         
    BYTE			    			byReserved[968];		// Reserved
}NET_FEATURE_VECTOR_INFO;

// Corresponding to data block description of event type EM_ANALYSE_EVENT_FEATURE_ABSTRACT (Feature abstract)
typedef struct tagDEV_EVENT_FEATURE_ABSTRACT_INFO
{
    int                 			nChannelID;                         		// Channel
    int								nAction;									// Event action, 0: Pulse, 1: Start, 2: Stop
    EM_CLASS_TYPE                   emClassType;                           		// class type
    UINT                            nFeatureNum;                                // The num of feature
    NET_FEATURE_VECTOR_INFO         stuFeatureVectorList[10];                   // The vector of feature. A picture may have lot of feature
    BYTE			    			byReserved[1024];			        		// Reserved
} DEV_EVENT_FEATURE_ABSTRACT_INFO;


//Trigger type of Panoramic capture
typedef enum tagEM_TRIGGER_EVENT_TYPE
{
	EM_TRIGGER_EVENT_TYPE_UNKNOWN,		// UnKnown
	EM_TRIGGER_EVENT_TYPE_PTZ_PRESET,	// Ptz Perset Point Trigger
	EM_TRIGGER_EVENT_TYPE_FIREWARNING,	// Fire Trigger
	EM_TRIGGER_EVENT_TYPE_MOVE_ABSOLUTELY,//  Absolute mobile positioning trigger
} EM_TRIGGER_EVENT_TYPE;

// Corresponding to data block description of event type EVENT_IVS_PANORAMA_SHOT (Panoramic snapshot)
typedef struct tagDEV_EVENT_PANORAMA_SHOT_INFO
{
	int						nChannelID;                 // Channel

	char					szStationID[64];			// Station ID
	char					szPictureID[128];			// Picture ID
	NET_TIME_EX				stuLocalSnapshotTime;		// Local Snapshot Time	
	int						nPitchAngleInSnapping;		// Pitch angle(Angle accurate to 0.1degree),range:[-1800~1800], corresponding to the actual [-180.0~180.0] degrees(degree expansion ten times)
	int						nHorizontalAngleInSnapping;	// Horizontal angle(Angle accurate to 0.1degree),range:[0~3599], corresponding to actual [0~359.9] degress(degree expanded by 10 times)
	EM_TRIGGER_EVENT_TYPE	emTriggerEventType;			// Trigger Event Type
	DWORD					dwFireID;					// FireIDtrigger time type is valid when fire trigger
	NET_RECT				stuFireBoundingBox;			// Fire border box(valid when triggering event type is fire trigger)
	BYTE					byReserved[1024];			// Reserved
} DEV_EVENT_PANORAMA_SHOT_INFO;

// Corresponding to data block description of event type EVENT_IVS_INTELLI_SHELF(intelligent replenishment)
typedef struct tagDEV_EVENT_INTELLI_SHELF_INFO
{
    int                 			nChannelID;                         		// Channel ID
    int								nAction;									// Event action, 0: Pulse, 1: Start, 2: Stop
    char                			szName[128];                         		// Event name
    double              			PTS;                                		// Timestamp (in milliseconds)
    NET_TIME_EX         			UTC;                                		// Time for the event occurred   
    UINT                			nEventID;                           		// Event ID
    EM_CLASS_TYPE				    emClassType;								// Class type

    UINT                            nAreaID;                                    // Area ID
    UINT                            nPresetID;                                  // Preset ID
    int                             nPercent;                                   // Percentage of surplus goos on the shelf
    SCENE_IMAGE_INFO_EX             stuSceneImage;                              // Scene image
	BYTE			    			byReserved1[4];				        		// Reserved for byte alignmaent
    BYTE			    			byReserved[1024];			        		// Reserved
} DEV_EVENT_INTELLI_SHELF_INFO;

// The direction of driving
typedef enum tagEM_DRIVING_DIRECTION
{
	EM_DRIVING_DIRECTION_UNKNOWN = 0,								// Unknown
	EM_DRIVING_DIRECTION_IN,										// In
	EM_DRIVING_DIRECTION_OUT,										// Out
}EM_DRIVING_DIRECTION;


// Corresponding to data block description of event type EVENT_IVS_CAR_DRIVING_IN_OUT
typedef struct tagDEV_EVENT_CAR_DRIVING_IN_OUT_INFO
{
	int                 nChannelID;                                 // Channel id
	int                 nEventID;                                   // Event id
	char                szName[128];                                // Event name
	double              PTS;                                        // Timestamp (in milliseconds)
	NET_TIME_EX         UTC;                                        // Time for the event occurred 
	DH_MSG_OBJECT       stuObject;                                  // The information of plate
	DH_MSG_OBJECT       stuVehicle;                                 // The information of vehicle
	DH_EVENT_FILE_INFO  stuFileInfo;                                // Event file info
	int					nSequence;									// snap index,such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	int					nFrameSequence;								// Frame sequence
	EM_DRIVING_DIRECTION emDrivingDirection;						// The direction of driving
	NET_EVENT_IMAGE_OFFSET_INFO	stuGlobalScene;						// Global scene image information
	NET_EVENT_IMAGE_OFFSET_INFO	stuParkingImage;					// Parking space image information
	char				szParkingNum[32];							// Parking ID
	BYTE				byReserved[512];							// Reserved
}DEV_EVENT_CAR_DRIVING_IN_OUT_INFO;

// Corresponding to data block description of event type EVENT_IVS_PARKINGSPACE_STATUS
typedef struct tagDEV_EVENT_PARKINGSPACE_STATUS_INFO
{
	int                 nChannelID;                                 // Channel id
	int                 nEventID;                                   // Event id
	char                szName[128];                                // Event name
	double              PTS;                                        // Timestamp (in milliseconds)
	NET_TIME_EX         UTC;                                        // Time for the event occurred 
	DH_EVENT_FILE_INFO  stuFileInfo;                                // Event file info 

	int					nSource;									// Source
	int					nFrameSequence;								// Frame sequence

	int					nMark;										// for mark snap 
	EM_PARKINGSPACE_STATUS emParkingSpaceStatus;					// Parking space status
	char				szParkingNum[32];							// Parking ID
	char				szText[32];									// Plate number
	BYTE				byReserved[512];							// Reserved
}DEV_EVENT_PARKINGSPACE_STATUS_INFO;


// object related info(customized)
typedef struct tagOBJECT_RELATED_INFO
{
	UINT							nObjectID;									// object id
	UINT							nRelativeID;								// related object id
	char							szObjectType[128];							// object type,,like "HumanFace"
	NET_RECT						stuBoundingBox;								// bounding box, [0, 8192]
	NET_RECT						stuOriginalBoundingBox;						// original bounding box,[0, 8192]
	BYTE							byReserved[1024];							// reserved
}OBJECT_RELATED_INFO;



// the describe of EVENT_IVS_FACEBODY_DETECT's data
typedef struct tagDEV_EVENT_FACEBODY_DETECT_INFO
{
	int                 			nChannelID;                                 // channel id 
	int								nAction;									// 0:pulse 1:start 2:stop
	char                			szName[128];                                // name 
	double              			PTS;                                        // PTS,unit:ms
	NET_TIME_EX         			UTC;                                        // UTC
	EM_CLASS_TYPE					emClassType;								// class type
	UINT                			nEventID;                           		// event ID
	UINT							nObjectID;									// object ID
	UINT							nRuleID;									// rule id 
	UINT							nSequence;									// sequence 
	int								nGroupID;									// group id
	int								nCountInGroup;								// the file count in the current file's group
	int								nIndexInGroup;								// the index of the file in the group,start from 1
	BYTE							byReserved1[4];								// byte alignment
	FACE_TRAIT						stuFaceTrait;								// face trait
	BODY_TRAIT						stuBodyTrait;								// body trait
	NET_EVENT_IMAGE_OFFSET_INFO		stuBodyImage;								// body image info
	NET_EVENT_IMAGE_OFFSET_INFO		stuFaceImage; 								// face image info
	NET_EVENT_IMAGE_OFFSET_INFO		stuSceneImage;								// scene image info
	OBJECT_RELATED_INFO				stuFaceObject;								// face related object info
	OBJECT_RELATED_INFO				stuBodyObject;								// body related object info
}DEV_EVENT_FACEBODY_DETECT_INFO;

// the describe of EVENT_IVS_FACEBODY_ANALYSE's data
typedef struct tagDEV_EVENT_FACEBODY_ANALYSE_INFO
{
	int                 			nChannelID;                                 // channel id
	int								nAction;									// 0:pulse 1:start 2:stop
	char                			szName[128];                                // name
	double              			PTS;                                        // PTS,unit:ms
	NET_TIME_EX         			UTC;                                        // UTC
	EM_CLASS_TYPE					emClassType;								// class type
	UINT                			nEventID;                           		// event id
	UINT							nObjectID;									// object id
	UINT							nRuleID;									// rule id
	UINT							nSequence;									// sequence
	int								nGroupID;									// group id
	int								nCountInGroup;								// the file count in the current file's group
	int								nIndexInGroup;								// the index of the file in the group,start from 1
	BYTE							byReserved1[4];								// byte alignment
	FACE_TRAIT						stuFaceTrait;								// face trait
	BODY_TRAIT						stuBodyTrait;								// body trait
	NET_EVENT_IMAGE_OFFSET_INFO		stuBodyImage;								// body image info
	NET_EVENT_IMAGE_OFFSET_INFO		stuFaceImage; 								// face image info
	NET_EVENT_IMAGE_OFFSET_INFO		stuSceneImage;								// scene image info
	OBJECT_RELATED_INFO				stuFaceObject;								// face related object info
	OBJECT_RELATED_INFO				stuBodyObject;								// body related object info
	CANDIDATE_INFOEX				stuCandidate[DH_MAX_CANDIDATE_NUM];			// stuCandidate info
	int								nCandidateNum;								// stuCandidate num
}DEV_EVENT_FACEBODY_ANALYSE_INFO;

// Corresponding to data block description of event type EVENT_IVS_CONGESTION_DETECTION
typedef struct tagDEV_EVENT_CONGESTION_DETECTION_INFO
{
	int                 			nChannelID;                                 // channel id
	int								nAction;									// 0:pulse 1:start 2:stop
	char                			szName[128];                                // name
	double              			PTS;                                        // PTS,unit:ms
	NET_TIME_EX         			UTC;                                        // UTC
	DH_EVENT_FILE_INFO				stuFileInfo;								// file information
	EM_CLASS_TYPE					emClassType;								// class type
	UINT                			nEventID;                           		// event ID
	UINT							nRuleID;									// rule id
	int 							nPresetID;									// preset ID
	char							szPresetName[64];							// preset name
	int								nAlarmMask;									// The mask of alarm, bit0 whether has jam alarm; bit1 whether has queue alarm
	int								nVehicleQuantity;							// The number of vehicles in jam
	int								nQueueLength;								// The number of vehicles in queue
	int								nDetectRegionNum;							// The number of stuDetectRegion
	DH_POINT						stuDetectRegion[32];						// The region of alarm occur
	BYTE			    			byReserved[1024];			        		// Reserved
}DEV_EVENT_CONGESTION_DETECTION_INFO;

// Corresponding to data block description of event type EVENT_IVS_VEHICLELIMIT_DETECTION
typedef struct tagDEV_EVENT_VEHICLELIMIT_DETECTION_INFO
{
	int                 			nChannelID;                                 // channel id
	int								nAction;									// 0:pulse 1:start 2:stop
	char                			szName[128];                                // name
	double              			PTS;                                        // PTS,unit:ms
	NET_TIME_EX         			UTC;                                        // UTC
	DH_EVENT_FILE_INFO				stuFileInfo;								// file information
	EM_CLASS_TYPE					emClassType;								// class type
	UINT                			nEventID;                           		// event ID
	UINT							nRuleID;									// rule id
	int 							nPresetID;									// preset ID
	char							szPresetName[64];							// preset name
	int								nVehicleQuantity;							// The number of vehicles
	int								nDetectRegionNum;							// The number of stuDetectRegion
	DH_POINT						stuDetectRegion[32];						// The region of alarm occur
	BYTE			    			byReserved[1024];			        		// Reserved
}DEV_EVENT_VEHICLELIMIT_DETECTION_INFO;

// Corresponding to data block description of event type EVENT_IVS_VIOLENT_THROW_DETECTION
typedef struct tagDEV_EVENT_VIOLENT_THROW_DETECTION_INFO
{
    int                 nChannelID;                                 // Channel id
    int					nAction;									// Event action, 0: Pulse, 1: Start, 2: Stop
    char                szName[128];                                // Event name
    double              PTS;                                        // Timestamp (in milliseconds)
    NET_TIME_EX         UTC;                                        // Time for the event occurred 
    int                 nEventID;                                   // Event ID
    DH_EVENT_FILE_INFO  stuFileInfo;                                // Event file info 

    int                 nFrameSequence;                             // The sequence of frame
	char                szRegionName[64];                           // The name of detection region
    SCENE_IMAGE_INFO_EX stuSceneImage;                              // The image info of big picture
	BYTE				byReserver[1028];							// Reserve byte
}DEV_EVENT_VIOLENT_THROW_DETECTION_INFO;

// Corresponding to data block description of event type EVENT_IVS_TRAMCARSECTIONS_DETECTION
typedef struct tagDEV_EVENT_TRAMCARSECTIONS_DETECTION_INFO
{
	int							nChannelID;                         // Channel id
	int							nAction;							// Event action, 0: Pulse, 1: Start, 2: Stop
	char						szName[128];                        // Event name
	double						PTS;                                // Timestamp (in milliseconds)
	NET_TIME_EX					UTC;                                // Time for the event occurred 
	int							nEventID;                           // Event ID

	UINT						nRuleID;							// Rule ID
	EM_CLASS_TYPE				emClassType;						// Event class
	int							nSequence;							// Frame sequence

	UINT						nCarSections;						// Current car sections
	NET_INTELLIGENCE_IMAGE_INFO	stuSceneImage;						// Scene image information
	BYTE						byReserved[512];					// Reserved byte
}DEV_EVENT_TRAMCARSECTIONS_DETECTION_INFO;

// Animal statistics
typedef struct tagNET_ANIMAL_OBJECTS_STATISTICS
{
    UINT                nAnimalsAmount;     // Total number of animals
    BYTE                bReserved[132];     // Reserve byte
}NET_ANIMAL_OBJECTS_STATISTICS;


// Scene image information for Animal Detection
typedef struct tagNET_ANIMAL_SCENE_IMAGE_INFO
{
    UINT				nOffSet;			// Offset in binary data blocks   
    UINT				nLength;		    // Picture size, unit byte
    BYTE                bReserved[256];     // Reserve byte
}NET_ANIMAL_SCENE_IMAGE_INFO;

// Corresponding to data block description of event type EVENT_IVS_ANIMAL_DETECTION(Animal Detection)
typedef struct tagDEV_EVENT_ANIMAL_DETECTION_INFO
{
    int							    nChannelID;                         // Channel id
    int							    nAction;							// Event action, 0: Pulse, 1: Start, 2: Stop
    char						    szName[128];                        // Event name
    double						    PTS;                                // Timestamp (in milliseconds)
    NET_TIME_EX					    UTC;                                // Time for the event occurred 
    int							    nEventID;                           // Event ID

    UINT						    nRuleID;							// Rule ID
    int							    nSequence;							// Frame sequence

    NET_ANIMAL_SCENE_IMAGE_INFO	    stuSceneImage;						// Scene image information for Animal Detection
    NET_ANIMAL_OBJECTS_STATISTICS   stuObjectsStatistics;               // Animal statistics
    EM_CLASS_TYPE				    emClassType;						// Event class
    BYTE						    byReserved[516];					// Reserve byte
}DEV_EVENT_ANIMAL_DETECTION_INFO;


// Vehicle action
typedef enum tagEM_VEHICLE_ACTION
{
    EM_VEHICLE_ACTION_UNKNOWN,          // Unknown
    EM_VEHICLE_ACTION_APPEAR,           // Appear in detect region
    EM_VEHICLE_ACTION_DISAPPEAR,        // Disappear from detect region
    EM_VEHICLE_ACTION_STAY,             // Stay in detect region
} EM_VEHICLE_ACTION;

// Vehicle information detected
typedef struct tagNET_DETECT_VEHICLE_INFO
{
    EM_VEHICLE_ACTION       emAction;               // Vehicle action
    UINT                    nObjectID;              // Object ID
    EVENT_PIC_INFO          stuVehicleImage;        // Vehicle image info
    NET_COLOR_RGBA          stuColor;               // Vehilce main color
    EM_CATEGORY_TYPE        emCategoryType;         // Vehicle type
    UINT                    nFrameSequence;         // Frame sequence
    UINT                    nCarLogoIndex;          // Car log index
    UINT                    nSubBrand;              // Sub brand
    UINT                    nBrandYear;             // Year of vehicle brand 
    UINT                    nConfidence;            // Confidence, and the larger the value, the higher the confidence. Range of the value is 0~255
    NET_RECT                stuBoundingBox;         // Bounding box, 0-8191 
    char                    szText[128];            // Auto log
    UINT                    nSpeed;                 // Speed, unit:km/h
    UINT                    nDirection;             // Vehicle direction, 0:unknown, 1:upstream, 2:Down
    BYTE                    bReserved[512];         // Reserved
} NET_DETECT_VEHICLE_INFO;

// Plate information detected
typedef struct tagNET_DETECT_PLATE_INFO
{
    UINT                    nObjectID;              // Object ID
    UINT                    nRelativeID;            // The associated vehicle ID
    EVENT_PIC_INFO          stuPlateImage;          // Plate image info
    EM_NET_PLATE_TYPE       emPlateType;            // Plate type
    EM_NET_PLATE_COLOR_TYPE emPlateColor;           // Plate color
    UINT                    nConfidence;            // Confidence, and the larger the value, the higher the confidence. Range of the value is 0~255
    char                    szCountry[3];           // Country of the plate
    BYTE                    bReserved1;             // Byte alignment
    char                    szPlateNumber[128];     // Plate number
    BYTE                    bReserved[512];         // Reserved
} NET_DETECT_PLATE_INFO;

// Corresponding to data block description of event type EVENT_IVS_GASSTATION_VEHICLE_DETECT(gas station vehicle detection)
typedef struct tagDEV_EVENT_GASSTATION_VEHICLE_DETECT_INFO
{
    int                         nChannelID;                                 // Channel ID
    int                         nAction;                                    // Event action, 0: Pulse, 1: Start, 2: Stop
    char                        szName[128];                                // Event name
    double                      PTS;                                        // Timestamp (in milliseconds)
    NET_TIME_EX                 UTC;                                        // Time for the event occurred 
    int                         nEventID;                                   // Event ID

    UINT                        nRuleID;                                    // Rule ID used to indicate which rule triggers
    EM_CLASS_TYPE               emClassType;                                // Event class

    NET_DETECT_VEHICLE_INFO     stuDetectVehicleInfo;                       // Vehicle information detected
    NET_DETECT_PLATE_INFO       stuDetectPlateInfo;                         // Plate information detected
    BOOL                        bIsGlobalScene;                             // Has scene image or not
    EVENT_PIC_INFO              stuSceneImage;                              // Scene image info , It is effect if bIsGlobalScene is TRUE
    int                         nCarCandidateNum;                           // Count of candidate cars    
    NET_CAR_CANDIDATE_INFO      stuCarCandidate[MAX_CAR_CANDIDATE_NUM];     // Info of candidate cars
    BYTE                        bReserved[1024];                            // Reserved
} DEV_EVENT_GASSTATION_VEHICLE_DETECT_INFO;


// Corresponding to data block description of event type EVENT_IVS_SHOP_WINDOW_POST(Shop  windows post)
typedef struct tagDEV_EVENT_SHOP_WINDOW_POST_INFO
{
    int                         nChannelID;                                 // Channel ID
    int                         nAction;                                    // Event action, 0: Pulse, 1: Start, 2: Stop
    char                        szName[128];                                // Event name
    double                      PTS;                                        // Timestamp (in milliseconds)
    NET_TIME_EX                 UTC;                                        // Time for the event occurred 
    int                         nEventID;                                   // Event ID
    UINT                        nRuleID;                                    // Rule ID used to indicate which rule triggers
    EM_CLASS_TYPE               emClassType;                                // Event class
    DH_EVENT_FILE_INFO          stuFileInfo;                                // Event file info 

	int							nDetectRegionNum;							// The number of stuDetectRegion
	DH_POINT					stuDetectRegion[DH_MAX_DETECT_REGION_NUM];	// The region of alarm occur
	int                 		nObjectNum;                         		// have being detected objects
	DH_MSG_OBJECT       		stuObjects[HDBJ_MAX_OBJECTS_NUM];			// Object detected
    
    UINT                        nPresetID;                                  // preset ID
    char                        szPresetName[64];                           // preset Name
    char                        szShopAddress[256];                         // Shop address
    UINT                        nViolationDuration;                         // Illegal duration, unit: seconds, default value 0 means meaningless
    DWORD                       dwSnapFlagMask;	                            // flag(by bit),see NET_RESERVED_COMMON
    BYTE                        bReserved[1024];                            // Reserved
} DEV_EVENT_SHOP_WINDOW_POST_INFO;

// Corresponding to data block description of event type EVENT_IVS_SHOP_SIGN_ABNORMAL(Shop sign abnormal)
typedef struct tagDEV_EVENT_SHOP_SIGN_ABNORMAL_INFO
{
    int                         nChannelID;                                 // Channel ID
    int                         nAction;                                    // Event action, 0: Pulse, 1: Start, 2: Stop
    char                        szName[128];                                // Event name
    double                      PTS;                                        // Timestamp (in milliseconds)
    NET_TIME_EX                 UTC;                                        // Time for the event occurred 
    int                         nEventID;                                   // Event ID
    UINT                        nRuleID;                                    // Rule ID used to indicate which rule triggers
    EM_CLASS_TYPE               emClassType;                                // Event class
    DH_EVENT_FILE_INFO          stuFileInfo;                                // Event file info 

	int							nDetectRegionNum;							// The number of stuDetectRegion
	DH_POINT					stuDetectRegion[DH_MAX_DETECT_REGION_NUM];	// The region of alarm occur
	int                 		nObjectNum;                         		// have being detected objects
	DH_MSG_OBJECT       		stuObjects[HDBJ_MAX_OBJECTS_NUM];			// Object detected
    
    UINT                        nPresetID;                                  // preset ID
    char                        szPresetName[64];                           // preset Name
    char                        szShopAddress[256];                         // Shop address
    UINT                        nViolationDuration;                         // Illegal duration, unit: seconds, default value 0 means meaningless
    DWORD                       dwSnapFlagMask;	                            // flag(by bit),see NET_RESERVED_COMMON
    BYTE                        bReserved[1024];                            // Reserved
} DEV_EVENT_SHOP_SIGN_ABNORMAL_INFO;

// Catrgory type of breed object
typedef enum tagEM_BREED_DETECT_CATEGORY_TYPE
{
    EM_BREED_DETECT_CATEGORY_UNKNOWN,                   // Unknown
    EM_BREED_DETECT_CATEGORY_PIG,                       // Pig
} EM_BREED_DETECT_CATEGORY_TYPE;

// Animal object info
typedef struct tagNET_VAOBJECT_ANIMAL_INFO
{
    UINT                            nObjectID;              // objectIDEach ID represents a unique object
    EM_BREED_DETECT_CATEGORY_TYPE   emCategoryType;         // Catrgory type of breed object
    NET_RECT                        stuBoundingBox;         // Bounding box
    UINT                            nObjectWeight;          // Object weight, unit g
    SCENE_IMAGE_INFO_EX             stuImageData;           // Image data of object
    BYTE                            byReserved[1024];        // Reserved
} NET_VAOBJECT_ANIMAL_INFO;

// Corresponding to data block description of event type EVENT_IVS_BREED_DETECTION(breed detection)
typedef struct tagDEV_EVENT_BREED_DETECTION_INFO
{
    int                         nChannelID;                         // Channel ID
    int                         nAction;                            // Event action, 0: Pulse, 1: Start, 2: Stop
    char                        szName[128];                         // Event name
    double                      PTS;                                // Timestamp (in milliseconds)
    NET_TIME_EX                 UTC;                                // Time for the event occurred 
    int                         nEventID;                           // Event ID

    UINT                        nRuleID;                            // Rule IDused to indicate which rule triggers
    UINT                        nSequence;                          // Sequence
    EM_CLASS_TYPE               emClassType;                        // Event class
    SCENE_IMAGE_INFO_EX         stuSceneImage;                      // Scene image
    BYTE                        byReserved1[4];                     // Byte alignment
    UINT                        nObjectNum;                         // Object count
    NET_VAOBJECT_ANIMAL_INFO    stuObjects[64];                     // Object info
    BYTE                        byReserved[512];                    // Reserved
} DEV_EVENT_BREED_DETECTION_INFO;

// Airport vehicle type
typedef enum tagEM_AIRPORT_VEHICLE_TYPE
{
	EM_AIRPORT_VEHICLE_TYPE_UNKNOWN = 0,							// Unknown
	EM_AIRPORT_VEHICLE_TYPE_TANKER,									// Cao's car
	EM_AIRPORT_VEHICLE_TYPE_CONVEYORCAR,							// Baggage transfer cart
	EM_AIRPORT_VEHICLE_TYPE_TRAILERCAR,								// Luggage trailer
}EM_AIRPORT_VEHICLE_TYPE;

// Airport vehicle action
typedef enum tagEM_AIRPORT_VEHICLE_ACTION
{
	EM_AIRPORT_VEHICLE_ACTION_UNKNOWN = 0,							// Unknown
	EM_AIRPORT_VEHICLE_ACTION_ENTERREGION,							// Enter region
	EM_AIRPORT_VEHICLE_ACTION_LEAVEREGION,							// Leave region
	EM_AIRPORT_VEHICLE_ACTION_STARTWORK,							// Start work
	EM_AIRPORT_VEHICLE_ACTION_OVERWORK,								// Over work
	EM_AIRPORT_VEHICLE_ACTION_AIRREFUEL,							// Aircraft fueling
	EM_AIRPORT_VEHICLE_ACTION_OVERREFUEL,							// Fueling over
}EM_AIRPORT_VEHICLE_ACTION;

// The object of airport vehicle
typedef struct tagNET_AIRPORT_VEHICLE_OBJECT
{
	int								nObjectID;						// Object ID
	EM_AIRPORT_VEHICLE_TYPE			emType;							// Airport vehicle type
	NET_RECT						stuRect;						// The location of vehicle
	EM_AIRPORT_VEHICLE_ACTION		emAction;						// Airport vehicle action
	BYTE							byReserved[1020];				// Reserved
}NET_AIRPORT_VEHICLE_OBJECT;

// Corresponding to data block description of event type EVENT_IVS_AIRPORT_VEHICLE_DETECT(Airport vehicle Detection)
typedef struct tagDEV_EVENT_AIRPORT_VEHICLE_DETECT_INFO
{
    int                         nChannelID;                         		// Channel ID
    int                         nAction;                            		// Event action, 0: Pulse, 1: Start, 2: Stop
    char                        szName[128];                         		// Event name
    double                      PTS;                                		// Timestamp (in milliseconds)
    NET_TIME_EX                 UTC;                                		// Time for the event occurred 
    int                         nEventID;                           		// Event ID

    UINT                        nRuleID;                           	 		// Rule IDused to indicate which rule triggers
    UINT                        nSequence;                          		// Sequence
    EM_CLASS_TYPE               emClassType;                        		// Event class
	int							nDetectRegionNum;							// The number of stuDetectRegion
	DH_POINT					stuDetectRegion[DH_MAX_DETECT_REGION_NUM];	// The region of alarm occur, [0,8192)
	SCENE_IMAGE_INFO_EX         stuSceneImage;								// Scene image
	int 						nVehicleObjectNum;							// The number of objects in stuVehicleObjects
	NET_AIRPORT_VEHICLE_OBJECT	stuVehicleObjects[MAX_AIRPORT_VEHICLE_OBJECT_NUM];	// The objects of airport vehicle
    BYTE                        byReserved[504];							// Reserved
} DEV_EVENT_AIRPORT_VEHICLE_DETECT_INFO;

// Corresponding to data block description of event type EVENT_IVS_MAN_CAR_COEXISTANCE(man and cars exist at the same time)
typedef struct tagDEV_EVENT_MAN_CAR_COEXISTANCE_INFO
{
    int                         nChannelID;                         		// Channel ID
    int                         nAction;                            		// Event action, 1: Start, 2: Stop
    char                        szName[128];                         		// Event name
    double                      PTS;                                		// Timestamp (in milliseconds)
    NET_TIME_EX                 UTC;                                		// Time for the event occurred 
    int                         nEventID;                           		// Event ID

    UINT                        nRuleID;                           	 		// Rule IDused to indicate which rule triggers
    UINT                        nSequence;                          		// Sequence
    EM_CLASS_TYPE               emClassType;                        		// Event class
    DWORD                       dwSnapFlagMask;                             // flag(by bit),see NET_RESERVED_COMMON
    SCENE_IMAGE_INFO			stuSceneImage;						        // Scene image
    BYTE                        byReserved[512];							// Reserved
}DEV_EVENT_MAN_CAR_COEXISTANCE_INFO;

// parking lot current status
typedef enum tagEM_PARKING_STATE
{
    EM_PARKING_STATE_UNKNOWN = -1,               // unknown
    EM_PARKING_STATE_FREE,                       // free
    EM_PARKING_STATE_BUSY,                       // busy
} EM_PARKING_STATE;

// parking lot change status
typedef enum tagEM_PARKING_CHANGE_STATUS
{
    EM_PARKING_CHANGE_STATUS_UNKNOWN = -1,               // unknown
    EM_PARKING_CHANGE_STATUS_NO_CHANGE,                  // no change
    EM_PARKING_CHANGE_STATUS_FREE_TO_BUSY,               // free to busy
    EM_PARKING_CHANGE_STATUS_BUSY_TO_FREE,               // busy to free
} EM_PARKING_CHANGE_STATUS;

// parking lot status
typedef struct tagNET_PARKING_STATUS
{
    char                                              szName[32];                                               // parking lot name
    int                                               nID;                                                      // parking lot's ID, range:[0,99]
    EM_PARKING_STATE                                  emStatus;                                                 // parking lot current status
    EM_PARKING_CHANGE_STATUS                          emChangeStatus;                                           // parking lot change status
    BYTE                                              reserved[252];                                            // reserved
} NET_PARKING_STATUS;

// Corresponding to data block description of event type EVENT_IVS_PARKING_LOT_STATUS_DETECTION(parking lot status detection)
typedef struct tagDEV_EVENT_PARKING_LOT_STATUS_DETECTION_INFO
{
    int                         nChannelID;                                 // Channel ID
    int                         nAction;                                    // Event action, 1: Start, 2: Stop
    char                        szName[128];                                // Event name
    EM_CLASS_TYPE               emClassType;                                // Event class
    NET_TIME_EX                 UTC;                                        // Time for the event occurred
    double                      PTS;                                        // Timestamp (in milliseconds)
    unsigned int                nEventID;                                   // Event ID
    UINT                        nRuleID;                                    // Rule ID, use to indicate which rule triggers
    UINT                        nSequence;                                  // Sequence
    int                         nParkingStatusNum;                          // parking number
    NET_PARKING_STATUS          stuParkingStatus[100];                      // parking lot status
    SCENE_IMAGE_INFO_EX         stuSceneImage;                              // Scene image
    BYTE                        byReserved[1020];                           // reserved
} DEV_EVENT_PARKING_LOT_STATUS_DETECTION_INFO;


// Vehicle info
typedef struct tagDREGS_UNCOVERED_VEHICLE_INFO
{
    char                        szPlateNumber[64];                          // Plate number
    NET_RECT                    stuBoundingBox;                             // Bounding box
    BYTE                        byReserved[512];                            // Reserved
}DREGS_UNCOVERED_VEHICLE_INFO;


// Corresponding to data block description of event type EVENT_IVS_DREGS_UNCOVERED(Loading test event not covered by muck truck)
typedef struct tagDEV_EVENT_DREGS_UNCOVERED_INFO
{
    int                         nChannelID;                                 // Channel ID
    int                         nAction;                                    // Event action,0 pause
    char                        szName[128];                                // Event name
    double                      PTS;                                        // Timestamp (in milliseconds)
    NET_TIME_EX                 UTC;                                        // Time for the event occurred
    UINT                        nEventID;                                   // Event ID

    EM_CLASS_TYPE               emClassType;                                // Event class
    int							nDetectRegionNum;							// The number of stuDetectRegion
    DH_POINT					stuDetectRegion[DH_MAX_DETECT_REGION_NUM];	// The region of alarm occur, [0,8192)
    DREGS_UNCOVERED_VEHICLE_INFO stuVehicleInfo;                            // Vehicle info
    BYTE                        byReserved[1024];                           // Reserved
} DEV_EVENT_DREGS_UNCOVERED_INFO;


// Corresponding to data block description of event type EVENT_IVS_HIGH_TOSS_DETECT(High toss detection)
typedef struct tagDEV_EVENT_HIGH_TOSS_DETECT_INFO
{
    int                         nChannelID;									// Channel ID
    int                         nAction;									// Event action, 0: Pulse, 1: Start, 2: Stop
    char                        szName[128];								// Event name
    double                      PTS;										// Timestamp (in milliseconds)
    NET_TIME_EX                 UTC;										// Time for the event occurred 
    int                         nEventID;									// Event ID
    UINT                        nRuleID;									// Rule IDused to indicate which rule triggers
    EM_CLASS_TYPE               emClassType;								// Event class
    NET_HIGHTOSS_OBJECT_INFO    stuObjInfos[50];                            // Object info
    UINT                        nObjNum;                                    // Object number
    BYTE                        byReserved[1020];							// Reserved
} DEV_EVENT_HIGH_TOSS_DETECT_INFO;


// Object image info
typedef struct tagNET_OBJECT_IMAGE_INFO
{
    unsigned int    nOffSet;            // Offset in binary data
    unsigned int    nLength;            // Image size, unit:bytes
    unsigned int    nWidth;             // Image width (pixels)
    unsigned int    nHeight;            // Image height (pixels)
    char            szFilePath[260];    // Scene image path
    BYTE            byReserved[508];    // Reserved
}NET_OBJECT_IMAGE_INFO;

// Type of electric glove
typedef enum tagEM_ELECTRIC_GLOVE_TYPE
{
    EM_ELECTRIC_GLOVE_TYPE_UNKNOWN,         // Unknown
    EM_ELECTRIC_GLOVE_TYPE_GENERAL,         // General glove
    EM_ELECTRIC_GLOVE_TYPE_INSULATED,       // Insulating glove
} EM_ELECTRIC_GLOVE_TYPE;

// Object info of electric glove
typedef struct tagNET_ELECTRIC_GLOVE_OBJECT
{
    UINT                        nObjectID;                      // Object ID
    EM_ELECTRIC_GLOVE_TYPE      emGloveType;                    // Type of electric glove
    NET_RECT                    stuBoundingBox;                 // Bounding box
    NET_OBJECT_IMAGE_INFO       stuImageData;                   // Object image
    BYTE                        byReserved[1024];               // Reserved
} NET_ELECTRIC_GLOVE_OBJECT;

// Corresponding to data block description of event type EVENT_IVS_ELECTRIC_GLOVE_DETECT(Electric glove detection)
typedef struct tagDEV_EVENT_ELECTRIC_GLOVE_DETECT_INFO
{
    int                         nChannelID;                     // Channel ID
    int                         nAction;                        // Event action, 0: Pulse, 1: Start, 2: Stop
    char                        szName[128];                    // Event name
    double                      PTS;                            // Timestamp (in milliseconds)
    NET_TIME_EX                 UTC;                            // Time for the event occurred 
    int                         nEventID;                       // Event ID

    UINT                        nRuleID;                        // Rule IDused to indicate which rule triggers
    UINT                        nSequence;                      // Sequence
    EM_CLASS_TYPE               emClassType;                    // Class of intelligent event
    UINT                        nGloveObjNum;                   // Number of glove objects
    NET_ELECTRIC_GLOVE_OBJECT   stuGloveObjs[32];               // Info of glove objects
    SCENE_IMAGE_INFO_EX         stuSceneImage;                  // Scene image
    BYTE                        byReserved[1028];               // Reserved
}DEV_EVENT_ELECTRIC_GLOVE_DETECT_INFO;

// Type of electric ladder
typedef enum tagEM_ELECTRIC_LADDER_TYPE
{
    EM_ELECTRIC_LADDER_TYPE_UNKNOWN,         // Unknown
    EM_ELECTRIC_LADDER_TYPE_GENERAL,         // General ladder
    EM_ELECTRIC_LADDER_TYPE_INSULATED,       // Insulating ladder
} EM_ELECTRIC_LADDER_TYPE;

// Info of ladder object
typedef struct tagNET_ELECTRIC_LADDER_OBJECT
{
    UINT                        nObjectID;                      // Object ID
    EM_ELECTRIC_LADDER_TYPE     emLadderType;                   // Type of electric ladder
    NET_RECT                    stuBoundingBox;                 // Bounding box
    NET_OBJECT_IMAGE_INFO       stuImageData;                   // Object image
    BYTE                        byReserved[1024];               // Reserved
} NET_ELECTRIC_LADDER_OBJECT;

// Corresponding to data block description of event type EVENT_IVS_ELECTRIC_LADDER_DETECT(Electric glove ladder)
typedef struct tagDEV_EVENT_ELECTRIC_LADDER_DETECT_INFO
{
    int                         nChannelID;                     // Channel ID
    int                         nAction;                        // Event action, 0: Pulse, 1: Start, 2: Stop
    char                        szName[128];                    // Event name
    double                      PTS;                            // Timestamp (in milliseconds)
    NET_TIME_EX                 UTC;                            // Time for the event occurred
    int                         nEventID;                       // Event ID

    UINT                        nRuleID;                        // Rule IDused to indicate which rule triggers
    UINT                        nSequence;                      // Sequence
    EM_CLASS_TYPE               emClassType;                    // Class of intelligent event
    UINT                        nLadderObjNum;                  // Number of ladder objects
    NET_ELECTRIC_LADDER_OBJECT  stuLadderObjs[32];              // Info of ladder objects
    SCENE_IMAGE_INFO_EX         stuSceneImage;                  // Scene image
    BYTE                        byReserved[1028];               // Reserved
}DEV_EVENT_ELECTRIC_LADDER_DETECT_INFO;

// Type of electric curtain
typedef enum tagEM_ELECTRIC_CURTAIN_TYPE
{
    EM_ELECTRIC_CURTAIN_TYPE_UNKNOWN,         // Unonwon
    EM_ELECTRIC_CURTAIN_TYPE_GENERAL,         // General curtain
} EM_ELECTRIC_CURTAIN_TYPE;

// Info of electric curtain object
typedef struct tagNET_ELECTRIC_CURTAIN_OBJECT
{
    UINT                        nObjectID;                      // Object ID
    EM_ELECTRIC_CURTAIN_TYPE    emCurtainType;                  // Type of electric curtain
    EM_UNIFIED_COLOR_TYPE       emCurtainColor;                 // Color of electric curtain
    BYTE                        byReserved1[4];                 // Byte alignment
    NET_RECT                    stuBoundingBox;                 // Bounding box
    NET_OBJECT_IMAGE_INFO       stuImageData;                   // Object image
    BYTE                        byReserved[1024];               // Reserved
} NET_ELECTRIC_CURTAIN_OBJECT;

// Corresponding to data block description of event type EVENT_IVS_ELECTRIC_CURTAIN_DETECT(Electric curtain detection)
typedef struct tagDEV_EVENT_ELECTRIC_CURTAIN_DETECT_INFO
{
    int                         nChannelID;                                 // Channel ID
    int                         nAction;                                    // Event action, 0: Pulse, 1: Start, 2: Stop
    char                        szName[128];                                // Event name
    double                      PTS;                                        // Timestamp (in milliseconds)
    NET_TIME_EX                 UTC;                                        // Time for the event occurred 
    int                         nEventID;                                   // Event ID

    UINT                        nRuleID;                                    // Rule IDused to indicate which rule triggers
    UINT                        nSequence;                                  // Sequence
    EM_CLASS_TYPE               emClassType;                                // Class of intelligent event
    UINT                        nCurtainObjNum;                             // Number of curtain objects
    NET_ELECTRIC_CURTAIN_OBJECT stuCurtainObjs[32];                         // Info of curtain objects
    SCENE_IMAGE_INFO_EX         stuSceneImage;                              // Scene image
    BYTE                        byReserved[1028];                           // Reserved
}DEV_EVENT_ELECTRIC_CURTAIN_DETECT_INFO;

// Type of electric fence 
typedef enum tagEM_ELECTRIC_FENCE_TYPE
{
    EM_ELECTRIC_FENCE_TYPE_UNKNOWN,         // Unknown
    EM_ELECTRIC_FENCE_TYPE_GENERAL,         // General
    EM_ELECTRIC_FENCE_TYPE_COLUMNAR,        // Columnar
    EM_ELECTRIC_FENCE_TYPE_GRID,            // Grid
} EM_ELECTRIC_FENCE_TYPE;

//Info of electric fence object
typedef struct tagNET_ELECTRIC_FENCE_OBJECT
{
    UINT                        nObjectID;                      // Object ID
    EM_ELECTRIC_FENCE_TYPE      emFenceType;                    // Type of electric fence 
    NET_RECT                    stuBoundingBox;                 // Bounding box
    NET_OBJECT_IMAGE_INFO       stuImageData;                   // Object image
    BYTE                        byReserved[1024];               // Reserved
} NET_ELECTRIC_FENCE_OBJECT;

// Corresponding to data block description of event type EVENT_IVS_ELECTRIC_FENCE_DETECT(Electric fence detection)
typedef struct tagDEV_EVENT_ELECTRIC_FENCE_DETECT_INFO
{
    int                         nChannelID;                     // Channel ID
    int                         nAction;                        // Event action, 0: Pulse, 1: Start, 2: Stop
    char                        szName[128];                    // Event name
    double                      PTS;                            // Timestamp (in milliseconds)
    NET_TIME_EX                 UTC;                            // Time for the event occurred 
    int                         nEventID;                       // Event ID

    UINT                        nRuleID;                        // Rule IDused to indicate which rule triggers
    UINT                        nSequence;                      // Sequence
    EM_CLASS_TYPE               emClassType;                    // Class of intelligent event
    UINT                        nFenceObjNum;                   // Number of fence objects
    NET_ELECTRIC_FENCE_OBJECT   stuFenceObjs[32];               // Info of fence objects
    SCENE_IMAGE_INFO_EX         stuSceneImage;                  // Scene image
    BYTE                        byReserved[1028];               // Reserved
}DEV_EVENT_ELECTRIC_FENCE_DETECT_INFO;

// Type of electric signboard
typedef enum tagEM_ELECTRIC_SIGNBOARD_TYPE
{
    EM_ELECTRIC_SIGNBOARD_TYPE_UNKNOWN,         // Unknown
    EM_ELECTRIC_SIGNBOARD_TYPE_GENERAL,         // General
    EM_ELECTRIC_SIGNBOARD_TYPE_WARNING,         // Warning
    EM_ELECTRIC_SIGNBOARD_TYPE_NAMEPLATE,       // Name plate
} EM_ELECTRIC_SIGNBOARD_TYPE;

// Info of electric signboard object
typedef struct tagNET_ELECTRIC_SIGNBOARD_OBJECT
{
    UINT                        nObjectID;                      // Object ID
    EM_ELECTRIC_SIGNBOARD_TYPE  emSignboardType;                // Type of electric signboard
    NET_RECT                    stuBoundingBox;                 // Bounding box
    NET_OBJECT_IMAGE_INFO       stuImageData;                   // Object image
    BYTE                        byReserved[1024];               // Reserved
} NET_ELECTRIC_SIGNBOARD_OBJECT;

// Corresponding to data block description of event type EVENT_IVS_ELECTRIC_SIGNBOARD_DETECT(Electric signboard detection)
typedef struct tagDEV_EVENT_ELECTRIC_SIGNBOARD_DETECT_INFO
{
    int                             nChannelID;                 // Channel ID
    int                             nAction;                    // Event action, 0: Pulse, 1: Start, 2: Stop
    char                            szName[128];                // Event name
    double                          PTS;                        // Timestamp (in milliseconds)
    NET_TIME_EX                     UTC;                        // Time for the event occurred
    int                             nEventID;                   // Event ID

    UINT                            nRuleID;                    // Rule IDused to indicate which rule triggers
    UINT                            nSequence;                  // Sequence
    EM_CLASS_TYPE                   emClassType;                // Class of intelligent event
    UINT                            nSignboardObjNum;           // Number of glove objects
    NET_ELECTRIC_SIGNBOARD_OBJECT   stuSignboardObjs[32];       // Info of glove objects
    SCENE_IMAGE_INFO_EX             stuSceneImage;              // Scene image
    BYTE                            byReserved[1028];           // Reserved
}DEV_EVENT_ELECTRIC_SIGNBOARD_DETECT_INFO;

// Type of electric belt
typedef enum tagEM_ELECTRIC_BELT_TYPE
{
    EM_ELECTRIC_BELT_TYPE_UNKNOWN,         // Unknown
    EM_ELECTRIC_BELT_TYPE_GENERAL,         // General
} EM_ELECTRIC_BELT_TYPE;

// Ware type of electric belt
typedef enum tagEM_BELT_WARE_TYPE
{
    EM_BELT_WARE_TYPE_UNKNOWN,          // Unknown
    EM_BELT_WARE_TYPE_NORMAL,           // Normal
    EM_BELT_WARE_TYPE_MISS_MAIN,        // Main protection rope missing
    EM_BELT_WARE_TYPE_MISS_BACKUP,      // Backup protection rope missing
    EM_BELT_WARE_TYPE_LOW_HANGING,      // Low hanging and high utilization
} EM_BELT_WARE_TYPE;

// Info of electric belt object
typedef struct tagNET_ELECTRIC_BELT_OBJECT
{
    UINT                        nObjectID;                      // Object ID
    EM_ELECTRIC_BELT_TYPE       emBeltType;                     // Type of electric belt
    EM_BELT_WARE_TYPE           emBeltWareType;                 // Ware type of electric belt
    BYTE                        byReserved1[4];                 // Byte alignment
    NET_RECT                    stuBoundingBox;                 // Bounding box
    NET_OBJECT_IMAGE_INFO       stuImageData;                   // Object image
    BYTE                        byReserved[1024];               // Reserved
} NET_ELECTRIC_BELT_OBJECT;

// Corresponding to data block description of event type EVENT_IVS_ELECTRIC_BELT_DETECT(Electric belt detection)
typedef struct tagDEV_EVENT_ELECTRIC_BELT_DETECT_INFO
{
    int                             nChannelID;                 // Channel ID
    int                             nAction;                    // Event action, 0: Pulse, 1: Start, 2: Stop
    char                            szName[128];                // Event name
    double                          PTS;                        // Timestamp (in milliseconds)
    NET_TIME_EX                     UTC;                        // Time for the event occurred 
    int                             nEventID;                   // Event ID

    UINT                            nRuleID;                    // Rule IDused to indicate which rule triggers
    UINT                            nSequence;                  // Sequence
    EM_CLASS_TYPE                   emClassType;                // Class of intelligent event
    UINT                            nBeltObjNum;                // Number of belt objects
    NET_ELECTRIC_BELT_OBJECT        stuBeltObjs[32];            // Info of belt objects
    SCENE_IMAGE_INFO_EX             stuSceneImage;              // Scene image
    BYTE                            byReserved[1028];           // Reserved
} DEV_EVENT_ELECTRIC_BELT_DETECT_INFO;

// Radar detect object type
typedef enum tagEM_RADAR_DETECT_OBJECT_TYPE
{
	EM_RADAR_DETECT_OBJECT_UNKNOWN,											// Unknown
	EM_RADAR_DETECT_OBJECT_HUMAN,											// Human
	EM_RADAR_DETECT_OBJECT_VEHICLE											// Vehicle
}EM_RADAR_DETECT_OBJECT_TYPE;

// Radar detect object
typedef struct tagNET_RADAR_DETECT_OBJECT
{
	int								nObjectID;								// Object ID
	EM_RADAR_DETECT_OBJECT_TYPE		emObjectType;							// Object type
	BYTE							byReserved[1024];						// Reserved			
}NET_RADAR_DETECT_OBJECT;

//  Corresponding to data block description of event type EVENT_IVS_RADAR_LINE_DETECTION
typedef struct tagDEV_EVENT_RADAR_LINE_DETECTION_INFO
{
    int                         nChannelID;									// Channel ID
    int                         nAction;									// Event action, 0: Pulse, 1: Start, 2: Stop
    char                        szName[128];								// Event name
    double                      PTS;										// Timestamp (in milliseconds)
    NET_TIME_EX                 UTC;										// Time for the event occurred 
    int                         nEventID;									// Event ID

    UINT                        nRuleID;									// Rule ID,used to indicate which rule triggers
	EM_CLASS_TYPE               emClassType;								// Event class
	DH_EVENT_FILE_INFO          stuFileInfo;                                // Event file info 
	int							nObjectNum;									// The number of object
	NET_RADAR_DETECT_OBJECT		stuObjects[100];							// The list of objects which was detected
	int							nPresetID;									// PresetID
	int							nDetectRegionNum;							// The number of stuDetectRegion
	NET_POINT					stuDetectRegion[DH_MAX_DETECT_REGION_NUM];	// The region of alarm occur, [0,8192)
	SCENE_IMAGE_INFO_EX			stuSceneImage;								// Scene image
	BYTE						byReserved[1020];							// Reserved
} DEV_EVENT_RADAR_LINE_DETECTION_INFO;

// Radar alarm type
typedef enum tagEM_RADAR_ALARM_TYPE
{
	EM_RADAR_ALARM_TYPE_UNKNOWN,											// Unknown
	EM_RADAR_ALARM_TYPE_ALARM,												// Alarm
	EM_RADAR_ALARM_TYPE_WARNING,											// Warning
}EM_RADAR_ALARM_TYPE;

//  Corresponding to data block description of event type EVENT_IVS_RADAR_REGION_DETECTION
typedef struct tagDEV_EVENT_RADAR_REGION_DETECTION_INFO
{
    int                         nChannelID;									// Channel ID
    int                         nAction;									// Event action, 0: Pulse, 1: Start, 2: Stop
    char                        szName[128];								// Event name
    double                      PTS;										// Timestamp (in milliseconds)
    NET_TIME_EX                 UTC;										// Time for the event occurred 
    int                         nEventID;									// Event ID

    UINT                        nRuleID;									// Rule ID,used to indicate which rule triggers
	EM_CLASS_TYPE               emClassType;								// Event class
	DH_EVENT_FILE_INFO          stuFileInfo;                                // Event file info 
	int							nObjectNum;									// The number of object
	NET_RADAR_DETECT_OBJECT		stuObjects[100];							// The list of objects which was detected
	int							nPresetID;									// PresetID
	int							nDetectRegionNum;							// The number of stuDetectRegion
	NET_POINT					stuDetectRegion[DH_MAX_DETECT_REGION_NUM];	// The region of alarm occur, [0,8192)
	SCENE_IMAGE_INFO_EX			stuSceneImage;								// Scene image
	EM_RADAR_ALARM_TYPE			emAlarmType;								// AlarmType
	BYTE						byReserved[1016];							// Reserved
} DEV_EVENT_RADAR_REGION_DETECTION_INFO;


// audio intensity info (customized)
typedef struct tagAUDIO_INTENSITY_MESSAGE_INFO
{
	char							szType[128];				// message type, like "Audio Detection"
	char							szContent[128];				// message content
	BYTE							byReserved[1024];			// reserved
}AUDIO_INTENSITY_MESSAGE_INFO;

// Corresponding to data block description of event type EVENT_IVS_AUDIO_INTENSITY(audio intensity)
typedef struct tagDEV_EVENT_AUDIO_INTENSITY_INFO
{
	int                         	nChannelID;					// Channel ID (audio)
	int                         	nAction;					// Event action, 0: Pulse, 1: Start, 2: Stop
	double                      	PTS;						// Timestamp (in milliseconds)
    NET_TIME_EX                 	UTC;						// Time for the event occurred 
	BYTE							byReserved1[4];				// reserved1
	AUDIO_INTENSITY_MESSAGE_INFO	stuAudioIntensityInfo;		// audio info
	BYTE							byReserved[1024];			// reserved
}DEV_EVENT_AUDIO_INTENSITY_INFO;

// Corresponding to data block description of event type EVENT_IVS_WALK_DETECTION
typedef struct tagDEV_EVENT_WALK_DETECTION_INFO
{
    int                             nChannelID;                 // Channel ID
    int                             nAction;                    // Event operation. 1: Start, 2: Stop
    char                            szName[128];                // Event name
    EM_CLASS_TYPE                   emClassType;                // class type
    NET_TIME_EX                     UTC;                        // UTC
    double                          PTS;                        // PTS
    UINT                            nEventID;                   // Event ID
    UINT                            nPresetID;                  // preset ID
    BYTE                            byReserved[1024];           // reserved
} DEV_EVENT_WALK_DETECTION_INFO;

// Corresponding to data block description of event type EVENT_IVS_BACK_TO_DETECTION
typedef struct tagDEV_EVENT_BACK_TO_DETECTION_INFO
{
    int                             nChannelID;                 // Channel ID
    int                             nAction;                    // Event operation. 1: Start, 2: Stop
    char                            szName[128];                // Event name
    EM_CLASS_TYPE                   emClassType;                // class type
    NET_TIME_EX                     UTC;                        // UTC
    double                          PTS;                        // PTS
    UINT                            nEventID;                   // Event ID
    UINT                            nPresetID;                  // preset ID
    BYTE                            byReserved[1024];           // reserved
} DEV_EVENT_BACK_TO_DETECTION_INFO;

// Corresponding to data block description of event type EVENT_IVS_WRITE_ON_THE_BOARD_DETECTION
typedef struct tagDEV_EVENT_WRITE_ON_THE_BOARD_DETECTION_INFO
{
    int                             nChannelID;                 // Channel ID
    int                             nAction;                    // Event operation. 1: Start, 2: Stop
    char                            szName[128];                // Event name
    EM_CLASS_TYPE                   emClassType;                // class type
    NET_TIME_EX                     UTC;                        // UTC
    double                          PTS;                        // PTS
    UINT                            nEventID;                   // Event ID
    UINT                            nPresetID;                  // preset ID
    BYTE                            byReserved[1024];           // reserved
} DEV_EVENT_WRITE_ON_THE_BOARD_DETECTION_INFO;

// Corresponding to data block description of event type EVENT_IVS_SMART_KITCHEN_CLOTHES_DETECTION(Smart Kitchen detection)
typedef struct tagDEV_EVENT_SMART_KITCHEN_CLOTHES_DETECTION_INFO
{
	int                         nChannelID;									// Channel ID
	int                         nAction;									// Event action, 0:Pulse 1:Start 2:Stop
	char                        szName[128];								// Event name
	double                      PTS;										// Timestamp(in milliseconds)
	NET_TIME_EX                 UTC;										// Time for the event occurred
	UINT                        nEventID;									// Event ID
	UINT						nRuleID;									// Rule ID, used to indicate which rule triggers 	
	
	EM_CLASS_TYPE               emClassType;								// Event class
	char						szClassAlias[16];							// Category alias of intelligent event
	HUMAN_IMAGE_INFO			stuHumanImage;								// Human image info
	SCENE_IMAGE_INFO			stuSceneImage;								// Panoramic wide angle picture
	FACE_IMAGE_INFO				stuFaceImage;								// Face picture information
	UINT						nObjectID;									// object ID
	EM_NONMOTOR_OBJECT_STATUS	emHasMask;									// Check whether the mask is worn 
	EM_NONMOTOR_OBJECT_STATUS	emHasChefHat;								// Check for chef's hat
	EM_NONMOTOR_OBJECT_STATUS	emHasChefClothes;							// Check if chef's clothes are worn
	EM_OBJECT_COLOR_TYPE		emChefClothesColor;							// Chef costume color detectedThe color of chef's suit that does not meet the requirements is detected
	BYTE						bReserved[1020];
}DEV_EVENT_SMART_KITCHEN_CLOTHES_DETECTION_INFO;

// Initialization parameter
typedef struct tagNETSDK_INIT_PARAM
{
    int                 nThreadNum;         // specify netsdk's normal network process thread number, zero means using default value
    BYTE                bReserved[1024];    // reserved
}NETSDK_INIT_PARAM, *LPNETSDK_INIT_PARAM;

// the return data info of config interface
typedef struct tagNET_CONFIG_RETURN_INFO
{
	DWORD				    dwSize;
	int						nRetCnt;		// the return count of config
} NET_CONFIG_RETURN_INFO;


// Overlay Type
typedef enum tagNET_EM_OSD_BLEND_TYPE
{
    NET_EM_OSD_BLEND_TYPE_UNKNOWN,                                  // unknow overlay type
    NET_EM_OSD_BLEND_TYPE_MAIN,                                     // Overlay to main stream 
    NET_EM_OSD_BLEND_TYPE_EXTRA1,                                   // Overlay to extra stream 1
    NET_EM_OSD_BLEND_TYPE_EXTRA2,                                   // Overlay to extra stream 2
    NET_EM_OSD_BLEND_TYPE_EXTRA3,                                   // Overlay to extra stream 3
    NET_EM_OSD_BLEND_TYPE_SNAPSHOT,                                 // Overlay to snap
    NET_EM_OSD_BLEND_TYPE_PREVIEW,                                  // Overlay to preview mode
}NET_EM_OSD_BLEND_TYPE;

// Encode widget-channel title 
typedef struct tagNET_OSD_CHANNEL_TITLE
{
	DWORD				    dwSize;
    NET_EM_OSD_BLEND_TYPE   emOsdBlendType;                 // Overlay Type, should set the value whether getting config  or setting config
    BOOL                    bEncodeBlend;                   // Overlay or not
	NET_COLOR_RGBA		    stuFrontColor;					// Foreground color
	NET_COLOR_RGBA		    stuBackColor;					// Background color 
	NET_RECT		    	stuRect;						// Zone. The coordinates value ranges from  0 to 8191. Only use left value and top value.The point (left,top) shall be the same as the point(right,bottom).
} NET_OSD_CHANNEL_TITLE;

// Encode widget-Time title
typedef struct tagNET_OSD_TIME_TITLE
{
	DWORD				    dwSize;
    NET_EM_OSD_BLEND_TYPE   emOsdBlendType;             // Overlay Type, should set the value whether getting config  or setting config
    BOOL                    bEncodeBlend;               // Overlay or not
	NET_COLOR_RGBA		    stuFrontColor;				// Foreground color
	NET_COLOR_RGBA		    stuBackColor;				// Background color
	NET_RECT 			    stuRect;					// Zone. The coordinates value ranges from  0 to 8191. Only use left value and top value.The point (left,top) shall be the same as the point(right,bottom).
	BOOL 				    bShowWeek;					// Display week or not 
} NET_OSD_TIME_TITLE;

// Overlapping heading purpose
typedef enum tagNET_EM_TITLE_TYPE
{
    NET_EM_TITLE_UNKNOWN,              // Unknown
    NET_EM_TITLE_RTINFO,               // Real-time recording information
    NET_EM_TITLE_CUSTOM,               // Custom Overlay, Temperature and Humidity Overlay
    NET_EM_TITLE_TITLE,                // Headline information
    NET_EM_TITLE_CHECK,                // Check code
    NET_EM_TITLE_SPEEDOMETER,          // Velocimeter
    NET_EM_TITLE_GEOGRAPHY,            // geographic information
    NET_EM_TITLE_ATMCARDINFP,          // ATM Card Number Information
    NET_EM_TITLE_CAMERAID,             // Camera number
}NET_EM_TITLE_TYPE; 


// Encode widget-User-defined title information
typedef struct tagNET_CUSTOM_TITLE_INFO
{
    BOOL                    bEncodeBlend;                   // Overlay or not
	NET_COLOR_RGBA		    stuFrontColor;					// Foreground color
	NET_COLOR_RGBA		    stuBackColor;					// Background color
	NET_RECT			    stuRect;						// Zone. The coordinates value ranges from  0 to 8191. Only use left value and top value.The point (left,top) shall be the same as the point(right,bottom).
	char				    szText[CUSTOM_TITLE_LEN];		// Title contents
    NET_EM_TITLE_TYPE       emTitleType;                    // Overlapping heading purpose
	BYTE                    byReserved[508];                // reserved 
} NET_CUSTOM_TITLE_INFO;

// Encode widget-User-defined title
typedef struct tagNET_OSD_CUSTOM_TITLE
{
	DWORD					dwSize;
	NET_EM_OSD_BLEND_TYPE   emOsdBlendType;                         // Overlay Type, should set the value whether getting config  or setting config
	int						nCustomTitleNum;						// User-defined title amount
	NET_CUSTOM_TITLE_INFO	stuCustomTitle[MAX_CUSTOM_TITLE_NUM];	// User-defined title
} NET_OSD_CUSTOM_TITLE;

// title text alignment type 
typedef enum tagEM_TITLE_TEXT_ALIGNTYPE
{
    EM_TEXT_ALIGNTYPE_INVALID,                              // Invalid alignment mathod
    EM_TEXT_ALIGNTYPE_LEFT,                                 // Left alignment 
    EM_TEXT_ALIGNTYPE_XCENTER,                              // X coordinate alignment 
    EM_TEXT_ALIGNTYPE_YCENTER,                              // Y coordinate alignment 
    EM_TEXT_ALIGNTYPE_CENTER,                               // Center
    EM_TEXT_ALIGNTYPE_RIGHT,                                // Right alignment 
    EM_TEXT_ALIGNTYPE_TOP,                                  // By top alignment 
    EM_TEXT_ALIGNTYPE_BOTTOM,                               // By bottom alignment 
    EM_TEXT_ALIGNTYPE_LEFTTOP,                              // By upper left alignment 
    EM_TEXT_ALIGNTYPE_CHANGELINE,                           // Next row alignment 
}EM_TITLE_TEXT_ALIGNTYPE;

// User-defined title text alignment 
typedef struct tagNET_OSD_CUSTOM_TITLE_TEXT_ALIGN
{
	DWORD					dwSize;
	int						nCustomTitleNum;						// User-defined title amount
    EM_TITLE_TEXT_ALIGNTYPE emTextAlign[MAX_CUSTOM_TITLE_NUM];      // User-defined title alignment info 
}NET_OSD_CUSTOM_TITLE_TEXT_ALIGN;

// Encode widget common info
typedef struct tagNET_OSD_COMM_INFO
{
	DWORD					dwSize;
	double					fFontSizeScale;			// overlay font size scale
													// if fFontSizeScale isn't 0, nFontSize is invalid 
													// otherwise nFontSize is valid
	int						nFontSize;				// global font size overlay to main stream, unit px, default is 24
	int						nFontSizeExtra1;		// global font size overlay to sub stream 1, unit px
	int						nFontSizeExtra2;		// global font size overlay to sub stream 2, unit px
	int						nFontSizeExtra3;		// global font size overlay to sub stream 3, unit px
	int						nFontSizeSnapshot;		// global font size overlay to snapshot stream, unit px
	int						nFontSizeMergeSnapshot; // combination picture overlay to snapshot stream, unit px
} NET_OSD_COMM_INFO;

// Encode widget - PTZZoom info
typedef struct tagNET_OSD_PTZZOOM_INFO
{
	DWORD					dwSize;
	BOOL					bMainBlend;				// Whether overlay to main stream  or not
	BOOL					bPreviewBlend;			// Whether overlay to preview stream or not
	NET_COLOR_RGBA		    stuFrontColor;			// front color
	NET_COLOR_RGBA		    stuBackColor;			// back color
	NET_RECT		    	stuRect;				// Zone. The coordinates value ranges from  0 to 8191. Only use left value and top value.The point (left,top) shall be the same as the point(right,bottom).
	int						nDisplayTime;			// the time of display,0 is means always show
} NET_OSD_PTZZOOM_INFO;

// Encode widget - GPS title info
typedef struct tagNET_OSD_GPS_TITLE
{
	DWORD					dwSize; 
	BOOL					bEncodeBlend;            //whether overlay to main stream or not
}NET_OSD_GPS_TITLE;

#define MAX_COUNT_PLANE		32	// max plane counts

// the osd info of people number plane 
typedef struct tagNET_STATPLAN_INFO
{
	int						nPlanID;				// plane ID
	BOOL					bEncodeBlend;			// blend main stream or not
	NET_COLOR_RGBA		    stuFrontColor;			// foreground color
	NET_COLOR_RGBA		    stuBackColor;			// background color
	EM_TITLE_TEXT_ALIGNTYPE emTextAlign;			// align type
	NET_RECT		    	stuRect;				// rect(0~8192)
	BOOL					bShowEnterNum;			// show the number of peoples entering or not
	BOOL					bShowExitNum;			// show the number of peoples leaving or not
	BYTE                    byReserved[128];        // reserved 
} NET_STATPLAN_INFO;

// the osd config of people number plane
typedef struct tagNET_OSD_NUMBER_STATPLAN
{
	DWORD					dwSize;
	int						nRetPlanCount;							// the actual count of plans
	NET_STATPLAN_INFO		stuStatplanInfo[MAX_COUNT_PLANE];		// OSD config
} NET_OSD_NUMBER_STATPLAN;
typedef enum tatNET_EM_AUDIO_FORAMT
{
	EM_AUDIO_FORMAT_UNKNOWN,							// unknown
	EM_AUDIO_FORMAT_G711A,                              // G711a
    EM_AUDIO_FORMAT_PCM,                                // PCM
    EM_AUDIO_FORMAT_G711U,                              // G711u
    EM_AUDIO_FORMAT_AMR,                                // AMR
    EM_AUDIO_FORMAT_AAC,                                // AAC
    
    EM_AUDIO_FORMAT_G726,								// G.726
    EM_AUDIO_FORMAT_G729,								// G.729
    EM_AUDIO_FORMAT_ADPCM,								// ADPCM
    EM_AUDIO_FORMAT_MPEG2,								// MPEG2
    EM_AUDIO_FORMAT_MPEG2L2,							// MPEG2-Layer2
    EM_AUDIO_FORMAT_OGG,								// OGG
    EM_AUDIO_FORMAT_MP3,								// MP3
    EM_AUDIO_FORMAT_G7221,								// G.722.1
} NET_EM_AUDIO_FORMAT;


// the type of video compression
typedef enum tagNET_EM_VIDEO_COMPRESSION
{
	EM_VIDEO_FORMAT_UNKNOWN = -1,						// Unknown
	EM_VIDEO_FORMAT_MPEG4,								// MPEG4
	EM_VIDEO_FORMAT_MS_MPEG4,							// MS-MPEG4
	EM_VIDEO_FORMAT_MPEG2,								// MPEG2
	EM_VIDEO_FORMAT_MPEG1,								// MPEG1
	EM_VIDEO_FORMAT_H263,								// H.263
	EM_VIDEO_FORMAT_MJPG,								// MJPG
	EM_VIDEO_FORMAT_FCC_MPEG4,							// FCC-MPEG4
	EM_VIDEO_FORMAT_H264,								// H.264
    EM_VIDEO_FORMAT_H265,								// H.265
	EM_VIDEO_FORMAT_SVAC,								// SVAC
} NET_EM_VIDEO_COMPRESSION;

// the type of BitRateControl
typedef enum tagNET_EM_BITRATE_CONTROL
{
	EM_BITRATE_CBR,									// CBR
	EM_BITRATE_VBR,									// VBR
} NET_EM_BITRATE_CONTROL;

// the type of image quality
typedef enum tagNET_EM_IMAGE_QUALITY
{
	EM_IMAGE_QUALITY_Q10 = 1,							// 10%
	EM_IMAGE_QUALITY_Q30,								// 30%
	EM_IMAGE_QUALITY_Q50,								// 50%
	EM_IMAGE_QUALITY_Q60,								// 60%
	EM_IMAGE_QUALITY_Q80,								// 80%
	EM_IMAGE_QUALITY_Q100,								// 100%
} NET_EM_IMAGE_QUALITY;

// H264 Encode Level
typedef enum tagNET_EM_H264_PROFILE_RANK
{
	EM_PROFILE_UNKNOWN,							   // unknow
	EM_PROFILE_BASELINE = 1,                       // Offer I/P Frame, Only support progressive(Progressive Scan)and CAVLC
	EM_PROFILE_MAIN,                               // Offer I/P/B Frame, Support progressiv and interlaced, Offer CAVLC or CABAC
	EM_PROFILE_EXTENDED,                           // Offer I/P/B/SP/SI Frame, Only support progressive(Progressive Scan)and CAVLC
	EM_PROFILE_HIGH,                               // FRExt Main_Profile Based on the new, o8x8 intra prediction(8x8 Intra-frame Predicdion), custom 
												   // Quant(custom quant ), lossless video coding(lossless video encoding), more yuv format
}NET_EM_H264_PROFILE_RANK;

// the type of stream
typedef enum tagNET_EM_FORMAT_TYPE
{
	EM_FORMAT_TYPE_UNKNOWN,				// unknow
	/*main stream*/
	EM_FORMAT_MAIN_NORMAL,				// main stream--normal
	EM_FORMAT_MAIN_MOVEEXAMINE,			// main stream--move examine
	EM_FORMAT_MAIN_ALARM,				// main stream--alarm

	/*extra stream*/
	EM_FORMAT_EXTRA1,					// extra stream 1
	EM_FORMAT_EXTRA2,					// extra stream 2
	EM_FORMAT_EXTRA3,					// extra stream 3
} NET_EM_FORMAT_TYPE;

// the type of pack
typedef enum tagNET_EM_PACK_TYPE
{
	EM_PACK_UNKOWN,				// UNKOWN
	EM_PACK_DHAV,				// DHAV
	EM_PACK_PS,					// ps
} NET_EM_PACK_TYPE;


// the video info of main(extra) stream
typedef struct tagNET_ENCODE_VIDEO_INFO
{
	DWORD						dwSize;
	NET_EM_FORMAT_TYPE			emFormatType;				// stream type, you need to set this value when get or set config
	BOOL						bVideoEnable;				// enable
	NET_EM_VIDEO_COMPRESSION 	emCompression;				// the type of video compression
	int							nWidth;						// the wigth of video 
	int							nHeight;					// the height of video
	NET_EM_BITRATE_CONTROL		emBitRateControl;			// the type of BitRateControl
	int							nBitRate;					// Video bit rate (kbps)
	float						nFrameRate;					// Frame Rate 
	int							nIFrameInterval;			// I frame interval(1-100). For example, 50 means there is I frame in each 49 B frame or P frame.
	NET_EM_IMAGE_QUALITY		emImageQuality;				// image quality
} NET_ENCODE_VIDEO_INFO;

// video pack info of main(extra) stream
typedef struct tagNET_ENCODE_VIDEO_PACK_INFO
{
	DWORD						dwSize;
	NET_EM_FORMAT_TYPE			emFormatType;				// stream type, you need to set this value when get or set config
	NET_EM_PACK_TYPE			emPackType;					// pack type 
} NET_ENCODE_VIDEO_PACK_INFO;

// video SVC info of main(extra) stream
typedef struct tagNET_ENCODE_VIDEO_SVC_INFO
{
	DWORD						dwSize;
	NET_EM_FORMAT_TYPE			emFormatType;				// stream type, you need to set this value when get or set config
	int							nSVC;						// SVC-T level
} NET_ENCODE_VIDEO_SVC_INFO;

//video profile info of main(extra) stream
typedef struct tagNET_ENCODE_VIDEO_PROFILE_INFO
{
	DWORD						dwSize;
	NET_EM_FORMAT_TYPE			emFormatType;				// stream type, you need to set this value when get or set config
	NET_EM_H264_PROFILE_RANK 	emProfile;                	// H.264 encode level
} NET_ENCODE_VIDEO_PROFILE_INFO;

// audio compression info of main(extra) stream
typedef struct tagNET_ENCODE_AUDIO_COMPRESSION_INFO
{
	DWORD						dwSize;
	BOOL						bAudioEnable;			// enable
	NET_EM_FORMAT_TYPE			emFormatType;			// stream type, you need to set this value when get or set config
	NET_EM_AUDIO_FORMAT			emCompression;			// the type of audio compression
} NET_ENCODE_AUDIO_COMPRESSION_INFO;

//audio  info of main(extra) stream
typedef struct tagNET_ENCODE_AUDIO_INFO
{
	DWORD						dwSize;
	NET_EM_FORMAT_TYPE			emFormatType;			// stream type, you need to set this value when get or set config
	int							nDepth;					// sampling depth
	int							nFrequency;				// sampling frequency
    int							nMode;					// Coding rate, different coding types have different definitions:
                                                       /* "AMR"code rate
                                                            0: 4.75kbps,
                                                            1: 5.15 kbps,
                                                            2: 5.9 kbps,
                                                            3: 6.7 kbps,
                                                            4: 7.4 kbps,
                                                            5: 7.95 kbps,
                                                            6: 10.2 kbps,
                                                            7: 12.2 kbps,
                                                        G726 code rate
                                                            0: 40kbps(default)
                                                            1: 16kbps
                                                            2: 24kbps
                                                            3: 32kbps*/

	int							nFrameType;				// audio frame type, 0-DHAV, 1-PS
	int							nPacketPeriod;			// audio packet period, ms
} NET_ENCODE_AUDIO_INFO;

// snap type
typedef enum tagNET_EM_SNAP_TYPE
{
	EM_SNAP_UNKNOWN,			// unknow
	EM_SNAP_NORMAL,				// normal
	EM_SNAP_MOVEEXAMINE,		// move examine
	EM_SNAP_ALARM,				// alarm
} NET_EM_SNAP_TYPE;

// the snap info
typedef struct tagNET_ENCODE_SNAP_INFO
{
	DWORD						dwSize;
	NET_EM_SNAP_TYPE			emSnapType;					// snap type
	BOOL						bSnapEnable;				// enable
	NET_EM_VIDEO_COMPRESSION 	emCompression;				// the video compression
	int							nWidth;						// the width of image
	int							nHeight;					// the height of image
	float						nFrameRate;					// frame rate
	int 						nQualityRange;				// the range of image quality
	NET_EM_IMAGE_QUALITY		emImageQuality;				// image quality
} NET_ENCODE_SNAP_INFO;

// snap time info
typedef struct tagNET_ENCODE_SNAP_TIME_INFO
{
	DWORD				dwSize;
	short           	shPicTimeInterval;             	// the time interval of snap, unit:second
	BYTE            	bPicIntervalHour;              	// the time interval of snap, unit:hour 
	DWORD           	dwTrigPicIntervalSecond;       	// the time interval of snap after alarm, unit:second
} NET_ENCODE_SNAP_TIME_INFO;

// config type
typedef enum tagNET_EM_CONFIG_TYPE
{
	NET_EM_CONFIG_DAYTIME,			// day time
	NET_EM_CONFIG_NIGHT,			// night
	NET_EM_CONFIG_NORMAL,			// normal
} NET_EM_CONFIG_TYPE;


// channel title info
typedef struct tagNET_ENCODE_CHANNELTITLE_INFO
{
	DWORD				dwSize;
	char				szChannelName[MAX_CHANNEL_NAME_LEN];	// channel title
} NET_ENCODE_CHANNELTITLE_INFO;

// the type of audio input
typedef enum tagNET_EM_AUDIOIN_SOURCE_TYPE
{
	NET_EM_AUDIOIN_SOURCE_UNKNOW,			// unkonw
	NET_EM_AUDIOIN_SOURCE_COAXIAL,			// Coaxial
	NET_EM_AUDIOIN_SOURCE_BNC,				// BNC
	NET_EM_AUDIOIN_SOURCE_HDCVI_BNC,		// HDCVI_BNC
	NET_EM_AUDIOIN_SOURCE_LINEIN,			// LineIn
	NET_EM_AUDIOIN_SOURCE_LINEIN1,			// LineIn1
	NET_EM_AUDIOIN_SOURCE_LINEIN2,			// LineIn2
	NET_EM_AUDIOIN_SOURCE_LINEIN3,			// LineIn3
	NET_EM_AUDIOIN_SOURCE_MIC,				// Mic
	NET_EM_AUDIOIN_SOURCE_MIC1,				// Mic1
	NET_EM_AUDIOIN_SOURCE_MIC2,				// Mic2
	NET_EM_AUDIOIN_SOURCE_MIC3,				// Mic3
	NET_EM_AUDIOIN_SOURCE_MICOUT,			// MicOut
	NET_EM_AUDIOIN_SOURCE_REMOTE,			// Remote
	NET_EM_AUDIOIN_SOURCE_REMOTE1,			// Remote1
	NET_EM_AUDIOIN_SOURCE_REMOTE2,			// Remote2
	NET_EM_AUDIOIN_SOURCE_REMOTE3,			// Remote3
} NET_EM_AUDIOIN_SOURCE_TYPE;

// the source info of audio input
typedef struct tagNET_ENCODE_AUDIO_SOURCE_INFO
{
	DWORD						dwSize;
	int 						nMaxAudioInSource;		// the max counts of audio input source
	int							nRetAudioInSource;		// the reality counts of audio input source
	NET_EM_AUDIOIN_SOURCE_TYPE	emAudioInSource[24];	// the source of  audio input
} NET_ENCODE_AUDIO_SOURCE_INFO;

// the denoise info of audio input
typedef struct tagNET_AUDIOIN_DENOISE_INFO
{
	DWORD				dwSize;
	BOOL				bEnable;			// enable
} NET_AUDIOIN_DENOISE_INFO;

// the volume config of audio input
typedef struct tagNET_AUDIOIN_VOLUME_INFO
{
	DWORD				dwSize;
	int					nVolume;			// the volume 
} NET_AUDIOIN_VOLUME_INFO;

// the volume config of audio output
typedef struct tagNET_AUDIOOUT_VOLUME_INFO
{
	DWORD				dwSize;
	int					nVolume;			// the volume
} NET_AUDIOOUT_VOLUME_INFO;

// switch mode
typedef enum tagNET_EM_SWITCH_MODE
{
	NET_EM_SWITCH_MODE_WIGHT,		// do not switch, use day time config
	NET_EM_SWITCH_MODE_LIGHT,		// switch by brightness
	NET_EM_SWITCH_MODE_TIME,		// switch by time
	NET_EM_SWITCH_MODE_NIGHT,		// do not switch, use night config
	NET_EM_SWITCH_MODE_NORMAL,		// use normal config
} NET_EM_SWITCH_MODE;

// roughly time of sunrise or sunset
typedef struct tagNET_SUN_TIME
{
	int				nHour;				// hour
	int				nMinute;			// minute
	int				nSecond;			// second
} NET_SUN_TIME;

// the config of switch mode
typedef struct tagNET_VIDEOIN_SWITCH_MODE_INFO
{
	DWORD				dwSize;
	NET_EM_SWITCH_MODE	emSwitchMode;			// switch mode

	/*roughly time of sunrise and sunset, use night config between sunset and sunrise, 
	it is valid when emSwitchMode is NET_EM_SWITCH_MODE_TIME*/
	NET_SUN_TIME		stuSunRiseTime;			// sunrise time
	NET_SUN_TIME		stuSunSetTime;			// sunset time
} NET_VIDEOIN_SWITCH_MODE_INFO;

// color style
typedef enum tagEM_COLOR_STYLE_TYPE
{
	EM_COLOR_STYLE_UNKNOWN,			// unknown
	EM_COLOR_STYLE_GENTLE,			// gentle
	EM_COLOR_STYLE_STANDARD,		// standard
	EM_COLOR_STYLE_FLAMBOYANT,		// plamboyant
} EM_COLOR_STYLE_TYPE;

// the color config of video input
typedef struct tagNET_VIDEOIN_COLOR_INFO
{
	DWORD				dwSize;
	NET_EM_CONFIG_TYPE	emCfgType;				// config type, you need set the value wether set or get config
	int					nBrightness;			// Brightness 0-100
	int					nContrast;				// nContrast 0-100
	int					nSaturation;			// Saturation 0-100
	int					nGamma;					// Gamma 0-100
	EM_COLOR_STYLE_TYPE	emColorStyle;			// color style

    int                 nHue;                   // Tone value 0-100
    int                 nChromaSuppress;        // Colour Suppression Level Value 0-100
    DH_TSECT            stuTimeSection;         // Time section
} NET_VIDEOIN_COLOR_INFO;

// LED Display Color
typedef enum tagNET_EM_FLIP_MODE
{
    NET_EM_FLIP_MODE_UNKNOWN = 0,     // Unknown
    NET_EM_FLIP_MODE_MANUAL,          // Manual
    NET_EM_FLIP_MODE_AUTO,            // Auto 
}NET_EM_FLIP_MODE;

// Image Rotation Setting Capability Configuration,corresponding to NET_EM_CFG_VIDEO_IMAGE_CTRL
typedef struct tagNET_EM_CFG_VIDEO_IMAGE_CTRL_INFO
{
    DWORD			dwSize;
    BOOL            bMirror;                // Does it support screen mirroring?
    BOOL            bFlip;                  // Does it support the flip function of screen 180?
    BOOL            bFreeze;                // Does it support image freezing?
    BOOL            bVerticalFlip;          // Whether to Turn on Vertical Rotation 180 Degree Function
    BOOL            bHorizontalFlip;        // Whether Horizontal Rotation 180 Degree Function is Turned on
    int             nRotate90;              // 90 clockwise rotation marks 0-no rotation, 1-clockwise 90 and 2-clockwise 90.
    int             nStable;                // Functional mask 0 to support image anti-shake is turned off, support electronic anti-shake by bit or 1-turn on, 2-turn on optical anti-shake, 4-turn on control anti-shake
    int             nStableSensitivity;     // Whether to support electronic anti-jitter sensitivity, value range [0-100]
    NET_EM_FLIP_MODE emFlipMode;            // Picture flip mode
}NET_EM_CFG_VIDEO_IMAGE_CTRL_INFO;

// image options config of video input
typedef struct tagNET_VIDEOIN_IMAGE_INFO
{
	DWORD				dwSize;
	NET_EM_CONFIG_TYPE	emCfgType;				// config type, you need set the value wether set or get config
	BOOL				bMirror;				// mirror
	BOOL				bFlip;					// flip
	int					nRotate90;				// 0-not rotate, 1-clockwise 90 degrees, 2-anti-clockwise 90 degrees
} NET_VIDEOIN_IMAGE_INFO;

// image stable type
typedef enum tagNET_EM_STABLE_TYPE
{
	NET_EM_STABLE_OFF,				// off
	NET_EM_STABLE_ELEC,				// electronics
	NET_EM_STABLE_LIGHT,			// light
	NET_EM_STABLE_CONTORL = 4,		// control
} NET_EM_STABLE_TYPE;

// image stable config of video input
typedef struct tagNET_VIDEOIN_STABLE_INFO
{
	DWORD				dwSize;
	NET_EM_CONFIG_TYPE	emCfgType;			// config type, you need set the value wether set or get config
	NET_EM_STABLE_TYPE	emStableType;		// image stable type
} NET_VIDEOIN_STABLE_INFO;

// iris auto config of video input
typedef struct tagNET_VIDEOIN_IRISAUTO_INFO
{
	DWORD				dwSize;
	NET_EM_CONFIG_TYPE	emCfgType;		// config type, you need set the value wether set or get config
	BOOL				bIrisAuto;		// iris auto enable
} NET_VIDEOIN_IRISAUTO_INFO;

// image enhancement config of video input
typedef struct tagNET_VIDEOIN_IMAGEENHANCEMENT_INFO
{
	DWORD				dwSize;
	BOOL				bEnable;			// enable
	int					nLevel;				// image enhancement level
}NET_VIDEOIN_IMAGEENHANCEMENT_INFO;

// Support Type of Double Shutter
typedef enum tagEM_DOUBLE_EXPOSURE_TYPE
{
    EM_DOUBLE_EXPOSURE_UNKNOWN = -1,				// Unknown
    EM_DOUBLE_EXPOSURE_NOT_SUPPORT,				    // Not support
    EM_DOUBLE_EXPOSURE_SUPPORT_FULL_FRAM,			// Support double shutter full frame rate, i.e. image and video only have different shutter parameters
    EM_DOUBLE_EXPOSURE_SUPPORT_HALF_FRAM,		    // Support double shutter full frame rate, i.e. images and videos have only different shutter parameters
    EM_DOUBLE_EXPOSURE_ALL,		                    // Supporting full frame rate and half frame rate with double shutters
} EM_DOUBLE_EXPOSURE_TYPE;


//normal exposure config of video input
typedef struct tagNET_VIDEOIN_EXPOSURE_NORMAL_INFO
{
	DWORD					dwSize;
	NET_EM_CONFIG_TYPE		emCfgType;				// config type, you need set the value wether set or get config
	NET_EM_EXPOSURE_MODE	emExposureMode;			// exposure mode
	int						nAntiFlicker;			// anti flicker 0-Outdoor  1-50Hz 2-60Hz
	int						nCompensation;			// Compensation 0-100
	int						nGain;					// gain value 0-100
	int						nGainMin;				// the min value of Gain 0-100
	int						nGainMax;				// the max value of gain 0-100
	int						nExposureIris;			// the value of iris(0-100),  it is valid when mode is NET_EM_EXPOSURE_APERTUREFIRST
	double					dbExposureValue1;		// Auto exposure value min limit or manual axposure custom, unit is millisecond (0.1ms~80ms).
	double					dbExposureValue2;		// Auto exposure time max limit, unit is millisecond (0.1ms~80ms)
    BOOL                    bIrisAuto;              // Automatic aperture enabling
    EM_DOUBLE_EXPOSURE_TYPE emDoubleExposure;       // Support Type of Double Shutter
} NET_VIDEOIN_EXPOSURE_NORMAL_INFO;

// other exposure config of video input
typedef struct tagNET_VIDEOIN_EXPOSURE_OTHER_INFO
{
	DWORD					dwSize;
	NET_EM_CONFIG_TYPE		emCfgType;				// config type, you need set the value wether set or get config
	BOOL					bSlowShutter;			// slow shutter enable
	int						nSlowSpeed;				// slow speed level
	int						nSlowAutoExposure;		// slow exposure
	int						nRecoveryTime;			// recovery time,units:second. 0 means not recovery
	int						nIrisMin;				// iris value min limit(0-100)
	int						nIrisMax;				// iris value max limit(0-100)
} NET_VIDEOIN_EXPOSURE_OTHER_INFO;

// exposure shutter config of video input
typedef struct tagNET_VIDEOIN_EXPOSURE_SHUTTER_INFO
{
	DWORD					dwSize;
	BOOL					bAutoSyncPhase;			// auto syncphase enable
	float					fShutter;				// shutter value(0.1ms-80ms), it is valid when bAutoSyncPhase is true. the value mst be brtween ExposureValue1  and ExposureValue2
	int						nPhase;					// phase value,0~360
} NET_VIDEOIN_EXPOSURE_SHUTTER_INFO;



// back light config of video input
typedef struct tagNET_VIDEOIN_BACKLIGHT_INFO
{
	DWORD					dwSize;
	NET_EM_CONFIG_TYPE		emCfgType;				// config type, you need set the value wether set or get config
	NET_EM_BACK_MODE		emBlackMode;			// black mode
	NET_EM_BLACKLIGHT_MODE	emBlackLightMode;		// black light mode
	NET_RECT				stuBacklightRegion;     // the region of black light
	int						nWideDynamicRange;		// the value of widedynamic, it is valid when emBlackMode is NET_EM_BACKLIGHT_MODE_WIDEDYNAMIC
	int						nGlareInhibition;		// the value of glareinhibition, it is valid when emBlackMode is NET_EM_BACKLIGHT_MODE_GLAREINHIBITION
} NET_VIDEOIN_BACKLIGHT_INFO;


//the config of Intensity, valid when black mode is SSA
typedef struct tagNET_VIDEOIN_INTENSITY_INFO
{
	DWORD						dwSize;
	NET_EM_CONFIG_TYPE			emCfgType;				// config type, you need set the value wether set or get config
	NET_EM_BACK_INTENSITY_MODE	emIntensityMode;		// the mode of Intensity
	int							nIntensity;				// Intensity value[0-100] , valid when emIntensityMode==NET_EM_INTENSITY_MANUAL
} NET_VIDEOIN_INTENSITY_INFO;


// white balance config of video input
typedef struct tagNET_VIDEOIN_WHITEBALANCE_INFO
{
	DWORD						dwSize;
	NET_EM_CONFIG_TYPE			emCfgType;					// config type, you need set the value wether set or get config
	NET_EM_WHITEBALANCE_TYPE	emWhiteBalanceType;			// white balance type
	int							nGainRed;					// red gain (0-100), it is valid when emWhiteBalanceType is NET_EM_WHITEBALANCE_CUSTOM
	int							nGainBlue;					// blue gain (0-100), it is valid when emWhiteBalanceType is NET_EM_WHITEBALANCE_CUSTOM
	int							nGainGreen;					// green gain (0-100), it is valid when emWhiteBalanceType is NET_EM_WHITEBALANCE_CUSTOMCOLORTEMP
	int							nColorTemperature;			// color temperature level, it is valid when emWhiteBalanceType is NET_EM_WHITEBALANCE_CUSTOM
} NET_VIDEOIN_WHITEBALANCE_INFO;

// day or night type
typedef enum tagNET_EM_DAYNIGHT_TYPE
{
	NET_EM_DAYNIGHT_COLOR,				// always color
	NET_EM_DAYNIGHT_AUTO,				// according to the brightness auromatically switches
	NET_EM_DAYNIGHT_WHITEBLACK,			// always black and white
} NET_EM_DAYNIGHT_TYPE;

//day or night config of video input
typedef struct tagNET_VIDEOIN_DAYNIGHT_INFO
{
	DWORD						dwSize;
	NET_EM_CONFIG_TYPE			emCfgType;					// config type, you need set the value wether set or get config
	NET_EM_DAYNIGHT_TYPE		emDayNightType;				// day or night type
	int							nDayNightSensitivity;		// Sensitivity of day or night(1-3)
	int							nDayNightSwitchDelay;		// delay time of day or night switch(2s - 10s)
} NET_VIDEOIN_DAYNIGHT_INFO;

// ICR config of video input
typedef struct tagNET_VIDEOIN_DAYNIGHT_ICR_INFO
{
	DWORD						dwSize;
	NET_EM_CONFIG_TYPE			emCfgType;					// config type, you need set the value wether set or get config
	NET_EM_ICR_TYPE				emType;						// ICR switch type
} NET_VIDEOIN_DAYNIGHT_ICR_INFO;

//lighting mode
typedef enum tagNET_EM_LIGHTING_MODE
{
	NET_EM_LIGHTING_UNKNOW,			// unknow
	NET_EM_LIGHTING_MANUAL,			// manual
	NET_EM_LIGHTING_AUTO,			// auto
	NET_EM_LIGHTING_OFF,			// off
	NET_EM_LIGHTING_ZOOMPRIO,		// zoomprio
	NET_EM_LIGHTING_TIMING,			// timing
	NET_EM_LIGHTING_SMARTLIGHT,		// smart light(only used by SD)
    NET_EM_LIGHTING_EXCLUSIVEMANUAL,	// Multiple lights are supported, but only one light is used in manual mode, using the Manual Lighting configuration
} NET_EM_LIGHTING_MODE;

// lighting config of video input
typedef struct tagNET_VIDEOIN_LIGHTING_INFO
{
	DWORD						dwSize;
	NET_EM_LIGHTING_MODE		emLightMode;			// lighting mode
	int							nCorrection;			// correction of lighting
	int							nSensitive;				// Sensitive of lighting
	int							nNearLight;				// near light 0-100
	int							nFarLight;				// far light 0-100
} NET_VIDEOIN_LIGHTING_INFO;

// defog mode
typedef enum tagNET_EM_DEFOG_MODE
{
	NET_EM_DEFOG_UNKNOW,			// unknow
	NET_EM_DEFOG_OFF,				// off
	NET_EM_DEFOG_AUTO,				// auto
	NET_EM_DEFOG_MANAUL,			// manual
}NET_EM_DEFOG_MODE;

//intensity mode
typedef enum tagNET_EM_INTENSITY_MODE
{
	NET_EM_INTENSITY_MODE_UNKNOW,	//unknow
	NET_EM_INTENSITY_MODE_AUTO,  	//auto
	NET_EM_INTENSITY_MODE_MANUAL, 	//manual
}NET_EM_INTENSITY_MODE;


// defog config of video input
typedef struct tagNET_VIDEOIN_DEFOG_INFO
{
	DWORD							dwSize;
	NET_EM_CONFIG_TYPE				emCfgType;					// config type, you need set the value wether set or get config
	NET_EM_DEFOG_MODE				emDefogMode;				// defog mode
	int								nIntensity;					// Intensity 0-100
	NET_EM_INTENSITY_MODE			emIntensityMode;			// Intensity mode
	int								nLightIntensityLevel;		// Intensity light level(0-15)
	BOOL							bCamDefogEnable;			// enable
} NET_VIDEOIN_DEFOG_INFO;


// focus mode config of video input
typedef struct tagNET_VIDEOIN_FOCUSMODE_INFO
{
	DWORD							dwSize;
	NET_EM_CONFIG_TYPE				emCfgType;				// config type, you need set the value wether set or get config
	NET_EM_FOCUS_MODE				emFocusMode;			// focus mode
} NET_VIDEOIN_FOCUSMODE_INFO;

// sensitivity type
typedef enum tagNET_EM_SENSITIVITY_TYPE
{
	NET_EM_SENSITIVITY_HIGH,				// high
	NET_EM_SENSITIVITY_DEFAULT,				// default
	NET_EM_SENSITIVITY_LOW,					// low
} NET_EM_SENSITIVITY_TYPE;

// ICR type
typedef enum tagNET_EM_IRC_TYPE
{
	NET_EM_IRC_DONOT,			// do not correct
	NET_EM_IRC_DOIT,			// do correct
	NET_EM_IRC_AUTO,			// auto correct
} NET_EM_IRC_TYPE;


// focus options config of video input
typedef struct tagNET_VIDEOIN_FOCUSVALUE_INFO
{
	DWORD							dwSize;
	NET_EM_CONFIG_TYPE				emCfgType;				// config type, you need set the value wether set or get config
	NET_EM_SENSITIVITY_TYPE			emSensitivity;			// Sensitivity
	NET_EM_IRC_TYPE					emIRCorrection;			// IR correction
	NET_EM_FOCUS_LIMITSELECT_MODE	emFocusLimitSelectMode;	// focus limit select mode
	int								nFocusLimit;			// the value of focus limit
	BOOL							bAutoFocusTrace;		// auto focus trace
} NET_VIDEOIN_FOCUSVALUE_INFO;


// sharpness config of video input
typedef struct tagNET_VIDEOIN_SHARPNESS_INFO
{
	DWORD							dwSize;
	NET_EM_CONFIG_TYPE				emCfgType;					// config type, you need set the value wether set or get config
	NET_EM_SHARPNESS_MODE			emSharpnessMode;			// sharpness type
	int								nSharpness;					// value of sharpness(0-100)
	int								nLevel;						// sharpness inhibition level
} NET_VIDEOIN_SHARPNESS_INFO;

// 3D denoise type
typedef enum tagNET_EM_3D_TYPE
{
	NET_EM_3D_UNKONW,		// unknow
	NET_EM_3D_OFF,			// off
	NET_EM_3D_AUTO,			// auto
} NET_EM_3D_TYPE;

// algorithm denoise type
typedef enum tagNET_EM_ALGORITHM_TYPE
{
	NET_EM_ALGORITHM_UNKNOW,		// unknow
	NET_EM_ALGORITHM_OFF,			// off
	NET_EM_ALGORITHM_MANUAL,		// manual
}NET_EM_ALGORITHM_TYPE;

// algorithm denoise config of video input
typedef struct tagNET_DENOISE_ALGORITHM
{
	NET_EM_ALGORITHM_TYPE	emAlgorithmType;		// algorithm denoise type
	int						nTnfLevel;				// time domain level
	int						nSnfLevel;				// space domain level
	BYTE					bReserved[256];			// reserved bytes
} NET_DENOISE_ALGORITHM;

// comm denoise config of video input
typedef struct tagNET_VIDEOIN_DENOISE_INFO
{
	DWORD							dwSize;
	NET_EM_CONFIG_TYPE				emCfgType;					// config type, you need set the value wether set or get config
	BOOL							b2DEnable;					// 2D denoise enable
	int								n2DLevel;					// 2D denoise level(0-100), valid when b2DEnable==TRUE
	NET_DENOISE_ALGORITHM			stuAlgorithm;				// algorithm denoise options
} NET_VIDEOIN_DENOISE_INFO;

// 3D denoise config of video input
typedef struct tagNET_VIDEOIN_3D_DENOISE_INFO
{
	DWORD							dwSize;
	NET_EM_CONFIG_TYPE				emCfgType;					// config type, you need set the value wether set or get config
	NET_EM_3D_TYPE					em3DType;					// 3D denoise type
	int								nAutoLevel;					// 3D denoise type, valid when em3DType==NET_EM_3D_AUTO
} NET_VIDEOIN_3D_DENOISE_INFO;

// Prior foucus mode
typedef struct tagNET_PRIOR_FOCUSMODE_INFO
{
	unsigned int					nPriorFocusMode;			// Prior foucus mode, 0: close shot 1:prospect
	BYTE							byReserved[256];			// Reserved bytes
}NET_PRIOR_FOCUSMODE_INFO;

// foucus on extended configuration NET_EM_CFG_VIDEOIN_FOCUSEX
typedef struct tagNET_VIDEOIN_FOCUS_INFO_EX
{
	DWORD							dwSize;											// struct size
	int								nPriorFocusModeNum;								// Number of priority focusing modes
	NET_PRIOR_FOCUSMODE_INFO		stuPriorFocusMode[8];							// Priority focus mode
}NET_VIDEOIN_FOCUS_INFO_EX;

// near light
typedef struct tagNET_NEAR_LIGHT
{
    int                 nLight;                     // Lighting Brightness Percentage, 0 Turn Off (1-100) Lighting Brightness Percentage
    int                 nAngle;                     // Normalized value of laser lamp angle, 0-100
    BYTE                byReserved[128];            // Reserved    
}NET_NEAR_LIGHT;

// middle light
typedef struct tagNET_MIDDLE_LIGHT
{
    BOOL                bEnable;                    // Enable
    int                 nLight;                     // Lighting Brightness Percentage, 0 Turn Off (1-100) Lighting Brightness Percentage
    int                 nAngle;                     // Normalized value of laser lamp angle, 0-100
    BYTE                byReserved[132];            // Reserved         
}NET_MIDDLE_LIGHT;

// far light
typedef struct tagNET_FAR_LIGHT
{
    int                 nLight;                     // Lighting Brightness Percentage, 0 Turn Off (1-100) Lighting Brightness Percentage
    int                 nAngle;                     // Normalized value of laser lamp angle, 0-100
    BYTE                byReserved[128];            // Reserved
}NET_FAR_LIGHT;

// Extension of supplementary lamp configuration(NET_EM_CFG_VIDEOIN_LIGHTINGEX)
typedef enum tagNET_EM_CONFIGEX_TYPE
{
    NET_EM_CONFIGEX_REALTIME,			// Real time
    NET_EM_CONFIGEX_DAYTIME,			// Day
    NET_EM_CONFIGEX_NIGHT,			    // Night
    NET_EM_CONFIGEX_NORMAL,			    // Normal
} NET_EM_CONFIGEX_TYPE;
typedef struct tagNET_VIDEOIN_LIGHTINGEX_INFO
{
    DWORD				dwSize;
    NET_EM_CONFIGEX_TYPE	emCfgType;  			// Configuration type, set when getting and setting
    NET_EM_LIGHTING_MODE emLightMode;			    // Light Mode
    int                 nCorrection;                // Lighting compensation is effective when the multiplier takes precedence. The range is switched from (0 ~ 4) to (0 ~ 100). There are two ranges, and there is no ability to distinguish them. Suggested use (0 ~ 100)
    int                 nSensitive;                 // Lighting sensitivity, multiplier priority, valid, range 0-5, default 3
    int                 nTimes;                     // Supplementary lights turn on time, automatic mode is effective, unit: seconds (face brake requirements)
    int                 nNearLight;                 // The number of near lighting
    int                 nMiddleLight;               // The number of middle lighting
    int                 nFarLight;                  // The number of far lighting
    BYTE                byReserved[4];              // Reserved byte for alignment
    NET_NEAR_LIGHT      stuNearLight[4];            // near lighting
    NET_MIDDLE_LIGHT    stuMiddleLight[4];          // middle lighting
    NET_FAR_LIGHT       stuFarLight[4];             // far lighting
}NET_VIDEOIN_LIGHTINGEX_INFO;

// snap mode config
typedef struct tagNET_SNAP_MODE
{
    DWORD                           dwSize;
    int                             nMode;                      // 0:AUTO,1:manual operation,2:close
    BOOL                            bDirectStorageMode;         // TRUE Open. FALSE Close
}NET_SNAP_MODE;

// burn CD coding plan, each channel a configuration(include picinpic channel)
typedef struct tagNET_ENCODE_PLAN_INFO
{
	DWORD				dwSize;
	BOOL                bEnable;                        // the channel is able or not,FALSE:without this channel,TRUE:this channel is available
	unsigned int        nExpectTime;                    // the business forecast time,int(s)
	CAPTURE_SIZE		emResolution;                   // video resolution
	unsigned int        nBitRate;                       // vide bit rate(kbps)
	unsigned int		nPacketSize;					// packet size of a single burning file(KB)
}NET_ENCODE_PLAN_INFO;

// compose channel config(NET_EM_CFG_COMPOSE_CHANNEL)
typedef struct tagNET_COMPOSE_CHANNEL_INFO
{
	DWORD				dwSize;
	DH_SPLIT_MODE		emSplitMode;			// Split mode
	int					nChannelCombination[CFG_MAX_VIDEO_CHANNEL_NUM]; // Each child window display content  in segmentation mode 
	int					nChannelCount;			// Split Window Number 
} NET_COMPOSE_CHANNEL_INFO;

// YueQing External lighting configuration(NET_EM_CFG_YUEQING_SUPPLYLIGHTING)
typedef struct tagNET_YUEQING_SUPPLYLIGHTING_INFO
{
	DWORD				dwSize;
	BOOL				bTimeEnable;					// Time   Enable(Give up use)
	BOOL				bManualEnable;					// Manual Enable true:Open lights false:Close lights
	unsigned int		nPreferentialMode;				// mode of lights 0:Sensitivity 1: manual control 2Timing control	
	unsigned int		nBrightness;					// The Brightness of the lamp[1~255]
	DH_TSECT			stuTimeSection[DH_TSCHE_DAY_NUM][DH_TSCHE_SEC_NUM];	// time schedule
}NET_YUEQING_SUPPLYLIGHTING_INFO;

// Get information list input parameters(CLIENT_ScenicSpotGetPointInfos) 
typedef struct tagNET_IN_SCENICSPOT_GETPOINTINFOS_INFO
{
	DWORD				dwSize;
	int					nChannelID;						// Channel number
	int					nOffset;						// start form the first fewmax 255
	int					nLimit;							// Get the first structurebegin 0
}NET_IN_SCENICSPOT_GETPOINTINFOS_INFO;

// the data of master-slave points
typedef struct tagNET_POINT_INFO
{
	DH_POINT	stuMasterPoint;		// the points of master, 8192 coordinate system
	DH_POINT	stuSlavePoint;		// the points of slave
	BYTE    byReserved[256];	// reserved bytes
}NET_POINT_INFO;

typedef struct
{
    int                nHorizontalAngle;               // Horizontal Angle 
    int                nVerticalAngle;                 // Vertical Angle
    int                nMagnification;                 // Magnification
} POSTION;

typedef struct tagNET_POSTIONF
{
	float                fHorizontalAngle;               // Horizontal Angle [-1,1]
	float                fVerticalAngle;                 // Vertical Angle [-1,1]
	float                fMagnification;                 // Magnification [-1,1]
} NET_POSTIONF;

typedef struct tagNET_POINT_PAIR_EX
{
	int					nCaliSceneID;           // The serial number of the scene can be calibrated, and the panoramic image can be divided into several scenes
	PTZ_SPACE_UNIT		stuSlaveCenter;			// Calibration of the first goal, the ball machine and the first scenne to the scene to approximate the location of the ball at the center coordinates
	NET_POINT_INFO		stuPoint[16];			// After the scene fixed ball machine, record the corresponding relationship of the two pixels pixel coordinates
	int					nEffectiveNumber;		// stuPoint Effective number
	float				fMasterZoom;			// Master zoom, Range [0,1]
	BYTE                byReserved[252];		// reserved bytes
} NET_POINT_PAIR_EX;

// Calibration value of master slave tracker
typedef struct tagNET_CALIBRATE_MATRIX_ELEMENT_EX
{
	char                szMasterSN[48];							// Group slave device serial number
    char                szSlaveSN[48];							// Device serial number
	PTZ_SPACE_UNIT		stuExpectRatio;							// Desired magnification(optional)
	NET_POINT_PAIR_EX	stuPointPairEx[8];						// Multi target tracking
	int					nEffectiveNumber;						// stuPointPairEx Effective number
	BYTE                byReserved[256];						// byReserved
} NET_CALIBRATE_MATRIX_ELEMENT_EX;

// The calibration matrix extension configuration of master-slave Multi purpose use(Corresponding NET_EM_CFG_CALIBRATE_MATRIX command)
typedef struct tagNET_MULTI_SENSOR_INFO
{	
	DWORD							 dwSize;
    DWORD							 nMaxCalibElement;			// the max counts of master-slave tracking mark matrix config
	DWORD							 nRetCalibElement;			// the counts of effective master-slave tracking mark matrix config
	NET_CALIBRATE_MATRIX_ELEMENT_EX	*pstCaliMatrixElementEx;	// memory by user
} NET_MULTI_SENSOR_INFO;

// Calibration modes
typedef enum tagNET_EM_CALIBRATION_MODES
{
	NET_EM_CALIBRATION_MODES_UNKNOWN,							// Unknown
	NET_EM_CALIBRATION_MODES_AUTO,								// Automatic
	NET_EM_CALIBRATION_MODES_MANUAL,							// Manual
	NET_EM_CALIBRATION_MODES_SEMIAUTO,							// Semi-automatic
	NET_EM_CALIBRATION_MODES_CLIENTAUTO							// Client automatic
}NET_EM_CALIBRATION_MODES;

// Calibrate matrix multi-mode
typedef struct tagNET_CALIBRATE_MATRIX_ELEMENT_MULTIMODE
{
	NET_EM_CALIBRATION_MODES	emMode;							// Current in effect mode, support for multi-mode calibrate camera
	char                szMasterSN[48];							// Group slave device serial number
	char                szSlaveSN[48];							// Device serial number
	PTZ_SPACE_UNIT		stuExpectRatio;							// Desired magnification(optional)
	NET_POINT_PAIR_EX	stuPointPairEx[8];						// Multi target tracking
	int					nPointPairNumber;						// stuPointPairEx Effective number
	NET_POINT_PAIR_EX	stuAutoPointPairEx[8];					//  Multi target tracking by automatic calculation
	int					nAutoPointPairNumber;					// stuAutoPointPairEx Effective number
	BYTE                byReserved[512];						// Reserved
} NET_CALIBRATE_MATRIX_ELEMENT_MULTIMODE;

// The calibration matrix extension configuration of master-slave Multi mode(Corresponding NET_EM_CFG_STEREO_CALIBRATEMATRIX_MULTIMODE)
typedef struct tagNET_CALIBRATEMATRIX_MULTIMODE_INFO
{
	DWORD									dwSize;
    DWORD									nMaxCalibElement;			// the max counts of master-slave tracking mark matrix config
	DWORD									nRetCalibElement;			// the counts of effective master-slave tracking mark matrix config
	NET_CALIBRATE_MATRIX_ELEMENT_MULTIMODE	*pstCaliMatrixElementEx;	// memory by user		  
} NET_CALIBRATEMATRIX_MULTIMODE_INFO;

// Timing snap configuration of intelligent aquaculture
typedef struct tagNET_CFG_AUTO_SNAP_SCHEDULE_INFO
{
    DWORD           dwSize;                 // Struct size
    BOOL            bEnable;                // Is it possible to capture pictures
    UINT            nChannelNum;            // Channel count
    int             arnChannelID[2];        // Channel ID
    UINT            nPeriod;                // Capture cycle, unit:second
} NET_CFG_AUTO_SNAP_SCHEDULE_INFO;

#define MAX_STAFF_COUNT		32		// max count of staff

// info of staff
typedef struct tagNET_MAP_STAFF_INFOO
{
	NET_POINT	stuStartPoint;		// strat point
	NET_POINT	stuEndPoint;		// end point
	double		dbLength;			// actual length, unit:meter
	BYTE        byReserved[256];	// byReserved
} NET_MAP_STAFF_INFO;

// config of the calibrate of crowddistri map
typedef struct tagNET_CROWDDISTRIMAP_CALIBRATE_INFO
{
	DWORD							dwSize;							// the size of this struct
	int								nStaffNum;						// count of staff
	NET_MAP_STAFF_INFO				stuStaffInfo[MAX_STAFF_COUNT];	// info of staff
} NET_CROWDDISTRIMAP_CALIBRATE_INFO;

// Period information
typedef struct tagNET_TIME_SECTION 
{
	BOOL				bEnable;			// Enable 0:time period is invalid  1:time period effective 
	int					nBeginHour;			// Begin Hour
	int					nBeginMin;			// Begin Min
	int					nBeginSec;			// Begin Sec
	int					nEndHour;			// End   Hour
	int					nEndMin;			// End	 Min 
	int					nEndSec;			// End   Sec
	BYTE				byReserved[80];		// Reserved bytes
} NET_TIME_SECTION;

// Week starting from Monday, the first two elements of a single Shuang 1 dan 2
typedef struct tagNET_NOPASSING_TIMESECTION_INFO
{
	int						nLimitedNum;											// Limit Number
	int						nPlateTailNum[MAX_PLATE_TAILNUM];						// Limit the number of the license plate(the default is the last one, if the letter is the last second, and so on)
	char					szLegalPlateHead[MAX_COMMON_STRING_8];					// The first character and initials of the legal license plate need to be snapped. The Chinese encoding format is UTF8;for empty representation, it does not catch the local word rule.
	NET_TIME_SECTION		stuTimeSection;											// Capture time period
	BYTE					byReserved[256];										// Reserved bytes
}NET_NOPASSING_TIMESECTION_INFO;

//Event type EVENT_IVS_TRAFFIC_NOPASSING configuration
typedef struct tagNET_TRAFFIC_NOPASSING_INFO
{
	DWORD									dwSize;													// struct size
	BOOL									bEnable;												// Time configuration enabling
	int										nLaneNumber;											// Lane Number
	int										nTimeSectionMode;										// Line limiting mode 0-week 1-odd
	int										nNoPassingTimeNumRow;									// No Number of days
	int										nNoPassingTimeNumCol;									// No Passing Time Section Number
	NET_NOPASSING_TIMESECTION_INFO			stuNoPassingTimeSection[DH_N_WEEKS][DH_N_REC_TSECT];	// Disabling time information configuration
}NET_TRAFFIC_NOPASSING_INFO;

// calibrate area info.
typedef struct tagNET_CALIBRATE_AREA_INFO
{
    int         nCalibratePloygonAreaNum;                                       // number of calibrate ploygon area
    DH_POINT	stuCalibratePloygonArea[MAX_CALIBRATE_PLOYGON_AREA_NUM];		// calibrate ploygon area
    int         nCalibrateRectNum;                                              // number of calibrate rect
    NET_RECT    stuCalibrateRects[MAX_CALIBRATE_RECT_NUM];                      // calibrate rect, it should be in calibrate ploygon area  
    BYTE        byReserved[256];	                                            // reserved
} NET_CALIBRATE_AREA_INFO;

// scene info.
typedef struct tagNET_SCENE_INFO
{
    int								nSceneID;						            // scene ID, single scene is 0, multi-scene is 0~N
    NET_CALIBRATE_AREA_INFO		    stuCalibrateAreaInfo;	                    // calibrate area info.
    BYTE                            byReserved[256];                            // reserved
} NET_SCENE_INFO;

// fight calibrate config
typedef struct tagNET_FIGHT_CALIBRATE_INFO
{
    DWORD							dwSize;							            // struct size
    int								nSceneNum;						            // scene num
    NET_SCENE_INFO	                stuScenes[MAX_SCENE_NUM];	                // scene info.
} NET_FIGHT_CALIBRATE_INFO;

typedef struct
{								
    int                nX;								// X coordinate(0~8191) 
    int                nY;								// Y coordinate(0~8191) 
} POINTCOORDINATE;											

// Shape type
typedef enum tagNET_EM_SHAPE_TYPE
{
	NET_EM_SHAPE_TYPE_UNKNOWN = -1,				// Unknown
	NET_EM_SHAPE_TYPE_MANSARD,					// Mansard
	NET_EM_SHAPE_TYPE_SECTOR,					// Sector
}NET_EM_SHAPE_TYPE;

typedef struct
{

	int					nIndex;											// information point number
	bool				bEnable;										// whether the information is effective
	bool				bTitleAttribute;								// Is there a child heading for this information pingt
	POSTION				stuPostion;										// tilt direction and magnificationHorizontal Angle 0~360, Vertical Angle -1800~1800, Magnification0~127
	POINTCOORDINATE		stuPoint;										// scenery position
	char				szTitleName[MAX_COMMON_STRING_64];				// Primary title
	BYTE				byTitleType;									// Level header name type
	BYTE				byReserved[3];									// Reserved
	NET_EM_SHAPE_TYPE	emShapeType;									// Shape type
	DH_POINT		    stuPolygon[DH_MAX_POLYGON_NUM];					// polygon,Each of the points represents the contour vertex coordinate.
	int					nRetPolygonPointNum;							// return polygon point num
	BYTE                byReserved1[184];								// reserved bytes
}POINTINFOS;

// Get information list output parameters(CLIENT_ScenicSpotGetPointInfos)
typedef struct tagNET_OUT_SCENICSPOT_GETPOINTINFOS_INFO
{
	DWORD				dwSize;
	int					nTotal;													// how many points of view
	int					nRetSceneNum;										    // Actual access to number
	POINTINFOS			stuPointInfos[MAX_SCENICSPOT_POINTS_NUM];				// The array length is equal to limit and the last set of queries may be less than limit		
}NET_OUT_SCENICSPOT_GETPOINTINFOS_INFO;

// set the scene, the original number will be covered input parameters (CLIENT_ScenicSpotSetPointInfo)
typedef struct tagNET_IN_SCENICSPOT_SETPOINTINFO_INFO
{
	DWORD				dwSize;
	int					nChannel;										// Channel
	int					nIndex;											// information point number
	bool				bEnable;										// whether the information is effective
	bool				bTitleAttribute;								// Is there a child heading for this information pingt
	POSTION				stuPosition;									// tilt direction and magnification
	POINTCOORDINATE		stuPoint;										// scenery position
	char				szTitleName[MAX_COMMON_STRING_64];				// Primary title
	BYTE				byTitleType;									// Level header name type
	BYTE				byReserved[3];									// Reserved
	NET_EM_SHAPE_TYPE   emShapeType;									// Shape type
	DH_POINT		    stuPolygon[DH_MAX_POLYGON_NUM];					// polygon,Each of the points represents the contour vertex coordinate.
	int					nPolygonPointNum;								// polygon point num,No more than DH_MAX_POLYGON_NUM
}NET_IN_SCENICSPOT_SETPOINTINFO_INFO;

// set the scene, the original number will be covered output parameters (CLIENT_ScenicSpotSetPointInfo)
typedef struct tagNET_OUT_SCENICSPOT_SETPOINTINFO_INFO
{
	DWORD				dwSize;
}NET_OUT_SCENICSPOT_SETPOINTINFO_INFO;

// Get the ability to support the scene points(CLIENT_ScenicSpotGetCaps input parameter) 
typedef struct tagNET_IN_SCENICSPOT_GETCAPS_INFO
{
	DWORD				dwSize;
	int					nChannel;					// channel number
}NET_IN_SCENICSPOT_GETCAPS_INFO;

// Capability Set
typedef struct tagNET_SCENICSPOT_CAPS_INFO
{
	BOOL						bEnable;			// Do you support feature points
	unsigned int				nTotalNum;			// How many poiints of view are supported at most
	unsigned int				nRegionNum;			// How many scene points does a single picture
	BYTE                		byReserved[256];	// reserved bytes
}NET_SCENICSPOT_CAPS_INFO;

// Get the ability to support the scene points(CLIENT_ScenicSpotGetCaps output parameter)
typedef struct tagNET_OUT_SCENICSPOT_GETCAPS_INFO
{
	DWORD						dwSize;
	NET_SCENICSPOT_CAPS_INFO	stuCaps;			// Capability Set information
}NET_OUT_SCENICSPOT_GETCAPS_INFO;

// Focus on the point of view,three dimensional positioning input param(corresponding to CLIENT_ScenicSpotTurnToPoint) 
typedef struct tagNET_IN_SCENICSPOT_TURNTOPOINT_INFO
{
	DWORD						dwSize;
	int							nChannel;			// Channel
	int							nIndex;				// Scenic spot index
}NET_IN_SCENICSPOT_TURNTOPOINT_INFO;

// Focus on the point of view,three dimensional positioning output param(corresponding to CLIENT_ScenicSpotTurnToPoint) 
typedef struct tagNET_OUT_SCENICSPOT_TURNTOPOINT_INFO
{
	DWORD						dwSize;
}NET_OUT_SCENICSPOT_TURNTOPOINT_INFO;

// sound effect type of alarm
typedef enum tagEM_ALARM_SOUND_EFFECT
{
    EM_ALARM_SOUND_EFFECT_UNKNOWN,                      // unknown effect
    EM_ALARM_SOUND_EFFECT_MUTE,                         // mute
    EM_ALARM_SOUND_EFFECT_NOTICE,                       // notice sound
    EM_ALARM_SOUND_EFFECT_ALERT,                        // alert sound
}EM_ALARM_SOUND_EFFECT;

// alarm sound config of device
typedef struct tagNET_ALARM_SOUND_INFO
{
    DWORD				dwSize;
    EM_ALARM_SOUND_EFFECT emSoundEffect;                // sound effect
}NET_ALARM_SOUND_INFO;

// stereo calibrate config
typedef struct tagNET_STEREO_CALIBRATE_INFO
{
	DWORD				dwSize;
	int					nCameraHeight;					// last saved calibrate heightunit: cm
	float				fCameraAngle;					// last saved calibrate angle unit: angle
} NET_STEREO_CALIBRATE_INFO;
// network connection mode
typedef enum tagEM_LINK_MODE
{
    EM_LINK_MODE_UNKNOWN,                                       // unknown mode
    EM_LINK_MODE_AUTO,                                          // auto select 
    EM_LINK_MODE_ADHOC,                                         // ADHOC
    EM_LINK_MODE_INFRASTRUCTURE,                                // infrastructure
}EM_LINK_MODE;

// Access point encryption mode
typedef enum tagEM_AP_DATA_ENCRYPT
{
    EM_AP_DATA_ENCRYPT_UNKNOWN,                           // UnKnown
    EM_AP_DATA_ENCRYPT_NONE,                              // NONE
    EM_AP_DATA_ENCRYPT_AUTO,                              // AUTO
    EM_AP_DATA_ENCRYPT_SHARED,                            // SHARED
    EM_AP_DATA_ENCRYPT_OPEN,                              // OPEN
    EM_AP_DATA_ENCRYPT_TKIP,                              // TKIP
    EM_AP_DATA_ENCRYPT_AES,                               // AES
} EM_AP_DATA_ENCRYPT;

// power mode
typedef enum tagEM_AP_POWER_MODE
{
    EM_AP_POWER_MODE_UNKNOWN,                             // UnKnown
    EM_AP_POWER_MODE_LOW,                                 // Low
    EM_AP_POWER_MODE_MIDDLE,                              // Middle
    EM_AP_POWER_MODE_HIGH,                                // High
}EM_AP_POWER_MODE;

// DHCP INFO
typedef struct tagNET_DHCP_INFO
{
    char                    szStartIP[NET_IPADDRSTR_LEN];       // start IP
    char                    szStopIP[NET_IPADDRSTR_LEN];        // stop IP
    int                     nLeaseTime;                         // Renewal time unit:minute
    BYTE                    byReserved[512];                    // reserved bytes
}NET_DHCP_INFO;

// WEP info
typedef struct tagNET_WEP_INFO
{
    int                     nKeyID;                             // key index :0~3
    char                    szKeys[MAX_WEP_KEY_NUM][MAX_COMMON_STRING_64];// keys array
    BYTE                    byReserved[256];                    // reserved bytes
}NET_WEP_INFO;


// WPA/WPA2 PSK info
typedef struct tagNET_WPA_PSK_INFO
{
    char                    szPassword[MAX_COMMON_STRING_64];  // password
    BYTE                    byReserved[256];                   // reserved bytes
}NET_WPA_PSK_INFO;

// EAP method
typedef enum tagEM_EAP_METHOD
{
    EM_EAP_METHOD_UNKNOWN,                                      // UnKnown
    EM_EAP_METHOD_PEAP,                                         // PEAP
    EM_EAP_METHOD_TLS,                                          // TLS
    EM_EAP_METHOD_TTLS,                                         // TTLS
} EM_EAP_METHOD;

// EAP authentication method
typedef enum tagEM_EAP_AUTH_TYPE
{
    EM_EAP_AUTH_TYPE_UNKNOWN,                                   // UnKnown
    EM_EAP_AUTH_TYPE_NONE,                                      // NONE
    EM_EAP_AUTH_TYPE_PAP,                                       // PAP
    EM_EAP_AUTH_TYPE_MSCHAP,                                    // MSCHAP
    EM_EAP_AUTH_TYPE_MSCHAPV2,                                  // MSCHAPV2
    EM_EAP_AUTH_TYPE_GTC,                                       // GTC
} EM_EAP_AUTH_TYPE;

// Acess point authentication method
typedef enum tagEM_AP_AUTHENTICATION
{
    EM_AP_AUTHENTICATION_UNKNOWN,                         // UnKnown
    EM_AP_AUTHENTICATION_OPEN,                            // OPEN
    EM_AP_AUTHENTICATION_WEP,                             // WEP
    EM_AP_AUTHENTICATION_WPAPSK,                          // WPA PSK
    EM_AP_AUTHENTICATION_WPA2PSK,                         // WPA2 PSK
    EM_AP_AUTHENTICATION_WPA,                             // WPA
    EM_AP_AUTHENTICATION_WPA2,                            // WPA2
} EM_AP_AUTHENTICATION;

// WPA/WPA2 info 
typedef struct tagNET_EAP_INFO
{
    EM_EAP_METHOD           emMethod;                           // EAP method
    EM_EAP_AUTH_TYPE        emAuthType;                         // EAP  authentication method
    char                    szIdentity[MAX_COMMON_STRING_64];   // identify
    char                    szAnonymousID[MAX_COMMON_STRING_64];// anonymousID
    char                    szPassword[MAX_COMMON_STRING_64];   // password
    char                    szCaCert[MAX_COMMON_STRING_512];    // CA certificate
    char                    szUserCert[MAX_COMMON_STRING_512];  // user  certificate
    BYTE                    byReserved[256];                    // reserved bytes
}NET_EAP_INFO;

// WIFI connection mode
typedef enum tagEM_WIFI_CONNECT_TYPE
{
    EM_WIFI_CONNECT_TYPE_UNKNOWN,                               // unknown
    EM_WIFI_CONNECT_TYPE_PUSH_BUTTON,                           // push button mode
    EM_WIFI_CONNECT_TYPE_PIN_ENROLLEE,                          // PINEnrollee mode
    EM_WIFI_CONNECT_TYPE_PIN_REG,                               // PIN REG mode ,not supported now
}EM_WIFI_CONNECT_TYPE;

// WIFI security configuration
typedef struct tagNET_WPS_INFO
{
    EM_WIFI_CONNECT_TYPE   emConnType;                          // connection mode
    char                   szPIN[MAX_COMMON_STRING_32];         // PIN code, supported in PINEnrollee mode
    BYTE                   byReserved[256];                     // reserved bytes
}NET_WPS_INFO;

// filter address list
typedef struct tagNET_FILTER_ADDRESS_LIST
{
    BOOL                    bEffective;                         // whether effective:true yes,false no
    char                    szMAC[DH_MACADDR_LEN];              // device mac address
    char                    szDescribeText[DH_COMMON_STRING_256]; // A detailed description of the MAC address  
    BYTE                    byReserved[256];                    // reserved bytes
}NET_FILTER_ADDRESS_LIST;

//the fitering policy of address list
typedef enum tagEM_ADDRLIST_FILTER_POLICY
{
    EM_ADDRLIST_FILTER_POLICY_UNKNOWN,                          // unknown
    EM_ADDRLIST_FILTER_POLICY_WHITE,                            // "white":list of valid address device connections
    EM_ADDRLIST_FILTER_POLICY_BLACK,                            // "black":list of valid address device connections in the forbidden list 
}EM_ADDRLIST_FILTER_POLICY;

// AccessPoint access fiter configuration
typedef struct tagNET_AP_FILTER
{
    BOOL                    bEnable;                            // enable ture:yes false:no
    int                     nMaxAccessNum;                      // maximum number of WIFI device connections
    EM_ADDRLIST_FILTER_POLICY emPolicy;                         // filter policy
    NET_FILTER_ADDRESS_LIST *pstuAddrList;                      // address filter list ,new/delete by user            
    int                     nMaxListNum;                        // the max of address number
    int                     nRetListNum;                        // return address number
    BYTE                    byReserved[256];                    // reserved bytes
}NET_AP_FILTER;

//Accesspoint work pattern type
typedef enum tagEM_WORKPATTERN
{
    EM_WORKPATTERN_UNKNOWN,                          // unknown
    EM_WORKPATTERN_2_4G,                             // 2.4G default
    EM_WORKPATTERN_5G,                               // 5G
}EM_WORKPATTERN;

// Accesspoint work pattern
typedef struct tagNET_AP_WORKPATTERN
{
    EM_WORKPATTERN          emWorkPatternType;                  // work pattern type:2.4G/5G
    BOOL                    bEnable;                            // WIFI enable switch: TRUE(enable), FALSE(disable)
    BOOL                    bHideSSID;                          // hide SSID,TRUE(yes),FALSE(no)
    char                    szSSID[DH_COMMON_STRING_36];        // SSID
    EM_LINK_MODE            emLinkMode;                         // link mode
    int                     nPriority;                          // priority(1-32)
    int                     nChannel;                           // channel(1-13)
    int                     nChannelBandwidth;                  // channel bandwidth,unit:M
    EM_AP_AUTHENTICATION    emAuthentication;                   // authentication
    EM_AP_DATA_ENCRYPT      emDataEncryption;                   // data encryption method
    EM_AP_POWER_MODE        emPowerMode;                        // power mode
    BOOL                    bDHCPEnable;                        // DHCP enable
    NET_DHCP_INFO           stuDHCP;                            // DHCP info
    char                    szIPAddresss[NET_IPADDRSTR_LEN];    // IP address
    char                    szSubnetMask[MAX_COMMON_STRING_16]; // subnetmask
    char                    szDefaultGateway[MAX_COMMON_STRING_16]; // default gateway
    NET_WEP_INFO            stuWEP;                             // WEP info
    NET_WPA_PSK_INFO        stuWPAPSK;                          // WPA/WPA2 PSK info
    NET_EAP_INFO            stuEAP;                             // WPA/WPA2 info
    NET_WPS_INFO            stuWPS;                             // WPS info
    NET_AP_FILTER           stuFilter;                          // access filter info
    BYTE                    byReserved[1024];                   // reserved bytes
}NET_AP_WORKPATTERN;

// Access Point name
typedef enum tagEM_ACCESSPOINT_NAME
{
    EM_ACCESSPOINT_NAME_UNKNOWN,                          // "Unknown"
    EM_ACCESSPOINT_NAME_ETH2,                             // "eth2" 
    EM_ACCESSPOINT_NAME_WALN0,                            // "wlan0" 
    EM_ACCESSPOINT_NAME_APRA0,                            // "apra0" 
}EM_ACCESSPOINT_NAME;

// AccessPoint info
typedef struct tagNET_ACCESSPOINT_INFO
{
    EM_ACCESSPOINT_NAME     emAccessPointName;                  // access point name    
    int                     nValidPatternNum;                   // valid pattern number
    NET_AP_WORKPATTERN      stuWorkPattern[MAX_WORKPATTERN_NUM];// work pattern configuration:2.4G(default)/5G
    BYTE                    byReserved[1024];                   // reserved bytes
}NET_ACCESSPOINT_INFO;

// WIFI server configuration(access point)
typedef struct tagNET_NETAPP_ACCESSPOINT
{
    DWORD                   dwSize;
    int                     nValidAPNum;                        // AccessPoints number
    NET_ACCESSPOINT_INFO    stuAccessPoints[NET_MAX_AP_NUM];    // Accesspoint info 
}NET_NETAPP_ACCESSPOINT;

//disorder window type
typedef enum tagEM_DISORDERWINDOW_TYPE
{
	EM_DISORDERWINDOW_TYPE_UNKNOWN = -1,         //unknown type
	EM_DISORDERWINDOW_TYPE_PACKETS_NUMBER = 0,   //packets number, default
	EM_DISORDERWINDOW_TYPE_DATA_DELAY = 1,       //data delay(ms)
	EM_DISORDERWINDOW_TYPE_MEMORY_SIZE = 2,      //memory size(KB)
}EM_DISORDERWINDOW_TYPE;

// rtsp transit configuration
typedef struct tagNET_CFG_RTSP_TRANSIT
{
	int                      nUdpSndBufSize;    // udp send socket buffer size(unit:KB) default:512 0-use system default value
	int                      nUdpRcvBufSize;    // udp receive socket buffer size(unit:KB),default:512 0-use system default value
	int                      nSliceSize;        // rtp pakcet slice size(unit:byte),default:1472 recommended value: network card mtu-ip head-udp head
	int                      nFlowControlMaxDelay; /* flow control max delay, indicates that the maxinum delay caused by flow control and 
	shaping is not greater than this value , default 400ms */
	int                      nFlowControlCoefficient;/* flow control coefficient, actual effective maxinum delay=MaxDelay* Coefficient/100, the greater the value, 
	the greater the tolerance coefficient.data transmission is even more uniform.value range[0,100], default:50.indicates that close flow control */
	EM_DISORDERWINDOW_TYPE   emDisorderWindowType;   //disorder window type
	int                      nDisorderWindowValue;   // disorder window value, default:100 packets
	BYTE                     byReserved[2048];   //reserved bytes
}NET_CFG_RTSP_TRANSIT;

//retransit type
typedef enum tagEM_RETRANSIT_TYPE
{
	EM_RETRANSIT_TYPE_UNKNOWN = -1,         // unknown retransit type
	EM_RETRANSIT_TYPE_PACKETS_NUMBER = 0,   // packets number,default
	EM_RETRANSIT_TYPE_DATA_DELAY = 1,       //data delay (ms)
}EM_RETRANSIT_TYPE;

// DVRIP transit configuration
typedef struct tagNET_CFG_DVRIP_TRANSIT
{
	int                      nUdpSndBufSize;     // udp send socket buffer size(unit:KB) default:512 0-use system default value
	int                      nMaxSize;           // max pakcet slice size(unit:byte),default:1400 recommended value: network card mtu-ip head-udp head
	int                      nFlowControlMaxDelay; /* flow control max delay, indicates that the maxinum delay caused by flow control and 
	shaping is not greater than this value , default 400ms */
	int                      nFlowControlCoefficient;/* flow control coefficient, actual effective maxinum delay=MaxDelay* Coefficient/100, the greater the value, 
	the greater the tolerance coefficient.data transmission is even more uniform.value range[0,100], default:50.indicates that close flow control */
	EM_RETRANSIT_TYPE        emRetransitType;    // retransit type
	int                      nRetransitValue;    // retransit value
	BYTE                     byReserved[2048];   // reserved bytes
}NET_CFG_DVRIP_TRANSIT;

// GB28181 transit configuration
typedef struct tagNET_CFG_GB28181_TRANSIT
{
	int                      nUdpSndBufSize;     // udp send socket buffer size(unit:KB) default:512 0-use system default value
	int                      nMaxSize;           // max pakcet slice size(unit:byte),default:1400 recommended value: network card mtu-ip head-udp head
	int                      nFlowControlMaxDelay; /* flow control max delay, indicates that the maxinum delay caused by flow control and 
	shaping is not greater than this value , default 400ms */
	int                      nFlowControlCoefficient;/* flow control coefficient, actual effective maxinum delay=MaxDelay* Coefficient/100, the greater the value, 
	the greater the tolerance coefficient.data transmission is even more uniform.value range[0,100], default:50.indicates that close flow control */
	BYTE                     byReserved[2048];  // reserved bytes
}NET_CFG_GB28181_TRANSIT;

// net auto adapt transit , according to NET_EM_CFG_NETAUTOADAPTTRANSIT
typedef struct tagNET_NETAUTOADAPTTRANSIT
{
	DWORD					dwSize;     // struct size
	NET_CFG_RTSP_TRANSIT    stuRtsp;    //RTSP configuration
	NET_CFG_DVRIP_TRANSIT   stuDvrip;   //DVRIP configuration
	NET_CFG_GB28181_TRANSIT stuGB28181; //GB28181 configuration
}NET_NETAUTOADAPTTRANSIT;


// Max Length of DN
#define	MAX_DN_LENGTH	128

// LDAP configuration
typedef struct tagNET_NETAPP_LDAP 
{
	DWORD					dwSize;
	BOOL					bEnable;							// LDAP enable
	char					szServerIP[MAX_SERVER_ADDRESS_LEN];	// Server IP Address
	int						nServerPort;						// Server Port
	char					szBindDN[MAX_DN_LENGTH];			// Bind DN
	char					szBindPwd[MAX_PWD_LEN];				// Bind Password
	BOOL					bAnonymousBind;						// AnonymousBind Enable
	char					szBaseDN[MAX_DN_LENGTH];			// Base DN
	char					szFilter[DH_COMMON_STRING_128];		// filter 
} NET_NETAPP_LDAP;


// facility type
typedef enum tagEM_SYSLOG_FACILITY_TYPE
{
	EM_SYSLOG_FACILITY_UNKNOWN = -1,
	EM_SYSLOG_FACILITY_KERNEL_MESSAGES,								// 0 kernel messages
	EM_SYSLOG_FACILITY_USER_LEVEL_MESSAGES,							// 1 user-level messages
	EM_SYSLOG_FACILITY_MAIL_SYSTEM,									// 2 mail system
	EM_SYSLOG_FACILITY_SYSTEM_DAEMONS,								// 3 system daemons
	EM_SYSLOG_FACILITY_SECURITY_MESSAGES,							// 4 security/authorization messages
	EM_SYSLOG_FACILITY_MESSAGES_GENERATED_INTERNALLY_BY_SYSLOGD,	// 5 messages generated internally by syslogd
	EM_SYSLOG_FACILITY_LINE_PRINTER_SUBSYSTEM,						// 6 line printer subsystem
	EM_SYSLOG_FACILITY_NETWORK_NEWS_SUBSYSTEM,						// 7 network news subsystem
	EM_SYSLOG_FACILITY_UUCP_SUBSYSTEM,								// 8 UUCP subsystem
	EM_SYSLOG_FACILITY_CLOCK_DAEMON,								// 9 clock daemon
	EM_SYSLOG_FACILITY_SECURITY_MESSAGES_2,							// 10 security/authorization messages
	EM_SYSLOG_FACILITY_FTP_DAEMON,									// 11 FTP daemon
	EM_SYSLOG_FACILITY_NTP_SUBSYSTEM,								// 12 NTP subsystem
	EM_SYSLOG_FACILITY_LOG_AUDIT,									// 13 log audit
	EM_SYSLOG_FACILITY_LOG_ALERT,									// 14 log alert
	EM_SYSLOG_FACILITY_CLOCK_DAEMON_2,								// 15 clock daemon
	EM_SYSLOG_FACILITY_LOCAL_USE_0,									// 16 local use 0
	EM_SYSLOG_FACILITY_LOCAL_USE_1,									// 17 local use 1
	EM_SYSLOG_FACILITY_LOCAL_USE_2,									// 18 local use 2
	EM_SYSLOG_FACILITY_LOCAL_USE_3,									// 19 local use 3
	EM_SYSLOG_FACILITY_LOCAL_USE_4,									// 20 local use 4
	EM_SYSLOG_FACILITY_LOCAL_USE_5,									// 21 local use 5
	EM_SYSLOG_FACILITY_LOCAL_USE_6,									// 22 local use 6
	EM_SYSLOG_FACILITY_LOCAL_USE_7,									// 23 local use 7
} EM_SYSLOG_FACILITY_TYPE;

// Syslog configuration
typedef struct tagNET_NETAPP_SYSLOG 
{
	DWORD						dwSize;
	BOOL						bEnable;							// Syslog enable
	char						szServerIP[MAX_SERVER_IP_LEN];		// Server IP Address
	int							nServerPort;						// Server Port
	EM_SYSLOG_FACILITY_TYPE		emFacility;							// facility type 
} NET_NETAPP_SYSLOG;

// APN
typedef enum tagEM_WIRELESS_APN_TYPE
{
	EM_WIRELESS_APN_UNKNOWN = -1,									// 
	EM_WIRELESS_APN_CUSTOMIZED,										// Customized
	EM_WIRELESS_APN_CTNET,											// China Telecom
	EM_WIRELESS_APN_CMNET,											// China Mobile
	EM_WIRELESS_APN_UNINET,											// China Unicom
}EM_WIRELESS_APN_TYPE;

// Authentication mode
typedef enum tagEM_WIRELESS_AUTH_MODE
{
	EM_WIRELESS_AUTH_MODE_UNKNOWN = 0,
	EM_WIRELESS_AUTH_MODE_NO,										// No authentication
	EM_WIRELESS_AUTH_MODE_PAP,										// PAP authentication
	EM_WIRELESS_AUTH_MODE_CHAP,										// CHAP authentication
}EM_WIRELESS_AUTH_MODE;

// Monthly flux control tactics
typedef enum tagEM_WIRELESS_3GFLUX_TACTICS
{
	EM_WIRELESS_3GFLUX_TACTICS_UNKNOWN = 0,
	EM_WIRELESS_3GFLUX_TACTICS_BYFLUX_MONTHLY,								// monthly by flux 
	EM_WIRELESS_3GFLUX_TACTICS_BYTIME_MONTHLY								// monthly by time 
}EM_WIRELESS_3GFLUX_TACTICS;

// Daily flux control tactics
typedef enum tagEM_WIRELESS_DAY3GFLUX_TACTICS
{
	EM_WIRELESS_DAY3GFLUX_TACTICS_UNKNOWN = 0,
	EM_WIRELESS_DAY3GFLUX_TACTICS_BYFLUX,									// by Flux
	EM_WIRELESS_DAY3GFLUX_TACTICS_BYTIME									// by Time
}EM_WIRELESS_DAY3GFLUX_TACTICS;

// Flux limit action
typedef enum tagEM_WIRELESS_3GFLUX_ACTION
{
	EM_WIRELESS_3GFLUX_ACTION_UNKNOWN = 0,
	EM_WIRELESS_3GFLUX_ACTION_NOTHING,										// Nothing
	EM_WIRELESS_3GFLUX_ACTION_3GNETDOWN										// 3G off-line
}EM_WIRELESS_3GFLUX_ACTION;

// work mode
typedef enum tagEM_WIRELESS_WORK_MODE
{
	EM_WIRELESS_WORK_MODE_UNKNOWN = 0,
	EM_WIRELESS_WORK_MODE_CDMA1X,											// CDMA1x
	EM_WIRELESS_WORK_MODE_EVDO,												// EVDO
	EM_WIRELESS_WORK_MODE_TD_SCDMA,											// TD-SCDMA
	EM_WIRELESS_WORK_MODE_WCDMA,											// WCDMA
	EM_WIRELESS_WORK_MODE_EDGE,												// EDGE
	EM_WIRELESS_WORK_MODE_TDD_LTE,											// TDD-LTE
	EM_WIRELESS_WORK_MODE_FDD_LTE,											// FDD-LTE
}EM_WIRELESS_WORK_MODE;

#define	MAX_DAIL_NUMBER	32													// Dail number len 
// wireless configuration
typedef struct tagNET_NETAPP_WIRELESS
{
	DWORD						dwSize;
	BOOL						bEnable;					                // Enable
	int							nIndex;										// The index of module, ReadOnly
	int							nKeepAlive;						            // keep alive time, Unit:s, 0:not actively disconnected 
	EM_WIRELESS_APN_TYPE		emAPN;							            // APN,if it is EM_WIRELESS_APN_CUSTOMIZED, use szAPNName.
	char						szAPNName[DH_COMMON_STRING_32];				// if emAPN is EM_WIRELESS_APN_CUSTOMIZED, use your customized string. for example:"CTNET", "CMNET", "UNINET", "CUSTOMIZED"
	EM_WIRELESS_AUTH_MODE		emAuthMode;									// Authentication mode
	char						szUserName[DH_COMMON_STRING_64];	        // User name
	char						szPassword[DH_COMMON_STRING_64];	        // Password
	BOOL						bAutoDial;									// stuTimeSection enable
	DH_TSECT					stuTimeSection[DH_N_WEEKS][DH_N_REC_TSECT]; // Dialing time section

	EM_WIRELESS_3GFLUX_TACTICS	em3GFluxTactic;								// Flux tactics 
	UINT						n3GFluxUp;									// Flux limit, [0,65535] MB or Minute
	UINT						n3GFlux;									// Actual use, [0,65535] MB or Minute

	EM_WIRELESS_DAY3GFLUX_TACTICS emDay3GFluxTactic;						// Flux tactics daily
	UINT						nDay3GFluxUp;								// The daily flux limit, [0,65535] MB or Minute
	UINT						nDay3GFlux;									// Actual use that day, [0,65535] MB or Minute
	EM_WIRELESS_3GFLUX_ACTION	emDay3GFluxAction;							// Flux limit action

	EM_WIRELESS_WORK_MODE		emWorkMode;									// Work mode
	char						szDailNumber[MAX_DAIL_NUMBER];				// Dail number
	BOOL						bActivate;									// Activated or not
} NET_NETAPP_WIRELESS;

// Railway record config
typedef struct tagNET_DEV_CAR_COACH_INFO
{
    DWORD                   dwSize;                         
    char                    szCarNo[MAX_CARNO_LEN];              // car no
    char                    szCoachNo[MAX_COACHNO_LEN];          // coach no
}NET_DEV_CAR_COACH_INFO;

// Snap format reference;
typedef enum tagEM_MEDIA_GLOBAL_SNAP_FORMAT_AS
{
	EM_MEDIA_GLOBAL_SNAP_FORMAT_AS_UNKNOWN,
	EM_MEDIA_GLOBAL_SNAP_FORMAT_AS_MAIN_FORMAT,                  // refer to main stream
	EM_MEDIA_GLOBAL_SNAP_FORMAT_AS_EXTRA_FORMAT,				 // refer to sub stream1
	EM_MEDIA_GLOBAL_SNAP_FORMAT_AS_EXTRA2_FORMAT,				 // refer to sub stream2
	EM_MEDIA_GLOBAL_SNAP_FORMAT_AS_EXTRA3_FORMAT,				 // refer to sub stream3
}EM_MEDIA_GLOBAL_SNAP_FORMAT_AS;

// Media global config
typedef struct tagNET_MEDIA_GLOBAL_INFO
{
	DWORD               dwSize;
	int                 nPacketType;                          // 0:by time,1:by size
	BYTE                byPacketLength;                       // Record packet time length. unit:minite. 1-255
	BYTE                byAlign[3];                           // align
	DWORD				dwPacketSize;                   	  // Record packet file size. unit:KB
	BOOL				bLogRecord;                           // Is wirte record's log
	BOOL				bLogEncode;                           // Is write abnormal encode's log
	EM_MEDIA_GLOBAL_SNAP_FORMAT_AS  emSnapFormatAs;           // Snap format reference; If device not support set snap format independently, snap format use reference
}NET_MEDIA_GLOBAL_INFO;

// parking Space config(The setting of special parking spaces and ordinary parking spaces), corresponding NET_EM_CFG_PARKINGSPACECELL_STATUS
// Note:the array is maximum 16, actually returns the effective configuration, please check the interface (NET_CONFIG_RETURN_INFO*)reserve parameter
typedef struct tagNET_PARKINGSPACECELL_STATUS_INFO
{
	DWORD				dwSize;	
	int					nCellNumber;			// Parking Space count
	UINT				nCellType;				// parking Space type, -1:invalid,0:ordinary 1:Special 2:charge
} NET_PARKINGSPACECELL_STATUS_INFO;

// Light color of parking space
typedef struct tagNET_PARKINGSPACELIGHT_INFO
{
	int						nRed;					// Red:		-1:invalid, 0/destory, 1/bright, 2/twinkle	
	int						nYellow;				// Yellow:  -1:invalid, 0/destory, 1/bright, 2/twinkle	
	int						nBlue;					// Blue:	-1:invalid, 0/destory, 1/bright, 2/twinkle	
	int						nGreen;					// Green:	-1:invalid, 0/destory, 1/bright, 2/twinkle	
	int						nPurple;				// Purple:	-1:invalid, 0/destory, 1/bright, 2/twinkle	
	int						nWhite;					// White:	-1:invalid, 0/destory, 1/bright, 2/twinkle
	int						nPink;					// Pink:	-1:invalid, 0/destory, 1/bright, 2/twinkle
	BYTE					byReserved[32];			// Reserved
} NET_PARKINGSPACELIGHT_INFO;

// Network abnormal state lamp color
typedef struct tagNET_NETWORK_EXCEPTION_INFO
{
	NET_PARKINGSPACELIGHT_INFO	stNetPortAbortInfo[MAX_NETPORT_NUM];	// Light color of opening state of net mouth
	int							nRetNetPortAbortNum;					// Actual return number
	NET_PARKINGSPACELIGHT_INFO	stuSpaceSpecialInfo;					// Special state lamp color of parking space						
	NET_PARKINGSPACELIGHT_INFO	stuSpaceChargingInfo;					// State lamp color of rechargeable car
	BYTE						byReserved[256];						// Reserved
} NET_NETWORK_EXCEPTION_INFO;

// Parking position corresponding to parking indicator light color, corresponding NET_EM_CFG_PARKINGSPACELIGHT_STATE
typedef struct tagNET_PARKINGSPACELIGHT_STATE_INFO
{
	DWORD								dwSize;
	NET_PARKINGSPACELIGHT_INFO			stuSpaceFreeInfo;			// Parking space idle state lamp color
	NET_PARKINGSPACELIGHT_INFO			stuSpaceFullInfo;			// Light color of parking space occupying full state
	NET_PARKINGSPACELIGHT_INFO			stuSpaceOverLineInfo;		// Light color of pressure line in parking space
	NET_PARKINGSPACELIGHT_INFO			stuSpaceOrderInfo;			// Seat reservation state lamp color
	NET_NETWORK_EXCEPTION_INFO			stuNetWorkExceptionInfo;	// Network abnormal state lamp color
} NET_PARKINGSPACELIGHT_STATE_INFO;

// NAS protocol type
typedef enum __EM_NAS_PROTOCOL
{
	NAS_PROTOCOL_UNKNOW = 0,
	NAS_PROTOCOL_FTP,			// FTP
	NAS_PROTOCOL_SMB,			// SMB
	NAS_PROTOCOL_NFS,			// NFS
	NAS_PROTOCOL_ISCSI,			// ISCSI
	NAS_PROTOCOL_CLOUD,			// CLOUD
}EM_NAS_PROTOCOL;

// NAS config
typedef struct tagNET_NAS_INFO
{
	DWORD               dwSize;
    BOOL                bEnable;									// Enable or not
	char				szName[MAX_COMMON_STRING_128];				// name
    char                szHostIp[DH_MAX_IPADDR_OR_DOMAIN_LEN];		// Host IP
    WORD                wHostPort;                          		// Host port 
	char				reserved[2];								// Reserved
    char                szDirName[DH_FTP_MAX_PATH];         		// FTP path
    char                szUserName[DH_FTP_USERNAME_LEN];    		// User name
    char                szPassword[DH_FTP_PASSWORD_LEN];    		// Password 
    int                 nInterval;                          		// Time interval between two near files.   	
	BOOL				bAnonymity;									// Anonymity enable or not, enable when byProtocol is 0
	EM_NAS_PROTOCOL     emProtocol;									// Protocol	
}NET_NAS_INFO;

// PPPoE config
typedef struct tagNET_PPPOE_INFO
{
	DWORD               dwSize; 
	BOOL				bEnable;								// Enable or not
    char                szUserName[MAX_USER_NAME_LEN];			// User name
	char				szPasswd[MAX_PWD_LEN];					// Password
}NET_PPPOE_INFO;

// Mail config
typedef struct tagNET_EMAIL_INFO
{
	DWORD               dwSize;		
	BOOL                bEnable;											// enable 0:false,    1:true
	char                szMailIPAddr[DH_MAX_DOMAIN_NAME_LEN];				// Mail server address(IP and domain name )   
    WORD                wMailPort;											// Mail server port     
	char				reserved[2];										// Reserved
    char                szSenderAddr[DH_MAX_MAIL_ADDR_LEN];					// From 
    char                szUserName[DH_MAX_MAIL_NAME_LEN];					// User name
    char                szUserPsw[DH_MAX_MAIL_NAME_LEN];					// Password
    char                szDestAddr[DH_MAX_MAIL_ADDR_LEN];					// To
    char                szSubject[DH_MAX_MAIL_SUBJECT_LEN];					// Subject
	char				*szReceivers[DH_MAX_MAIL_ADDR_LEN];					// Receiver list
	unsigned int		nReceiversNum;										// szReceivers num
	unsigned int		nReceiversNumRet;									// szReceivers num return
    BOOL                bSSLEnable;											// SSL enable
	BOOL				bTLSEnable;											// TLS enable
    WORD                wSendInterval;										// Send interval,[0,3600]s
    BYTE                bAnonymous;											// Anonymous Options[0,1], 0:FALSE,1:TRUE.
    BYTE                bAttachEnable;										// Attach Options[0,1], 0:FALSE,1:TRUE..
	BOOL				bHealthReport;										// Health report enable
	int					nHealthReportInterval;								// Health report interval
}NET_EMAIL_INFO;

// DDNS config
typedef struct tagNET_DDNS_INFO
{
	DWORD                dwSize;
    DWORD                dwDdnsServerNum; // DDNS server num
    DH_DDNS_SERVER_CFG   stuDdnsServer[DH_MAX_DDNS_NUM];
}NET_DDNS_INFO;

// Protocols manager config list
typedef struct tagNET_PROTOCOLS_MANAGER
{
	char				szDesc[DH_COMMON_STRING_128];       // Protocol description
	BOOL				bEnable;							// whether enbale or not
	char				szProtocol[DH_COMMON_STRING_128];   // protocol name,for example:DI_SMK
	char				szShowType[DH_COMMON_STRING_128];	// protocol type,for example:SmokingSensor
	BYTE				byReserved[256];					// Reserved
}NET_PROTOCOLS_MANAGER;

// Protocols manager config
typedef struct tagNET_SCADA_PROTOCOLS_MANAGER
{
	DWORD					dwSize;
	NET_PROTOCOLS_MANAGER*	pstProtocolsManager;		     // Protocols manager
	int						nProtocolsManagerNum;		     // num of ProtocolsManager
	int						nRetProtocolsManagerNum;         // Return actual num of ProtocolsManager
															 // When user get all Protocols managers at first,if nRetProtocolsManagerNum is greater than nProtocolsManagerNum,
															 // Then user get all Protocols managers at second,Suggest nProtocolsManagerNum is the same with nRetProtocolsManagerNum(Get by first).
}NET_SCADA_PROTOCOLS_MANAGER;

// device info config list
typedef struct tagNET_DEVICEIDSETS
{
	char			  szDevName[DH_COMMON_STRING_32];		// Device name
	char			  szDevType[DH_COMMON_STRING_32];		// Device type
	char			  szNewDeviceId[DH_COMMON_STRING_32];   // New device id config by user,the actual size of szNewDeviceId is the same as szOldDeviceId
	char			  szOldDeviceId[DH_COMMON_STRING_32];	// Default device id
	BYTE			  byReserved[128];						// Reserved
}NET_DEVICEIDSETS;

// device info config
typedef struct tagNET_SCADA_DEVICEINFO_CFG
{
	DWORD			    dwSize;
	char			    szCity[DH_COMMON_STRING_32];         // Current city
	char			    szProvince[DH_COMMON_STRING_32];     // Current province
	int				    nStation;							 // station type
	NET_DEVICEIDSETS*   pstDeviceIdSets;					 // Device info 
	int					nDeviceIdSetsNum;					 // num of DeviceIdSets
	int					nRetDeviceIdSetsNum;				 // Return num of DeviceIdSets
}NET_SCADA_DEVICEINFO_CFG;
//Controller information
typedef struct tagNET_SCADA_CONTROLLER_SITE_INFO
{
	char			szIPAddress[64];			// IP address
	char			szDevName[64];				// Device name
	UINT			nPort;						// Port
	char			szDeviceID[32];				// Device ID.Only read,can't change
	BYTE			bReserved[128];				// Reserved
}NET_SCADA_CONTROLLER_SITE_INFO;
//SCADA config information
typedef struct tagNET_CFG_SCADA_CONTROLLER_SITE_INFO
{
	DWORD								dwSize;						// Struct size
	int									nControllerNum;				// Controller num
	NET_SCADA_CONTROLLER_SITE_INFO		stuControllerInfo[128];		// Controller information
}NET_CFG_SCADA_CONTROLLER_SITE_INFO;
// Link layer VPN type
typedef enum tagNET_EM_LINK_LAYER_VPN_TYPE
{
	NET_EM_TYPE_UNKNOWN = 0,     // unknown
	NET_EM_TYPE_PPTP,			 // VPN type:PPTP
	NET_EM_TYPE_L2TP,			 // VPN type:L2TP
}NET_EM_LINK_LAYER_VPN_TYPE;

// Link layer VPN config list
typedef struct tagNET_NETAPP_LINK_LAYER_VPN
{
	char						szName[MAX_LINK_NAME_LEN];				// link name
	NET_EM_LINK_LAYER_VPN_TYPE  emLinkLayerVPNType;						// link layer VPN type
	BOOL						bEnable;								// whether enbale or not
	char						szAddress[MAX_SERVER_ADDRESS_LEN];				// server IP
	char						szUserName[MAX_USER_NAME_LEN];			// user name
	char						szPassword[MAX_PWD_LEN];				// password
	BYTE						byReserved[1024];						// Reserved
}NET_NETAPP_LINK_LAYER_VPN;

// Link layer VPN config
typedef struct tagNET_NETAPP_LINK_LAYER_VPN_CFG
{
	DWORD			            dwSize;
	int							nRetLinkLayerVPNNum;					 // return num of Link layer VPN config
	NET_NETAPP_LINK_LAYER_VPN   stLinkLayerVPN[LINK_LAYER_VPN_NUM];   // Link layer VPN config array
}NET_NETAPP_LINK_LAYER_VPN_CFG;

// SSHD config 
typedef struct tagNET_NETAPP_SSHD_CFG 
{
	DWORD						dwSize;									// struct size
	BOOL						bEnable;								// enable open sshd server
} NET_NETAPP_SSHD_CFG;

// Contact member info
typedef struct tagNET_MEMBERS_INFO
{
    char                        szName[MAX_COMMON_STRING_32];           // contact member name
    char                        szMobile[MAX_COMMON_STRING_16];         // device description
    char                        szEmail[MAX_COMMON_STRING_32];          // E-mail
    char                        szOrganization[MAX_COMMON_STRING_64];   // organization                            
}NET_MEMBERS_INFO;

// Notify type
typedef enum tagNET_NOTIFY_TYPE
{
    NET_NOTIFY_TYPE_UNKNOWN,                    // unknown
    NET_NOTIFY_TYPE_SMS,                        // message, SMS
    NET_NOTIFY_TYPE_CALL,                       // phone call
    NET_NOTIFY_TYPE_ALL,                        // SMS&CALL
}NET_NOTIFY_TYPE;

// User group association notify information
typedef struct tagNET_NOTIFY_INFO
{
    NET_NOTIFY_TYPE                 emType;                         // notify type
    BOOL                            bAlarmEvents;                   // accept alarm event notify or not 
    BOOL                            bSystemEvents;                  // accept system fault event notify or not
    BOOL                            bOperationEvents;               // accept operation event or not
}NET_NOTIFY_INFO;

// communication config list
typedef struct tagNET_NETAPP_COMMUNICATION_LIST
{
    char                            szGroupName[MAX_COMMON_STRING_16];      // custom group name,Non-repeatable naming
    int                             nMembersNum;                            // num of member
    NET_MEMBERS_INFO                arrMembers[32];                         // contact member info
    NET_NOTIFY_INFO                 stuNotifyInfo;                          // user group association notify info
}NET_NETAPP_COMMUNICATION_LIST;

// CommunicationList config
typedef struct tagNET_NETAPP_COMMUNICATION_LIST_CFG
{
    DWORD                           dwSize;                                 // struct size 
    int                             nConmmunicationListNum;                 // num of communication list config
    NET_NETAPP_COMMUNICATION_LIST   stuCommunication[10];                   // communication config array
}NET_NETAPP_COMMUNICATION_LIST_CFG;

// China tower config
typedef struct tagNET_VSP_CHINA_TOWER
{
	DWORD			dwSize;
	BOOL			bEnable;                              // whether enable or not,TRUE means on,FALSE means off
	char			szServerIP[MAX_SERVER_IP_LEN];     // Server IP
	int				nServerPort;						  // Server port,value range:0~65535
	int				nLoginInterval;						  // Login interval,Unit:second,value range:60~180
}NET_VSP_CHINA_TOWER;

// China Telecom Mobile Shop
typedef struct tagNET_VSP_SHDXJT 
{
    DWORD			dwSize;
    BOOL			bEnable;                              // Access enabled, TRUE turned on, FALSE turned off
    char            szRegisterUrl[128];                   // The URL address of the registration request
    char            szDeviceID[32];                       // Unique Identification Code for Equipment, Unified Distribution and Management by Platform
    char            szDeviceKey[32];                      // Equipment validation code, distributed and managed by the platform
    int             nEStoreFlag;                          // Cloud Storage Function Identification, 0: unsupported, 1: Supported
    BYTE            byReserve[4];                         // Reserved used for byte alignment
}NET_VSP_SHDXJT;


// consume config
typedef struct tagNET_CFG_VSP_CONSUME
{
	DWORD			dwSize;									// struct size
	UINT			nTotalNumber;							// consumer number
}NET_CFG_VSP_CONSUME;


// VTH password config(corresponding to NET_EM_CFG_VTH_PASSWORD)
typedef struct tagNET_CFG_VTH_PASSWORD_INFO
{
	DWORD		   dwSize;
	char		   szUser[8];					  // user password,must be 6 digits
}NET_CFG_VTH_PASSWORD_INFO;

// Sip server info
typedef struct tagNET_CFG_SIPSERVER_INFO
{
    DWORD                   dwSize; 
    char                    szAccoutName[MAX_COMMON_STRING_64];         // accout name
    char                    szAddres[DH_MAX_IPADDR_EX_LEN];             // address of sip server
    int                     nPort;                                      // port of sip server
    char                    szProxyAdress[DH_MAX_IPADDR_EX_LEN];        // address of proxy server
    char                    szProxyID[MAX_COMMON_STRING_64];            // id of proxy server
    int                     nProxyPort;                                 // port of proxy server
    char                    szUserID[MAX_COMMON_STRING_64];             // user id,it's usually cellphone number 
    int                     nUserType;                                  // user type,0:SIP client,2:vto is the server,3:VTNC is the server
    char                    szAuthID[MAX_USER_NAME_LEN];				// user authentication id
    char                    szAuthPassword[MAX_PWD_LEN];				// user authentication password
    char                    szSTUNServer[DH_MAX_IPADDR_EX_LEN];         // address of STUN server
    char                    szRegisterRealm[MAX_COMMON_STRING_64];      // register realm
    int                     nRegExpiration;                             // expireation of register,unit:S
    int                     nSipPort;                                   // sip port of local
    int                     nRTPPort;                                   // RTP port of local
    BOOL                    bUnregisterOnReboot;                        // enable of unregister onreboot
    char                    szDefaultCallNumber[MAX_COMMON_STRING_64];  // call number of default
    UINT                    nVideoStreamType;                           // video stream type,0main1extra12extra23extra3
    UINT                    nAudioStreamType;                           // audio stream type,0main1extra12extra23extra3
    BOOL                    bRouteEnable;                               // sip enable of cross route
    int                     nRouteCount;                                // route number
    char                    szRouteAddress[DH_MAX_IPADDR_EX_LEN][MAX_ROUTE_NUM];   // route address
    char                    szSIPServerLoginUserName[MAX_USER_NAME_LEN];// username of login VTNC
    char                    szSIPServerLoginPWD[MAX_PWD_LEN];			// password of login VTNC
    BOOL                    bMainVTO;                                   // Enable of be Main VTO
    char                    szRedundancyServer[DH_MAX_IPADDR_EX_LEN];   // address of redundancy sip server
    char                    szRedundancyUserName[MAX_USER_NAME_LEN];	// username of redundancy sip server
    char                    szRedundancyPassword[MAX_PWD_LEN];			// password of redundancy sip server
    char                    szAnalogNumberStart[MAX_COMMON_STRING_64];  // analog start number
    char                    szAnalogNumberEnd[MAX_COMMON_STRING_64];    // analog end number
	BOOL					bUserEnable;								// User Enable
}NET_CFG_SIPSERVER_INFO; 

// Device Login Info configation
typedef struct tagNET_DEVICE_LOGIN_INFO
{
	char					szAddress[DH_MAX_IPADDR_EX_LEN];			// IP address
	char					szLongNumber[MAX_COMMON_STRING_16];			// long number
	char					szUsername[MAX_COMMON_STRING_16];			// username
	char					szPassword[MAX_COMMON_STRING_16];			// password
	BYTE					byReserved[512];							// reserved
} NET_DEVICE_LOGIN_INFO;

// Device Login Information
typedef struct tagNET_CFG_DEVICE_LOGIN_INFO 
{
	DWORD					dwSize;
	int						nCount;										// count of Device Login Information
	NET_DEVICE_LOGIN_INFO	stDeviceLoginInfo[32];						// Device Login Info configation
} NET_CFG_DEVICE_LOGIN_INFO;


//Front shield cover configuration(corresponding to NET_EM_CFG_AELENSMASK)
typedef struct tagNET_CFG_AELENSMASK_INFO
{
	DWORD		   dwSize;
	BOOL           bEnable;                       // enable(only be true can support open and close front shield cover)
	char           szName[MAX_COMMON_STRING_128]; // custom name
	BOOL           bStatus;                       // status(true:open  false:close)
}NET_CFG_AELENSMASK_INFO;

//single ultrasonic configuration
typedef struct tagNET_CFG_SINGLE_ULTRASONIC
{
	BOOL      bEnable;                       //ultrasonic enable TRUE:yes FALSE:no
	UINT      nFreq;                         //ultrasonic frequency,unit(hz)
	int       nBurst;                        //burst
	int       nGain;                         //gain  value range [0,100]
	int       nDriveCurrent;                 //drive current,unit(mA)
	int       nMinValidDistance;             //min valid distance,unit(cm)
	int       nMaxValidDistance;             //max valid distance,unit(cm)
	int       nMinVaildSignalIntensity;      //min valid signal intensity
	int       nMaxVaildSignalIntensity;      //max valid signal intensity
	BYTE      byReserved[512];               //reserved bytes
}NET_CFG_SINGLE_ULTRASONIC;

//ultrasonic info
typedef struct tagNET_CFG_ULTRASONIC_INFO
{
	DWORD                      dwSize;
	int                        nMaxCount;         //max ultrasonic count 
	int                        nRetCount;         //return ultrasonic count
	NET_CFG_SINGLE_ULTRASONIC  *pstuULTRASONIC;   //ultrasonic info , new/malloc by user, delete/free by user
}NET_CFG_ULTRASONIC_INFO;

// AccessControl Delay strategy
typedef struct tagNET_CFG_ACCESS_DELAYSTRATEGY
{
    DWORD                   dwSize;
    BOOL                    bEnable;                                    // enable
    int                     nPreArrearsTerm;                            // Prepare Arrears TermunitDay
    int                     nArrearsTerm;                               // Arrears TermunitDay
}NET_CFG_ACCESS_DELAYSTRATEGY;

// server type
typedef enum tagNET_EM_REGISTAR_SERVER_TYPE
{
    NET_EM_REGISTAR_SERVER_TYPE_UNKNOWN,
    NET_EM_REGISTAR_SERVER_TYPE_VTO,
    NET_EM_REGISTAR_SERVER_TYPE_H500,
    NET_EM_REGISTAR_SERVER_TYPE_VTNC,
    NET_EM_REGISTAR_SERVER_TYPE_ZYCOO,
    NET_EM_REGISTAR_SERVER_TYPE_THIRDPARTY,
    NET_EM_REGISTAR_SERVER_TYPE_3CXSYSTEM,
    NET_EM_REGISTAR_SERVER_TYPE_ASTERISK,
}NET_EM_REGISTAR_SERVER_TYPE;

// Registar server info
typedef struct tagNET_CFG_REGISTAR_INFO
{
    DWORD                   dwSize;
    char                    szRegistarName[MAX_COMMON_STRING_64];    // name of registar serverexclusive
    NET_EM_REGISTAR_SERVER_TYPE emServerType;                        // type of registar server
    BOOL                    bRegistarEnable;                         // enable to registar
    char                    szAddress[DH_MAX_IPADDR_EX_LEN];         // registar address
    int                     nPort;                                   // registar port
	char                    szPassword[MAX_COMMON_STRING_64];  	     // registar password
}NET_CFG_REGISTAR_INFO;

// record extra config time schedule
typedef struct tagNET_CFG_RECORDEXTRA_INFO
{
	DWORD					dwSize;
	DH_TSECT                stuTimeSection[DH_N_SCHEDULE_TSECT][DH_N_REC_TSECT];            // The first dimension of the first 7 elements corresponds to 7 days a week,the eighth element corresponds to the holiday,Up to 6 time periods per day
}NET_CFG_RECORDEXTRA_INFO;

#define  NET_MAX_NUM_RECORDBACKUP_TASK       512         // the max num of record backup restore task
#define  NET_MAX_NUM_RECORDBACKUP_CHANNEL    128         // the max num of record backup channel

// record backup restore task
typedef struct tagNET_RECORDBACKUP_TASK
{
	int                     nNumChannel;                 // the num of channel
	int                     nChannel[NET_MAX_NUM_RECORDBACKUP_CHANNEL];// channel list
	NET_TIME_EX             stuStartTime;                // start time 
	NET_TIME_EX             stuEndTime;                  // end time
	char                    szStorageGroupName[DH_COMMON_STRING_32];   // storage group name
	//"ReadWrite*",* is null or integer
	//"ReadOnly"
	//"Redundant"
	//"NASFTP-" or "NASNFS-" or "NASSMB-" or "NASISCSI-" or "NASCloud-"
	//"Backup"
	//"DrawFrame"
	BYTE                    byReserved[512];             // reserve byte
}NET_RECORDBACKUP_TASK;

// auto record backup restore config(NET_EM_CFG_AUTO_RECORDBACKUP_RESTORE)
typedef struct tagNET_CFG_AUTORECORDBACKUPRESTORE_INFO
{
	DWORD					dwSize;                      // structure size
	BOOL                    bEnable;                     // enable
	UINT                    nSpeed;                      // backup speed,unit:Kbps
	NET_TIME_EX             stuBackupTime;               // backup time
	int                     nNumTask;                    // the num of task 
	NET_RECORDBACKUP_TASK   stuTask[NET_MAX_NUM_RECORDBACKUP_TASK]; // auto record backup restore task
}NET_CFG_AUTORECORDBACKUPRESTORE_INFO;

// IPC
typedef enum tagEM_FACE_SNAP_POLICY
{
	EM_FACE_SNAP_POLICY_UNKNOWN,					// unknown
	EM_FACE_SNAP_POLICY_REALTIME,					// realtime
	EM_FACE_SNAP_POLICY_OPTIMAL,					// optimal
	EM_FACE_SNAP_POLICY_QUALITY,					// quality
	EM_FACE_SNAP_POLICY_RECOGNITION,				// recognize
	EM_FACE_SNAP_POLICY_QUICK,						// quick(customized)
	EM_FACE_SNAP_POLICY_FULLTRACK,					// full track(customized)
	EM_FACE_SNAP_POLICY_INTERVAL,					// interval(customized)
	EM_FACE_SNAP_POLICY_SINGLE,						// single(customized)
	EM_FACE_SNAP_POLICY_PRECISION,					// precision(customized)
}EM_FACE_SNAP_POLICY;

//  IPC
typedef enum tagEM_CUTOUT_POLICY
{
	EM_CUTOUT_POLICY_UNKNOWN = -1,					// unknown
	EM_CUTOUT_POLICY_UNSUPPORT,						// unsupport
	EM_CUTOUT_POLICY_ORIGINAL,						// original
	EM_CUTOUT_POLICY_HALF,							// half
	EM_CUTOUT_POLICY_WHOLE,							// whole
	EM_CUTOUT_POLICY_CEPHALOTHORAX,					// cephalothorax
}EM_CUTOUT_POLICY;

// IPC
typedef struct tagNET_CFG_FACESNAPSHOT_INFO
{
	DWORD					dwSize;					// strcut size
	EM_FACE_SNAP_POLICY		emSnapPolicy;			// snap policy
	UINT					nSnapFrames;			// snap frame, [10,1500]default:25(customized)
	UINT					nOptimalTime;			// face optimal time,unit:s
													// valid if emSnapPolicy is EM_FACE_SNAP_POLICY_OPTIMAL or EM_FACE_SNAP_POLICY_QUALITY
	EM_CUTOUT_POLICY		emCutoutPolicy;			// 
	UINT					nIntervalFrmCnt;		// interval frame count, valid if emSnapPolicy is EM_FACE_SNAP_POLICY_RECOGNITION
	UINT					nOptimalInterval;		// optimal interval, valid if emSnapPolicy is EM_FACE_SNAP_POLICY_INTERVAL(customized)
	UINT					nOptimalCount;			// optimal countvalid if emSnapPolicy is EM_FACE_SNAP_POLICY_INTERVAL(customized)
	UINT					nRecognizeTimeout;		// recognize fail time out,unit:s
}NET_CFG_FACESNAPSHOT_INFO;
typedef enum tagNET_EM_REPORT_POLICY
{
	NET_EM_REPORT_POLICY_UNKNOWN,			// Unknown
	NET_EM_REPORT_POLICY_AUTO,			    // Device auto report
	NET_EM_REPORT_POLICY_TIMING,			// timing report
}NET_EM_REPORT_POLICY;

// Auto report info
typedef struct tagNET_AUTO_REPORT_INFO
{
	int				nReportTime;			// Report time,Unit:second
	int				nReportDistance;		// Report distance,Unit:meter
	int				nInflectionPointAngle;	// Inflection point angle,Unit:degree
	int				nAccOffReportTime;		// ACC off report time,Unit:second
	BYTE			byReserved[1024];		// Reserved
}NET_AUTO_REPORT_INFO;

// GPS position report policy info(corresponding to NET_EM_CFG_POSITIONREPORTPOLICY)
typedef struct tagNET_CFG_POSITIONREPORTPOLICY_INFO
{
	DWORD						    dwSize;
	NET_EM_REPORT_POLICY			emReportPolicy;			// Report policy, When set this field, emReportPolicy must not be NET_EM_REPORT_POLICY_UNKNOWN
	NET_AUTO_REPORT_INFO			stuAutoReportInfo;		// Auto report info, Valid when emReportPolicy is NET_EM_REPORT_POLICY_AUTO
}NET_CFG_POSITIONREPORTPOLICY_INFO;

// Encode config
												// If it supports high definition setup, the high definition channel ranges from 0 to N-1. If your high definition channel number is more than N, the save operation may fail. 

//run mode parameter
typedef struct tagNET_RUNMODE_PARAMS
{	
	DWORD                   dwSize;                     
	//run mode:0(normal) 1(memory pool mode)
	int                     nMode;                              
	/*nWinConnectBufSize (windows) unit(byte)
	0:keep the original value;Best:250*1024;Min:128*1024*/
	int                     nWinConnectBufSize;
	/*nWinSocketRcvBuf (windows/linux)  unit(byte),
	0:keep the original value;Best:64*1024;Min:36*1024 */
	int                     nWinSocketRcvBuf;
}NET_RUNMODE_PARAMS;

// automatic arming schedule
typedef struct tagNET_CFG_ARMSCHEDULE_INFO
{
    DWORD					dwSize;
    BOOL                    bEnable;                                               // valid enable
    DH_TSECT                stuTimeSection[DH_N_SCHEDULE_TSECT][DH_N_REC_TSECT];   // The first dimension of the first 7 elements corresponds to 7 days a week,the eighth element corresponds to the holiday,Up to 6 time periods per day
}NET_CFG_ARMSCHEDULE_INFO;

#define MAX_CID_NUM				    100				    // max number of CID protocol 
#define MAX_FTCID_NUM				100				    // max number of FTCID protocol 
#define MAX_TEL_NUM			        2				    // max index number of tel alarm center

// protocol type
typedef enum tagEM_CID_REPORT_PROTOCOL_TYPE
{
    EM_CID_REPORT_PROTOCOL_TYPE_UNKNOWN,             // unknown
    EM_CID_REPORT_PROTOCOL_TYPE_CID,                 // CID protocol
    EM_CID_REPORT_PROTOCOL_TYPE_FTCID,               // FTCID protocol
}EM_CID_REPORT_PROTOCOL_TYPE;

// event code of CID protocol
typedef enum tagEM_CID_EVENT_CODE
{
    EM_CID_EVENT_CODE_UNKNOWN =-1,                                    // -1 : unknown
    EM_CID_EVENT_CODE_DEFENCE_GENERAL_ALARM,                          // 0 : defence general alarm
    EM_CID_EVENT_CODE_DEFENCE_PREVENT_MOVE_ALARM,                     // 1 : defence prevent move alarm
    EM_CID_EVENT_CODE_DEFENCE_FAULT_ALARM,                            // 2 : defence fault alarm
    EM_CID_EVENT_CODE_DEFENCE_BYPASS,                                 // 3 : defence bypass
    EM_CID_EVENT_CODE_RAPID_ARM,                                      // 4 : rapid arm
    EM_CID_EVENT_CODE_LOCK_ARM_DISARM,                                // 5 : lock arm and disarm
    EM_CID_EVENT_CODE_REMOTE_ARM_DISARM,                              // 6 : remote arm and disarm
    EM_CID_EVENT_CODE_TIME_ARM_DISARM,                                // 7 : time arm and disarm
    EM_CID_EVENT_CODE_TELEOPERATION_ARM_DISARM,                       // 8 : teleaperation arm and disarm
    EM_CID_EVENT_CODE_USER_ARM_DISARM,                                // 9 : user arm and disarm
    EM_CID_EVENT_CODE_PART_ARM_DISARM,                                // 10 : part arm and disarm
    EM_CID_EVENT_CODE_HOST_PREVENT_MOVE,                              // 11 :host prevent move
    EM_CID_EVENT_CODE_HOST_POWER_FAULT,                               // 12 :host power fault
    EM_CID_EVENT_CODE_BATTERY_LOW,                                    // 13 :battery low
    EM_CID_EVENT_CODE_BATTERY_FAULT,                                  // 14 :battery fault
    EM_CID_EVENT_CODE_TELEPHONE_DISCONNECTION,                        // 15 :telephone disconnection
    EM_CID_EVENT_CODE_GSM_SIGNAl_BAD,                                 // 16 :GSM signal bad
    EM_CID_EVENT_CODE_ALARM_PREVENT_MOVE,                             // 17 :alarm prevent move
    EM_CID_EVENT_CODE_MODULE_COMMUNICATION_FAULT,                     // 18 :module communication fault
    EM_CID_EVENT_CODE_SYSTEM_TIME_ABNORMAl,                           // 19 :system time abnormal
    EM_CID_EVENT_CODE_SIM_CAR_FAULT,                                  // 20 :SIM car fault
    EM_CID_EVENT_CODE_NETWORK_COMMUNICATION_FAULT,                    // 21 :network communication fault
    EM_CID_EVENT_CODE_FIRE_ALARM,                                     // 22 :fire alarm
    EM_CID_EVENT_CODE_ROBBER_ALARM,                                   // 23 :robber alarm
    EM_CID_EVENT_CODE_URGENT_MEDICAL_ALARM,                           // 24 :urgent medical alarm
    EM_CID_EVENT_CODE_DURESS_ALARM,                                   // 25 :duress alarm
    EM_CID_EVENT_CODE_PANIC_ALARM,                                    // 26 :panic alarm
    EM_CID_EVENT_CODE_PERIOD_TEST_REPORT,                             // 27 :period test report
    EM_CID_EVENT_CODE_MANUAL_TEST_REPORT,                             // 28 :manual test report
    EM_CID_EVENT_CODE_CLEAR_ALARM_CACHE,                              // 29 :clear alarm cache
    EM_CID_EVENT_CODE_ALARM_CANCEL,                                   // 30 :alarm cancel
    EM_CID_EVENT_CODE_EMERGENCY_ALARM,                                // 31 :emergency alarm                                                 
    EM_CID_EVENT_CODE_OUTSIDE_ZONE_ALARM,                             // 32 :outside zone alarm                                                  
    EM_CID_EVENT_CODE_INSIDE_ZONE_ALARM,                              // 33 :inside zone alarm                                                  
    EM_CID_EVENT_CODE_24H_ZONE_ALARM,                                 // 34 :24h zone alarm                                                  
    EM_CID_EVENT_CODE_DELAY_ZONE_ALARM,                               // 35 :delay zone alarm                                                  
    EM_CID_EVENT_CODE_INTIME_DOUBLEMETHOD_ZONE_ALARM,                 // 36 :intime doublemethod zone alarm                                                  
    EM_CID_EVENT_CODE_24H_URGENCYBUTTON_ZONE_ALARM,                   // 37 :24h urgencybutton zone alarm                                                  
    EM_CID_EVENT_CODE_24H_FIRE_ZONE_ALARM,                            // 38 :24h fire zone alarm                                                  
    EM_CID_EVENT_CODE_24H_ROBBERY_ZONE_ALARM,                         // 39 :24h robbery zone alarm                                                  
    EM_CID_EVENT_CODE_24H_SILENT_ZONE_ALARM,                          // 40 :24h silent zone alarm                                                  
    EM_CID_EVENT_CODE_24H_SOUND_ZONE_ALARM,                           // 41 :24h sound zone alarm                                                  
    EM_CID_EVENT_CODE_24H_AUXILIARY_ZONE_ALARM,                       // 42 :24h auxiliary zone alarm                                                  
    EM_CID_EVENT_CODE_24H_VIBRATION_ZONE_ALARM,                       // 43 :24h vibration zone alarm                                                  
    EM_CID_EVENT_CODE_TIMEOUT_ZONE_ALARM,                             // 44 :timeout zone alarm                                                  
    EM_CID_EVENT_CODE_FOLLOW_ZONE_ALARM,                              // 45 :follow zone alarn                                                  
    EM_CID_EVENT_CODE_EXMODULE_FAULT,                                 // 46 :exmodule failure                                                  
    EM_CID_EVENT_CODE_EXMODULE_DC_LOSS,                               // 47 :exmodule dc loss                                                  
    EM_CID_EVENT_CODE_EXMODULE_LOW_BATTERY,                           // 48 :exmodule low battery                                                  
    EM_CID_EVENT_CODE_EXMODULE_TAMPER,                                // 49 :exmodule tamper                                                  
    EM_CID_EVENT_CODE_EXMODULE_AC_LOSS,                               // 50 :exmodule ac loss                                                  
    EM_CID_EVENT_CODE_PRINTER_FAILURE,                                // 51 :printer failure                                                  
    EM_CID_EVENT_CODE_GSM_FAULT,                                      // 52 :gsm fault                                                  
    EM_CID_EVENT_CODE_ARMED_STAY,                                     // 53 :armed stay                                                  
    EM_CID_EVENT_CODE_AUTO_ARM_FAILED,                                // 54 :auto arm failed                                                  
    EM_CID_EVENT_CODE_SYSTEM_TROUBLE_PRESENT,                         // 55 :system trouble present                                                  
    EM_CID_EVENT_CODE_PROGRAM_MODE_ENTRY,                             // 56 :program mode entry                                                  
    EM_CID_EVENT_CODE_PROGRAM_MODE_EXIT,                              // 57 :program mode exit                                                  
    EM_CID_EVENT_CODE_PANEL_PROGRAMMING_CHANGED,                      // 58 :panel programming changed                                                  
    EM_CID_EVENT_CODE_KEYPAD_TAMPER_ALARM,                            // 59 :keypad tamper                                                  
    EM_CID_EVENT_CODE_IP_CONFLICT,                                    // 60 :ip conflict       
}EM_CID_EVENT_CODE;

// configuration  information of CID protocol 
typedef struct tagNET_CFG_CID_REPORT_CID_INFO
{
    int                                       nTelNum;                            // index number of tel alarm center
    int                                       nTel[MAX_TEL_NUM];                  // index of tel alarm center
    EM_CID_EVENT_CODE                         emEventCode;                        // event code 
    BOOL                                      bEventRestore;                      // event restore, true:valid,false:invalid
    char                                      szContactId[4];                     // contact id of 3 digit number
    BYTE                                      bReserved[256];                       // reserved
}NET_CFG_CID_REPORT_CID_INFO;

// event code of FTCID protocol
typedef enum tagEM_FTCID_EVENT_CODE
{
    EM_FTCID_EVENT_CODE_UNKNOWN =-1,                                              // unknown
    EM_FTCID_EVENT_CODE_DEFENCE_ALARM = 0,                                        // alarm0~15 : defence 1~16 alarm
    EM_FTCID_EVENT_CODE_DEFENCE_ALARM_RESTORE = 16,                               // alarm restore16~31 : defence 1~16 alarm restore
    EM_FTCID_EVENT_CODE_DEFENCE_BYPASS = 32,                                      // bypass32~47 : defence 1~16 bypass
    EM_FTCID_EVENT_CODE_DEFENCE_BYPASS_RESTORE = 48 ,                             // bypass restore48~63 : defence 1~16 bypass restore
    EM_FTCID_EVENT_CODE_ARM = 64,                                                 // 64 : arm
    EM_FTCID_EVENT_CODE_DISARM = 65,                                              // 65 : disarm
    EM_FTCID_EVENT_CODE_ALARM_CANCEL = 66,                                        // 66 : alarm cancel
    EM_FTCID_EVENT_CODE_PERIOD_TEST_REPORT = 67,                                  // 67 : period test report
    EM_FTCID_EVENT_CODE_MANUAL_TEST_REPORT = 68,                                  // 68 : manual test report
    EM_FTCID_EVENT_CODE_HOST_POWER_FAULT = 69,                                    // 69 : host power fault
    EM_FTCID_EVENT_CODE_HOST_POWER_FAULT_RESTORE = 70,                            // 70 : host power fault restore
    EM_FTCID_EVENT_CODE_BATTERY_LOW = 71,                                         // 71 : battery low
    EM_FTCID_EVENT_CODE_BATTERY_LOW_RESTORE = 72,                                 // 72 : battery low restore
    EM_FTCID_EVENT_CODE_SOFT_KEYBOARD_REPORT_CODE = 73,                           // 73 : keyboard report code
}EM_FTCID_EVENT_CODE;

// configuration  information of FTCID protocol 
typedef struct tagNET_CFG_CID_REPORT_FTCID_INFO
{
    int                                       nTelNum;                            // index number of tel alarm center
    int                                       nTel[MAX_TEL_NUM];                  // index of tel alarm center  
    EM_FTCID_EVENT_CODE                       emEventCode;                        // event code
    int                                       nDefenceChannel;                    // defence channel,valid when event code is alarm,alarm restore,bypass and bypass restore
    char                                      szContactId[3];                     // contact id of 2 digit number
    BYTE                                      bReserved[257];                       // reserved
}NET_CFG_CID_REPORT_FTCID_INFO; 

// configuration  information of CID report (corresponding to NET_EM_CFG_CID_REPORT)
typedef struct tagNET_CFG_CID_REPORT_INFO
{
    DWORD							          dwSize;				              // struct size
    EM_CID_REPORT_PROTOCOL_TYPE		          emProtocol;                         // protocol type
    int                                       nCIDNum;                            // CID protocol number
    NET_CFG_CID_REPORT_CID_INFO                   stuCID[MAX_CID_NUM];                // CID protocol,valid when emProtocol is EM_CID_REPORT_PROTOCOL_TYPE_CID
    int                                       nFTCIDNum;                          // FTCID protocol number
    NET_CFG_CID_REPORT_FTCID_INFO                 stuFTCID[MAX_FTCID_NUM];            // FTCID protocol,valid when emProtocol is EM_CID_REPORT_PROTOCOL_TYPE_FTCID
}NET_CFG_CID_REPORT_INFO;

//Information of Keyboard password 
typedef struct tagNET_CFG_KBUSER_SERVER
{
	int								nUserCode;			//User Code
	char							szPasswd[7];		//Keyboard's Password
	BYTE							bReserved[129]; 	//Reserved
}NET_CFG_KBUSER_SERVER;
//Max supported server count
#define MAX_KBUSER_SERVER_NUM	100
//Struct of config keyboard password(corresponding to NET_EM_CFG_KBUER_PASSWORD)
typedef struct tagNET_CFG_KBUSER_PASSWORD
{
	DWORD							dwSize;								//Struct size
	int								nServerNum;							//Server's information count
	NET_CFG_KBUSER_SERVER			stuServers[MAX_KBUSER_SERVER_NUM];	//Server information
}NET_CFG_KBUSER_PASSWORD;
// task of video diagmosis plan
typedef struct tagNET_PROJECT_TASK
{
	BOOL							bEnable;									// is it enable
	char							szTaskName[MAX_PATH];						// task name
	DH_TSECT                		stuTimeSection[DH_N_WEEKS][DH_N_REC_TSECT]; // time section of the task
	BOOL                            bIsCycle;                                   // is it cycle
	BYTE      						byReserved[512];      						// reserved bytes
}NET_PROJECT_TASK;

// plan of video diagmosis
typedef struct tagNET_VIDEODIAGNOSIS_PROJECT_INFO
{
	DWORD					dwSize;	
	char					szProjectName[MAX_PATH];		// project name
	int						nTotalTaskNum;					// User allocates total parameter number depending on capacity collection
	int						nReturnTaskNum;					// Returned real parameter number
	NET_PROJECT_TASK*		pstProjectTasks;				// User allocate nTotalProfileNum  count NET_PROJECT_TASK
} NET_VIDEODIAGNOSIS_PROJECT_INFO;

// task info of video diagnosis project
typedef struct tagNET_PROJECT_TASK_INFO
{
	BOOL							bEnable;									// Enable button
	char							szTaskName[260];							// Task name
	DH_TSECT                		stuTimeSection[32][6];						// Task time section
																				// In the first dimension,the first 31 elements corresponding to the date of the month, the last element is the reserved element
																				// In the second dimension,elements means time period of every day
	BOOL                            bIsCycle;                                   // Whether task is cycle or not,TRUE is cycle,FALSE is non-cycle
	BYTE      						byReserved[512];      						// Reserved
}NET_PROJECT_TASK_INFO;

// Monthly video diagnostic project,corresponding to NET_EM_CFG_VIDEO_DIAGNOSIS_PROJECT_MONTH
typedef struct tagNET_CFG_VIDEODIAGNOSIS_PROJECT_MONTH_INFO
{
	DWORD					dwSize;							// Struct size
	char					szProjectName[260];				// Project name
	int						nTotalTaskNum;					// User allocates total task number depending on capacity collection,not exceed 32
	int						nReturnTaskNum;					// Returned real task number
	NET_PROJECT_TASK_INFO*	pstProjectTasks;				// Project task info,User allocate nTotalTaskNum*sizeof(NET_PROJECT_TASK_INFO)
}NET_CFG_VIDEODIAGNOSIS_PROJECT_MONTH_INFO;

// GPS star number osd config
typedef struct tagNET_CFG_GPSSTARNUM_OSD_INFO
{
	DWORD                   dwSize;
	BOOL                    bBDOSDEnable;                   // Is beidou OSD enable
	BOOL                    bGPSOSDEnable;                  // Is GPS OSD enable
}NET_CFG_GPSSTARNUM_OSD_INFO;

// Picture title
typedef struct tagNET_OSD_PICTURE_TITLE
{
	DWORD					dwSize;
	NET_EM_OSD_BLEND_TYPE   emOsdBlendType;                     // Overlay Type, should set the value whether getting config  or setting config
	BOOL                    bEncodeBlend;						// Overlay or not
	NET_COLOR_RGBA			stuFrontColor;						// Foreground color
	NET_COLOR_RGBA			stuBackColor;						// Background color
	NET_RECT				stuRect;							// Area, coordinate value is (0, 8091)
	char					szName[DH_COMMON_STRING_64];		// Picture name
	int						nWidth;								// Picture width
	int						nHeight;							// Picture height
}NET_OSD_PICTURE_TITLE;

// Preset Point Information Overlay NET_EM_CFG_PTZ_PRESET
typedef struct tagNET_OSD_CFG_PTZ_PRESET
{
    DWORD					dwSize;
    int                     nDisplayTime;           // Display time, in seconds, 0 is always displayed, custom range: 1-3600
    BOOL                    bEncodeBlend;           // Overlay to main stream video coding
    BOOL                    bPreviewBlend;          // Whether to Overlay to Preview Display
    NET_COLOR_RGBA			stuFrontColor;			// Foreground color
    NET_COLOR_RGBA			stuBackColor;			// Background color
    NET_RECT		    	stuRect;			    // Region
}NET_OSD_CFG_PTZ_PRESET;

// Display Path Percentage Overlay Configuration NET_EM_CFG_PTZ_PATTERN
typedef struct tagNET_OSD_CFG_PTZ_PATTERN
{
    DWORD					dwSize;
    int                     nDisplayTime;           // Display time, in seconds, 0 is always displayed, custom range: 1-3600
    BOOL                    bEncodeBlend;           // Overlay to main stream video coding
    BOOL                    bPreviewBlend;          // Whether to Overlay to Preview Display
    NET_COLOR_RGBA			stuFrontColor;			// Foreground color
    NET_COLOR_RGBA			stuBackColor;			// Background color
    NET_RECT		    	stuRect;			    // Region
}NET_OSD_CFG_PTZ_PATTERN;

// Overlay Configuration of Displaying RS485 Test Results NET_EM_CFG_PTZ_RS485_DETECT
typedef struct tagNET_OSD_CFG_PTZ_RS485_DETECT
{
    DWORD					dwSize;
    int                     nDisplayTime;           // Display time, in seconds, 0 is always displayed, custom range: 1-3600
    BOOL                    bEncodeBlend;           // Overlay to main stream video coding
    BOOL                    bPreviewBlend;          // Whether to Overlay to Preview Display
    NET_COLOR_RGBA			stuFrontColor;			// Foreground color
    NET_COLOR_RGBA			stuBackColor;			// Background color
    NET_RECT		    	stuRect;			    // Region
}NET_OSD_CFG_PTZ_RS485_DETECT;

// Overlay configuration of display platform coordinates NET_EM_CFG_PTZ_COORDINATES
typedef struct tagNET_OSD_CFG_PTZ_COORDINATES
{
    DWORD					dwSize;
    int                     nDisplayTime;           // Display time, in seconds, 0 is always displayed, custom range: 1-3600
    BOOL                    bEncodeBlend;           // Overlay to main stream video coding
    BOOL                    bPreviewBlend;          // Whether to Overlay to Preview Display
    NET_COLOR_RGBA			stuFrontColor;			// Foreground color
    NET_COLOR_RGBA			stuBackColor;			// Background color
    NET_RECT		    	stuRect;			    // Region
}NET_OSD_CFG_PTZ_COORDINATES;

// Overlay configuration for displaying the direction of the platform NET_EM_CFG_PTZ_DIRECTION
typedef struct tagNET_OSD_CFG_PTZ_DIRECTION
{
    DWORD					dwSize;
    int                     nDisplayTime;           // Display time, in seconds, 0 is always displayed, custom range: 1-3600
    BOOL                    bEncodeBlend;           // Overlay to main stream video coding
    BOOL                    bPreviewBlend;          // Whether to Overlay to Preview Display
    NET_COLOR_RGBA			stuFrontColor;			// Foreground color
    NET_COLOR_RGBA			stuBackColor;			// Background color
    NET_RECT		    	stuRect;			    // Region
}NET_OSD_CFG_PTZ_DIRECTION;

// Temperature type
typedef enum tagEM_TEMPERATURE_UNIT_EX
{
    EM_TEMPERATURE_EX_UNKNOWN,              // Unknown
    EM_TEMPERATURE_EX_CENTIGRADE,			// Centigrade
    EM_TEMPERATURE_EX_FAHRENHEIT,			// Fahrenheit
    EM_TEMPERATURE_EX_KELVIN,				// Kelvin
} EM_TEMPERATURE_UNIT_EX;

// Overlay Configuration of Displaying Ambient Temperature NET_EM_CFG_TEMPERATURE
typedef struct tagNET_OSD_CFG_TEMPERATURE
{
    DWORD					dwSize;
    int                     nDisplayTime;           // Display time, in seconds, 0 is always displayed, custom range: 1-3600
    BOOL                    bEncodeBlend;           // Overlay to main stream video coding
    BOOL                    bPreviewBlend;          // Whether to Overlay to Preview Display
    NET_COLOR_RGBA			stuFrontColor;			// Foreground color
    NET_COLOR_RGBA			stuBackColor;			// Background color
    NET_RECT		    	stuRect;			    // Region
    EM_TEMPERATURE_UNIT_EX  emTemperatureType;      // Temperature type
}NET_OSD_CFG_TEMPERATURE;

// coverage areas
typedef struct tagNET_VEDIO_WIDGET_COVER
{
    BOOL				bPreviewBlend;					// Overlay to preview mode
    BOOL				bEncodeBlend;					// Overlay to main stream 
    BOOL				bEncodeBlendExtra1;				// Overlay to extra stream 1
    BOOL				bEncodeBlendExtra2;				// Overlay to extra stream 2
    BOOL				bEncodeBlendExtra3;				// Overlay to extra stream 3
    BOOL				bEncodeBlendSnapshot;			// verlay to snap
    NET_COLOR_RGBA		stuFrontColor;					// Foreground color
    NET_COLOR_RGBA		stuBackColor;					// Background color
    NET_RECT			stuRect;						// Region
    BYTE                byReserver[128];                // Reserved
}NET_VEDIO_WIDGET_COVER;

// Regional coverage NET_EM_CFG_COVERS
typedef struct tagNET_OSD_CFG_COVERS
{
    DWORD				    dwSize;
    int                     nCoverCount;            // Number of coverage areas
    NET_VEDIO_WIDGET_COVER  stuCovers[16];          // Coverage area
}NET_OSD_CFG_COVERS;

// Custom title information
typedef struct tagNET_USER_DEF_TITLE_INFO
{
    char				    szText[CUSTOM_TITLE_LEN];		// Title Content
    BOOL                    bEncodeBlend;                   // Overlay to main stream video coding
    BOOL                    bPreviewBlend;                  // Whether to Overlay to Preview Display
    NET_RECT			    stuRect;						// Region
    NET_COLOR_RGBA		    stuFrontColor;					// Foreground color
    NET_COLOR_RGBA		    stuBackColor;					// Background color
    EM_TITLE_TEXT_ALIGNTYPE emTextAlign;                    // The type of text align
    BYTE                    byReserved[516];                // Reserved 
}NET_USER_DEF_TITLE_INFO;

// User defined OSD title NET_EM_CFG_USER_DEF_TITLE
typedef struct tagNET_OSD_USER_DEF_TITLE
{
    DWORD					dwSize;
    int						nUserDefTitleNum;						// Number of custom titles
    NET_USER_DEF_TITLE_INFO	stuUserDefTitle[16];					// Custom title
}NET_OSD_USER_DEF_TITLE;

// OSD Configuration of Face Quantity Statistics
typedef struct tagNET_OSD_FACEFLOW_STAT_INFO
{
	DWORD							dwSize;							// struct size
	BOOL							bEncodeBlend;					// whether overlay to video stream
	
	NET_COLOR_RGBA					stuFrontColor;					// front color
	NET_COLOR_RGBA					stuBackColor;					// back color
	NET_RECT						stuRect;						// overlay rect,[0, 8192]
	int								nTextAlign;						// text align:0-left  2-right
	BOOL							bShowFaceRecognition;			// whether show face recognition num 
	BOOL							bShowFaceDetection;				// whether show face detection num
	BOOL							bShowBodyDetection;				// whether show body detection num	
}NET_OSD_FACEFLOWSTAT_INFO;


// Water monitor title information
typedef struct tagNET_WATERMONITOR_OSD_INFO
{
	BOOL							bEncodeBlend;					// whether blend to main stream
	int								nTextAlign;						// The align of text, 0-Left  2-Right
	NET_COLOR_RGBA					stuFrontColor;					// front color
	NET_COLOR_RGBA					stuBackColor;					// Back color
	NET_RECT						stuRect;						// Rect	1~8192
	BYTE							byReserved[1024];				// Reserved
}NET_WATERMONITOR_OSD_INFO;

// Struct of config WaterMonitorTitle(corresponding to NET_EM_CFG_WATER_MONITOR_TITLE)
typedef struct tagNET_CFG_WATER_MONITOR_TITLE_INFO
{
	DWORD                           dwSize;
	NET_WATERMONITOR_OSD_INFO		stuWaterLevel;					// Waterlevel OSD
	NET_WATERMONITOR_OSD_INFO		stuFlotage;						// Flotage OSD
}NET_CFG_WATER_MONITOR_TITLE_INFO;


// Configuration of RTSP Enables for KT Project(corresponding to NET_EM_CFG_KT_RTSP_FLAG) 
typedef struct tagNET_CFG_KT_RTSP_FLAG_INFO
{
    DWORD                dwSize;
    BOOL                 bEnable;    // Whether to enable Rtsp's disconnection strategy, TRUE: enable; FALSE: no enable
}NET_CFG_KT_RTSP_FLAG_INFO;

// Names of individual videos
typedef struct tagNET_ABORT_VEDIO
{
    char                szVedio[100];
}NET_ABORT_VEDIO;

// Get a list of videos stored locally on the device after RTSP disconnection (only access, no settings)(corresponding to NET_EM_CFG_RTSP_ABORT_LIST) 
typedef struct tagNET_CFG_RTSP_ABORT_LIST_INFO
{
    DWORD               dwSize;
    BYTE                byReserved[4];         // Keep bytes for byte alignment
    int                 nMaxListCount;         // Number of video lists allocated by users.Maximum support 3000
    UINT                nRetListCount;         // Number of video lists returned by the device
    NET_ABORT_VEDIO*    pVedioList;            // Specific video list, user application is required
    char                szMark[32];            // Current Video Types
}NET_CFG_RTSP_ABORT_LIST_INFO;

// Recording saving days configuration (corresponding to  NET_EM_CFG_FILE_HOLD_DAYS) 
typedef struct tagNET_CFG_FILE_HOLD_DAYS_INFO
{
    DWORD               dwSize;
    UINT                nDays;       // Set the retention days of the file. If the time is exceeded, it will be deleted. Unit: day. The value range is 0-65535. 0 means there is no limit on the number of days.
}NET_CFG_FILE_HOLD_DAYS_INFO;
// Access function config(corresponding to NET_EM_CFG_ACCESS_FUNCTION)
typedef struct tagNET_CFG_ACCESS_FUNCTION_INFO
{
    DWORD               dwSize;
    BOOL                bGb28181ClientEnable;                   // access to Gb28181 Client Enable
    BOOL                bGb28181ServerEnable;                   // access to Gb28181 Server Enable
    BOOL                bONVIFClientEnable;                     // access to ONVIF Client Enable
    BOOL                bONVIFServerEnable;                     // access to ONVIF Server Enable
    BOOL                bRTSPEnable;                            // support RTSP Enable
}NET_CFG_ACCESS_FUNCTION_INFO;


// user type
typedef enum tagEM_ATTENDANCE_USER_TYPE
{
    EM_ATTENDANCE_USER_TYPE_UNKNOWN = -1,            	 // unknown
    EM_ATTENDANCE_USER_TYPE_NORMAL,                      // normal
    EM_ATTENDANCE_USER_TYPE_BLACKLIST,                   // blacklist    
}EM_ATTENDANCE_USER_TYPE;

// attendance user status
typedef enum tagEM_ATTENDANCE_USER_STATUS
{
	EM_ATTENDANCE_USER_STATUS_UNKNOWN = -1,				// unknown
	EM_ATTENDANCE_USER_STATUS_NORMAL,					// normal
	EM_ATTENDANCE_USER_STATUS_FROZEN,					// frozen	
}EM_ATTENDANCE_USER_STATUS;

// attendance user info
typedef struct tagNET_ATTENDANCE_USER_INFO
{
	char							szUserID[64];					// user id
	EM_ATTENDANCE_USER_TYPE			emUserType;						// user type
	EM_ATTENDANCE_USER_STATUS		emUserStatus;                   // user status
	BYTE							byReserved[128];				// reserved
}NET_ATTENDANCE_USER_INFO;

// attendance model info (customized, Corresponding to NET_EM_CFG_ATTENDANCE_MODEL_INFO)
typedef struct tagNET_CFG_ATTENDANCE_MODEL_INFO
{	
	DWORD							dwSize;							// struct size					
	BOOL							bEnable;						// whether to open attendance mode
	NET_TIME						stuBeginTime;					// begin time of attendance
	NET_TIME						stuEndTime;						// end time of attendance
	NET_ATTENDANCE_USER_INFO		stuUserInfo[128];				// attendance user info
	UINT							nUserCount;						// attendance user count
	BYTE							byReserved[4];					// reserved
}NET_CFG_ATTENDANCE_MODEL_INFO;


// Timeable information
typedef struct tagNET_CFG_TIME_SCHEDULE
{
	BOOL                    bEnableHoliday;                                                 // Whether to support the holiday configuration,default is not supported,returned TRUE if configuration is obtained, don't enable holiday configuration
	DH_TSECT                stuTimeSection[DH_N_SCHEDULE_TSECT][DH_N_REC_TSECT];            // The first dimension of the first 7 elements corresponds to 7 days a week,the eighth element corresponds to the holiday,Up to 6 time periods per day
} NET_CFG_TIME_SCHEDULE;

// Event title content structure
typedef struct tagNET_CFG_EVENT_TITLE
{
	char					szText[CFG_MAX_CHANNELNAME_LEN];
	DH_POINT				stuPoint;						// the upper left corner of the title, use 0-8191 relative coordinate system
	DH_SIZE     			stuSize;						// The width and height of the title,use 0-8191 relative coordinate system,one or two of them are 0 in accordance with the font adaptive width and height
	NET_COLOR_RGBA			stuFrontColor;					// Foreground color
	NET_COLOR_RGBA			stuBackColor;					// Background color
} NET_CFG_EVENT_TITLE;

// Mail attachment type
typedef enum tagNET_CFG_ATTACHMENT_TYPE
{
	NET_ATTACHMENT_TYPE_PIC,							// Picture attachments
	NET_ATTACHMENT_TYPE_VIDEO,							// video attachments
	NET_ATTACHMENT_TYPE_NUM,							// the total number of attachment of types
} NET_CFG_ATTACHMENT_TYPE;

// Mail details
typedef struct tagNET_CFG_MAIL_DETAIL
{
	NET_CFG_ATTACHMENT_TYPE		emAttachType;                 // Attachments type
	int							nMaxSize;                     // File cap sizeunit:kB
	int							nMaxTimeLength;               // Maximum recording time lengthunit:svalid for video
}NET_CFG_MAIL_DETAIL;

// Tour link configuration
typedef struct tagNET_CFG_TOURLINK
{
	BOOL					bEnable;									// Polling enabled
	DH_SPLIT_MODE	        emSplitMode;								// Split mode when polling
	int						nChannels[CFG_MAX_VIDEO_CHANNEL_NUM];		// Polling the list of channel numbers
	int						nChannelCount;								// Numbers of polling channels
} NET_CFG_TOURLINK;

// Access Control type
typedef enum tagNET_EM_CFG_ACCESSCONTROLTYPE
{
	NET_EM_CFG_ACCESSCONTROLTYPE_NULL = 0,					// Not for operation
	NET_EM_CFG_ACCESSCONTROLTYPE_AUTO,						// Automaitc
	NET_EM_CFG_ACCESSCONTROLTYPE_OPEN,						// Open the door
	NET_EM_CFG_ACCESSCONTROLTYPE_CLOSE,						// Close the door
	NET_EM_CFG_ACCESSCONTROLTYPE_OPENALWAYS,				// Always open
	NET_EM_CFG_ACCESSCONTROLTYPE_CLOSEALWAYS,				// Always close
}NET_EM_CFG_ACCESSCONTROLTYPE;

// Voice call originator
typedef enum tagNET_EM_CALLER_TYPE
{
	NET_EM_CALLER_DEVICE = 0,								// Device initiated
}NET_EM_CALLER_TYPE;

// Call protocol
typedef enum tagNET_EM_CALLER_PROTOCOL_TYPE
{
	NET_EM_CALLER_PROTOCOL_CELLULAR = 0,					// Mobile phone way
}NET_EM_CALLER_PROTOCOL_TYPE;

// Voice call linkage information
typedef struct tagNET_CFG_TALKBACK_INFO
{
	BOOL							bCallEnable;					// Voice call enable
	NET_EM_CALLER_TYPE				emCallerType;					// Voice call Originator
	NET_EM_CALLER_PROTOCOL_TYPE		emCallerProtocol;				// Voice call protocol
}NET_CFG_TALKBACK_INFO;

// Telephone alarm center linkage information
typedef struct tagNET_CFG_PSTN_ALARM_SERVER
{
	BOOL				bNeedReport;									// Whether to report to the telephone alarm center
	int					nServerCount;									// Number of telephone alarm servers					
	BYTE 				byDestination[CFG_MAX_PSTN_SERVER_NUM];			// Reported by the alarm center
}NET_CFG_PSTN_ALARM_SERVER;

// Vehicle Work time schedule
typedef struct tagNET_CFG_VEHICLE_WORKTIMESCHEDULE_INFO
{
	DWORD							dwSize;
	BOOL							bEnable;						    // worktime schedule enable
	NET_CFG_TIME_SCHEDULE			stuWorkSchedule;				    // work time schedule
}NET_CFG_VEHICLE_WORKTIMESCHEDULE_INFO;

// Vehicle Load Number
typedef struct tagNET_CFG_VEHICLE_LOAD_INFO
{
	DWORD							dwSize;
	int								nLoadNumber;					    // Load Number
}NET_CFG_VEHICLE_LOAD_INFO;

#define MAX_TICKETINFO_NUM 8											// Maximum number of Tickets info
typedef struct tagNET_CFG_TICKET_INFO
{
	BOOL							bEnable;							// show and print enable
	char							szScreenModel[32];					// The short for ticket which was displayed on the screen
	char							szPrintModel[64];					// The name of ticket which was printed
	unsigned int					nFare;								// Fare
}NET_CFG_TICKET_INFO;

// Bus print the ticket
typedef struct tagNET_CFG_TICKETPRINT_INFO
{
	DWORD							dwSize;
	BOOL							bEncodeBlend;						// whether blend to main stream
	char							szRoute[32];						// Route
	char							szNumber[32];						// Number
	unsigned int					nNormal;							// Normal Fare
	unsigned int					nDiscount;							// Discount
	unsigned int					nSubsidy;							// Subsidy
	unsigned int					nStatisticsNum;						// Statistics the number of tickets, Default: 1, Range[1,2]
	unsigned int					nTicketInfoNum;						// Tickets info number
	NET_CFG_TICKET_INFO				stuTicketInfo[MAX_TICKETINFO_NUM];	// Tickets info
	char							szText[256];						// remark
}NET_CFG_TICKETPRINT_INFO;

// shutdown delay
typedef struct tagNET_CFG_VEHICLEAUTOMAIN_INFO
{
	DWORD							dwSize;
	int								nAutoShutDelay;						//The delay time of auto shutdown. Unit:minute,[0, 65536], 65536 means don't shutdown
	int								nForceShutDelay;					//The delay time of forced shutdown. When ACC outage, it delay (nAutoShutDelay + nForceShutDelay) minutes to shutdown, [0, 65536]
	int								nPercent;							//When the percent of remaining battery is lower than that value, it will shutdwon. default: 0, range[0, 100]
}NET_CFG_VEHICLEAUTOMAIN_INFO;

// Vehicle NetServer information
typedef struct tagNET_CFG_VEHICLENETSERVER_INFO
{
	DWORD							dwSize;
	BOOL							bEnable;							// net service is enabled
	UINT							nUdpPort;							// Udp port
	UINT							nTcpPort;							// Tcp port
}NET_CFG_VEHICLENETSERVER_INFO;

// IMSI bind configuration
typedef struct tagNET_CFG_IMSIBIND_INFO
{
	DWORD							dwSize;
	int								nIMSI;								// The number of IMSI
	char							szIMSI[4][32];						// The list of IMSI
}NET_CFG_IMSIBIND_INFO;

// vehicle maintaince configuration (NET_EM_CFG_VEHICLE_MAINTAINCE)
typedef struct tagNET_CFG_VEHICLE_MAINTAINCE_INFO
{
	DWORD							dwSize;
	char							szMaintainer[32];					// Maintainer
	char							szMaintainerID[32];					// Maintainer ID
	char							szInfo[256];						// Custom information
}NET_CFG_VEHICLE_MAINTAINCE_INFO;

// Holiday info
typedef struct tagNET_ACCESSCTL_SPECIALDAY_INFO
{
    char                            szDayName[32];                      // holiday name
    NET_TIME                        stuStartTime;                       // start time
    NET_TIME                        stuEndTime;                         // end time
    BYTE                            byReserved[256];
}NET_ACCESSCTL_SPECIALDAY_INFO;

// Speciaday group configration
typedef struct tagNET_CFG_ACCESSCTL_SPECIALDAY_GROUP_INFO
{
    DWORD							dwSize;
    BOOL                            bGroupEnable;                       // group enable
    char                            szGroupName[32];                    // group name
    int                             nSpeciaday;                         // Speciaday number
    NET_ACCESSCTL_SPECIALDAY_INFO   stuSpeciaday[16];                   // speciaday info
}NET_CFG_ACCESSCTL_SPECIALDAY_GROUP_INFO;

// Speciaday schdule configration
typedef struct tagNET_CFG_ACCESSCTL_SPECIALDAYS_SCHEDULE_INFO 
{
    DWORD							dwSize;
    char                            szSchduleName[64];                  // Speciaday schdule name
    BOOL                            bSchdule;                           // Speciaday schdule enable
    int                             nGroupNo;                           // sub index of NET_EM_CFG_ACCESSCTL_SPECIALDAY_GROUP 
    int                             nTimeSection;                       // time section number
    DH_TSECT                        stuTimeSection[6];                  // time section
    int                             nDoorNum;                           // valid door number
    int                             nDoors[64];                         // door number to apply   
}NET_CFG_ACCESSCTL_SPECIALDAYS_SCHEDULE_INFO;

// send serial white list to NVR 
typedef struct tagNET_CFG_SERIALNOWHITETABLE_INFO
{
    DWORD                           dwSize;
    int                             nCount;                         // the count of serial number
    char                            szSerialNo[512][48];            // array of serial number
}NET_CFG_SERIALNOWHITETABLE_INFO;

/////////////////////////////////////////////////////////LXSJ-start////////////////////////////////////////////////////////////////////////
// wuxijiaojing 
typedef struct tagNET_CFG_LXSJ_WXJJ_INFO
{
    DWORD                           dwSize;
    BOOL                            bEnable;                            // enable
    NET_TIME                        stuStartTime;                       // start time
    NET_TIME                        stuEndTime;                         // end time
    char                            szText[256];                        // send text
    char                            szDisplayContent[256];              // show text
}NET_CFG_LXSJ_WXJJ_INFO;

// Transmode
typedef enum tagNET_EM_LXSJ_TRANSMODE
{
	NET_EM_LXSJ_TRANSMODE_UNKNOWN = -1,									// unknown
	NET_EM_LXSJ_TRANSMODE_TCP,											// TCP
	NET_EM_LXSJ_TRANSMODE_UDP											// UDP
}NET_EM_LXSJ_TRANSMODE;

// font color
typedef enum tagNET_EM_LXSJ_FONTCOLOR
{
	NET_EM_LXSJ_FONTCOLOR_UNKNOWN = -1,									// unkonwn
	NET_EM_LXSJ_FONTCOLOR_R0_G0_B0,										// 0-The red light, green light and bule light are not on
	NET_EM_LXSJ_FONTCOLOR_R1_G0_B0,										// 1-The red light is on, the green light and bule light are not on
	NET_EM_LXSJ_FONTCOLOR_R0_G1_B0,										// 2-The red light is not on, the green light is on, the bule light is not on
	NET_EM_LXSJ_FONTCOLOR_R1_G1_B0,										// 3-The red light is on, the green light is on, the bule light is not on
	NET_EM_LXSJ_FONTCOLOR_R0_G0_B1,										// 4-The red light is not on, the green light is not on, the bule light is on
	NET_EM_LXSJ_FONTCOLOR_R1_G0_B1,										// 5-The red light is on, the green light is not on, the bule light is on
	NET_EM_LXSJ_FONTCOLOR_R0_G1_B1,										// 6-The red light is not on, the green light is on, the bule light is not on
	NET_EM_LXSJ_FONTCOLOR_R1_G1_B1										// 7--The red light, green light and bule light are all on
}NET_EM_LXSJ_FONTCOLOR;

// NoPlate Configuration
typedef struct tagNET_CFG_VSP_LXSJ_NOPLATE
{
	BOOL							bEnable;							// Enable
	char							szText[128];						// Content
	BYTE							byReserved[380];					// Reserved
}NET_CFG_VSP_LXSJ_NOPLATE;

//General Violation Configuration
typedef struct tagNET_CFG_VIOLATIONTYPE_NORMAL
{
	BOOL							bEnable;							// Enable
	NET_EM_LXSJ_FONTCOLOR			emTextColor;						// Text color
	char							szText[128];						// Content
	BYTE							byReserved[376];					// Reserved
}NET_CFG_VIOLATIONTYPE_NORMAL;

typedef NET_CFG_VIOLATIONTYPE_NORMAL NET_CFG_VIOLATIONTYPE_TRAFFICOVERSPEED;			// TrafficOverSpeed 
typedef NET_CFG_VIOLATIONTYPE_NORMAL NET_CFG_VIOLATIONTYPE_TRAFFICCROSSLANE;			// TrafficCrossLane 
typedef NET_CFG_VIOLATIONTYPE_NORMAL NET_CFG_VIOLATIONTYPE_TRAFFICPARKING;			// TrafficParking
typedef NET_CFG_VIOLATIONTYPE_NORMAL NET_CFG_VIOLATIONTYPE_TRAFFICBACKING;			// TrafficBacking
typedef NET_CFG_VIOLATIONTYPE_NORMAL NET_CFG_VIOLATIONTYPE_TRAFFICRETROGRADE;		// TrafficRetrograde
typedef NET_CFG_VIOLATIONTYPE_NORMAL NET_CFG_VIOLATIONTYPE_PARKINGWARNING;			// ParkingWarning
typedef NET_CFG_VIOLATIONTYPE_NORMAL NET_CFG_VIOLATIONTYPE_TRAFFICPEDESTRAINPRIORITY;// TrafficPedestrainPriority
typedef NET_CFG_VIOLATIONTYPE_NORMAL NET_CFG_VIOLATIONTYPE_TRAFFICRUNREDLIGHT;		// TrafficRunRedLight
typedef NET_CFG_VIOLATIONTYPE_NORMAL NET_CFG_VIOLATIONTYPE_TRAFFICWRONGROUTE;		// TrafficWrongRoute
typedef NET_CFG_VIOLATIONTYPE_NORMAL NET_CFG_VIOLATIONTYPE_TRAFFICJAMFORBIDINTO;		// TrafficJamForbidInto
typedef NET_CFG_VIOLATIONTYPE_NORMAL NET_CFG_VIOLATIONTYPE_TRAFFICOVERLINE;			// TrafficOverLine
typedef NET_CFG_VIOLATIONTYPE_NORMAL NET_CFG_VIOLATIONTYPE_TRAFFICVEHICLEINROUTE;	// TrafficVehicleInRoute

// TrafficJunction
typedef struct tagNET_CFG_VIOLATIONTYPE_TRAFFICJUNCTION
{
	BOOL							bEnable;							// Enable
	NET_EM_LXSJ_FONTCOLOR			emTrustTextColor;					// TrustTextColor
	char							szTrustText[128];					// TrustText
	NET_EM_LXSJ_FONTCOLOR			emDisTrustTextColor;				// DisTrustTextColor
	char							szDisTrustText[128];				// DisTrustText
	BYTE							byReserved[244];					// Reserved
}NET_CFG_VIOLATIONTYPE_TRAFFICJUNCTION;

// The collection of all violation configuration
typedef struct tagNET_CFG_VSP_LXSJ_VIOLATIONTYPE
{
	NET_CFG_VIOLATIONTYPE_TRAFFICOVERSPEED			stuTrafficOverSpeed;				// TrafficOverSpeed 
	NET_CFG_VIOLATIONTYPE_TRAFFICCROSSLANE			stuTrafficCrossLane;				// TrafficCrossLane 
	NET_CFG_VIOLATIONTYPE_TRAFFICPARKING			stuTrafficParking;					// TrafficParking 
	NET_CFG_VIOLATIONTYPE_TRAFFICBACKING			stuTrafficBacking;					// TrafficBacking 
	NET_CFG_VIOLATIONTYPE_TRAFFICRETROGRADE			stuTrafficRetrograde;				// TrafficRetrograde
	NET_CFG_VIOLATIONTYPE_PARKINGWARNING			stuParkingWarning;					// ParkingWarning 
	NET_CFG_VIOLATIONTYPE_TRAFFICJUNCTION			stuTrafficJunction;					// TrafficJunction
	NET_CFG_VIOLATIONTYPE_TRAFFICPEDESTRAINPRIORITY	stuTrafficPedestrainPriority;		// TrafficPedestrainPriority
	NET_CFG_VIOLATIONTYPE_TRAFFICRUNREDLIGHT		stuTrafficRunRedLight;				// TrafficRunRedLight
	NET_CFG_VIOLATIONTYPE_TRAFFICWRONGROUTE			stuTrafficWrongRoute;				// TrafficWrongRoute
	NET_CFG_VIOLATIONTYPE_TRAFFICJAMFORBIDINTO		stuTrafficJamForbidInto;			// TrafficJamForbidInto
	NET_CFG_VIOLATIONTYPE_TRAFFICOVERLINE			stuTrafficOverLine;					// TrafficOverLine
	NET_CFG_VIOLATIONTYPE_TRAFFICVEHICLEINROUTE		stuTrafficVehicleInRoute;			// TrafficVehicleInRoute
	BYTE											byReserved[13824];					// Reserved
}NET_CFG_VSP_LXSJ_VIOLATIONTYPE;

// Color type
typedef enum tagNET_EM_LXSJ_COLORTYPE
{
	NET_EM_LXSJ_COLORTYPE_UNKNOWN = -1,										// unknown
	NET_EM_LXSJ_COLORTYPE_SINGLE_COLOR = 1,									// single color
	NET_EM_LXSJ_COLORTYPE_DOUBLE_COLOR = 2,										// double color
	NET_EM_LXSJ_COLORTYPE_THREE_COLOR = 3,										// three color
}NET_EM_LXSJ_COLORTYPE;

// Area type
typedef enum tagNET_EM_LXSJ_AREATYPE
{
	NET_EM_LXSJ_AREATYPE_UNKNOWN = -1, //unknown
	NET_EM_LXSJ_AREATYPE_STATIC_TYPE = 0, // 0- Static
	NET_EM_LXSJ_AREATYPE_DYNAMIC_TYPE = 1, // 1-Dynamic
}NET_EM_LXSJ_AREATYPE;

// Display type
typedef enum tagNET_EM_LXSJ_DISPLAYTYPE
{
	NET_EM_LXSJ_DISPLAYTYPE_UNKNOWN = -1, //unknown
	NET_EM_LXSJ_DISPLAYTYPE_BACK_TYPE = 0, // 0- Background
	NET_EM_LXSJ_DISPLAYTYPE_FRONT_TYPE = 1, // 1- Frontground
}NET_EM_LXSJ_DISPLAYTYPE;

// Show mode
typedef enum tagNET_EM_LXSJ_SHOWMODE
{
	NET_EM_LXSJ_SHOWMODE_UNKNOWN  = -1,				// unknown
	NET_EM_LXSJ_SHOWMODE_IMMEDIATELY = 1,			// Immediately
	NET_EM_LXSJ_SHOWMODE_TO_LEFT = 2,				// Move to left
	NET_EM_LXSJ_SHOWMODE_TO_TOP = 3,				// Move to top
	NET_EM_LXSJ_SHOWMODE_TO_RIGHT = 4,				// Move to right
	NET_EM_LXSJ_SHOWMODE_TO_BOTTOM = 5,				// Move to bottom
	NET_EM_LXSJ_SHOWMODE_BLINK = 6,					// Blink
	NET_EM_LXSJ_SHOWMODE_TO_TOP_CONTINUOUS = 94,	// Continuous top movement
	NET_EM_LXSJ_SHOWMODE_TO_BOTTOM_CONTINUOUS = 95,	// Continuous bottom movement
	NET_EM_LXSJ_SHOWMODE_TO_RIGHT_CONTINUOUS = 96,	// Continuous right movement
	NET_EM_LXSJ_SHOWMODE_TO_LEFT_CONTINUOUS = 97,	// Continuous left movement
}NET_EM_LXSJ_SHOWMODE;

// Font size
typedef enum tagNET_EM_LXSJ_FONTSIZE
{
	NET_EM_LXSJ_FONTSIZE_UNKNOWN = -1,		// unknown
	NET_EM_LXSJ_FONTSIZE_16 = 16,			// 16lattice
	NET_EM_LXSJ_FONTSIZE_32 = 32,			// 32lattice
}NET_EM_LXSJ_FONTSIZE;

// Name type
typedef enum tagNET_EM_LXSJ_ELEM_NAMETYPE
{
	NET_EM_LXSJ_ELEM_NAMETYPE_UNKNOWN = -1,		// unknown
	NET_EM_LXSJ_ELEM_NAMETYPE_SEPERATER = 0,			// 0-Seperater
	NET_EM_LXSJ_ELEM_NAMETYPE_NEWLINE = 1,				// 1-Newline
	NET_EM_LXSJ_ELEM_NAMETYPE_PLATE = 2,				// 2-Plate
	NET_EM_LXSJ_ELEM_NAMETYPE_VIOLATIONINFO = 3,		// 3-ViolationInfo
	NET_EM_LXSJ_ELEM_NAMETYPE_SPEED = 4,				// 4-Speed
	NET_EM_LXSJ_ELEM_NAMETYPE_CUSTOM = 5,				// 5-Custom
}NET_EM_LXSJ_ELEM_NAMETYPE;

// Element
typedef struct tagNET_CFG_VSP_LXSJ_ELEMENT
{
	NET_EM_LXSJ_ELEM_NAMETYPE		emNameType;			// Name type
	char							szName[32];			// Name
	char							szPrefix[64];		// Prefix	
	char							szPostfix[64];		// Postfix
	int								nSeperaterCount;	// SeperaterCount
	BYTE							byReserved[856];	// Reserved
}NET_CFG_VSP_LXSJ_ELEMENT;

// AreaData Configuration
typedef struct tagNET_CFG_VSP_LXSJ_AREADATA
{
	NET_EM_LXSJ_AREATYPE			emAreaType;							// AreaData type
	NET_EM_LXSJ_DISPLAYTYPE			emAreaDisplayType;					// AreaData display type
	UINT							nAreaX1;							// Area coordinates X1
	UINT							nAreaY1;							// Area coordinates Y1
	UINT							nAreaX2;							// Area coordinates X2
	UINT							nAreaY2;							// Area coordinates Y2
	NET_EM_LXSJ_FONTCOLOR			emFontColor;						// Area font color
	DH_COLOR_RGBA					stuRGB;								// Font RGB value
	NET_EM_LXSJ_SHOWMODE			emShowMode;							// Show mode
	UINT							nMoveSpeed;							// Move speed,The lower the faster(Unit:5ms)
	UINT							nStayTime;							// StayTime per page(Unit:1s)
	NET_EM_LXSJ_FONTSIZE			emFontSize;							// Font size
	UINT							nMaxRollingItem;					// MaxRollingItem
	int								nElement;							// The number of elements
	NET_CFG_VSP_LXSJ_ELEMENT		stuElement[16];						// The list of elements
	BYTE							byReserved[956];					// Reserved
}NET_CFG_VSP_LXSJ_AREADATA;

// Custom configuration
typedef struct tagNET_CFG_VSP_LXSJ_CUSTOM
{
	BOOL							bEnable;
	UINT							nWaitTime;							// WaitTime,Unit:s
	char							szText[256];						// Custom content
	NET_EM_LXSJ_DISPLAYTYPE			emAreaDisplayType;					// Area display type
	UINT							nAreaX1;							// Area coordinates X1
	UINT							nAreaY1;							// Area coordinates Y1
	UINT							nAreaX2;							// Area coordinates X2
	UINT							nAreaY2;							// Area coordinates Y2
	NET_EM_LXSJ_FONTCOLOR			emFontColor;						// Font color
	DH_COLOR_RGBA					stuRGB;								// Font RGB value
	NET_EM_LXSJ_SHOWMODE			emShowMode;							// Show mode
	UINT							nMoveSpeed;							// Move speed,The lower the faster(Unit:5ms)
	UINT							nStayTime;							// StayTime per page(Unit:1s)
	NET_EM_LXSJ_FONTSIZE			emFontSize;							// Font size
	BYTE							byReserved[704];					// Reserved 
}NET_CFG_VSP_LXSJ_CUSTOM;

// Roll configuration
typedef struct tagNET_CFG_VSP_LXSJ_ROLLCONFIG
{
	BOOL							bEnable;
	UINT							nMaxItemNum;						// The maximum number of item
	UINT							nPeriod;							// Period
	BYTE							byReserved[52];						// Reserved 
}NET_CFG_VSP_LXSJ_ROLLCONFIG;

// Slogan/Warnning configuration
typedef struct tagNET_CFG_VSP_LXSJ_SLOGAN
{
	char							szText[256];						// Content
	NET_EM_LXSJ_DISPLAYTYPE			emAreaDisplayType;					// display type
	UINT							nAreaX1;							// Area coordinates X1
	UINT							nAreaY1;							// Area coordinates Y1
	UINT							nAreaX2;							// Area coordinates X2
	UINT							nAreaY2;							// Area coordinates Y2
	NET_EM_LXSJ_FONTCOLOR			emFontColor;						// Font color
	DH_COLOR_RGBA					stuRGB;								// Font RGB value
	NET_EM_LXSJ_SHOWMODE			emShowMode;							// Show mode
	UINT							nMoveSpeed;							// Move speed,The lower the faster(Unit:5ms)
	UINT							nStayTime;							// StayTime per page(Unit:1s)
	NET_EM_LXSJ_FONTSIZE			emFontSize;							// Font size
	BYTE							byReserved[712];					// Reserved 
}NET_CFG_VSP_LXSJ_SLOGAN, NET_CFG_VSP_LXSJ_WARNNING;

// TrafficJam configuration
typedef struct tagNET_CFG_VSP_LXSJ_TRAFFICJAM
{
	BOOL							bEnable;
	NET_CFG_VSP_LXSJ_SLOGAN			stuSlogan;							// Slogan
	NET_CFG_VSP_LXSJ_WARNNING		stuWarnning;						// Warnning
	BYTE							byReserved[4096];					// Reserved
}NET_CFG_VSP_LXSJ_TRAFFICJAM;

// RadarPreAlarm configuration
typedef struct tagNET_CFG_VSP_LXSJ_RADARPREALARM
{
	BOOL							bEnable;
	char							szText[256];						// Content
	NET_EM_LXSJ_DISPLAYTYPE			emAreaDisplayType;					// display type
	UINT							nAreaX1;							// Area coordinates X1
	UINT							nAreaY1;							// Area coordinates Y1
	UINT							nAreaX2;							// Area coordinates X2
	UINT							nAreaY2;							// Area coordinates Y2
	NET_EM_LXSJ_FONTCOLOR			emFontColor;						// Font color
	DH_COLOR_RGBA					stuRGB;								// Font RGB value
	NET_EM_LXSJ_SHOWMODE			emShowMode;							// Show mode
	UINT							nMoveSpeed;							// Move speed,The lower the faster(Unit:5ms)
	UINT							nStayTime;							// StayTime per page(Unit:1s)
	NET_EM_LXSJ_FONTSIZE			emFontSize;							// Font size
	BYTE							byReserved[708];					// Reserved 
}NET_CFG_VSP_LXSJ_RADARPREALARM;

// VSP_LXSJ
typedef struct tagNET_CFG_VSP_LXSJ_INFO
{
    DWORD                           dwSize;
	BOOL                            bEnable;                            // Enable
	char							szServerIP[32];						// Server IP
	int								nServerPort;						// Server port
	NET_EM_LXSJ_TRANSMODE			emTransMode;						// TransMode
	char							szContorlID[32];					// Contorl ID
	UINT								nWidth;								// Width
	UINT								nHeigth;							// Heigth
	UINT							nPlayTime;							// PlayTime(s)
	UINT							nCirclePlayTimes;					// CirclePlayTimes

	NET_EM_LXSJ_COLORTYPE			emColorType;						// Color type
	NET_CFG_VSP_LXSJ_NOPLATE		stuNoPlate;							// NoPlate configuration
	NET_CFG_VSP_LXSJ_VIOLATIONTYPE	stuViolationType;					// The collection of all violation configuration
	int								nAreaDataNum;						// The number of AreaData
	NET_CFG_VSP_LXSJ_AREADATA		stuAreaData[16];					// The list of AreaData
	NET_CFG_VSP_LXSJ_CUSTOM			stuCustom;							// Custom configuration
	NET_CFG_VSP_LXSJ_ROLLCONFIG     stuRollConfig;						// Roll configuration
	NET_CFG_VSP_LXSJ_TRAFFICJAM		stuTrafficJam;						// TrafficJam configuration
	NET_CFG_VSP_LXSJ_RADARPREALARM  stuRadarPreAlarm;					// RadarPreAlarm configuration
}NET_CFG_VSP_LXSJ_INFO;

/////////////////////////////////////////////////////////LXSJ-end////////////////////////////////////////////////////////////////////////

// // The value in the different mode
typedef struct tagNET_CFG_GLOBAL_MODEVALUE_INFO
{
	int				nNormal;											// Normal
	int				nAlarm;												// Alarm
	BYTE			byReserved[24];										// Reserved	
}NET_CFG_GLOBAL_MODEVALUE_INFO;

// Sensor alarm global configuration 
typedef struct tagNET_CFG_SENSOR_ALARM_GLOBAL_INFO
{
	DWORD                           dwSize;
	NET_CFG_GLOBAL_MODEVALUE_INFO	stuFrequency;						// Gathered data frequency
	NET_CFG_GLOBAL_MODEVALUE_INFO	stuTimes;							// Gathered data Times
}NET_CFG_SENSOR_ALARM_GLOBAL_INFO;

// Sensor information
typedef struct tagNET_CFG_SERSOR_INFO
{
	NET_SENSE_METHOD				emSenseMethod;						// Sensor type
	int								nAlarmLowerLimit;					// Low alarm limit
	int								nAlarmHighLimit;					// High alarm limit
	BYTE							byReserved[500];					// Reserved	
}NET_CFG_SERSOR_INFO;

// Sensor alarm configuration 
typedef struct tagNET_CFG_SENSOR_ALARM_INFO
{
	DWORD                           dwSize;
	int								nMaxNum;							// The maximum number of sensor
	int								nRetNum;							// The actual number of sensor
	NET_CFG_SERSOR_INFO*			pstSensorList;						// The list of sensor, malloced by user, size = nMaxNum * sizeof(NET_CFG_SERSOR_INFO)
}NET_CFG_SENSOR_ALARM_INFO;

// Time Point
typedef struct tagNET_TIME_POINT
{
	int             bEnable;                        // Enable
	int				nHour;							// Hour
	int				nMin;							// Minutes
	int				nSec;							// Second
}NET_TIME_POINT;

// Configuration of TimingCapture(corresponding to NET_EM_CFG_TIMINGCAPTURE) 
typedef struct tagNET_CFG_TIMINGCAPTURE_INFO
{
	DWORD                           dwSize;
	NET_TIME_POINT					stuTimeSchedule[DH_N_WEEKS];		// The time of Capture(first element is Sunday, second is Monday,and so on)
}NET_CFG_TIMINGCAPTURE_INFO;

//Configuration of  Ptz speed
typedef struct tagNET_CFG_PTZ_SPEED
{
	DWORD                           dwSize;
	int                             nPtzSpeed;							//Ptz Speed 0~4
	int                             nPatternSpeed;						//Pattern Speed 1-10,10:100%Speed,5:50%Speed,and the like.
}NET_CFG_PTZ_SPEED;

// PTZ Horizontal Rotation Limit Info 
typedef struct tagNET_CFG_HORIZONTAL_ROTATION_LIMIT_INFO
{
	BOOL			bLimitEnable;					// Limit enable
	int				nLimitMode;						// Limit mode 0Left and right 1up and down
	BYTE			byReserved[256];				// Reserved
} NET_CFG_HORIZONTAL_ROTATION_LIMIT_INFO;

// PTZ Pan Group Scan Config NET_EM_CFG_PTZ_HORIZONTAL_ROTATION_SCAN
typedef struct tagNET_CFG_HORIZONTAL_ROTATION_GROUP_SCAN_INFO
{
	DWORD												dwSize;										// Struct size					
	NET_CFG_HORIZONTAL_ROTATION_LIMIT_INFO				stuHorizontalRotationInfo;					// Horizontal rotation config info
} NET_CFG_HORIZONTAL_ROTATION_GROUP_SCAN_INFO;

// Auto scan information
typedef struct tagNET_AUTOSCAN_INFO
{
	char												szName[32];				// Scan name
	BOOL												bLeftEnable;			// Left enable
	BOOL												bRightEnable;			// Right enable
	UINT												nScanSpeed;				// Scan speed,0~7
	BYTE												byReserved[948];		// Reserved
}NET_AUTOSCAN_INFO;

// AutoScan config NET_EM_CFG_AUTOSCAN
typedef struct tagNET_CFG_AUTOSCAN_INFO
{
	DWORD												dwSize;					// Struct size
	int													nMaxScanInfoNum;		// The number of pAutoScanInfos user malloc
	NET_AUTOSCAN_INFO*									pAutoScanInfos;			// AutoScan information, size is nMaxScanInfoNum * sizeof(NET_AUTOSCAN_INFO)
	int													nRetScanInfoNum;		// The actual number of pAutoScanInfos it must < MaxScanInfoNum
}NET_CFG_AUTOSCAN_INFO;

// Coaxial Light Config
typedef struct tagNET_CFG_COAXIAL_LIGHT_INFO 
{
	DWORD							dwSize;
	BOOL							bEnable;							// enable
	DH_TSECT						stuTimeSection[DH_TSCHE_DAY_NUM][DH_TSCHE_SEC_NUM];	// time section
} NET_CFG_COAXIAL_LIGHT_INFO;

// Video output color
typedef struct tagNET_VIDEO_OUT_COLOR 
{
    UINT			nBrightness;					// Brightness, 0~100
    UINT			nContrast;						// Contrast, 0~100
    UINT			nSaturation;					// Saturation, 0~100
    UINT			nHue;							// Hue, 0~100
    UINT			nGamma;						    // Gamma, 0~100
    BYTE            byResered[132];                 // Resered
} NET_VIDEO_OUT_COLOR;

// Output signal mode
typedef enum tagEM_VIDEO_OUT_FORMAT
{
    EM_VIDEO_OUT_FORMAT_UNKNOWN,            // Unknown
    EM_VIDEO_OUT_FORMAT_AUTO,               // Auto, don't allaw to set this config
    EM_VIDEO_OUT_FORMAT_TV,                 // TV
    EM_VIDEO_OUT_FORMAT_VGA,                // VGA
    EM_VIDEO_OUT_FORMAT_DVI,                // DVI
    EM_VIDEO_OUT_FORMAT_HDMI,               // DHMI
    EM_VIDEO_OUT_FORMAT_SPOT,               // SPOT
    EM_VIDEO_OUT_FORMAT_SDI,                // SDI
} EM_VIDEO_OUT_FORMAT;

// Output scanning mode
typedef enum tagEM_VIDEO_OUT_SCAN_FORMAT
{
    EM_VIDEO_OUT_SCAN_FORMAT_UNKNOWN,       // Unknown
    EM_VIDEO_OUT_SCAN_FORMAT_PROGRESSIVE,   // Line by line
    EM_VIDEO_OUT_SCAN_FORMAT_INTERLACE,     // Interlacing
} EM_VIDEO_OUT_SCAN_FORMAT;


// Video output mode
typedef struct tagNET_VIDEO_OUT_MODE 
{
    int			                nWidth;							// Horizontal Resolution
    int			                nHeight;						// Vertical resolution
    int			                nBPP;							// color depth
    int			                nRefreshRate;					// refresh frequency
    EM_VIDEO_OUT_FORMAT		    emFormat;						// Output signal mode
    EM_VIDEO_OUT_SCAN_FORMAT    emScanFormat;					// Output scanning mode
    BYTE                        byResered[128];                 // Reserved
} NET_VIDEO_OUT_MODE;

// Custom Video Output Mode
typedef struct tagNET_VIDEO_OUT_USERDEF_MODE 
{
    int			                nWidth;							// Horizontal Resolution
    int			                nHeight;						// Vertical resolution
    int			                nBPP;							// color depth
    int			                nRefreshRate;					// refresh frequency
    EM_VIDEO_OUT_FORMAT		    emFormat;						// Output signal mode
    EM_VIDEO_OUT_SCAN_FORMAT    emScanFormat;					// Output scanning mode
    BYTE                        byResered[128];                 // Reserved
} NET_VIDEO_OUT_USERDEF_MODE;

// Video Output Configuration NET_EM_CFG_VIDEO_OUT
typedef struct tagNET_CFG_VIDEO_OUT_INFO
{
    DWORD				        dwSize;
    BOOL                        bEnable;                    // Enable
    UINT		                nMargin[4];					// Reduction ratio. Each item represents the reduction ratio of the top left and the bottom right sides of the video output, 0-100 for each item.
    BOOL				        bIQIMode;					// Output image enhancement
    BOOL				        bIsUserDefMode;				// Whether to Enable User-defined Video Output Mode
    NET_VIDEO_OUT_COLOR         stuColor;                   // Video output color
    NET_VIDEO_OUT_MODE          stuMode;                    // Video output mode
    NET_VIDEO_OUT_USERDEF_MODE  stuSelfDefMode;             // Custom Video Output Mode.It is valid when bIsUserDefMode is TRUE
} NET_CFG_VIDEO_OUT_INFO;

// cloud upload time configration  
typedef struct tagNET_CFG_CLOUDUPLOADTIME_INFO
{
    DWORD                           dwSize;
    BOOL                            bEnable;                        // enable
    NET_TIME                        stStartTime;                    // start time
    NET_TIME                        stEndTime;                      // end time
}NET_CFG_CLOUDUPLOADTIME_INFO;

// Server Option
typedef enum tagEM_SERVER_OPTION
{
	EM_SERVER_OPTION_UNKNOWN,			// Unknown
	EM_SERVER_OPTION_DISABLE,			// Server option disable 
	EM_SERVER_OPTION_GB28181,			// Open with GB28181 access
	EM_SERVER_OPTION_GB35114,			// Open with GB35114 access
}EM_SERVER_OPTION;

// Channel info
typedef struct tagNET_CHANNEL_INFO
{
	char				szID[MAX_CHANNEL_ID_LEN];				// Channel ID
	unsigned int		nAlarmLevel;							// Alarm level,valid range is [1,6]
	BYTE				byReserved[1024];						// Reserved		
}NET_CHANNEL_INFO;

// Alarm info
typedef struct tagNET_ALARM_INFO
{
	char				szID[MAX_CHANNEL_ID_LEN];				// Channel ID
	unsigned int		nAlarmLevel;							// Alarm level,valid range is [1,6]
	BYTE				byReserved[1024];						// Reserved
}NET_ALARM_INFO;

// Audio output channel info
typedef struct tagNET_AUDIO_OUTPUT_CHANNEL_INFO
{
	char				szID[MAX_CHANNEL_ID_LEN];				// Channel ID
	BYTE				byReserved[1024];						// Reserved
}NET_AUDIO_OUTPUT_CHANNEL_INFO;

// SIP server info 
typedef struct tagNET_SIP_SERVER_INFO
{
	EM_SERVER_OPTION			emServerOption;								// Server access enbale option
	char						szSipSvrId[MAX_SIP_SVR_ID_LEN];				// SIP server ID
	char						szDomain[MAX_SIP_DOMAIN_LEN];				// SIP domain
	char						szSipSvrIp[MAX_SIP_SVR_IP_LEN];				// SIP server IP
	char						szDeviceId[MAX_SIP_SERVER_DEVICE_ID_LEN];	// Device ID or User name
	char						szPassword[MAX_REG_PASSWORD_LEN];		    // Password
	unsigned short				nLocalSipPort;								// Local SIP port
	unsigned short				nSipSvrPort;								// SIP server port
	unsigned int				nSipRegExpires;								// SIP register validity,Unit:second
	unsigned int				nRegInterval;								// Re-registration interval after failed registration,Unit:second
	unsigned int				nKeepAliveCircle;							// Keep alive circle,Unit:second
	unsigned int				nMaxTimeoutTimes;							// Max timeout times
	char						szCivilCode[MAX_CIVIL_CODE_LEN];			// Civil code
	char						szIntervideoID[MAX_INTERVIDEO_ID_LEN];		// Intervideo ID
	NET_CHANNEL_INFO*			pstuChannnelInfo;							// Channel info.malloc memory by user,size is sizeof(NET_CHANNEL_INFO)*nChannelInfoNum
	unsigned int				nChannelInfoNum;							// Channel info num, it can depend on channel num by Login get
	unsigned int				nRetChannelInfoNum;							// Return channel info num
	NET_ALARM_INFO*				pstuAlarmInfo;								// Alarm info,malloc memory by user,size issizeof(NET_ALARM_INFO)*nAlarmInfoNum
	unsigned int				nAlarmInfoNum;								// Alarm info num, max value is 640
	unsigned int				nRetAlarmInfoNum;							// Return alarm info num
	NET_AUDIO_OUTPUT_CHANNEL_INFO*		pstuAudioOutputChnInfo;				// Audio output channel info,malloc memory by user,size is sizeof(NET_AUDIO_OUTPUT_CHANNEL_INFO)*nAudioOutputChnInfoNum
	unsigned int				nAudioOutputChnInfoNum;						// Audio output channel info num, max value is 181
	unsigned int				nRetAudioOutputChnInfoNum;					// Return audio output channel info num
	BYTE						byReserved[1024];							// Reserved
}NET_SIP_SERVER_INFO;


// Public security 1 platform input config info
typedef struct tagNET_CFG_VSP_GAYS_SERVER_INFO
{
	DWORD							dwSize;											// Struct size
	unsigned int					nSipServerInfoNum;								// SIP server info num,not more than MAX_SIP_SERVER_NUM, Used in set Sip Server Info
	NET_SIP_SERVER_INFO				stuSipServerInfo[MAX_SIP_SERVER_NUM];			// SIP server info
	unsigned int					nRetSipServerInfoNum;							// Return SIP server info num
	BYTE							byReserved[4];									// Reserved
}NET_CFG_VSP_GAYS_SERVER_INFO;

// Co-signing server info,Corresponding to NET_EM_CFG_VSP_CO_SIGN_SERVER
typedef struct tagNET_CFG_VSP_CO_SIGN_SERVER_INFO
{
	DWORD							dwSize;						// Struct size
	char							szCoSignServerIP[64];		// Co-signing server IP
	unsigned int					nCoSignServerPort;			// Co-signing server port
}NET_CFG_VSP_CO_SIGN_SERVER_INFO;

// notify object info of vsp gavi
typedef struct tagNET_VSP_GAVI_NOTIFY_OBJECT
{
	BOOL							bFaceChecked;				// the face is checked
	BOOL							bPersonChecked;				// the body is checked
	BOOL							bMotorVehicleChecked;		// the motor vehicle is checked
	BOOL							bNonMotorVehicleChecked;	// the non motor vehicle is checked
	BOOL							bImageChecked;				// the image is checked
	BYTE							byReserved[516];			// reserved
}NET_VSP_GAVI_NOTIFY_OBJECT;


// channel info of vsp gavi
typedef struct tagNET_VSP_GAVI_CHANNEL_INFO
{
	char							szChannelEncode[24];		// channel encode
	NET_VSP_GAVI_NOTIFY_OBJECT		stuNotifyObject;			// notify object
	BYTE							byReserved[512];			// reserved
}NET_VSP_GAVI_CHANNEL_INFO;




// paltform code
typedef enum tagEM_VSP_GAVI_PLATFORM_CODE
{
	EM_VSP_GAVI_PLATFORM_CODE_UNKNOWN = -1,						// unknown
	EM_VSP_GAVI_PLATFORM_CODE_DEFAULT,							// default,standard
	EM_VSP_GAVI_PLATFORM_CODE_DAHUA,							// Dahua
	EM_VSP_GAVI_PLATFORM_CODE_HKTDA_CLOUDSTORAGE,				// Hikvision TDA and cloud storage
	EM_VSP_GAVI_PLATFORM_CODE_UNIVIEW,							// Uniview
	EM_VSP_GAVI_PLATFORM_CODE_HKTEST,							// Hikvision interface test
	EM_VSP_GAVI_PLATFORM_CODE_SHQPNETPOSE,						// shanghai qingpu netpose
	EM_VSP_GAVI_PLATFORM_CODE_HKTDA,							// Hikvision TDA
	EM_VSP_GAVI_PLATFORM_CODE_HARZONE,							// harzone
	EM_VSP_GAVI_PLATFORM_CODE_NETPOSE,							// netpose
	EM_VSP_GAVI_PLATFORM_CODE_TAOAN,							// tao an
	EM_VSP_GAVI_PLATFORM_CODE_RESERVED,							// reserved
	EM_VSP_GAVI_PLATFORM_CODE_HKVIEWGATEWAY,					// Hikvision view gateway
	EM_VSP_GAVI_PLATFORM_CODE_KODAK,							// kodak
}EM_VSP_GAVI_PLATFORM_CODE;


// key of Hikvision image server info
typedef struct tagNET_HKIMAGESERVER_INFO
{
	char						szAccessKey[136];				// access code
	char						szSecretKey[136];				// secret key
	BYTE						szReserved[512];				// reserved
}NET_HKIMAGESERVER_INFO;

// Register info
typedef struct tagNET_VSP_GAVI_INFO
{
    char                			szAddress[128];     		// Register platform IP address or network name. IP is space-time, no access
    char                			szUserId[64];       		// Equipment login account
    char                			szPassword[64];     		// Login password
    UINT                			nPort;              		// Port number
	BOOL							bEnable;					// connect enable
	UINT							nKeepAliveTime;				// keep alive time,[10,90],unit:s
	UINT							nMaxTimeoutTimes;			// max timeout times,[2,5]
	UINT							nRegisterInterval;			// register interval,[30,300],unit:s	
	char							szDeviceID[24];				// device id	
	NET_VSP_GAVI_CHANNEL_INFO* 		pstuChannelInfo; 			// channel info,user allocate memory
	UINT							nChannelCount;				// num of pstuChannelInfo,same as the channel num of device
	UINT							nChannelCountRet;			// the returned num of pstuChannelInfo
	EM_VSP_GAVI_PLATFORM_CODE		emPlatform;					// current platform
	BOOL							bIsOnLine;					// is online,can not modified
	NET_HKIMAGESERVER_INFO*			pHKImageServerInfo;			// Hikvision image server info, valid when emPlatform is EM_VSP_GAVI_PLATFORM_CODE_HKTDA_CLOUDSTORAGE
    BYTE                			byReserved[68];    			// reserved
}NET_VSP_GAVI_INFO;
// platform info
typedef struct tagNET_VSP_GAVI_PLATFORM_INFO
{
	EM_VSP_GAVI_PLATFORM_CODE	emPlatformCode;					// platform code
	char						szPlatformName[128];			// platform name
	BYTE						byReserved[132];				// reserved
}NET_VSP_GAVI_PLATFORM_INFO;


// Access configuration of public security video and image information application system,Corresponding to NET_EM_CFG_VSP_GAVI
typedef struct tagNET_CFG_VSP_GAVI_INFO
{
    DWORD						dwSize;							// Struct size
    int                 		nGaviInfoCount;     			// Count of stuGaviInfo
    NET_VSP_GAVI_INFO   		stuGaviInfo[16];    			// Register info
	int							nPlatformCount;					// stuPlatformInfo's count
	NET_VSP_GAVI_PLATFORM_INFO  stuPlatformInfo[64];			// platform info, unallowed to modify
}NET_CFG_VSP_GAVI_INFO;

// Media encrypt info
typedef struct tagNET_MEDIA_ENCRYPT_INFO
{
	DWORD							dwSize;						// struct size
	BOOL							bKeyFrameEncryptEnable;		// whether Key frame encrypt is enable
	unsigned int					nVKUpdateTime;				// VK update time,Unit:minute, if this value is 0, it means not change the VK update time 
	BOOL							bRTSPOverTlsEnable;			// whether RTSP and TLS server is enable
}NET_MEDIA_ENCRYPT_INFO;

// download encrypt mediafile configuration
typedef struct tagNET_DOWNLOAD_ENCRYPT_INFO
{
	DWORD							dwSize;						// struct size
	BOOL							bEncryptEnable;				// encrypt enable	
	char							szEncryptPasswd[256];		// password of encrypted file
}NET_DOWNLOAD_ENCRYPT_INFO;

// Country/area configuration
typedef struct tagNET_CFG_COUNTRY_INFO
{
    DWORD                           dwSize;                     // struct size
    char                            szCountry[3];               // country/area
    BYTE                            byReserved1[1];             // keep align, not reserved
}NET_CFG_COUNTRY_INFO;

// video standard
typedef enum tagEM_VIDEO_STANDARD
{
    EM_VIDEO_STANDARD_UNKNOWN,                               
	EM_VIDEO_STANDARD_PAL,      // "PAL"                               
	EM_VIDEO_STANDARD_NTSC,     // "NTSC"
	EM_VIDEO_STANDARD_SECAM,    // "SECAM"
}EM_VIDEO_STANDARD;

// video standard configuration
typedef struct tagNET_CFG_VIDEOSTANDARD_INFO
{
    DWORD                           dwSize;                     // struct size
    EM_VIDEO_STANDARD               emVideoStandard;            // video standard
}NET_CFG_VIDEOSTANDARD_INFO;

// Cascade Light Info
typedef struct tagNET_CFG_CASCADE_LIGHT_INFO
{
	DWORD							dwSize;
	int								nCount;						// light count
	BOOL							bEnable[16];				// light enable
} NET_CFG_CASCADE_LIGHT_INFO;

// LeChange simple smart lock info
typedef struct tagNET_CFG_LE_SMARTTRACK_INFO
{
	DWORD							dwSize;                     // Struct size
	BOOL							bEnable;                    // LeChange simple smart lock enable
} NET_CFG_LE_SMARTTRACK_INFO;

// LeChange lens mask config info
typedef struct tagNET_CFG_LE_LENS_MASK_INFO
{
    DWORD                           dwSize;                         // Struct size
    BOOL                            bEnable;                        // Lens is masked or not, TRUE:mask, no video; FALSE:normal location
    int                             nValidLastPositionNum;          // Valid num of last position arr before mask
    BYTE                            byReserved[4];                  // Byte alignment
    double                          dbLastPosition[3];              // last position arr before mask, record the position before mask, when recover, return the position.
                                                                    // first element is pan, normalization:-1~1; second element is tilt, normalization: -1~1; third element is zoom, normalization:0~1;
                                                                    // The arr element corresponding to DH_PTZ_LOCATION_INFO (pantiltzoom) of DH_DEVSTATE_PTZ_LOCATION
                                                                    // if bEnable is FALSE, not fill the last position
}NET_CFG_LE_LENS_MASK_INFO;

// Register Type
typedef enum tagNET_EM_REGISTER_TYPE
{
	NET_EM_REGISTER_TYPE_UNKNOWN,                               // unknown
	NET_EM_REGISTER_TYPE_LECHENG,                               // domestic:lecheng
	NET_EM_REGISTER_TYPE_EASY4IP,                               // abroad:easy4ip
}NET_EM_REGISTER_TYPE;

//lecheng cloud register config(NET_EM_CFG_VSP_PAAS)
typedef struct tagNET_CFG_VSP_PAAS_INFO
{
	DWORD							dwSize;						// struct size
	BOOL							bEnable;	                // enable
	BOOL							bOnline;				    // whether online
	char							szRsServerIP[DH_MAX_IPADDR_EX_LEN];	    // register server IP
	int							    nRsServerPort;				// register server port
	char							szSN[DH_DEV_SERIALNO_LEN];	// device SN
	char							szCheckCode[DH_DEV_SERIALNO_LEN];       // device check code
	NET_EM_REGISTER_TYPE			emType;	                    // register type
}NET_CFG_VSP_PAAS_INFO;

// face auth mode
typedef enum tagNET_EM_FACE_AUTH_MODE
{
	NET_EM_FACE_AUTH_MODE_UNKNOWN = 0,                          // unknown
	NET_EM_FACE_AUTH_MODE_LOCAL,                                // local auth
	NET_EM_FACE_AUTH_MODE_REMOTE,                               // remote auth
}NET_EM_FACE_AUTH_MODE;

// card auth mode
typedef enum tagNET_EM_CARD_AUTH_MODE
{
	NET_EM_CARD_AUTH_MODE_UNKNOWN = 0,                          // unknown
	NET_EM_CARD_AUTH_MODE_LOCAL,                                // local auth
	NET_EM_CARD_AUTH_MODE_REMOTE,                               // remote auth
}NET_EM_CARD_AUTH_MODE;

// QR code auth mode
typedef enum tagNET_EM_QR_CODE_AUTH_MODE
{
	NET_EM_QR_CODE_AUTH_MODE_UNKNOWN = 0,                       // unknown
	NET_EM_QR_CODE_AUTH_MODE_LOCAL,                             // local auth
	NET_EM_QR_CODE_AUTH_MODE_REMOTE,                            // remote auth
}NET_EM_QR_CODE_AUTH_MODE;

// All authentication authority mode
typedef enum tagNET_EM_ALL_AUTH_MODE
{
    NET_EM_ALL_AUTH_MODE_UNKNOWN = 0,                       // Unknown
    NET_EM_ALL_AUTH_MODE_DISABLE,                           // Invalid, when config the single authority than use it
    NET_EM_ALL_AUTH_MODE_LOACL,                             // Local authentication
    NET_EM_ALL_AUTH_MODE_REMOTE,                            // Remote authentication
}NET_EM_ALL_AUTH_MODE;


// online and offline open door auth mode of accesscontrol config,if it is online auth mode,the device open door authority by the remote platform to authenticate,if it is offline auth mode,then the open door authority by the local device to authenticate
typedef struct tagNET_CFG_ACCESSCTL_AUTH_MODE
{
	DWORD						   dwSize;						// struct size
	NET_EM_FACE_AUTH_MODE		   emFaceAuthMode;	            // face auth mode
	NET_EM_CARD_AUTH_MODE          emCardAuthMode;              // card auth mode
	NET_EM_QR_CODE_AUTH_MODE       emQRCodeAuthMode;            // QR code auth mode
    NET_EM_ALL_AUTH_MODE           emAllAuthMode;               // All authentication authority mode. When is authority is valid, the other authority is invalid
}NET_CFG_ACCESSCTL_AUTH_MODE;

// LED screen diaplay color
typedef enum tagNET_EM_LED_COLOR
{
	NET_EM_LED_COLOR_UNKNOWN = 0,                                   // unknown
	NET_EM_LED_COLOR_GREEN,                                         // green
	NET_EM_LED_COLOR_YELLOW,                                        // yellow
	NET_EM_LED_COLOR_RED,                                           // red
}NET_EM_LED_COLOR;

// LED screen display configuration
typedef struct tagNET_CFG_LED_TEXT
{
	DWORD                          dwSize;                      // struct size
	char                           szText[128];                 // display text
	NET_EM_LED_COLOR               emColor;                     // display color
}NET_CFG_LED_TEXT;

// LED screen display array configuration
typedef struct tagNET_CFG_LED_TEXT_ARRAY
{
    DWORD                          dwSize;                     // struct size
    char                           szText[128];                // display text
    NET_EM_LED_COLOR               emColor;                    // display color
    int                            nHoldTime;                  // hold time(s)
}NET_CFG_LED_TEXT_ARRAY;

// Disable linkage configuration
typedef struct tagNET_CFG_DISABLE_LINKAGE
{
	DWORD                          dwSize;                     // Struct size
	BOOL						   bEnable;					   // Disable linkage switch
}NET_CFG_DISABLE_LINKAGE;

// Network Keyboard Quick Control Configuration Array Element Information
typedef struct tagNET_MATRIX_NETKBDFASTCTRL_ELEMENTS_INFO
{
	int						nChannel;				// Video source channel which is corresponed to keyboard operation
	char					szUserName[64];		// User name corresponding to keyboard
	BYTE                    byReserved[260];    // Reserved
} NET_MATRIX_NETKBDFASTCTRL_ELEMENTS_INFO;

// Fast control configuration of network beyboard
typedef struct tagNET_CFG_MATRIX_NETKBDFASTCTRL_INFO
{
	DWORD										dwSize;								// Struct size
	int											nMatrixNetKBDFastCtrlInfoNum;		// Network Keyboard to Quick Control Configuration Number
	NET_MATRIX_NETKBDFASTCTRL_ELEMENTS_INFO		stuMatrixNetKBDFastCtrlInfo[128];	// Fast control configuration of network beyboard
} NET_CFG_MATRIX_NETKBDFASTCTRL_INFO;

// Video channel label config
typedef struct tagNET_CFG_VIDEO_CHANNEL_LABEL_INFO
{
	DWORD					dwSize;						// Struct size
	char					szSecurityRoomCode[32];		// Room code
	char					szSecurityRoomName[32];		// Room name
}NET_CFG_VIDEO_CHANNEL_LABEL_INFO;

// Snap picture num of preset point config, related to NET_EM_CFG_PRESET_SNAP_PICTURE_NUM
typedef struct tagNET_CFG_PRESET_SNAP_PICTURE_NUM
{
	DWORD					dwSize;						// Strcut size
	int						nNum;						// snap picture num	
}NET_CFG_PRESET_SNAP_PICTURE_NUM;

// alarm rule type
typedef enum tagEM_ALARM_RULE_TYPE
{
	EM_ALARM_RULE_UNKNOWN = -1,	// unknown
	EM_ALARM_RULE_NONE,			// no alarm
	EM_ALARM_RULE_SUCCESS,		// alarm only after success
	EM_ALARM_RULE_FAIL,			// alarm only after fail
} EM_ALARM_RULE_TYPE;

// alarm ou channel info
typedef struct tagNET_ALARM_OUT_CHANNEL_INFO
{
	EM_ALARM_RULE_TYPE		emAlarmRuleType;		// alarm rule info
	int						nAlarmOutLatch;			// delay of alarm output, unit:second, value range:1-300
	BYTE                    byReserved[128];        // reserved
} NET_ALARM_OUT_CHANNEL_INFO;

// linkage alarm channel info for face recognition
typedef struct tagNET_FACE_RECOGNITION_ALARM_CHANNEL
{
	char						szGroupID[64];			// group ID
	char						szGroupName[128];		// group name
	BOOL						bAlarmOutEnable;		// whether face recognition events link to alarm output
	UINT						nAlarmChannelNum;		// count of alarm output channel
	NET_ALARM_OUT_CHANNEL_INFO	stuAlarmChannel[64];		// info of linkage alarm output channel
	BYTE                    	byReserved[256];        	// reserved
} NET_FACE_RECOGNITION_ALARM_CHANNEL;

// config of linkage alarm channel for face recognition, corresponding to NET_EM_CFG_FACE_RECOGNITION_ALARM
typedef struct tagNET_FACE_RECOGNITION_ALARM_INFO
{
	DWORD								dwSize;						// struct size
	UINT								nFaceReconChannelNum;		// count of linkage alarm channel for face recognition
	NET_FACE_RECOGNITION_ALARM_CHANNEL	stuFaceReconChannel[50];		// info of linkage alarm channel for face recognition
} NET_FACE_RECOGNITION_ALARM_INFO;

// The type of contents
typedef enum tagNET_EM_SCREEN_SHOW_CONTENTS
{
	EM_TRAFFIC_LATTICE_SCREEN_UNKNOWN = 0,				// Unknown
	EM_TRAFFIC_LATTICE_SCREEN_PLATENUMBE,				// PlateNumber
	EM_TRAFFIC_LATTICE_SCREEN_SYSTIME,					// System time
	EM_TRAFFIC_LATTICE_SCREEN_PARKTIME,					// Parking time
	EM_TRAFFIC_LATTICE_SCREEN_MASTEROFCAR,				// Car owner
	EM_TRAFFIC_LATTICE_SCREEN_USERTYPE,					// User type
	EM_TRAFFIC_LATTICE_SCREEN_REMAINDAY,				// Expiration date
	EM_TRAFFIC_LATTICE_SCREEN_PARKCHARGE,				// Parking fee
	EM_TRAFFIC_LATTICE_SCREEN_REMAINSPACE,				// Remaining space
	EM_TRAFFIC_LATTICE_SCREEN_SYSDATE,					// System date
	EM_TRAFFIC_LATTICE_SCREEN_PASSICONCIRCLE,			// The traffic light of vehicle pass(red O and green O)
	EM_TRAFFIC_LATTICE_SCREEN_PASSICONARROW,			// The traffic light of vehicle pass(red X and green ->)
	EM_TRAFFIC_LATTICE_SCREEN_INTIME,					// Entry time
	EM_TRAFFIC_LATTICE_SCREEN_OUTTIME,					// Departure time
	EM_TRAFFIC_LATTICE_SCREEN_REMARKS,					// Remarks
	EM_TRAFFIC_LATTICE_SCREEN_RESOURCE,					// Resource(video or picture)
	EM_TRAFFIC_LATTICE_SCREEN_CUSTOM,					// Custom information
}NET_EM_SCREEN_SHOW_CONTENTS;

// lattice screen show contents
typedef struct tagNET_TRAFFIC_LATTICE_SCREEN_SHOW_CONTENTS
{
	NET_EM_SCREEN_SHOW_CONTENTS	emContents;				// The type of contents 
	BYTE						byReserved1[4];			// Byte alignment
	char						szCustomStr[32];		// Custom string, valid when emContents is EM_TRAFFIC_LATTICE_SCREEN_CUSTOM
	BYTE						byReserved[32];			// Reserved
}NET_TRAFFIC_LATTICE_SCREEN_SHOW_CONTENTS;

// lattice screen show contents
typedef struct tagNET_TRAFFIC_LATTICE_SCREEN_SHOW_INFO
{
	NET_TRAFFIC_LATTICE_SCREEN_SHOW_CONTENTS	stuContents[64];		// lattice screen show contents
	int											nContentsNum;			// The number of contents
	BYTE										byReserved[1020];		// Reserved
}NET_TRAFFIC_LATTICE_SCREEN_SHOW_INFO;

// The config of traffic lattice screen, corresponding to NET_EM_CFG_TRAFFIC_LATTICE_SCREEN
typedef struct tagNET_CFG_TRAFFIC_LATTICE_SCREEN_INFO
{
	DWORD									dwSize;						// Structure size
	int										nStatusChangeTime;			// Sataus change time, unit:s range:10 ~ 60
	NET_TRAFFIC_LATTICE_SCREEN_SHOW_INFO	stuNormal;					// Normal
	NET_TRAFFIC_LATTICE_SCREEN_SHOW_INFO	stuCarPass;					// Car pass
}NET_CFG_TRAFFIC_LATTICE_SCREEN_INFO;

#define NET_MAX_PLATEENABLE_NUM			16      // The maximum number of plate enable
#define NET_MAX_BROADCAST_ELEMENT_NUM	64      // The maximum number of broadcast element

// plate enable type
typedef enum tagNET_EM_PLATEENABLE_TYPE
{
	EM_PLATEENABLE_UNKNOWN = 0,					// Unknown
	EM_PLATEENABLE_TIPS,						// Tips
	EM_PLATEENABLE_PLATE,						// Plate
	EM_PLATEENABLE_ELEMENT,						// Element
} NET_EM_PLATEENABLE_TYPE;

// The type of element
typedef enum tagNET_EM_VOICE_BROADCAST_ELEMENT_TYPE
{
	EM_VOICE_BROADCAST_ELEMENT_UNKNOWN = 0,		// Unknown
	EM_VOICE_BROADCAST_ELEMENT_PLATENUMBER,		// PlateNumber
	EM_VOICE_BROADCAST_ELEMENT_PARKTIME,		// Parking time
	EM_VOICE_BROADCAST_ELEMENT_PARKCHARGE,		// Parking fee
	EM_VOICE_BROADCAST_ELEMENT_USERTYPE,		// User type
	EM_VOICE_BROADCAST_ELEMENT_REMAINDAY,		// Expiration date
	EM_VOICE_BROADCAST_ELEMENT_INTIME,			// Entry time
	EM_VOICE_BROADCAST_ELEMENT_OUTTIME,			// Departure time
	EM_VOICE_BROADCAST_ELEMENT_REMARKS,			// Remarks
	EM_VOICE_BROADCAST_ELEMENT_CUSTOM,			// Custom, = szPrefix + szPostfix
}NET_EM_VOICE_BROADCAST_ELEMENT_TYPE;

// Element
typedef struct tagNET_TRAFFIC_VOICE_BROADCAST_ELEMENT
{
	NET_EM_VOICE_BROADCAST_ELEMENT_TYPE	emType;		// Type
	BYTE						byReserved1[4];		// Byte alignment
	char						szPrefix[512];		// Prefix
	char						szPostfix[512];		// Postfix
	BYTE						byReserved[1024];	// Reserved
}NET_TRAFFIC_VOICE_BROADCAST_ELEMENT;

//The config of traffic voice broadcast, corresponding to NET_EM_CFG_TRAFFIC_VOICE_BROADCAST
typedef struct tagNET_CFG_TRAFFIC_VOICE_BROADCAST_INFO
{
	DWORD									dwSize;								// Structure size
	int										nEnableCount;                       // The number of Enable
	NET_EM_PLATEENABLE_TYPE					emEnable[NET_MAX_PLATEENABLE_NUM];  // The type of Enable, corresponding to NET_EM_PLATEENABLE_TYPE
	char									szNormalCar[MAX_PATH];              // The normal car pass, such as play audio file "welcome.wav"
	char									szTrustCar[MAX_PATH];               // The trust car pass, such as play audio file "welcome.wav"
	char									szSuspiciousCar[MAX_PATH];          // The suspicious car pass, such as play audio file "unknowcar.wav"
	NET_TRAFFIC_VOICE_BROADCAST_ELEMENT		stuElement[NET_MAX_BROADCAST_ELEMENT_NUM];	// The element information
	int										nElementNum;						// The number of element
}NET_CFG_TRAFFIC_VOICE_BROADCAST_INFO;

// snap shot Type
typedef enum tagNET_EM_SNAP_SHOT_TYPE
{
	NET_EM_SNAP_SHOT_TYPE_UNKNOWN = 0,											// Unknown
	NET_EM_SNAP_SHOT_TYPE_NEAR,													// Near
	NET_EM_SNAP_SHOT_TYPE_MEDIUM,												// Medium
	NET_EM_SNAP_SHOT_TYPE_FAR,													// Far
	NET_EM_SNAP_SHOT_TYPE_FEATURE,												// Feature
}NET_EM_SNAP_SHOT_TYPE;				

// snap shot interval mode
typedef enum tagNET_EM_SNAP_SHOT_INTERVAL_MODE
{
	NET_EM_SNAP_SHOT_INTERVAL_UNKNOWN = 0,										// Unknown
	NET_EM_SNAP_SHOT_INTERVAL_TIME,												// Time interval, at this mode nSingleInterval is enable
	NET_EM_SNAP_SHOT_INTERVAL_FRAMEADAPTSPEED,									// Frame interval adapt speed
	NET_EM_SNAP_SHOT_INTERVAL_FRAME,											// Frame interval
}NET_EM_SNAP_SHOT_INTERVAL_MODE;

// The information of snap shot with rule 
typedef struct tagNET_SNAP_SHOT_WITH_RULE_INFO
{
	UINT								nRuleId;
	DWORD							dwRuleType;									// Rule type, see "intelligent analyse event type" in dhnetsdk.h
	UINT								nSnapShotNum;							// The number of images to snap shot
	NET_EM_SNAP_SHOT_TYPE			emSnapShotType[MAX_SNAP_SHOT_NUM];			// The type of image to snap shot
	UINT							nSingleInterval[MAX_SNAP_SHOT_NUM];			// The array of snap shot interval,Unit:s, first item:5~180 default:10, Other item:Snap interval 1~3600 default:20
	NET_EM_SNAP_SHOT_INTERVAL_MODE	emIntervalMode;								// The mode of snap shot interval
	BYTE							byReserved[1024];							// Reserved
}NET_SNAP_SHOT_WITH_RULE_INFO;

// The information of snap shot with rule2 
typedef struct tagNET_SCENE_SNAP_SHOT_WITH_RULE2_INFO
{
	UINT							nPresetID;									// PresetID
	UINT								nRetSnapShotRuleNum;						// The available number in stuSnapShotWithRule
	NET_SNAP_SHOT_WITH_RULE_INFO	stuSnapShotWithRule[32];					// The information of snap shot with rule 
	BYTE							byReserved[1024];							// Reserved
}NET_SCENE_SNAP_SHOT_WITH_RULE2_INFO;

// The config of Scene snap shot with rule2  corresponding to NET_EM_CFG_SCENE_SNAP_SHOT_WITH_RULE2
typedef struct tagNET_CFG_SCENE_SNAP_SHOT_WITH_RULE2_INFO
{
	DWORD									dwSize;								// Structure size
	UINT										nMaxRuleNum;						// The maximum number of snap shot information user alloc (pstuSceneSnapShotWithRule)
	UINT										nRetRuleNum;						// The available number of snap shot information
	NET_SCENE_SNAP_SHOT_WITH_RULE2_INFO*	pstuSceneSnapShotWithRule;			// Snap shot information,alloc and delete by user
}NET_CFG_SCENE_SNAP_SHOT_WITH_RULE2_INFO;

// Door Bell Type
typedef enum tagNET_EM_DOORBELL_TYPE
{
	NET_EM_DOORBELL_UNKNOWN = -1,               // Unknown
    NET_EM_DOORBELL_UNCONNECTED,                // Unconnected
	NET_EM_DOORBELL_MECHANICAL,                 // Mechanical
	NET_EM_DOORBELL_ELECTRONIC,                 // Electronic
} NET_EM_DOORBELL_TYPE;

// The config of external door bell, corresponding to NET_EM_CFG_DOORBELL_EXTERNALDOORBELL
typedef struct tagNET_CFG_DOORBELL_EXTERNALDOORBELL
{
    DWORD                               dwSize;             // Structure size
    NET_EM_DOORBELL_TYPE                emDoorBellType;     // Door bell type
    BOOL                                bEnable;            // External door bell enable
}NET_CFG_DOORBELL_EXTERNALDOORBELL;

// Mount mode
typedef enum tagEM_MOUNT_MODE
{
    EM_MOUNT_MODE_UNKNOWN,
    EM_MOUNT_MODE_INDOOR,       // "Indoor"
    EM_MOUNT_MODE_OUTDOOR,      // "Outdoor"
}EM_MOUNT_MODE;

// The config of external door bell, corresponding to NET_EM_CFG_DOORBELL_EXTERNALDOORBELL
typedef struct tagNET_CFG_WIFI_INSTALL_PARAM
{
    DWORD                       dwSize;                             // Structure size
    char                        szCountry[4];                       // Country/area
    EM_MOUNT_MODE               emMountMode;                        // Mount mode
    BYTE                        byReserved[4];                     // Byte alignment
}NET_CFG_WIFI_INSTALL_PARAM;

// The config information of KVM main node
typedef struct tagNET_CFG_KVM_MAIN_NODE_INFO
{
    int                 nLevel;                            // level
    char                szAddress[128];                    // KVM main node output address
    BYTE                byReserved[128];                   // reserved
} NET_CFG_KVM_MAIN_NODE_INFO;

// The config of KVM main node, corresponding to NET_EM_CFG_KVM_MAIN_NODE
typedef struct tagNET_CFG_KVM_MAIN_NODE
{
    DWORD                      dwSize;                         // structure size
    UINT                       nMainNodeNum;                   // number of main node 
    NET_CFG_KVM_MAIN_NODE_INFO stuMainNodeInfo[1024];          // kvm main node information
} NET_CFG_KVM_MAIN_NODE;

//Hot key function name
typedef enum tagNET_EM_KVM_HOTKEY_FUNCTION_NAME
{
    EM_KVM_HOTKEY_FUNCTION_NAME_UNKNOWN,                // unknown
    EM_KVM_HOTKEY_FUNCTION_NAME_SPLITMENU,              // split menu
    EM_KVM_HOTKEY_FUNCTION_NAME_GETMENU,                // get menu
    EM_KVM_HOTKEY_FUNCTION_NAME_PUSHMENU,               // push menu
    EM_KVM_HOTKEY_FUNCTION_NAME_BASEINFOMENU            // base info menu
}EM_KVM_HOTKEY_FUNCTION_NAME;

// The config information of KVM hot key
typedef struct tagNET_CFG_KVM_HOT_KEY_INFO
{
    int                            nKeyNum;               // the element number of one complete key
    int                            szKey[3];              // hot key
    EM_KVM_HOTKEY_FUNCTION_NAME    emFuncName;            // function name
    BYTE                           byReserved[128];       // reserved
}NET_CFG_KVM_HOT_KEY_INFO;

// The config of KVM hot key, corresponding to NET_EM_CFG_KVM_HOT_KEY
typedef struct tagNET_CFG_KVM_HOT_KEY
{
    DWORD                     dwSize;                           // structure size
    int                       nHotKeyNum;                       // number of hot key information
    NET_CFG_KVM_HOT_KEY_INFO  stuHotKeyInfo[64];                // hot key information
}NET_CFG_KVM_HOT_KEY;

// The config of KM transmission and encrypt, corresponding to NET_EM_CFG_KM_TRANS_ENCRYPT
typedef struct tagNET_CFG_KM_TRANS_ENCRYPT
{
    DWORD               dwSize;                         // structure size
    BOOL                bEnable;                        // enable transmission, encrypt key and mouse; true:able, fals:disable
}NET_CFG_KM_TRANS_ENCRYPT;

// Maintenance configuration of thermal imaging machine core, corresponding to NET_EM_CFG_SENSOR_MAINTAIN
typedef struct tagNET_CFG_SENSOR_MAINTAIN
{
    DWORD                       dwSize;                     //  Structure size
    BOOL                        bEnable;                    // Whether to enable maintenance function, must fill in
    DH_TSECT                    stuTimeSection[DH_TSCHE_DAY_NUM][DH_TSCHE_SEC_NUM];     /*Time period is a two-dimensional array. 
        The first seven elements correspond to seven days a week, and the eighth element corresponds to holidays, with a maximum of six time periods per day.*/
    
    
}NET_CFG_SENSOR_MAINTAIN;

// Limitation of Pitch Angle in Laser Ranging, corresponding to  NET_EM_CFG_TILT_LIMIT
typedef struct tagNET_CFG_TILT_LIMIT
{
    DWORD                       dwSize;                 // Structure size
    int                         nUp;                    // Upper pitch angle, accuracy 0.1, actual value has been expanded 10 times, range [0,900]
    int                         nDown;                  // Lower pitch angle, accuracy 0.1, actual value has been expanded 10 times, range [-900,0]
    BYTE                        byReserve[4];           // Reserve bytes for byte alignment
}NET_CFG_TILT_LIMIT;

// Entrance guard face recognition configuration, corresponding to NET_EM_CFG_ACS_FACE_RECOGNITION_SCHEME
typedef struct tagNET_CFG_ACS_FACE_RECOGNITION_SCHEME
{
    DWORD                           dwSize;                 // Structure size 
    UINT                            nMode;                  // Face recognition mode
}NET_CFG_ACS_FACE_RECOGNITION_SCHEME;

// composit channel bind mode
typedef enum tagEM_COMPOSIT_CHANNEL_BIND_MODE
{
    EM_COMPOSIT_CHANNEL_BIND_MODE_UNKNOWN,                        // unknown
    EM_COMPOSIT_CHANNEL_BIND_MODE_AUTOMATIC,                      // automatic
    EM_COMPOSIT_CHANNEL_BIND_MODE_SEMIAUTOMATIC,                  // semiautomatic
    EM_COMPOSIT_CHANNEL_BIND_MODE_MANUAL,                         // manual
} EM_COMPOSIT_CHANNEL_BIND_MODE; 

// start stream enbale
typedef enum tagEM_CAN_START_STREAM
{
    EM_CAN_START_STREAM_UNKNOWN = -1,                                               // unknown
    EM_CAN_START_STREAM_OFF,                                                        // can't start stream
    EM_CAN_START_STREAM_ON,                                                         // can start stream
} EM_CAN_START_STREAM;

// record enable
typedef enum tagEM_IS_RECORD
{
    EM_IS_RECORD_UNKNOWN,                                                           // unknown
    EM_IS_RECORD_ON,                                                                // can record
    EM_IS_RECORD_OFF,                                                               // can't record
} EM_IS_RECORD;

// Record default config, corresponding to NET_CFG_COURSE_RECORD_DEFAULT_CONFIG
typedef struct tagNET_CFG_COURSE_RECORD_DEFAULT_CONFIG
{
    DWORD                                     dwSize;                               // structure size 
    UINT                                      nCompositChannelMode;                 // composit channel mode
    int                                       nCanStartStreamNum;                   // start stream enable logical channel number
    int                                       nIsRecordNum;                         // record enable logical channel number
    EM_CAN_START_STREAM                       emCanStartStream[64];                 // start stream enable
    EM_IS_RECORD                              emIsRecord[64];                       // record enable
    EM_COMPOSIT_CHANNEL_BIND_MODE             emCompositChannelBindMode;            // composit channel bind mode
	BYTE						              byReserved[4];	                    // reserved
}NET_CFG_COURSE_RECORD_DEFAULT_CONFIG;


// lift controller option
typedef struct tagNET_CFG_LIFTCONTROL_OPTION
{
	DWORD										dwSize;			// struct size
	BOOL										bEnable;		// TRUE:enable, FALSE:unenable
}NET_CFG_LIFTCONTROL_OPTION;

// config type
typedef enum tagNET_EM_CFG_OPERATE_TYPE
{
    NET_EM_CFG_SNAP_MODE,                   // Snap Mode Config
    NET_EM_CFG_DEV_CAR_COACH,               // Railway record config,corresponding to struct NET_DEV_CAR_COACH_INFO
	NET_EM_CFG_YUEQING_SUPPLYLIGHTING,		// YueQing External lighting configuration, corresponding to struct NET_YUEQING_SUPPLYLIGHTING_INFO
	NET_EM_CFG_MEDIA_GLOBAL,                // media global config,corresponding to struct NET_MEDIA_GLOBAL_INFO
	NET_EM_CFG_PARKINGSPACECELL_STATUS,		// parking space(The setting of special parking spaces and ordinary parking spaces), corresponding NET_PARKINGSPACECELL_STATUS_INFO
	NET_EM_CFG_PARKINGSPACELIGHT_STATE,		// parking space light state, corresponding NET_PARKINGSPACELIGHT_STATE_INFO
	NET_EM_CFG_COAXIAL_LIGHT,				// Coaxial Light Config, corresponding to struct NET_CFG_COAXIAL_LIGHT_INFO
	NET_EM_CFG_VIDEO_OUT,				    // VideoOut config, corresponding to NET_CFG_VIDEO_OUT_INFO

	NET_EM_CFG_MEDIA_ENCRYPT=9,				// media encrypt config,corresponding to NET_MEDIA_ENCRYPT_INFO,not related to channels,ChannelID must be fill in -1
    NET_EM_CFG_COUNTRY,                     // Country/area config,corresponding to NET_CFG_COUNTRY_INFO, not related to channels,ChannelID must be fill in -1
    NET_EM_CFG_VIDEOSTANDARD,               // Video standard config,corresponding to NET_CFG_VIDEOSTANDARD_INFO, not related to channels,ChannelID must be fill in -1, device currently not support SECAM 
	NET_EM_CFG_SERIAL_PUSH_LOG,				// Serial push log corresponding to NET_CFG_SERIALPUSHLOG_INFO,not related to channels,ChannelID must be fill in -1
	NET_EM_CFG_PRESET_SNAP_PICTURE_NUM,		// snap picture num of preset point,related to NET_CFG_PRESET_SNAP_PICTURE_NUM
	NET_EM_CFG_DOWNLOAD_ENCRYPT,			// download file encrypt config,corresponding to NET_DOWNLOAD_ENCRYPT_INFO,not related to channels,ChannelID must be fill in -1
	NET_EM_CFG_LIFT_CONTROL_OPTION,			// lift controller option, corresponding to NET_CFG_LIFTCONTROL_OPTION,not related to channels,ChannelID must be fill in -1

	/*********the configuration about OSD*************************************************************************************/
	NET_EM_CFG_CHANNELTITLE = 1000,         // Encode widget-channel title config, corresponding to struct NET_OSD_CHANNEL_TITLE, emOsdBlendType in struct must be set
	NET_EM_CFG_TIMETITLE,               	// Encode widget-Time title config, corresponding to NET_OSD_TIME_TITLE, emOsdBlendType in struct must be set
	NET_EM_CFG_CUSTOMTITLE,             	// Encode widget-Self-defined title config, corresponding to NET_OSD_CUSTOM_TITLE, emOsdBlendType  in struct must be set
	NET_EM_CFG_CUSTOMTITLETEXTALIGN,    	// Encode widget-Self-defined title alignment config, corresponding to NET_OSD_CUSTOM_TITLE_TEXT_ALIGN
	NET_EM_CFG_OSDCOMMINFO,             	// Encode widget-common info config, corresponding to NET_OSD_COMM_INFO
	NET_EM_CFG_OSD_PTZZOOM,					// Encode widget-PTZ zoom config, corresponding to NET_OSD_PTZZOOM_INFO
	NET_EM_CFG_GPSTITLE,                    // Encode widget-GPS title,corresponding to NET_OSD_GPS_TITLE
	NET_EM_CFG_OSD_NUMBERSTATPLAN,          // Configuration of the statistical plane,which about number of people,  use this config when Class type is NumberStatPlan, correspinding to NET_OSD_NUMBER_PLAN
	NET_EM_CFG_GPSSTARNUM_OSD,              // GPS Start number OSD config, used by vehicle equipment , corresponding to NET_CFG_GPSSTARNUM_OSD_INFO
	NET_EM_CFG_PICTURETITLE,				// Picture title,corresponding to NET_OSD_PICTURE_TITLE
	NET_EM_CFG_OSD_FACEFLOWSTAT,			// face flow stat,corresponding to NET_OSD_FACEFLOWSTAT_INFO

    NET_EM_CFG_PTZ_PRESET,		            // Preset Point Information Overlay,corresponding to NET_OSD_CFG_PTZ_PRESET
    NET_EM_CFG_PTZ_PATTERN,		            // Display Path Percentage Overlay Configuration,corresponding to NET_OSD_CFG_PTZ_PATTERN
    NET_EM_CFG_PTZ_RS485_DETECT,		    // Overlay Configuration of Displaying RS485 Test Results,corresponding to NET_OSD_CFG_PTZ_RS485_DETECT
    NET_EM_CFG_PTZ_COORDINATES,		        // Overlay configuration of display platform coordinates,corresponding to NET_OSD_CFG_PTZ_COORDINATES
    NET_EM_CFG_PTZ_DIRECTION,		        // 	Overlay configuration for displaying the direction of the platform,corresponding to NET_OSD_CFG_PTZ_DIRECTION
    NET_EM_CFG_TEMPERATURE,		            // Overlay Configuration of Displaying Ambient Temperature,corresponding to NET_OSD_CFG_TEMPERATURE
    NET_EM_CFG_COVERS,		                // Cover Configuration ,corresponding to NET_OSD_CFG_COVERS
    NET_EM_CFG_USER_DEF_TITLE,		        // User defined OSD title, corresponding to NET_OSD_USER_DEF_TITLE
	/*********the configuration about Encode**********************************************************************************/
	NET_EM_CFG_ENCODE_VIDEO = 1100,			// Encode-video options config, corresponding to NET_ENCODE_VIDEO_INFO
	NET_EM_CFG_ENCODE_VIDEO_PACK,			// Encode-video pack options config, corresponding to NET_ENCODE_VIDEO_PACK_INFO
	NET_EM_CFG_ENCODE_VIDEO_SVC,			// Encode-video SVC options config, corresponding to NET_ENCODE_VIDEO_SVC_INFO
	NET_EM_CFG_ENCODE_VIDEO_PROFILE,		// Encode-video profile options config, corresponding to NET_ENCODE_VIDEO_PROFILE_INFO
	NET_EM_CFG_ENCODE_AUDIO_COMPRESSION,	// Encode-video audio compression options config, corresponding to NET_ENCODE_AUDIO_COMPRESSION_INFO
	NET_EM_CFG_ENCODE_AUDIO_INFO,			// Encode-video audio options config, corresponding to NET_ENCODE_AUDIO_INFO
	NET_EM_CFG_ENCODE_SNAP_INFO,			// Encode-video snap options config, corresponding to NET_ENCODE_SNAP_INFO
	NET_EM_CFG_ENCODE_SNAPTIME, 			// Encode-video snap time options config, corresponding to NET_ENCODE_SNAP_TIME_INFO
	NET_EM_CFG_ENCODE_CHANNELTITLE,			// Encode-video channel title options config, corresponding to NET_ENCODE_CHANNELTITLE_INFO
	
	/**********the configuration about audio**********************************************************************************/
	NET_EM_CFG_AUDIOIN_SOURCE = 1200,		// Audio-input audio source config, corresponding to NET_ENCODE_AUDIO_SOURCE_INFO
	NET_EM_CFG_AUDIOIN_DENOISE,				// Audio-denoise config, corresponding to NET_AUDIOIN_DENOISE_INFO
	NET_EM_CFG_AUDIOIN_VOLUME,				// Audio-volume of audio input, corresponding to NET_AUDIOIN_VOLUME_INFO
	NET_EM_CFG_AUDIOOUT_VOLUME,				// Audio-volume of audio output, corresponding to NET_AUDIOOUT_VOLUME_INFO
	
	/**********the configuration about video**********************************************************************************/
	NET_EM_CFG_VIDEOIN_SWITCHMODE = 1300,	// VideoIn-switch mode config, corresponding to NET_VIDEOIN_SWITCH_MODE_INFO
	NET_EM_CFG_VIDEOIN_COLOR,				// VideoIn-color options config, corresponding to NET_VIDEOIN_COLOR_INFO			
	NET_EM_CFG_VIDEOIN_IMAGE_OPT,			// VideoIn-image options config, corresponding to NET_VIDEOIN_IMAGE_INFO
	NET_EM_CFG_VIDEOIN_STABLE,				// VideoIn-stable config, corresponding to NET_VIDEOIN_STABLE_INFO
	NET_EM_CFG_VIDEOIN_IRISAUTO,			// VideoIn-auto iris config-, corresponding to NET_VIDEOIN_IRISAUTO_INFO
	NET_EM_CFG_VIDEOIN_IMAGEENHANCEMENT,	// VideoIn-image enhancement config, corresponding to NET_VIDEOIN_IMAGEENHANCEMENT_INFO
	NET_EM_CFG_VIDEOIN_EXPOSURE_NORMAL,		// VideoIn-normal exposure config, corresponding to NET_VIDEOIN_EXPOSURE_NORMAL_INFO
	NET_EM_CFG_VIDEOIN_EXPOSURE_OTHER,		// VideoIn-other exposure config, corresponding to NET_VIDEOIN_EXPOSURE_OTHER_INFO
	NET_EM_CFG_VIDEOIN_EXPOSURE_SHUTTER,	// VideoIn-exposure shutter config, corresponding to NET_VIDEOIN_EXPOSURE_SHUTTER_INFO
	NET_EM_CFG_VIDEOIN_BACKLIGHT,			// VideoIn-back light config, corresponding to NET_VIDEOIN_BACKLIGHT_INFO
	NET_EM_CFG_VIDEOIN_INTENSITY,			// VideoIn-Intensity config, corresponding to NET_VIDEOIN_INTENSITY_INFO
	NET_EM_CFG_VIDEOIN_LIGHTING,			// VideoIn-lighting config, corresponding to NET_VIDEOIN_LIGHTING_INFO
	NET_EM_CFG_VIDEOIN_DEFOG,				// VideoIn-defog config, corresponding to NET_VIDEOIN_DEFOG_INFO
	NET_EM_CFG_VIDEOIN_FOCUSMODE,			// VideoIn-focus mode config, corresponding to NET_VIDEOIN_FOCUSMODE_INFO
	NET_EM_CFG_VIDEOIN_FOCUSVALUE,			// VideoIn-focus options config, corresponding to NET_VIDEOIN_FOCUSVALUE_INFO
	NET_EM_CFG_VIDEOIN_WHITEBALANCE,		// VideoIn-white balance config, corresponding to NET_VIDEOIN_WHITEBALANCE_INFO
	NET_EM_CFG_VIDEOIN_DAYNIGHT,			// VideoIn-day night config, corresponding to NET_VIDEOIN_DAYNIGHT_INFO
	NET_EM_CFG_VIDEOIN_DAYNIGHT_ICR,		// VideoIn-ICR config, corresponding to NET_VIDEOIN_DAYNIGHT_ICR_INFO
	NET_EM_CFG_VIDEOIN_SHARPNESS,			// VideoIn-shrpness config, corresponding to NET_VIDEOIN_SHARPNESS_INFO
	NET_EM_CFG_VIDEOIN_COMM_DENOISE,		// VideoIn-comm denoise config, corresponding to NET_VIDEOIN_DENOISE_INFO
	NET_EM_CFG_VIDEOIN_3D_DENOISE,			// VideoIn-3D denoise config, corresponding to NET_VIDEOIN_3D_DENOISE_INFO
	NET_EM_CFG_VIDEOIN_FOCUSEX,				// VideoIn-foucus on extended configuratio corresponding to NET_VIDEOIN_FOCUS_INFO_EX
    NET_EM_CFG_VIDEOIN_LIGHTINGEX,			// Extension of supplementary lamp configurationcorresponding to NET_VIDEOIN_LIGHTINGEX_INFO
	/***********the configuration about case**********************************************************************************/
	NET_EM_CFG_ENCODE_PLAN = 1400,			// Case-the plan config of encode, corresponding to NET_ENCODE_PLAN_INFO
	NET_EM_CFG_COMPOSE_CHANNEL,				// Compose channel config, corresponding to NET_COMPOSE_CHANNEL_INFO
	
    /***********the configuration about alarm gateway ************************************************************************/
    NET_EM_CFG_ALARM_SOUND 		= 1500,		// alarm sound config of alarm gateway, corresponding to NET_ALARM_SOUND_INFO 
    NET_EM_CFG_LOCAL_EXT_ALARM 	= 1501,		// Local ext alarm config,corresponding to NET_LOCAL_EXT_ALARM_INFO,ChannelID is invalid
	NET_EM_CFG_REMOTE_ALARM_BELL= 1502,		// Remote Alarm Bell Config, corresponding to NET_CFG_REMOTE_ALARM_BELL_INFO
	NET_EM_CFG_FIRE_WARNINGMODE = 1503,		 // Fire Warning Mode, corresponding to NET_FIREWARNING_MODE_INFO
	NET_EM_CFG_FIRE_WARNING = 1504,			 // Fire Warning Config, corresponding to NET_FIRE_WARNING_INFO
    NET_EM_CFG_HOT_COLD_SPOT_WARNING = 1505, // hot cold spot warning config, corresponding to NET_HOT_COLD_SPOT_WARNING_INFO
	NET_EM_CFG_COAXIAL_ALARMLOCAL,			 // coaxial local alarm config, corresponding to NET_COAXIAL_ALARMLOCAL_INFO

    /**********network application configuration***********************************************************************************************/
    NET_EM_CFG_ACCESS_POINT 	= 1600,		// WIFI server configuration(access point),corresponding to NET_NETAPP_ACCESSPOINT
	NET_EM_CFG_LDAP,						// LDAP configuration, corresponding to NET_NETAPP_LDAP
	NET_EM_CFG_SYSLOG,						// Syslog configuration, corresponding to NET_NETAPP_SYSLOG	
    NET_EM_CFG_NETAUTOADAPTTRANSIT,         // net auto adapt transit configuration,corresponding to NET_NETAUTOADAPTTRANSIT
	NET_EM_CFG_WIRELESS,					// Cellular NetWork, corresponding to NET_NETAPP_WIRELESS

	NET_EM_CFG_NAS				= 1700,		// NAS config, corresponding to NET_NAS_INFO 
	NET_EM_CFG_PPPOE,						// PPPOE configcorresponding to  NET_PPPOE_INFO  
	NET_EM_CFG_EMAIL,						// Email configcorresponding to  NET_EMAIL_INFO  
	NET_EM_CFG_DDNS,						// DDNS configcorresponding to  NET_DDNS_INFO 

	/**************SCADA configuration****************************************************************************************/
	NET_EM_CFG_SCADA_PROTOCOLS_MANAGER  = 1800,   	// Protocol manager config,corresponding to NET_SCADA_PROTOCOLS_MANAGER
	NET_EM_CFG_SCADA_DEVICEINFO_CFG,			  	// Device info config, corresponding to NET_SCADA_DEVICEINFO_CFG
	NET_EM_CFG_SCADA_CONTROLLER_SITE,			    // Controller config corresponding to NET_CFG_SCADA_CONTROLLER_SITE_INFO

	/**************NetApp configuration****************************************************************************************/
	NET_EM_CFG_NETAPP_LINK_LAYER_VPN 	= 1900,	  	// Link layer VPN config,correspongindg to NET_NETAPP_LINK_LAYER_VPN_CFG
	NET_EM_CFG_NETAPP_SSHD,							// SSHD config, correspongindg to NET_NETAPP_SSHD_CFG
    NET_EM_CFG_NETAPP_COMMUNICATION_LIST,           // Communication list config, corresponding NET_NETAPP_COMMUNICATION_LIST_CFG, not related to channels,ChannelID must be fill in -1 

	/**************Tripartite platform access configuration****************************************************************************************/
	NET_EM_CFG_VSP_CHINA_TOWER = 2000,			  	// (China tower)VSP china tower config,corresponding to NET_VSP_CHINA_TOWER 
    NET_EM_CFG_VSP_SHDXJT = 2001,				    // Access Configuration of China Telecom Mobile Shopping ,corresponding to NET_VSP_SHDXJT 
	NET_EM_CFG_VSP_CONSUME,							// consume config, corresponding to NET_CFG_VSP_CONSUME,ChannelID must be fill in -1 

	/**************intelligent configuration****************************************************************************************/
	NET_EM_CFG_STEREO_CALIBRATE = 2100,			  	// stero calibrate config, corresponding to NET_STEREO_CALIBRATE_INFO
	NET_EM_CFG_STEREO_CALIBRATEMATRIX_MULTISENSOR,	// Multi Sensor configuration, corresponding to NET_MULTI_SENSOR_INFO
	NET_EM_CFG_CROWDDISTRIMAP_CALIBRATE,			// config of the calibrate of crowddistri map, corresponding to NET_CROWDDISTRIMAP_CALIBRATE_INFO
	NET_EM_CFG_TRAFFIC_NOPASSING,					// Traffic No Passing config, corresponding to NET_TRAFFIC_NOPASSING_INFO
    NET_EM_CFG_FIGHT_CALIBRATE,                     // fight calibrate config, corresponding to NET_FIGHT_CALIBRATE_INFO
	NET_EM_CFG_FACE_RECOGNITION_ALARM,				// config of linkage alarm chanel for face recognition, corresponding to NET_FACE_RECOGNITION_ALARM_INFO
	NET_EM_CFG_STEREO_CALIBRATEMATRIX_MULTIMODE,	// Multi Mode configuration, corresponding to NET_CALIBRATEMATRIX_MULTIMODE_INFO
	NET_EM_CFG_AUTO_SNAP_SCHEDULE,                  // Timing snap configuration of intelligent aquaculture, corresponding to NET_CFG_AUTO_SNAP_SCHEDULE_INFO
	
	/**************radar configuration****************************************************************************************/
	NET_EM_CFG_RADAR            = 2200,				// radar configuration, corresponding to DEV_RADAR_CONFIG
	/**************VTH password configuration**************************************************************************************/
	NET_EM_CFG_VTH_PASSWORD		= 2300,				// VTH password configuration,corresponding to NET_CFG_VTH_PASSWORD_INFO
    NET_EM_CFG_REGISTAR         = 2301,             // registar server configuration,corresponding NET_CFG_REGISTAR_INFO
    NET_EM_CFG_SIP              = 2302,             // sip configuration, corresponding NET_CFG_SIPSERVER_INFO
	NET_EM_CFG_DEVICE_LOGIN_INFO	= 2303,			// Device Login Info configuration, corresponding to NET_CFG_DEVICE_LOGIN_INFO
	/**********Front shield cover configuration***********************************************************************************************/
	NET_EM_CFG_AELENSMASK       = 2400,             // Front shield cover configuration,corresponding to NET_CFG_AELENSMASK_INFO
	NET_EM_CFG_ULTRASONIC       = 2500,     		// ultrasonic configuration,corresponding to NET_CFG_ULTRASONIC_INFO 
    /**********ARC Configuration***********************************************************************************************/
    NET_EM_CFG_ARMSCHEDULE      = 2600,     		// arming plan configuration,corresponding to NET_CFG_ARMSCHEDULE_INFO
    NET_EM_CFG_CID_REPORT      	= 2601,             // configuration of CID report,corresponding to NET_CFG_CID_REPORT_INFO
	NET_EM_CFG_VSP_HONEYWELL    = 2602,       		// Configuration of HoneyWell server corresponding to NET_CFG_VSP_HONEYWELL_INFO
	NET_EM_CFG_KBUSER_PASSWORD	= 2603,				// Configuration of keyboard passwordcorresponding to NET_CFG_KBUSER_PASSWORD	
	/**********record snap configuration*******************************************************************************************/
    NET_EM_CFG_RECORDEXTRA		= 3610,				// RecodeExtra config, corresponding to NET_CFG_RECORDEXTRA_INFO
	NET_EM_CFG_AUTO_RECORDBACKUP_RESTORE = 3611,    // Auto record backup restore, corresponding to NET_CFG_AUTORECORDBACKUPRESTORE_INFO
	NET_EM_CFG_FACESNAPSHOT			= 3612,			// face snap shot, corresponding to NET_CFG_FACESNAPSHOT_INFO
	
	/**********video diagnosis configuration*******************************************************************************************/
	NET_EM_VIDEODIAGNOSIS_PROJECT = 3700,			// video diagnosis plan config, corresponding to NET_VIDEODIAGNOSIS_PROJECT_INFO
	NET_EM_CFG_VIDEO_DIAGNOSIS_PROJECT_MONTH = 3701,// video diagnosis plan config, corresponding to NET_CFG_VIDEODIAGNOSIS_PROJECT_MONTH_INFO,ChannelID must be -1
	/**********Position report policy configuration***********************************************************************************/
	NET_EM_CFG_POSITIONREPORTPOLICY = 3800,			// GPS postion report policy config, corresponding to NET_CFG_POSITIONREPORTPOLICY_INFO
	NET_EM_CFG_VEHICLE_WORKTIMESCHEDULE,			// Vehicle Work time schedulecorresponding to NET_CFG_VEHICLE_WORKTIMESCHEDULE_INFO
	NET_EM_CFG_VEHICLE_LOAD,						// Vehicle Load Number, corresponding to NET_CFG_VEHICLE_LOAD_INFO
	NET_EM_CFG_TICKETPRINT,							// Bus print ticket price, corresponding to NET_CFG_TICKETPRINT_INFO
	NET_EM_CFG_VEHICLEAUTOMAIN,						// The delay time to shutdown, corresponding to NET_CFG_VEHICLEAUTOMAIN_INFO
	NET_EM_CFG_VEHICLENETSERVER,					// Vehicle NetServer Configuration(India BRT), corresponding to NET_CFG_VEHICLENETSERVER_INFO
	NET_EM_CFG_IMSIBIND,							// IMSI bind configuration, corresponding to NET_CFG_IMSIBIND_INFO
	NET_EM_CFG_VEHICLE_MAINTAINCE,					// vehicle maintaince configuration,corresponding to NET_CFG_VEHICLE_MAINTAINCE_INFO
    /***********AccessControl configuration******************************************************************************************/
    NET_EM_CFG_ACCESSCTL_BLACKLIST 				= 3900,	// blacklist of accesscontrol config, corresponding to NET_CFG_ACCESSCTL_BLACKLIST
    NET_EM_CFG_ACCESSCTL_BLACKLIST_LINK 		= 3901,	// blacklist of accesscontrol link config,corresponding to NET_CFG_ALARM_MSG_HANDLE
    NET_EM_CFG_ACCESSCTL_SPECIALDAY_GROUP 		= 3902,	// holiday of accesscontrol config, corresponding to NET_CFG_ACCESSCTL_SPECIALDAY_GROUP_INFO
    NET_EM_CFG_ACCESSCTL_SPECIALDAYS_SCHEDULE 	= 3903,	// holiday schdule of accesscontrol config, corresponding to NET_CFG_ACCESSCTL_SPECIALDAYS_SCHEDULE_INFO
	NET_EM_CFG_ACCESSCTL_AUTH_MODE 				= 3904,	// online and offline open door auth mode of accesscontrol config,corresponding to NET_CFG_ACCESSCTL_AUTH_MODE
    NET_EM_CFG_ACS_FACE_RECOGNITION_SCHEME      = 3905, // Entrance guard face recognition configuration, corresponding to NET_CFG_ACS_FACE_RECOGNITION_SCHEME

    /*********** Custom configuration ************************************************************************************************/
    NET_EM_CFG_SERIALNOWHITETABLE    		= 4000,     // send serial whith list to NVR , corresponding to NET_CFG_SERIALNOWHITETABLE_INFO
    NET_EM_CFG_LXSJ_WXJJ             		= 4001,    	// wuxijiaojing , corresponding to NET_CFG_LXSJ_WXJJ_INFO
	NET_EM_CFG_SENSOR_ALARM_GLOBAL	 		= 4002,		// Sensor alarm global config corresponding to NET_CFG_SENSOR_ALARM_GLOBAL_INFO
	NET_EM_CFG_SENSOR_ALARM					= 4003,		// Sensor alarm config corresponding to NET_CFG_SENSOR_ALARM_INFO
	NET_EM_CFG_VSP_LXSJ				 		= 4004,		// VSP_LXSJ configuration corresponding to NET_CFG_VSP_LXSJ_INFO
	NET_EM_CFG_TIMINGCAPTURE		 		= 4005,		// TimingCapture configuration corresponding to NET_CFG_TIMINGCAPTURE_INFO
	NET_EM_CFG_WATER_MONITOR_TITLE	 		= 4006,		// Water monitor title configuration corresponding to NET_CFG_WATER_MONITOR_TITLE_INFO
	NET_EM_CFG_ATTENDANCE_MODEL_INFO		= 4007,		// attendance model info corresponding to  NET_CFG_ATTENDANCE_MODEL_INFO
    NET_EM_CFG_KT_RTSP_FLAG                 = 4008,		// KT's customized RTSP enabling configuration, corresponding to NET_CFG_KT_RTSP_FLAG_INFO ,ChannelID must be -1
    NET_EM_CFG_RTSP_ABORT_LIST              = 4009,		// Get a list of videos stored locally on the device after RTSP disconnection (only access, no settings), corresponding to NET_CFG_RTSP_ABORT_LIST_INFO ,ChannelID must be -1
	NET_EM_CFG_FILE_HOLD_DAYS               = 4010,		// Recording saving days configuration,corresponding to NET_CFG_FILE_HOLD_DAYS_INFO
	NET_EM_CFG_ACCESS_FUNCTION              = 4011,     // Access function config corresponding to NET_CFG_ACCESS_FUNCTION_INFO, not related to channels, ChannelID must be fill in -1
	/***********Ptz configuration************************************************************************************************/

    /***********cloud operation configuration************************************************************************************************/
    NET_EM_CFG_CLOUDUPLOADTIME    = 5000,           // cloud upload time configuration , corresponding to NET_CFG_CLOUDUPLOADTIME_INFO
	
	/***********radar adaptor configuration************************************************************************************************/
	//when call CLIENT_SetConfig, restart is invalid
	NET_EM_CFG_RADAR_MAPPARA        = 6000,         // radar map param configuration, corresponding to NET_CFG_RADAR_MAPPARA_INFO
	NET_EM_CFG_RADAR_CALIBRATION    = 6001,         // radar calibration configuration, corresponding to NET_CFG_RADAR_CALIBRATION_INFO
	NET_EM_CFG_RADAR_LINKSD         = 6002,         // radar link SD enable configuration, corresponding to NET_CFG_RADAR_LINKSD_INFO
	NET_EM_CFG_RADAR_RULELINE       = 6003,         // radar guard line configuration, corresponding to NET_CFG_RADAR_RULELINE_INFO
	NET_EM_CFG_RADAR_ANALYSERULE    = 6004,         // radar link analyse rule configuration, corresponding to NET_CFG_RADAR_ANALYSERULE_INFO
	NET_EM_CFG_RADAR_TRACKGLOBALCONFIG = 6005,      // radar track global configuration, corresponding to NET_CFG_RADAR_TRACKGLOBALCONFIG_INFO
	NET_EM_CFG_RADAR_RADARPARA		= 6006,			// radar param configuration, corresponding to NET_CFG_RADAR_RADARPARA_INFO
	NET_EM_CFG_RADAR_REMOTESDLINK	= 6007,			// radar link remote SD enable configuration, corresponding to NET_CFG_RADAR_REMOTESDLINK_INFO
	NET_EM_CFG_RADAR_RADARLINKDEVICE= 6008,			// radar link device configuration, corresponding to NET_CFG_RADAR_RADARLINKDEVICE_INFO
	NET_EM_CFG_RADAR_MAPOSDPARA		= 6009,			// radar map OSD configuration, corresponding to NET_CFG_RADAR_MAPOSDPARA_INFO

	/***********Ptz configuration************************************************************************************************/
	NET_EM_CFG_PTZ_SPEED			= 7000,			// PtzSpeed config, corresponding to NET_CFG_PTZ_SPEED
	NET_EM_CFG_PTZ_HORIZONTAL_ROTATION_GROUP_SCAN	= 7001,		// PTZ horizontal rotation group scanning, corresponding to NET_CFG_HORIZONTAL_ROTATION_GROUP_SCAN_INFO 
	NET_EM_CFG_AUTOSCAN				= 7002,						// AutoScan configuration, corresponding to NET_CFG_AUTOSCAN_INFO 

	/***********Lecheng Camera custom configuration************************************************************************************************/
	NET_EM_CFG_CASCADE_LIGHT		= 8000,			// cascade light configuration, corresponding to NET_CFG_CASCADE_LIGHT_INFO
    NET_EM_CFG_LE_SMARTTRACK        = 8001,         // LeChange simple smart track, corresponding to NET_CFG_LE_SMARTTRACK_INFO
    NET_EM_CFG_LE_LENS_MASK         = 8002,         // LeChange lens mask configuration, corresponding to NET_CFG_LE_LENS_MASK_INFO

	/***********cloud operation configuration************************************************************************************************/
	NET_EM_CFG_VSP_PAAS           = 9000,           // lecheng cloud register config configuration , corresponding to NET_CFG_CLOUDUPLOADTIME_INFO
	NET_EM_CFG_VSP_GAYS_SERVER	  = 9001,			// Public security 1 platform input config(GB server),corresponding to NET_CFG_VSP_GAYS_SERVER_INFO,ChannelID must be -1
	NET_EM_CFG_VSP_CO_SIGN_SERVER = 9002,			// Co-signing server configuration,corresponding to NET_CFG_VSP_CO_SIGN_SERVER_INFO,ChannelID must be -1
    NET_EM_CFG_VSP_GAVI           = 9003,		    // Access configuration of public security video and image information application system. Corresponding to NET_EM_CFG_VSP_GAVI.ChannelID must be -1

	/***********gateway configuration**************************************************************************************************/
	NET_EM_CFG_TRAFFICSTROBE 	  = 9100,			// gateway configuration, corresponding to NET_CFG_TRAFFICSTROBE_INFO

	/***********LED screen configuration************************************************************************************************/
	NET_EM_CFG_LED_TEXT  		  = 9200,           // LED screen display configuration,corresponding to NET_CFG_LED_TEXT
    NET_EM_CFG_LED_TEXT_ARRAY  	  = 9201,           // LED screen display array configuration,corresponding to NET_CFG_LED_TEXT_ARRAY

	/***********Disable linkage configuration*******************************************************************************************/
	NET_EM_CFG_DISABLE_LINKAGE 	  = 9300,		   	// Disable linkage configuration,corresponding to NET_CFG_DISABLE_LINKAGE,not related to channels,ChannelID must be fill in -1

	/***********Matrix configuration************************************************************************************************/
	NET_EM_CFG_MATRIX_NETKBDFASTCTRL = 9400,		// Fast control configuration of network beyboard, corresponding to NET_CFG_MATRIX_NETKBDFASTCTRL_INFO
	
	/***********Vedio configuration************************************************************************************************/
	NET_EM_CFG_VIDEO_CHANNEL_LABEL = 9600,	// configuration of channel laber, corresponding to NET_CFG_VIDEO_CHANNEL_LABEL_INFO
    NET_EM_CFG_VIDEO_IMAGE_CTRL = 9601,		// Image Rotation Setting Capability Configuration ,corresponding to NET_EM_CFG_VIDEO_IMAGE_CTRL_INFO
	
	/***********Traffic configuration***************************************************************************************************/
	NET_EM_CFG_TRAFFIC_LATTICE_SCREEN = 10000,	// The configuration of traffic lattice screen, corresponding to NET_CFG_TRAFFIC_LATTICE_SCREEN_INFO
	NET_EM_CFG_TRAFFIC_VOICE_BROADCAST = 10001,	// The configuration of traffic voice broadcast, corresponding to NET_CFG_TRAFFIC_VOICE_BROADCAST_INFO
	NET_EM_CFG_SCENE_SNAP_SHOT_WITH_RULE2= 10002, // The configuration of scene snap shot with rule2, corresponding to NET_CFG_SCENE_SNAP_SHOT_WITH_RULE2_INFO

    /***********DoorBell configuration******************************************************************************************/
	NET_EM_CFG_DOORBELL_EXTERNALDOORBELL = 11000,		// External door bell configuration, corresponding to NET_CFG_DOORBELL_EXTERNALDOORBELL, not related to channels,ChannelID must be fill in -1


    /***********Thermal imaging related configuration******************************************************************************************/
    NET_EM_CFG_SENSOR_MAINTAIN = 11100,		//Maintenance configuration of thermal imaging machine core,corresponding to NET_CFG_SENSOR_MAINTAIN
    NET_EM_CFG_TILT_LIMIT = 11101,		    // Limitation of Pitch Angle in Laser Ranging,corresponding to NET_CFG_TILT_LIMIT

    /***********KVM configuration******************************************************************************************/
    NET_EM_CFG_KVM_MAIN_NODE = 12000,                    // main node configuration of key, video and mouse, corresponding to NET_CFG_KVM_MAIN_NODE, not related to channels, ChannelID must be fill in -1
    NET_EM_CFG_KVM_HOT_KEY = 12001,                      // hot key configuration of key, video and mouse, corresponding to NET_CFG_KVM_HOT_KEY, not related to channels, ChannelID must be fill in -1
    NET_EM_CFG_KM_TRANS_ENCRYPT = 12002,                 // transmission, encrypt configuration of key and mouse, corresponding to NET_CFG_KM_TRANS_ENCRYPT, not related to channels, ChannelID must be fill in -1

	/***********Record default config******************************************************************************************/
    NET_EM_CFG_COURSE_RECORD_DEFAULT_CONFIG = 12100,     // Record default config, corresponding to NET_CFG_COURSE_RECORD_DEFAULT_CONFIG

    /***********AroundWifi configuration*****************************************************************************************/
    NET_EM_CFG_WIFI_INSTALL_PARAM = 12200,              // Wifi device install config, corresponding to NET_CFG_WIFI_INSTALL_PARAM, not related to channels,ChannelID must be fill in -1
} NET_EM_CFG_OPERATE_TYPE;


//////////////////////////////////////////////////////////////////////////
// RPC method name
//////////////////////////////////////////////////////////////////////////

#define RPC_METHOD_MONITORWALL_ADD      "monitorWallManager.addMonitorWall"     // add MonitorWall

/***********************************************************************
 ** Callback Function Definition 
 ***********************************************************************/

// Network disconnection callback function original shape 
typedef void (CALLBACK *fDisConnect)(LLONG lLoginID, char *pchDVRIP, LONG nDVRPort, LDWORD dwUser);

// network re-connection callback function original shape
typedef void (CALLBACK *fHaveReConnect)(LLONG lLoginID, char *pchDVRIP, LONG nDVRPort, LDWORD dwUser);

// The prototype of dynamic sub connection offline call function 
typedef void (CALLBACK *fSubDisConnect)(EM_INTERFACE_TYPE emInterfaceType, BOOL bOnline, LLONG lOperateHandle, LLONG lLoginID, LDWORD dwUser);

// monitor disconnect callback function
typedef void (CALLBACK *fRealPlayDisConnect)(LLONG lOperateHandle, EM_REALPLAY_DISCONNECT_EVENT_TYPE dwEventType, void* param, LDWORD dwUser);

// Real-time monitor data callback function original shape
// Obtain corresponding stream by filtering dwDataType, stream type refers to EM_REALDATA_FLAG
// The dwDataType value in stream transcoding refers to NET_DATA_CALL_BACK_VALUE
typedef void (CALLBACK *fRealDataCallBack)(LLONG lRealHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, LDWORD dwUser);

// Real-time monitor data callback function original shape---extensive
// Obtain corresponding stream by filtering dwDataType, stream type refers to EM_REALDATA_FLAG
// The dwDataType value in stream transcoding refers to NET_DATA_CALL_BACK_VALUE
typedef void (CALLBACK *fRealDataCallBackEx)(LLONG lRealHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, LONG param, LDWORD dwUser);


// Obtain corresponding stream by filtering dwDataType, stream type refers to EM_REALDATA_FLAG
// The dwDataType value in stream converting refers to NET_DATA_CALL_BACK_VALUE
// when convert stream, param refers to frame info(video frame info or audio frame info), param's type is NET_STREAMCONVERT_INFO
typedef void (CALLBACK *fRealDataCallBackEx2)(LLONG lRealHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, LLONG param, LDWORD dwUser);
// OSD callback function original shape 
typedef void (CALLBACK *fDrawCallBack)(LLONG lLoginID, LLONG lPlayHandle, HDC hDC, LDWORD dwUser);

// Playback process by time callback function original shape
typedef void (CALLBACK *fTimeDownLoadPosCallBack) (LLONG lPlayHandle, DWORD dwTotalSize, DWORD dwDownLoadSize, int index, NET_RECORDFILE_INFO recordfileinfo, LDWORD dwUser);

// Alarm message callback function original shape
typedef BOOL (CALLBACK *fMessCallBack)(LONG lCommand, LLONG lLoginID, char *pBuf, DWORD dwBufLen, char *pchDVRIP, LONG nDVRPort, LDWORD dwUser);
// explanation of new parameter: 
// bAlarmAckFlag : TRUE,the event is affirmable event;FALSE,the event is not affirmable event
// nEventID is used by CLIENT_AlarmAck, when bAlarmAckFlag is TRUE, this data is efficient
// pBuf memory was managed by SDK 
typedef BOOL (CALLBACK *fMessCallBackEx1)(LONG lCommand, LLONG lLoginID, char *pBuf, DWORD dwBufLen, char *pchDVRIP, LONG nDVRPort, BOOL bAlarmAckFlag, LONG nEventID, LDWORD dwUser);

// Listening server callback function original shape
typedef int (CALLBACK *fServiceCallBack)(LLONG lHandle, char *pIp, WORD wPort, LONG lCommand, void *pParam, DWORD dwParamLen, LDWORD dwUserData);

// Audio data of audio talk callback function original shape
// When byAudioFlag is 2pDataBuf is data without frame header,firstly should send data by CLIENT_AudioDec when byAudioFlag is 1, then callback data without frame header to user when byAudioFlag is 2
typedef void (CALLBACK *pfAudioDataCallBack)(LLONG lTalkHandle, char *pDataBuf, DWORD dwBufSize, BYTE byAudioFlag, LDWORD dwUser);

// Upgrade device callback function original shape
// nTotalSize = 0, nSendSize = -1 Indicates Upgrade Finish
// nTotalSize = 0, nSendSize = -2 Indicates Upgrade Failed
// nTotalSize = 0, nSendSize = -3 User do not have permission to upgrade
// nTotalSize = 0, nSendSize = -4 Upgrade version  too low
// nTotalSize = -1, nSendSize = XX Indicates Upgrade Progress
// nTotalSize = XX, nSendSize = XX Upgrade file transmission progress
typedef void (CALLBACK *fUpgradeCallBack) (LLONG lLoginID, LLONG lUpgradechannel, int nTotalSize, int nSendSize, LDWORD dwUser);

//Upgrade device callback function original shape, support large file upgrade for example G bytes file.
// nTotalSize = 0, nSendSize = -1 Indicates Upgrade Finish
// nTotalSize = 0, nSendSize = -2 Indicates Upgrade Failed
// nTotalSize = 0, nSendSize = -3 User do not have permission to upgrade
// nTotalSize = 0, nSendSize = -4 Upgrade version  too low
// nTotalSize = -1, nSendSize = XX Indicates Upgrade Progress
// nTotalSize = XX, nSendSize = XX Upgrade file transmission progress
typedef void (CALLBACK *fUpgradeCallBackEx) (LLONG lLoginID, LLONG lUpgradechannel, INT64 nTotalSize, INT64 nSendSize, LDWORD dwUser);

// Transparent COM callback function original shape
typedef void (CALLBACK *fTransComCallBack) (LLONG lLoginID, LLONG lTransComChannel, char *pBuffer, DWORD dwBufSize, LDWORD dwUser);

// Search device log data callback function original shape 
typedef void (CALLBACK *fLogDataCallBack)(LLONG lLoginID, char *pBuffer, DWORD dwBufSize, DWORD nTotalSize, BOOL bEnd, LDWORD dwUser);

// Snapshot callback function original shape 
// Encode Type 10: jpeg 0: number i frame of mpeg4 
typedef void (CALLBACK *fSnapRev)(LLONG lLoginID, BYTE *pBuf, UINT RevLen, UINT EncodeType, DWORD CmdSerial, LDWORD dwUser);

// GPS message subscription callback 
typedef void( CALLBACK *fGPSRev)(LLONG lLoginID, GPS_Info GpsInfo, LDWORD dwUserData);

// GPSGPS message subscription callback - extra
typedef void (CALLBACK *fGPSRevEx)(LLONG lLoginID, GPS_Info GpsInfo, ALARM_STATE_INFO stAlarmInfo, LDWORD dwUserData, void *reserved);

// GPSGPS message subscription callback - extra2
typedef void (CALLBACK *fGPSRevEx2)(LLONG lLoginID, const LPNET_GPS_LOCATION_INFO lpData, LDWORD dwUserData, void *reserved);

// GPS GPS subscription of temperature and humidity callback
typedef void (CALLBACK *fGPSTempHumidityRev)(LLONG lLoginID, GPS_TEMP_HUMIDITY_INFO GpsTHInfo, LDWORD dwUserData);

// Asynchronous data callback
typedef void (CALLBACK *fMessDataCallBack)(LLONG lCommand, LPNET_CALLBACK_DATA lpData, LDWORD dwUser);

// File Transfer callback
typedef void (CALLBACK *fTransFileCallBack)(LLONG lHandle, int nTransType, int nState, int nSendSize, int nTotalSize, LDWORD dwUser);

// intelligent analysis data callback;nSequence instruct the repeat picture's station,0 instruct the first time it appear, 2 instruct the last time it appear or it only appear once,1 instruct it will appear next time
// int nState = (int) reserved instruct current callback data's state, 0 means realtime data,1 means offline data,2 means send offline data over
typedef int  (CALLBACK *fAnalyzerDataCallBack)(LLONG lAnalyzerHandle, DWORD dwAlarmType, void* pAlarmInfo, BYTE *pBuffer, DWORD dwBufSize, LDWORD dwUser, int nSequence, void *reserved);

// Asynchronism search device call
typedef void (CALLBACK *fSearchDevicesCB)(DEVICE_NET_INFO_EX *pDevNetInfo, void* pUserData);

// Asynchronism search device call
typedef void (CALLBACK *fSearchDevicesCBEx)(LLONG lSearchHandle,DEVICE_NET_INFO_EX2 *pDevNetInfo, void* pUserData);
// Asynchronism register device call
// typedef void (CALLBACK *fHaveLogin)(LLONG lLoginID, char *pchDVRIP, LONG nDVRPort, BOOL bOnline, NET_DEVICEINFO_Ex stuDeviceInfo, int nError, LDWORD dwUser, void *reserved);

// playback YUV callback function
typedef void (CALLBACK *fYUVDataCallBack)(LLONG lPlaybackHandle, BYTE *pBuffer, DWORD dwBufSize, LONG param, LDWORD dwUser, void *reserved);

// Subscribe log data callback
typedef void (CALLBACK *fSubLogDataCallBack)(LLONG lLogHandle, NET_EM_LOG_QUERY_TYPE emLogType, const DH_DEVICE_LOG_ITEM_EX *pstuLogData, const int nCount, LDWORD dwUser, void *reserved);

/************************************************************************
 ** Interface Definition 
 ***********************************************************************/

// SDK Initialization 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Init(fDisConnect cbDisConnect, LDWORD dwUser);

// SDK Initialization, specify initialization parameter through struct NETSDK_INIT_PARAM,
// e.g., netsdk's normal network process thread number.
// equivalent to CLIENT_Init when lpInitParam is NULL
CLIENT_NET_API BOOL CALL_METHOD CLIENT_InitEx(fDisConnect cbDisConnect, LDWORD dwUser, LPNETSDK_INIT_PARAM lpInitParam );

// SDK exit and clear
CLIENT_NET_API void CALL_METHOD CLIENT_Cleanup();

//set run mode parameter, should be called before after CLIENT_Init
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetRunModeParams(NET_RUNMODE_PARAMS *pstuRunParams);

//------------------------------------------------------------------------

// Set re-connection callback function after disconnection. Internal SDK  auto connect again after disconnection 
CLIENT_NET_API void CALL_METHOD CLIENT_SetAutoReconnect(fHaveReConnect cbAutoConnect, LDWORD dwUser);

// Dynamic sub-set link disconnected callback function, the current monitoring and playback equipment SVR is a short connection
CLIENT_NET_API void CALL_METHOD CLIENT_SetSubconnCallBack(fSubDisConnect cbSubDisConnect, LDWORD dwUser);

// Return the function execution failure code
CLIENT_NET_API DWORD CALL_METHOD CLIENT_GetLastError(void);

// Set device connection timeout value and trial times 
CLIENT_NET_API void CALL_METHOD CLIENT_SetConnectTime(int nWaitTime, int nTryTimes);

// Set log in network environment 
CLIENT_NET_API void CALL_METHOD CLIENT_SetNetworkParam(NET_PARAM *pNetParam);

// set UDP and Multicast Option
CLIENT_NET_API void CALL_METHOD CLIENT_GetUdpOption(NET_UDP_OPTION *pUdpOption);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetUdpOption(NET_UDP_OPTION *pUdpOption);

// Get SDK version information 
CLIENT_NET_API DWORD CALL_METHOD CLIENT_GetSDKVersion();

//------------------------------------------------------------------------

// Register to the device 
// the value of error and it's meaning  
//					error =	-1	device not support high level security login
//					error = 0   no error
//					error = 1   username or passwd invalid
//                  error = 2   user not exist
//                  error = 3   timeout
//                  error = 4   repeat login
//                  error = 5   account has been locked
//                  error = 6   the account has been blacklisted
//                  error = 7   system busy, insufficient resources
//                  error = 8   sub socket connect fail
//                  error = 9   main socket connect fail
//                  error = 10  exceed max num of connections
//                  error = 11  device only support third protocol login
//                  error = 12  device not insert U shield or U shiled info invalid
//                  error = 13  client ip address is not permit to login
//					error = 18  device does not been initialized,so cannot be login
//					error = 19  limited login
//					error = 20  device only support high level security login
CLIENT_NET_API LLONG CALL_METHOD CLIENT_Login(const char *pchDVRIP, WORD wDVRPort, const char *pchUserName, const char *pchPassword, LPNET_DEVICEINFO lpDeviceInfo, int *error );

// Expension interface nSpecCap =0 is login under TCP mode, void* pCapParam fill in NULL
//			           nSpecCap =2 is login with active registeration, void* pCapParam fill in NULL
//					   nSpecCap =3 is login under multicast mode, void* pCapParam fill in NULL
//			           nSpecCap =4 is login under UDP mode, void* pCapParam fill in NULL
//					   nSpecCap =6 is login with main connection,void* pCapParam fill in NULL
//					   nSpecCap =7 is SSL encription,void* pCapParam fill in NULL
//			           nSpecCap =9 is login in to remote device, enter void* pCapParam as remote device name
//					   nSpecCap = 12 is login under LDAP mode,void* pCapParam fill in NULL
//                     nSpecCap = 13 is login under AD mode,void* pCapParam fill in NULL
//                     nSpecCap = 14 is Radius login,void* pCapParam fill in NULL 
//                     nSpecCap = 15 is Socks5 login, now void* pCapParam fill in Socks5 server IP&&port&&ServerName&&ServerPassword string
//                     nSpecCap = 16 is proxy login, now void* pCapParam fill in SOCKET value
//                     nSpecCap = 19 is web privatepenestrating login,void* pCapParam fill in NULL
//                     nSpecCap = 20 mobile phone client login,void* pCapParam fill in NULL
CLIENT_NET_API LLONG CALL_METHOD CLIENT_LoginEx(const char *pchDVRIP, WORD wDVRPort, const char *pchUserName, const char *pchPassword, int nSpecCap, void* pCapParam, LPNET_DEVICEINFO lpDeviceInfo, int *error );

// Login extension interface
CLIENT_NET_API LLONG CALL_METHOD CLIENT_LoginEx2(const char *pchDVRIP, WORD wDVRPort, const char *pchUserName, const char *pchPassword, EM_LOGIN_SPAC_CAP_TYPE emSpecCap, void* pCapParam, LPNET_DEVICEINFO_Ex lpDeviceInfo, int *error );

// Asynchronism login device 
// nSpecCap = 0 TCP login,nSpecCap = 6 only main connect login
// nSpecCap = 19 is private penestrating login
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartLogin(char *pchDVRIP, WORD wDVRPort, char *pchUserName, char *pchPassword, int nSpecCap, void* pCapParam, fHaveLogin cbLogin, LDWORD dwUser);

// Only when CLIENT_StartLogin () callback errors for 11 when asynchronous log in using the interface to continue
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartLoginEx(NET_IN_STARTLOGINEX* pInParam, NET_OUT_STARTLOGINEX* pOutParam);

// stop login
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopLogin(LLONG lLoginID);

CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopLoginEx(LLONG lLoginID);

// Log out the device 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Logout(LLONG lLoginID);


// input param of CLIENT_LoginWithHighLevelSecurity
typedef struct tagNET_IN_LOGIN_WITH_HIGHLEVEL_SECURITY
{
	DWORD						dwSize;				// struct size 
	char						szIP[64];			// IP
	int							nPort;				// port
	char						szUserName[64];		// user name
	char						szPassword[64];		// passwd
	EM_LOGIN_SPAC_CAP_TYPE		emSpecCap;			// login mode
	BYTE						byReserved[4];		// byte alignment
	void*						pCapParam;			// see the relationship between pCapParam and nSpecCap in CLIENT_LoginEx
}NET_IN_LOGIN_WITH_HIGHLEVEL_SECURITY;

// output param of CLIENT_LoginWithHighLevelSecurity
typedef struct tagNET_OUT_LOGIN_WITH_HIGHLEVEL_SECURITY
{
	DWORD						dwSize;				// struct size 
	NET_DEVICEINFO_Ex			stuDeviceInfo;		// device info
	int							nError;				// error code , see error in CLIENT_Login
	BYTE						byReserved[132];	// reserved
}NET_OUT_LOGIN_WITH_HIGHLEVEL_SECURITY;


// login device with high level security
CLIENT_NET_API LLONG CALL_METHOD CLIENT_LoginWithHighLevelSecurity(NET_IN_LOGIN_WITH_HIGHLEVEL_SECURITY* pstInParam, NET_OUT_LOGIN_WITH_HIGHLEVEL_SECURITY* pstOutParam);

// get the protocol type from device
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDevProtocolType(LLONG lLoginID, EM_DEV_PROTOCOL_TYPE *pemProtocolType);

// struct and functions with security stream 
// VK and VKID info
// Algorithm type
typedef enum tagEM_ALGORITHM_TYPE
{
	EM_ALGORITHM_TYPE_UNKNOWN,					// Unknown
	EM_ALGORITHM_TYPE_AES256_OFB,				// AES256-OFB
}EM_ALGORITHM_TYPE;

typedef struct tagNET_VKINFO
{
    char szVKID[128];							// VKID
    char szVK[128];								// VK
	EM_ALGORITHM_TYPE   emAlgorithmType;		// AlgorithmType
	int	 nRetVKIDLen;							// Return VKID len
	int	 nRetVKLen;								// Return VK len
    BYTE byReserved[500];   					// Reserved
}NET_VKINFO;

// VK info callback,dwError value will be finded in dhnetsdk.h,for example:NET_NOERROR,NET_ERROR_VK_INFO_DECRYPT_FAILED
typedef void (CALLBACK *fVKInfoCallBack)(LLONG lRealHandle, NET_VKINFO* pBuffer, DWORD dwError, LDWORD dwUser, void* pReserved);


// CLIENT_GetVK input param
typedef struct tagNET_IN_GET_VKINFO
{
    DWORD	dwSize;			// struct size
    int		nChannelID;		// Channel ID
}NET_IN_GET_VKINFO;

// CLIENT_GetVK output param
typedef struct tagNET_OUT_GET_VKINFO
{
    DWORD			dwSize;			// struct size
    NET_VKINFO		stuVKInfo;		// VK and VKID info
	BOOL			bContainPrevVKInfo;	// Whether contain the previous VK info,TRUE means contain previous VK info,FALSE means not contain previous VK info
	NET_VKINFO		stuPrevVKInfo;	// Previous VK and VKID info
}NET_OUT_GET_VKINFO;

// CLIENT_UpdateVK input param
typedef struct tagNET_IN_UPDATE_VKINFO
{
    DWORD		dwSize;				// struct size
    int			nChannelID;			// Channel ID
}NET_IN_UPDATE_VKINFO;

// CLIENT_UpdateVK output param
typedef struct tagNET_OUT_UPDATE_VKINFO
{
    DWORD		dwSize;				// struct size
    char		szVKID[128];		// VKID
}NET_OUT_UPDATE_VKINFO;

// Callback of CLIENT_AttachVK 
typedef void (CALLBACK *fAttachVK)(LLONG lLoginID, LLONG lAttachHandle,int nChannelID,const NET_VKINFO* pVKInfo,LDWORD dwUser);

// CLIENT_AttachVK input param
typedef struct tagNET_IN_ATTACH_VK
{
    DWORD              dwSize;                  // struct size 
    int                nChannelID;				// Channel ID
    fAttachVK          cbAttachVK;              // call back
    LDWORD             dwUser;                  // user data
}NET_IN_ATTACH_VK;

// CLIENT_AttachVK output param
typedef struct tagNET_OUT_ATTACH_VK
{
    DWORD				dwSize;				// struct size
	NET_VKINFO			stuCurrentVKInfo;	// Current VK and VKID info
	BOOL				bContainPrevVKInfo;	// Whether contain the previous VK info,TRUE means contain previous VK info,FALSE means not contain previous VK info
	NET_VKINFO			stuPrevVKInfo;		// Previous VK and VKID info
}NET_OUT_ATTACH_VK;


// Media encrypt caps info
typedef struct tagNET_MEDIA_ENCRYPT_CAPS_INFO
{
    BOOL		bSupport;				// whether media encrypt is support
    BYTE		byReserved[256];		// Reserved
}NET_MEDIA_ENCRYPT_CAPS_INFO;

// CLIENT_GetMediaEncryptCaps input param
typedef struct tagNET_IN_GET_MEDIA_ENCRYPT_CAPS
{
    DWORD              dwSize;          // struct size
    int                nChannelOffset;	// Channel offset
    int                nChannelCount;	// Channel count
}NET_IN_GET_MEDIA_ENCRYPT_CAPS;

// CLIENT_GetMediaEncryptCaps output param
typedef struct tagNET_OUT_GET_MEDIA_ENCRYPT_CAPS
{
    DWORD                           dwSize;             // struct size
    NET_MEDIA_ENCRYPT_CAPS_INFO*    pstuCapsInfo;       // media encrypt caps info
    int                             nMaxCapsInfoCount;	// max caps info count
    int                             nRetCapsInfoCount;	// return caps info count
}NET_OUT_GET_MEDIA_ENCRYPT_CAPS;

// Update VK
CLIENT_NET_API BOOL CALL_METHOD CLIENT_UpdateVK(LLONG lLoginID, const NET_IN_UPDATE_VKINFO* pInParam, NET_OUT_UPDATE_VKINFO* pOutParam, int nWaitTime);

// Attach VK, can get current vk info ,even can get previous vk info
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachVK( LLONG lLoginID, const NET_IN_ATTACH_VK* pInParam, NET_OUT_ATTACH_VK* pOutParam, int nWaitTime);

// Detach VK
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachVK( LLONG lAttachHandle);

// Get media encrypt caps
CLIENT_NET_API LLONG CALL_METHOD CLIENT_GetMediaEncryptCaps( LLONG lLoginID, const NET_IN_GET_MEDIA_ENCRYPT_CAPS* pInParam, NET_OUT_GET_MEDIA_ENCRYPT_CAPS* pOutParam, int nWaitTime);


//------------------------------------------------------------------------



//------------------------------------------------------------------------

// Begin real-time monitor 
CLIENT_NET_API LLONG CALL_METHOD CLIENT_RealPlay(LLONG lLoginID, int nChannelID, HWND hWnd);

// Begin real-time monitor--extensive
CLIENT_NET_API LLONG CALL_METHOD CLIENT_RealPlayEx(LLONG lLoginID, int nChannelID, HWND hWnd, DH_RealPlayType rType );

//start real-time monitor
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartRealPlay(LLONG lLoginID, int nChannelID, HWND hWnd, DH_RealPlayType rType, fRealDataCallBackEx cbRealData, fRealPlayDisConnect cbDisconnect, LDWORD dwUser, DWORD dwWaitTime );





// Multiple-window preview 
CLIENT_NET_API LLONG CALL_METHOD CLIENT_MultiPlay(LLONG lLoginID, HWND hWnd);

// Stop multiple-window preview 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopMultiPlay(LLONG lMultiHandle);

// Snapshot;hPlayHandle is monitor or playback handle
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CapturePicture(LLONG hPlayHandle, const char *pchPicFileName);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CapturePictureEx(LLONG hPlayHandle, const char *pchPicFileName, NET_CAPTURE_FORMATS eFormat);

// Input param of CLIENT_CapturePictureEx2
typedef struct tagNET_IN_CAPTURE_PICTURE
{
    DWORD                   dwSize;                         // Struct size
    NET_CAPTURE_FORMATS     emFormat;                       // Format of picture
    char                    szPicFilePath[256];             // Path of picture
} NET_IN_CAPTURE_PICTURE;

// Output param of CLIENT_CapturePictureEx2
typedef struct tagNET_OUT_CAPTURE_PICTURE
{
    DWORD                   dwSize;                         // Struct size
    NET_TIME_EX             stuTime;                        // Snap picture time
} NET_OUT_CAPTURE_PICTURE;

// Extended Interface of snapshot(Support for returning picture time, accurate to milliseconds), hPlayHandle is monitor or playback handle
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CapturePictureEx2(LLONG lPlayHandle, NET_IN_CAPTURE_PICTURE *pstInParam, NET_OUT_CAPTURE_PICTURE *pstOutParam);

// Set real-time monitor data callback 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetRealDataCallBack(LLONG lRealHandle, fRealDataCallBack cbRealData, LDWORD dwUser);

typedef enum _PrerecordStreamType
{
	Prerecord_RType_Realplay_0,						   // Real-time monitor-main stream
	Prerecord_RType_Realplay_1,                        // 1 Real-time monitor -- extra stream 1
	Prerecord_RType_Realplay_2,                        // 2 Real-time monitor -- extra stream 2
	Prerecord_RType_Realplay_3,                        // 3 Real-time monitor -- extra stream 3
}EM_PRERECODE_STREAM_TYPE;

CLIENT_NET_API LLONG CALL_METHOD CLIENT_PrerecordStream(LLONG lLoginID, int nChannelID,EM_PRERECODE_STREAM_TYPE emPreRecord, int nWaitTime);

// real data flag, corresponding param dwFlag in CLIENT_SetRealDataCallBackEx
// supports '|' operator, like dwFlag = REALDATA_FLAG_RAW_DATA | REALDATA_FLAG_YUV_DATA
typedef enum tagEM_REALDATA_FLAG
{	
	REALDATA_FLAG_RAW_DATA				= 0x01, // raw data flag,		corresponding param dwDataType in fRealDataCallBack / fRealDataCallBackEx is 0, 0x01 = 0x01 << 0
	REALDATA_FLAG_DATA_WITH_FRAME_INFO	= 0x02, // data with frame info flag,	corresponding param dwDataType in fRealDataCallBack / fRealDataCallBackEx is 1, 0x02 = 0x01 << 1
	REALDATA_FLAG_YUV_DATA				= 0x04, // YUV data flag,		corresponding param dwDataType in fRealDataCallBack / fRealDataCallBackEx is 2, 0x04 = 0x01 << 2
	REALDATA_FLAG_PCM_AUDIO_DATA		= 0x08, // PCM audio data flag,	corresponding param dwDataType in fRealDataCallBack / fRealDataCallBackEx is 3, 0x08 = 0x01 << 3
} EM_REALDATA_FLAG;

// Set real-time monitor data callback--extensive 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetRealDataCallBackEx(LLONG lRealHandle, fRealDataCallBackEx cbRealData, LDWORD dwUser, DWORD dwFlag);

// Real-time monitor encrypt data callback function
typedef void (CALLBACK *fEncryptRealDataCallBackEx)(LLONG lRealHandle, BYTE *pBuffer, DWORD dwBufSize, LDWORD dwUser);

// Set real-time monitor encrypt data callback
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetEncryptRealDataCallBack(LLONG lRealHandle, fEncryptRealDataCallBackEx cbRealData, LDWORD dwUser);

// Set real-time monitor data callback--extensive 2
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetRealDataCallBackEx2(LLONG lRealHandle, fRealDataCallBackEx2 cbRealData, LDWORD dwUser, DWORD dwFlag);

// Real-time monitor original data callback function
typedef void (CALLBACK *fOriginalRealDataCallBack)(LLONG lRealHandle, BYTE *pBuffer, DWORD dwBufSize, LDWORD dwUser);

// Set real-time monitor original data callback
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetOriginalRealDataCallBack(LLONG lRealHandle, fOriginalRealDataCallBack cbRealData, LDWORD dwUser);



// Set VK info callbacklPlayHandle can be realplay handle or playback handle
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetVKInfoCallBack(LLONG lPlayHandle, fVKInfoCallBack cbVKInfo, LDWORD dwUser);


// Set video fluency
CLIENT_NET_API BOOL	CALL_METHOD CLIENT_AdjustFluency(LLONG lRealHandle, int nLevel);

// Save data as file
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SaveRealData(LLONG lRealHandle, const char *pchFileName);

// Stop saving data as file 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopSaveRealData(LLONG lRealHandle);

// Set video property
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ClientSetVideoEffect(LLONG lPlayHandle, unsigned char nBrightness, unsigned char nContrast, unsigned char nHue, unsigned char nSaturation);

// Get video property 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ClientGetVideoEffect(LLONG lPlayHandle, unsigned char *nBrightness, unsigned char *nContrast, unsigned char *nHue, unsigned char *nSaturation);

// Set screen overlay callback 
CLIENT_NET_API void CALL_METHOD CLIENT_RigisterDrawFun(fDrawCallBack cbDraw, LDWORD dwUser);

// Open audio 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OpenSound(LLONG hPlayHandle);

// Set volume;lPlayHandle is monitor handle or playabck handle 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetVolume(LLONG lPlayHandle, int nVolume);

// If use HD image internal adjustment strategy, enable by default. This strategy is used, when quick play x4 and higher, only play 1 frame, When disable, play every frame. 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PlayEnableLargePicAdjustment(LLONG lPlayHandle, BOOL bEnable);

// Stop audio 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CloseSound();

// Stop real-time preview 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopRealPlay(LLONG lRealHandle);

// stop real-time preview-extensive
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopRealPlayEx(LLONG lRealHandle);

//------------------------------------------------------------------------

// PTZ Move Relatively param
typedef struct tagNET_IN_MOVERELATIVELY_INFO
{
	DWORD							dwSize;				// struct size
	PTZ_SPACE_RELATIVELY_UNIT		stuTranslation;		// PTZ Move Relatively x/y/zoom, normalized to -1~1 
	PTZ_SPACE_RELATIVELY_UNIT		stuSpeed;			// PTZ run Speed x/y/zoom, normalized to 0~1 
}NET_IN_MOVERELATIVELY_INFO;

// Direction
typedef enum tagNET_EM_PTZ_DIRECTION_TYPE
{
	NET_EM_PTZ_DIRECTION_TYPE_UNKNOWN,	// Unknown
	NET_EM_PTZ_DIRECTION_TYPE_EAST,		// East
	NET_EM_PTZ_DIRECTION_TYPE_SOUTH,	// South
	NET_EM_PTZ_DIRECTION_TYPE_WEST,		// West
	NET_EM_PTZ_DIRECTION_TYPE_NORTH,	// North
}NET_EM_PTZ_DIRECTION_TYPE;

// Set PTZ Direction DH_EXTPTZ_SET_DIRECTION
typedef struct tagNET_IN_SET_DIRECTION_INFO
{
	DWORD								dwSize;				// struct size
	NET_EM_PTZ_DIRECTION_TYPE			emDirection;		// PTZ Direction
}NET_IN_SET_DIRECTION_INFO;

// general PTZ control
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PTZControl(LLONG lLoginID, int nChannelID, DWORD dwPTZCommand, DWORD dwStep, BOOL dwStop);

// Private PTZ control,user malloc param4's memory,please refer to corresponding structure of DH_EXTPTZ_ControlType
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DHPTZControl(LLONG lLoginID, int nChannelID, DWORD dwPTZCommand, unsigned char param1, unsigned char param2, unsigned char param3, BOOL dwStop,void* param4);

//  private PTZ control extensive port. support 3D intelligent position
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DHPTZControlEx(LLONG lLoginID, int nChannelID, DWORD dwPTZCommand, LONG lParam1, LONG lParam2, LONG lParam3, BOOL dwStop);

// private PTZ control expansion port , support 3D quick positioning, Fish eye ,user malloc param4's memory,please refer to corresponding structure of DH_EXTPTZ_ControlType
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DHPTZControlEx2(LLONG lLoginID, int nChannelID, DWORD dwPTZCommand, LONG lParam1, LONG lParam2, LONG lParam3, BOOL dwStop , void* param4 );

// Area Scan interface,private PTZ control
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DHPTZAreaScan(LLONG lLoginID ,DWORD dwPTZCommand, char* szInBuffer, DWORD dwInBufferSize,char* szOutBuffer );

// CLIENT_DHPTZCalibrateSingleDirection inparam
typedef struct tagNET_IN_CALIBRATE_SINGLEDIRECTION
{
    DWORD                       dwSize;
    int                         nMode;                      // calibrate1level2vertical
}NET_IN_CALIBRATE_SINGLEDIRECTION;
//------------------------------------------------------------------------
// query record state everyday in the month
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryRecordStatus(LLONG lLoginID, int nChannelId, int nRecordFileType, LPNET_TIME tmMonth, char* pchCardid, LPNET_RECORD_STATUS pRecordStatus, int waittime);

// Search whether there is recorded file in specified period
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryRecordTime(LLONG lLoginID, int nChannelId, int nRecordFileType, LPNET_TIME tmStart, LPNET_TIME tmEnd, char* pchCardid, BOOL *bResult, int waittime);

// Search all recorded file sin the specified periods
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryRecordFile(LLONG lLoginID, int nChannelId, int nRecordFileType, LPNET_TIME tmStart, LPNET_TIME tmEnd, char* pchCardid, LPNET_RECORDFILE_INFO nriFileinfo, int maxlen, int *filecount, int waittime);

// Async search period all record files
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartQueryRecordFile(LLONG lLoginID, NET_IN_START_QUERY_RECORDFILE *pInParam, NET_OUT_START_QUERY_RECORDFILE *pOutParam);


// Stop async search record file
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopQueryRecordFile(LLONG lQueryHandle);

// search first 16 records

CLIENT_NET_API BOOL CALL_METHOD CLIENT_QuickQueryRecordFile(LLONG lLoginID, int nChannelId, int nRecordFileType, LPNET_TIME tmStart, LPNET_TIME tmEnd, char* pchCardid, LPNET_RECORDFILE_INFO nriFileinfo, int maxlen, int *filecount, int waittime);


// Query the first record time 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryFurthestRecordTime(LLONG lLoginID, int nRecordFileType, char *pchCardid, NET_FURTHEST_RECORD_TIME* pFurthrestTime, int nWaitTime);

// Begin searching recorded file
CLIENT_NET_API LLONG	CALL_METHOD CLIENT_FindFile(LLONG lLoginID, int nChannelId, int nRecordFileType, char* cardid, LPNET_TIME time_start, LPNET_TIME time_end, BOOL bTime, int waittime);

// Search recorded file 
CLIENT_NET_API int	CALL_METHOD CLIENT_FindNextFile(LLONG lFindHandle,LPNET_RECORDFILE_INFO lpFindData);

// Stop searching recorded file 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FindClose(LLONG lFindHandle);

// Playback in file 
CLIENT_NET_API LLONG CALL_METHOD CLIENT_PlayBackByRecordFile(LLONG lLoginID, LPNET_RECORDFILE_INFO lpRecordFile, HWND hWnd, fDownLoadPosCallBack cbDownLoadPos, LDWORD dwUserData);

// Playback in file--extensive
CLIENT_NET_API LLONG CALL_METHOD CLIENT_PlayBackByRecordFileEx(LLONG lLoginID, LPNET_RECORDFILE_INFO lpRecordFile, HWND hWnd, fDownLoadPosCallBack cbDownLoadPos, LDWORD dwPosUser, fDataCallBack fDownLoadDataCallBack, LDWORD dwDataUser);

// the input param for playback with file
typedef struct tagNET_IN_PLAY_BACK_BY_FILE_INFO
{
    LPNET_RECORDFILE_INFO pRecordFile;                     // record file info ptr 
    HWND                hWnd;                              // play wnd,can be NULL
    fDownLoadPosCallBack cbDownLoadPos;                    // download progress callback
    LDWORD              dwPosUser;                         // download progress callback user data
    fDataCallBack       fDownLoadDataCallBack;             // data callback
    LDWORD              dwDataUser;                        // data callback user data
    int                 nPlayDirection;                    // play direction,0:forward; 1:backward;
    int                 nWaittime;                         // time out value,in milliseconds
    BYTE                bReserved[1024];                   // reserved
}NET_IN_PLAY_BACK_BY_FILE_INFO;

// the output param for playback with file
typedef struct tagNET_OUT_PLAY_BACK_BY_FILE_INFO
{
    BYTE                bReserved[1024];                   // reserved
}NET_OUT_PLAY_BACK_BY_FILE_INFO;

// play back in file 
CLIENT_NET_API LLONG CALL_METHOD CLIENT_PlayBackByRecordFileEx2(LLONG lLoginID, const NET_IN_PLAY_BACK_BY_FILE_INFO *pstNetIn, NET_OUT_PLAY_BACK_BY_FILE_INFO *pstNetOut);

// playback in file - disconnect callback
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartPlayBackByRecordFile(LLONG lLoginID,  LPNET_RECORDFILE_INFO lpRecordFile, HWND hWnd, 
															 fDownLoadPosCallBack cbDownLoadPos, LDWORD dwPosUser, 
															 fDataCallBack fDownLoadDataCallBack, LDWORD dwDataUser, 
															 fRealPlayDisConnect fDisConnectCallBack, LDWORD dwDisUser, DWORD dwWaitTime );

//Playback in file--Drop frame playback (not enough bandwidth can be used)
CLIENT_NET_API LLONG CALL_METHOD CLIENT_FramCotrolPlayBackByRecordFile(LLONG lLoginID, LPNET_RECORDFILE_INFO lpRecordFile, HWND hWnd, 
																   fDownLoadPosCallBack cbDownLoadPos, LDWORD dwPosUser, 
																   fDataCallBack fDownLoadDataCallBack, LDWORD dwDataUser, unsigned int nCutFrameRate);

// Playback in time
CLIENT_NET_API LLONG CALL_METHOD CLIENT_PlayBackByTime(LLONG lLoginID, int nChannelID, LPNET_TIME lpStartTime, LPNET_TIME lpStopTime, HWND hWnd, fDownLoadPosCallBack cbDownLoadPos, LDWORD dwPosUser);

// Playback in time--extensive
CLIENT_NET_API LLONG CALL_METHOD CLIENT_PlayBackByTimeEx(LLONG lLoginID, int nChannelID, LPNET_TIME lpStartTime, LPNET_TIME lpStopTime, HWND hWnd, 
													 fDownLoadPosCallBack cbDownLoadPos, LDWORD dwPosUser, 
													 fDataCallBack fDownLoadDataCallBack, LDWORD dwDataUser);

// Playback by time, support playback by direction compare to the old version,user malloc memory of pstNetIn and pstNetOut
CLIENT_NET_API LLONG CALL_METHOD CLIENT_PlayBackByTimeEx2(LLONG lLoginID, int nChannelID, 
                        NET_IN_PLAY_BACK_BY_TIME_INFO *pstNetIn, NET_OUT_PLAY_BACK_BY_TIME_INFO *pstNetOut);

// playback in time--disconnect callback
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartPlayBackByTime(LLONG lLoginID, int nChannelID, 
													   LPNET_TIME lpStartTime, LPNET_TIME lpStopTime, HWND hWnd, 
													   fDownLoadPosCallBack cbDownLoadPos, LDWORD dwPosUser,
													   fDataCallBack fDownLoadDataCallBack, LDWORD dwDataUser, 
													   fRealPlayDisConnect fDisConnectCallBack, LDWORD dwDisUser, DWORD dwWaitTime );

//Playback in time--Drop frame playback (not enough bandwidth can be used)
CLIENT_NET_API LLONG CALL_METHOD CLIENT_FramCotrolPlayBackByTime(LLONG lLoginID, int nChannelID, LPNET_TIME lpStartTime, LPNET_TIME lpStopTime, HWND hWnd, 
															 fDownLoadPosCallBack cbDownLoadPos, LDWORD dwPosUser, 
															 fDataCallBack fDownLoadDataCallBack, LDWORD dwDataUser, unsigned int nCutFrameRate);

//playback by synopsis file
CLIENT_NET_API LLONG CALL_METHOD CLIENT_PlayBackBySynopsisFile(LLONG lLoginID, 
															LPNET_SYNOPSISFILE_INFO lpRecordFile, 
															HWND hWnd, 
															fDownLoadPosCallBack cbDownLoadPos,
															LDWORD dwPosUser, 
															fDataCallBack fDownLoadDataCallBack,
															LDWORD dwDataUser,
															LDWORD dwUser);

// multi-channel preview palyabck
CLIENT_NET_API LLONG CALL_METHOD CLIENT_MultiPlayBack(LLONG lLoginID, NET_MULTI_PLAYBACK_PARAM *pParam);

// position record playback initial point
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SeekPlayBack(LLONG lPlayHandle, unsigned int offsettime, unsigned int offsetbyte);

// position record playback initial point by time
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SeekPlayBackByTime(LLONG lPlayHandle, LPNET_TIME lpSeekTime);

// Pause or restore file playback 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PausePlayBack(LLONG lPlayHandle, BOOL bPause);

// Fast playback file 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FastPlayBack(LLONG lPlayHandle);

// Slow playback file 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SlowPlayBack(LLONG lPlayHandle);

// Set playback speed
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetPlayBackSpeed(LLONG lPlayHandle, EM_PLAY_BACK_SPEED emSpeed);

// Step playback file 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StepPlayBack(LLONG lPlayHandle, BOOL bStop);

// Control playback direction--Forward or Backward playback
// bBackward FALSE:normal play TRUE:upend
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PlayBackControlDirection(LLONG lPlayHandle, BOOL bBackward);

// Set playback frame rate 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetFramePlayBack(LLONG lPlayHandle, int framerate);

// Get playback frame rate
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetFramePlayBack(LLONG lPlayHandle, int *fileframerate, int *playframerate);

// Restore ordinary playback
CLIENT_NET_API BOOL CALL_METHOD CLIENT_NormalPlayBack(LLONG lPlayHandle);

// smart search play back
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SmartSearchPlayBack(LLONG lPlayHandle, LPIntelligentSearchPlay lpPlayBackParam);

// Get playback OSD time 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetPlayBackOsdTime(LLONG lPlayHandle, LPNET_TIME lpOsdTime, LPNET_TIME lpStartTime, LPNET_TIME lpEndTime);

// Stop file playback 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopPlayBack(LLONG lPlayHandle);

// Download recorded file 
CLIENT_NET_API LLONG CALL_METHOD CLIENT_DownloadByRecordFile(LLONG lLoginID,LPNET_RECORDFILE_INFO lpRecordFile, char *sSavedFileName, fDownLoadPosCallBack cbDownLoadPos, LDWORD dwUserData);

// Download video files - extension
// sSavedFileName Is not null, video data written to the corresponding file path; fDownLoadDataCallBack Is not null, video data through the callback function returns 
// pReserved is the password of encrypted media file (password's len must not less than 8)
CLIENT_NET_API LLONG CALL_METHOD CLIENT_DownloadByRecordFileEx(LLONG lLoginID, LPNET_RECORDFILE_INFO lpRecordFile, char *sSavedFileName, 
                                                           fDownLoadPosCallBack cbDownLoadPos, LDWORD dwUserData, 
                                                           fDataCallBack fDownLoadDataCallBack, LDWORD dwDataUser, void* pReserved );

// Download file by time 
// nRecordFileType corresonding to emum EM_QUERY_RECORD_TYPE
CLIENT_NET_API LLONG CALL_METHOD CLIENT_DownloadByTime(LLONG lLoginID, int nChannelId, int nRecordFileType, LPNET_TIME tmStart, LPNET_TIME tmEnd, char *sSavedFileName, fTimeDownLoadPosCallBack cbTimeDownLoadPos, LDWORD dwUserData);

// Through the time to download the video - extension
// sSavedFileName Is not null, video data written to the corresponding file path; fDownLoadDataCallBack Is not null, video data through the callback function returns
// pReserved is the password of encrypted media file (password's len must not less than 8)
CLIENT_NET_API LLONG CALL_METHOD CLIENT_DownloadByTimeEx(LLONG lLoginID, int nChannelId, int nRecordFileType, LPNET_TIME tmStart, LPNET_TIME tmEnd, char *sSavedFileName, 
                                                     fTimeDownLoadPosCallBack cbTimeDownLoadPos, LDWORD dwUserData, 
                                                     fDataCallBack fDownLoadDataCallBack, LDWORD dwDataUser, void* pReserved );

// Search record download process 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDownloadPos(LLONG lFileHandle, int *nTotalSize, int *nDownLoadSize);

// Stop record download 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopDownload(LLONG lFileHandle);

// Pause or restore download file
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PauseDownload(LLONG lFileHandle, BOOL bPause);

//------------------------------------- realplay playback download by stream date type  ---------------------


#define NET_DATA_CALL_BACK_VALUE      1000       // dwDataType = NET_DATA_CALL_BACK_VALUE + emDataType
                                                 // dwDataType is the param in fRealDataCallBackEx and fDataCallBack
                                                 // emDataType is the enum in NET_IN_REALPLAY_BY_DATA_TYPE/NET_IN_PLAYBACK_BY_DATA_TYPE/NET_IN_DOWNLOAD_BY_DATA_TYPE                                       
                                                 
// stream date type
typedef enum tagEM_REAL_DATA_TYPE
{
    EM_REAL_DATA_TYPE_PRIVATE,       // private stream
    EM_REAL_DATA_TYPE_GBPS,          // Chinese standard ps stream 
    EM_REAL_DATA_TYPE_TS,            // TS stream
    EM_REAL_DATA_TYPE_MP4,           // MP4 file(the callback function supply the private stream data, the parama dwDataType is 0 )
    EM_REAL_DATA_TYPE_H264,          // raw video stream,both h264 and h265 can convert successfully
	EM_REAL_DATA_TYPE_FLV_STREAM,	 // FLV stream
	EM_REAL_DATA_TYPE_PS,			 // PS stream
	EM_REAL_DATA_TYPE_DHTS,			 // DHTS
}EM_REAL_DATA_TYPE;

// RealPlay By Stream Data Type (in param)
typedef struct tagNET_IN_REALPLAY_BY_DATA_TYPE
{
    DWORD               	dwSize;                 // struct size
    int                 	nChannelID;             // channel id
    HWND                	hWnd;                   // play handle
    DH_RealPlayType     	rType;                  // real play stream type 
    fRealDataCallBackEx 	cbRealData;             // realplay data callback function prototype
    EM_REAL_DATA_TYPE   	emDataType;             // stream data type
    LDWORD              	dwUser;                 // data user
    const char*         	szSaveFileName;         // file name to convert
	fRealDataCallBackEx2	cbRealDataEx;           // realplay data callback function prototype-ex
}NET_IN_REALPLAY_BY_DATA_TYPE;

// RealPlay By Stream Data Type (out param)
typedef struct tagNET_OUT_REALPLAY_BY_DATA_TYPE
{
    DWORD               	dwSize;                 // struct size  
}NET_OUT_REALPLAY_BY_DATA_TYPE;

// RealPlay By Stream Data Type
CLIENT_NET_API LLONG CALL_METHOD CLIENT_RealPlayByDataType(LLONG lLoginID, const NET_IN_REALPLAY_BY_DATA_TYPE* pstInParam, NET_OUT_REALPLAY_BY_DATA_TYPE* pstOutParam, DWORD dwWaitTime);


// PlayBack By stream Data Type (in param)
typedef struct tagNET_IN_PLAYBACK_BY_DATA_TYPE
{
    DWORD               dwSize;                 // struct size
    int                 nChannelID;             // channel id
    NET_TIME            stStartTime;            // start time 
    NET_TIME            stStopTime;             // stop time
    HWND                hWnd;                   // play handle
    fDownLoadPosCallBack cbDownLoadPos;         // function prototype of play back progress 
    LDWORD              dwPosUser;              // pos user
    fDataCallBack       fDownLoadDataCallBack;  // Playback data callback function prototype
    EM_REAL_DATA_TYPE   emDataType;             // stream data type 
    LDWORD              dwDataUser;             // date user
    int                 nPlayDirection;         // Playback direction, 0:normal; 1:reverse;
}NET_IN_PLAYBACK_BY_DATA_TYPE;

// PlayBack By stream Data Type (out param)
typedef struct tagNET_OUT_PLAYBACK_BY_DATA_TYPE
{
    DWORD               dwSize;                 // struct size  
}NET_OUT_PLAYBACK_BY_DATA_TYPE;

// PlayBack By stream Data Type
CLIENT_NET_API LLONG CALL_METHOD CLIENT_PlayBackByDataType(LLONG lLoginID, const NET_IN_PLAYBACK_BY_DATA_TYPE* pstInParam, NET_OUT_PLAYBACK_BY_DATA_TYPE* pstOutParam, DWORD dwWaitTime);


// Download record by stream data type (in param)
typedef struct tagNET_IN_DOWNLOAD_BY_DATA_TYPE
{
    DWORD                       dwSize;                 // struct size
    int                         nChannelID;             // channel id     
    EM_QUERY_RECORD_TYPE        emRecordType;           // record type
    char*                       szSavedFileName;        // save file path
    NET_TIME                    stStartTime;            // start time
    NET_TIME                    stStopTime;             // stop time 
    fTimeDownLoadPosCallBack    cbDownLoadPos;          // function prototype of play back progress
    LDWORD                      dwPosUser;              // pos user
    fDataCallBack               fDownLoadDataCallBack;  // Playback data callback function prototype
    EM_REAL_DATA_TYPE           emDataType;             // stream data type 
    LDWORD                      dwDataUser;             // date user
}NET_IN_DOWNLOAD_BY_DATA_TYPE;

// Download record by stream data type (out param)
typedef struct tagNET_OUT_DOWNLOAD_BY_DATA_TYPE
{
    DWORD               dwSize;                 // struct size  
}NET_OUT_DOWNLOAD_BY_DATA_TYPE;

// Download record by stream data type
CLIENT_NET_API LLONG CALL_METHOD CLIENT_DownloadByDataType(LLONG lLoginID, const NET_IN_DOWNLOAD_BY_DATA_TYPE* pstInParam, NET_OUT_DOWNLOAD_BY_DATA_TYPE* pstOutParam, DWORD dwWaitTime);

// CLIENT_AdaptiveDownloadByTime's in param
typedef struct tagNET_IN_ADAPTIVE_DOWNLOAD_BY_TIME
{
	DWORD                       dwSize;                 // struct size
	int                         nChannelID;             // channel id
	EM_QUERY_RECORD_TYPE        emRecordType;           // record type
	char*                       szSavedFileName;        // save file path
	NET_TIME                    stStartTime;            // start time
	NET_TIME                    stStopTime;             // stop time 
	fTimeDownLoadPosCallBack    cbDownLoadPos;          // Download data callback function prototype
	LDWORD                      dwPosUser;              // date user
	fDataCallBack               fDownLoadDataCallBack;  // Download data callback function prototype
	EM_REAL_DATA_TYPE           emDataType;             // data type for download data callback
	LDWORD                      dwDataUser;             // pos user
	char						szEncryptPasswd[64];	// password of encrypted media file, password's len must not less than 8
}NET_IN_ADAPTIVE_DOWNLOAD_BY_TIME;

// CLIENT_AdaptiveDownloadByTime's out param
typedef struct tagNET_OUT_ADAPTIVE_DOWNLOAD_BY_TIME
{
	DWORD               dwSize;                 // struct size  
}NET_OUT_ADAPTIVE_DOWNLOAD_BY_TIME;

// Download record method, speed is adapted, need call CLIENT_StopDownload to release resources
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AdaptiveDownloadByTime(LLONG lLoginID, const NET_IN_ADAPTIVE_DOWNLOAD_BY_TIME* pstInParam, NET_OUT_ADAPTIVE_DOWNLOAD_BY_TIME* pstOutParam, DWORD dwWaitTime);

// Input param of  CLIENT_DownloadByFileSelfAdapt 
typedef struct tagNET_IN_DOWNLOAD_BYFILE_SELFADAPT
{
	DWORD                       dwSize;                 // struct size
	int                         nChannelID;             // channel ID
	EM_QUERY_RECORD_TYPE        emRecordType;           // record type
	char                       	szFileName[MAX_PATH];   // the path of this record on the device
	unsigned int        		size;                   // length of record, unit is Kbyte
	fDownLoadPosCallBack    	cbDownLoadPos;          // function prototype of play back progress
	LDWORD                      dwPosUser;              // user data of playback pos
	fDataCallBack               fDownLoadDataCallBack;  // Playback data callback function prototype
	EM_REAL_DATA_TYPE           emDataType;             // stream data type 
	LDWORD                      dwDataUser;             // user data of playback data
}NET_IN_DOWNLOAD_BYFILE_SELFADAPT;

// Out param of CLIENT_DownloadByFileSelfAdapt
typedef struct tagNET_OUT_DOWNLOAD_BYFILE_SELFADAPT
{
	DWORD               dwSize;                 // struct size
}NET_OUT_DOWNLOAD_BYFILE_SELFADAPT;

// Download record by file name, speed is adapted. the resourse of pstInParam and pstOutParam is requested and released by user
CLIENT_NET_API LLONG CALL_METHOD CLIENT_DownloadByFileSelfAdapt(LLONG lLoginID, const NET_IN_DOWNLOAD_BYFILE_SELFADAPT* pstInParam, NET_OUT_DOWNLOAD_BYFILE_SELFADAPT* pstOutParam, DWORD dwWaitTime);

//-------------------------------------------------------------------

//partial enlarged
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDisplayRegion(LLONG lPlayHandle,DWORD nRegionNum, DH_DISPLAYRREGION *pSrcRect, HWND hDestWnd, BOOL bEnable);

// start to search record file frame info
CLIENT_NET_API BOOL    CALL_METHOD CLIENT_FindFrameInfo(LLONG lLoginID, NET_IN_FIND_FRAMEINFO_PRAM *pInParam, NET_OUT_FIND_FRAMEINFO_PRAM* pOutParam, int nWaitTime);

// search record file frame info, search by specified info item
CLIENT_NET_API BOOL    CALL_METHOD CLIENT_FindNextFrameInfo(LLONG lFindHandle, NET_IN_FINDNEXT_FRAMEINFO_PRAM *pInParam, NET_OUT_FINDNEXT_FRAMEINFO_PRAM* pOutParam, int nWaitTime);

// set file stream tags
CLIENT_NET_API BOOL    CALL_METHOD CLIENT_FileStreamSetTags(LLONG lFindHandle, NET_IN_FILE_STREAM_TAGS_INFO *pInParam, NET_OUT_FILE_STREAM_TAGS_INFO *pOutParam, int nWaitTime);

// get file stream tags
CLIENT_NET_API BOOL    CALL_METHOD CLIENT_FileStreamGetTags(LLONG lFindHandle, NET_IN_FILE_STREAM_GET_TAGS_INFO *pInParam, NET_OUT_FILE_STREAM_GET_TAGS_INFO *pOutParam, int nWaitTime);

// clear file stream tags
CLIENT_NET_API BOOL    CALL_METHOD CLIENT_FileStreamClearTags(LLONG lFindHandle, NET_IN_FILE_STREAM_TAGS_INFO *pInParam, NET_OUT_FILE_STREAM_TAGS_INFO *pOutParam, int nWaitTime);

// filter file stream tags
CLIENT_NET_API BOOL    CALL_METHOD CLIENT_FileStreamFilterTags(LLONG lFindHandle, NET_IN_FILE_STREAM_FILTER_TAGS_INFO *pInParam, NET_OUT_FILE_STREAM_GET_TAGS_INFO *pOutParam, int nWaitTime);

// end record file search
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FindFrameInfoClose(LLONG lFindHandle);
// pInParam, pOutParam memory managed by user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FileStreamMotionMatch(LLONG lLoginID, const NET_IN_MOTIONMATCH_PARAM *pInParam, NET_OUT_MOTIONMATCH_PARAM* pOutParam, int nWaitTime);

// find tags' info, lFindHandle is get from CLIENT_FindFrameInfo, the tags in the result were set by CLIENT_TagManagerStartTag/CLIENT_TagManagerSetSubTag/CLIENT_TagManagerStopTag
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FileStreamFindTags(LLONG lFindHandle, NET_IN_FINDTAGS_INFO *pInParam, NET_OUT_FINDTAGS_INFO *pOutParam, int nWaitTime);

// get tag state
CLIENT_NET_API BOOL CALL_METHOD CLIENT_TagManagerGetTagState(LLONG lLoginID, NET_IN_TAGMANAGER_GETTAGSTATE_INFO *pInParam, NET_OUT_TAGMANAGER_GETTAGSTATE_INFO *pOutParam, int nWaitTime);

// start tag
CLIENT_NET_API BOOL CALL_METHOD CLIENT_TagManagerStartTag(LLONG lLoginID, NET_IN_TAGMANAGER_STARTTAG_INFO *pInParam, NET_OUT_TAGMANAGER_STARTTAG_INFO *pOutParam, int nWaitTime);

// set a sub tag, sub tag's count can not greater than 20, otherwise it will failed 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_TagManagerSetSubTag(LLONG lLoginID, NET_IN_TAGMANAGER_SETSUBTAG_INFO *pInParam, NET_OUT_TAGMANAGER_SETSUBTAG_INFO *pOutParam, int nWaitTime);

// stop a tag
CLIENT_NET_API BOOL CALL_METHOD CLIENT_TagManagerStopTag(LLONG lLoginID, NET_IN_TAGMANAGER_STOPTAG_INFO *pInParam, NET_OUT_TAGMANAGER_STOPTAG_INFO *pOutParam, int nWaitTime);

// Get ability to get Tags
CLIENT_NET_API BOOL CALL_METHOD CLIENT_TagManagerGetCaps(LLONG lLoginID, NET_IN_TAGMANAGER_GETCAPS_INFO *pInParam, NET_OUT_TAGMANAGER_GETCAPS_INFO *pOutParam, int nWaitTime);

// Start to find tag information
CLIENT_NET_API LLONG CALL_METHOD CLIENT_TagManagerStartFind(LLONG lLoginID, NET_IN_TAGMANAGER_STARTFIND_INFO *pInParam, NET_OUT_TAGMANAGER_STARTFIND_INFO *pOutParam, int nWaitTime);

// Get label find result information
CLIENT_NET_API BOOL CALL_METHOD CLIENT_TagManagerDoFind(LLONG lFindID, NET_IN_TAGMANAGER_DOFIND_INFO *pInParam, NET_OUT_TAGMANAGER_DOFIND_INFO *pOutParam, int nWaitTime);

// Stop to find tag information
CLIENT_NET_API BOOL CALL_METHOD CLIENT_TagManagerStopFind(LLONG lFindID);
//------------------------------------------------------------------------

// Set alarm callback function 
CLIENT_NET_API void CALL_METHOD CLIENT_SetDVRMessCallBack(fMessCallBack cbMessage,LDWORD dwUser);

CLIENT_NET_API void CALL_METHOD CLIENT_SetDVRMessCallBackEx1(fMessCallBackEx1 cbMessage,LDWORD dwUser);


// subscribe alarm 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartListen(LLONG lLoginID);

// subscribe alarm---extensive
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartListenEx(LLONG lLoginID);

// Stop subscribe alarm 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopListen(LLONG lLoginID);

// alarm reset
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AlarmReset(LLONG lLoginID, DWORD dwAlarmType, int nChannel, void* pReserved );

//------------------------------------------------------------------------


// CLIENT_SetServerParam param
typedef struct tagNET_ACTIVE_RIGST_PARAMS
{
    DWORD               dwSize;             // Struct size
    BOOL                bManualLogout;      // Whether to log out manually (SDK automatically logout is the default after active registered devices are disconnected)
} NET_ACTIVE_RIGST_PARAMS;


// Set param of active registration
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetServerParam(NET_ACTIVE_RIGST_PARAMS* pParam);

// actively registration function. enable service. nTimeout is invalid. 
CLIENT_NET_API LLONG CALL_METHOD CLIENT_ListenServer(char* ip, WORD port, int nTimeout, fServiceCallBack cbListen, LDWORD dwUserData);

// stop service
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopListenServer(LLONG lServerHandle);

// Respond the registration requestion from the device 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ResponseDevReg(char *devSerial, char* ip, WORD port, BOOL bAccept);

//------------------------------------------------------------------------

// redirect service callback function original shape
typedef int (CALLBACK *fRedirectServerCallBack)( LLONG lDevHandle, char *pDevIp, WORD wDevPort, LDWORD dwUserData);

// start redirect service
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartRedirectService(char* ip, WORD port,fRedirectServerCallBack cbListen, LDWORD dwUserData);

// stop redirect service
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopRedirectService(LLONG lServerHandle);

// set ip and port of auto register server 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetAutoRegisterServerInfo(LLONG lDevHandle, char* ARSIP, WORD ARSPort,WORD nRetry);

//------------------------------------------------------------------------

//------------------------------------------------------------------------
// stream type of request device to push
typedef enum tagEM_DEV_PUSH_STREAM_TYPE
{
	EM_DEV_PUSH_STREAM_TYPE_MAJOR,	// major stream
	EM_DEV_PUSH_STREAM_TYPE_MINOR1, // minor stream 1
	EM_DEV_PUSH_STREAM_TYPE_MINOR2, // minor stream 2
}EM_DEV_PUSH_STREAM_TYPE;

// CLIENT_ReqDevStartPushStream input param 
typedef struct tagNET_IN_REQUEST_START_PUSH_STREAM_TYPE
{
	DWORD						dwSize;
	int							nChannelID;
	EM_DEV_PUSH_STREAM_TYPE		emStreamType;
	char						szSSID[MAX_PUSH_STREAM_AUTH_SSID];
	char						szReciveServerIP[DH_MAX_IPADDR_LEN_EX];
	int							nReciveServerPort;
}NET_IN_REQUEST_START_PUSH_STREAM_TYPE;

// CLIENT_ReqDevStartPushStream output param 
typedef struct tagNET_OUT_REQUEST_START_PUSH_STREAM_TYPE
{
	DWORD dwSize;
}NET_OUT_REQUEST_START_PUSH_STREAM_TYPE;

// CLIENT_ReqDevStopPushStream input param
typedef struct tagNET_IN_REQUEST_STOP_PUSH_STREAM_TYPE
{
	DWORD	dwSize;
	char	szSSID[MAX_PUSH_STREAM_AUTH_SSID];
}NET_IN_REQUEST_STOP_PUSH_STREAM_TYPE;

// CLIENT_ReqDevStopPushStream output param
typedef struct tagNET_OUT_REQUEST_STOP_PUSH_STREAM_TYPE
{
	DWORD	dwSize;
}NET_OUT_REQUEST_STOP_PUSH_STREAM_TYPE;

// CLIENT_QueryDevPushStreamInfo input param
typedef struct tagNET_IN_QUERY_PUSH_STREAM_INFO
{
	DWORD	dwSize;
	char	szSSID[MAX_PUSH_STREAM_AUTH_SSID];
}NET_IN_QUERY_PUSH_STREAM_INFO;

// CLIENT_QueryDevPushStreamInfo output param
typedef struct tagNET_OUT_QUERY_PUSH_STREAM_INFO
{
	DWORD	dwSize;
	char	szReciveServerIP[DH_MAX_IPADDR_LEN_EX];
	int		nReciveServerPort;
}NET_OUT_QUERY_PUSH_STREAM_INFO;

// request device push stream to receive server
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ReqDevStartPushStream(LLONG lLoginID,const NET_IN_REQUEST_START_PUSH_STREAM_TYPE* pInParam, NET_OUT_REQUEST_START_PUSH_STREAM_TYPE* pOutParam, int nWaitTime);

// request device  stop push stream to receive server
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ReqDevStopPushStream(LLONG lLoginID,const NET_IN_REQUEST_STOP_PUSH_STREAM_TYPE* pInParam, NET_OUT_REQUEST_STOP_PUSH_STREAM_TYPE* pOutParam, int nWaitTime);

// query the push stream info of device
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDevPushStreamInfo(LLONG lLoginID, const NET_IN_QUERY_PUSH_STREAM_INFO* pInParam, NET_OUT_QUERY_PUSH_STREAM_INFO* pOutParam, int nWaitTime);
//------------------------------------------------------------------------

//------------------------------------------------------------------------
// push stream client connect state
typedef enum tagEM_PUSH_STREAM_CONNECT_STATE
{
	EM_PUSH_STREAM_CONNECT_STATE_SETUP,
	EM_PUSH_STREAM_CONNECT_STATE_TEARDOWN,
}EM_PUSH_STREAM_CONNECT_STATE;

// push stream client state callback function original shape
typedef void (CALLBACK *fStreamClientState)(LLONG lClientHandle, char* clientIP, int clientPort, EM_PUSH_STREAM_CONNECT_STATE clientConState, LDWORD dwUserData);

// push stream data come callback function original shape
typedef void (CALLBACK *fStreamDataComing)(LLONG lClientHandle, BYTE *pBuffer, DWORD dwBufSize,LDWORD dwUserData);

// start receive stream service
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartReceiveStreamService(char *ip, WORD port,fStreamClientState cbClientState,LDWORD dwUserData1, fStreamDataComing cbLiveStreamData, LDWORD dwUserData2);

// stop receive stream service
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopReceiveStreamService(LLONG lServerHandle);

// stop one stream client
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopStreamClient(LLONG lClientHandle);

// set stream client authentication SSID
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetStreamClientAuthID(LLONG lServerHandle, const char* pSSID);

//------------------------------------------------------------------------


//------------------------------------------------------------------------

// Alarm upload function. Enable service. dwTimeOut paramter is invalid 
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartService(WORD wPort, char *pIp );

// Stop service 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopService(LLONG lHandle);

//------------------------------------------------------------------------

// Set audio talk mode(client-end mode or server mode), user malloc pValue's memory,please refer to the corresponding structure of EM_USEDEV_MODE
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDeviceMode(LLONG lLoginID, EM_USEDEV_MODE emType, void* pValue);

// Enable audio talk 
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartTalkEx(LLONG lLoginID, pfAudioDataCallBack pfcb, LDWORD dwUser);

// Talk direction
typedef enum tagEM_TALK_DIRECTION
{
	EM_TALK_DIRECTION_UNKNOWN = 0,					// unknown
	EM_TALK_DIRECTION_UNI,							// uni-talk: client -> device
	EM_TALK_DIRECTION_BILATERAL,					// bilateral talk: client <-> device
	EM_TALK_DIRECTION_LISTEN,						// listen: device -> client
}EM_TALK_DIRECTION;

// Get talk direction: lTalkHandle is the value returned by CLIENT_StartTalkEx
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetTalkDirection(LLONG lTalkHandle, EM_TALK_DIRECTION* pDirection);

// Begin PC record 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RecordStart();

// Stop PC record 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RecordStop();


// start PC record(to CLIENT_RecordStart()extend)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RecordStartEx(LLONG lLoginID);

// end PC record(to CLIENT_RecordStop() extend)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RecordStopEx(LLONG lLoginID);


// Send out audio data to the device 
CLIENT_NET_API LONG CALL_METHOD CLIENT_TalkSendData(LLONG lTalkHandle, char *pSendBuf, DWORD dwBufSize);

// Decode audio data 
CLIENT_NET_API void CALL_METHOD CLIENT_AudioDec(char *pAudioDataBuf, DWORD dwBufSize);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AudioDecEx(LLONG lTalkHandle, char *pAudioDataBuf, DWORD dwBufSize);

// Set audio talk volume
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetAudioClientVolume(LLONG lTalkHandle, WORD wVolume);

// Stop audio talk 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopTalkEx(LLONG lTalkHandle);

// add device into broadcast group 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AudioBroadcastAddDev(LLONG lLoginID);

// Remove device from the broadcast group 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AudioBroadcastDelDev(LLONG lLoginID);

// audio encode-initialization(specified standard format, private format)
CLIENT_NET_API int  CALL_METHOD CLIENT_InitAudioEncode(DH_AUDIO_FORMAT aft);

// Audio encode--data encode
CLIENT_NET_API int	CALL_METHOD	CLIENT_AudioEncode(LLONG lTalkHandle, BYTE *lpInBuf, DWORD *lpInLen, BYTE *lpOutBuf, DWORD *lpOutLen);

// audio encode--complete and then exit
CLIENT_NET_API int	CALL_METHOD	CLIENT_ReleaseAudioEncode();

//------------------------------------------------------------------------

// Search device log
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryLog(LLONG lLoginID, char *pLogBuffer, int maxlen, int *nLogBufferlen, int waittime);

// Search device log page by page.
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDeviceLog(LLONG lLoginID, QUERY_DEVICE_LOG_PARAM *pQueryParam, char *pLogBuffer, int nLogBufferLen, int *pRecLogNum, int waittime);

// search device log item
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDevLogCount(LLONG lLoginID, NET_IN_GETCOUNT_LOG_PARAM *pInParam, NET_OUT_GETCOUNT_LOG_PARAM* pOutParam , int waittime);

// Set Subscribe log callback
CLIENT_NET_API void CALL_METHOD CLIENT_SetSubscribeLogCallBack(fSubLogDataCallBack pLogDataCB, LDWORD dwUser);

// start Subscribe device log
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartSubscribeLog(LLONG lLoginID, int nWaittime, void* pReserved);

// Stop subscribe device log
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopSubscribeLog(LLONG lSubLogHandle);

// Search channel record status, user malloc and free the memory of pRSBuffer
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryRecordState(LLONG lLoginID, char *pRSBuffer, int maxlen, int *nRSBufferlen, int waittime);

// Search channel extra record status (the returned byte number was equal to the channel number, every byte instruct the respond channel's state,0-stop,1-manual,2-schedule),user malloc and free the memory of pRSBuffer
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryExtraRecordState(LLONG lLoginID, char *pRSBuffer, int maxlen, int *nRSBufferlen, void *pReserved, int waittime);

// Search device status,user malloc pBuf memory,please refer to query device type to ensure structure,then apply to the memory size of structure 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDevState(LLONG lLoginID, int nType, char *pBuf, int nBufLen, int *pRetLen, int waittime);

// query remote device state,when nType = DH_DEVSTATE_ALARM_FRONTDISCONNECT,the number form 1.
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryRemotDevState(LLONG lLoginID, int nType, int nChannelID, char *pBuf, int nBufLen, int *pRetLen, int waittime);

// Search system capacity information ,user malloc pSysInfoBuffer's memory,please refer to the corresponding structure of DH_SYS_ABILITY.if nSystemType is ABILITY_DYNAMIC_CONNECT,memory is sizeof(BOOL) at least,if nSystemType is ABILITY_TRIGGER_MODE,memory size is sizeof(int) at least.
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QuerySystemInfo(LLONG lLoginID, int nSystemType, char *pSysInfoBuffer, int maxlen, int *nSysInfolen, int waittime);

// New Search system capacity information(by Json)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryNewSystemInfo(LLONG lLoginID, char* szCommand, int nChannelID, char* szOutBuffer, DWORD dwOutBufferSize, int *error, int waittime);

// Get channel bit stream 
CLIENT_NET_API LONG CALL_METHOD CLIENT_GetStatiscFlux(LLONG lLoginID, LLONG lPlayHandle);

// Get PTZ information 
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_GetPtzOptAttr(LLONG lLoginID,DWORD dwProtocolIndex,LPVOID lpOutBuffer,DWORD dwBufLen,DWORD *lpBytesReturned,int waittime);

// device capacity type, corresponding to CLIENT_GetDevCaps port
#define NET_DEV_CAP_SEQPOWER            0x01                // power timing capacity, pInBuf=NET_IN_CAP_SEQPOWER*, pOutBuf=NET_OUT_CAP_SEQPOWER*
#define NET_ENCODE_CFG_CAPS             0x02                // device encode config corresponding to capacity, pInBuf=NET_IN_ENCODE_CFG_CAPS*, pOutBuf= NET_OUT_ENCODE_CFG_CAPS*
#define NET_VIDEOIN_FISHEYE_CAPS        0x03                // Fish eye capacity , pInBuf=NET_IN_VIDEOIN_FISHEYE_CAPS*, pOutBuf=NET_OUT_VIDEOIN_FISHEYE_CAPS*
#define NET_COMPOSITE_CAPS              0x04                // Get composited caps by pointed window number, pInBuf=NET_IN_COMPOSITE_CAPS*, pOutBuf=NET_OUT_COMPOSITE_CAPS*
#define NET_VIDEO_DETECT_CAPS           0x05                // Get video detect device caps,pInBuf=NET_IN_VIDEO_DETECT_CAPS* , pOutBuf=NET_OUT_VIDEO_DETECT_CAPS*
#define NET_THERMO_GRAPHY_CAPS          0x06                // Thermal imaging camera capability, pInBuf=NET_IN_THERMO_GETCAPS*, pOutBuf=NET_OUT_THERMO_GETCAPS*
#define NET_RADIOMETRY_CAPS             0x07                // Thermal imaging radiometry capability, pInBuf=NET_IN_RADIOMETRY_GETCAPS*, pOutBuf=NET_OUT_RADIOMETRY_GETCAPS*
#define NET_POS_CAPS                    0x08                // POS capability, pInBuf = NET_IN_POS_GETCAPS *, pOutBuf = NET_OUT_POS_GETCAPS *
#define NET_USER_MNG_CAPS               0x09                // User manage capability, pInBuf = NET_IN_USER_MNG_GETCAPS *, pOutBuf = NET_OUT_USER_MNG_GETCAPS *
#define NET_MEDIAMANAGER_CAPS           0x0a                // query capabilities of VideoInput, pInBuf=NET_IN_MEDIAMANAGER_GETCAPS*, pOutBuf=NET_OUT_MEDIAMANAGER_GETCAPS*
#define NET_VIDEO_MOSAIC_CAPS           0x0b                // query capabilities of video mosaic, pInBuf=NET_IN_MEDIA_VIDEOMOSAIC_GETCAPS*, pOutBuf=NET_OUT_MEDIA_VIDEOMOSAIC_GETCAPS*
#define NET_SNAP_CFG_CAPS               0x0c                // query capabilities of snap config, pInBuf=NET_IN_SNAP_CFG_CAPS*, pOutBuf= NET_OUT_SNAP_CFG_CAPS*
#define NET_VIDEOIN_CAPS                0x0d                // query capabilities of VideoInput, pInBUf = NET_IN_VIDEOIN_CAPS*, pOutBuf = NET_OUT_VIDEOIN_CAPS*
#define NET_FACE_BOARD_CAPS             0x0e                // query capabilities of face board, pInBuf = NET_IN_FACEBOARD_CAPS*, pOutBuf = NET_OUT_FACEBOARD_CAPS*
#define NET_EXTERNALSENSOR_CAPS         0x0f                // query capabilities of external sensor, pInBuf = NET_IN_EXTERNALSENSOR_CAPS*, pOutBuf = NET_OUT_EXTERNALSENSOR_CAPS*
#define NET_VIDEO_IMAGECONTROL_CAPS     0x10                // video image control capability, pInBuf = NET_IN_VIDEO_IMAGECONTROL_CAPS*, pOutBuf = NET_OUT_VIDEO_IMAGECONTROL_CAPS*
#define NET_VIDEOIN_EXPOSURE_CAPS       0x11                // video exposure capability, pInBuf = NET_IN_VIDEOIN_EXPOSURE_CAPS*, pOutBuf = NET_OUT_VIDEOIN_EXPOSURE_CAPS*
#define NET_VIDEOIN_DENOISE_CAPS        0x12                // video denoise capability, pInBuf = NET_IN_VIDEOIN_DENOISE_CAPS*, pOutBuf = NET_OUT_VIDEOIN_DENOISE_CAPS*
#define NET_VIDEOIN_BACKLIGHT_CAPS      0x13                // video back light capability, pInBuf = NET_IN_VIDEOIN_BACKLIGHT_CAPS*, pOutBuf = NET_OUT_VIDEOIN_BACKLIGHT_CAPS*
#define NET_VIDEOIN_WHITEBALANCE_CAPS   0x14                // video white balance capability, pInBuf = NET_IN_VIDEOIN_WHITEBALANCE_CAPS*, pOutBuf = NET_OUT_VIDEOIN_WHITEBALANCE_CAPS*
#define NET_VIDEOIN_DAYNIGHT_CAPS       0x15                // video day night capability, pInBuf = NET_IN_VIDEOIN_DAYNIGHT_CAPS*, pOutBuf = NET_OUT_VIDEOIN_DAYNIGHT_CAPS*
#define NET_VIDEOIN_ZOOM_CAPS           0x16                // video zoom capability, pInBuf = NET_IN_VIDEOIN_ZOOM_CAPS*, pOutBuf = NET_OUT_VIDEOIN_ZOOM_CAPS*
#define NET_VIDEOIN_FOCUS_CAPS          0x17                // video focus capability, pInBuf = NET_IN_VIDEOIN_FOCUS_CAPS*, pOutBuf = NET_OUT_VIDEOIN_FOCUS_CAPS*
#define NET_VIDEOIN_SHARPNESS_CAPS      0x18                // video sharpness capability, pInBuf = NET_IN_VIDEOIN_SHARPNESS_CAPS*, pOutBuf = NET_OUT_VIDEOIN_SHARPNESS_CAPS*
#define NET_VIDEOIN_COLOR_CAPS          0x19                // video color capability, pInBuf = NET_IN_VIDEOIN_COLOR_CAPS*, pOutBuf = NET_OUT_VIDEOIN_COLOR_CAPS*
#define NET_GET_MASTERSLAVEGROUP_CAPS   0x1a                // Get service capability set, pInBuf = NET_IN_GET_MASTERSLAVEGROUP_CAPS*, pOutBuf = NET_OUT_GET_MASTERSLAVEGROUP_CAPS*
#define NET_FACERECOGNITIONSE_CAPS      0x1b                // Face Recognition Server Caps bility Query  pInBuf = NET_IN_FACERECOGNITIONSERVER_CAPSBILITYQUERY, pOutBuf = NET_OUT_FACERECOGNITIONSERVER_CAPSBILITYQUERY *
#define NET_STORAGE_CAPS                0x1c                // Get Storage capability, pInBuf = NET_IN_STORAGE_CAPS*, pOutBuf = NET_OUT_STORAGE_CAPS*
#define NET_VIDEOIN_RAWFRAME_CAPS       0x1d                // Get the video input extension capability set, pInBuf = NET_IN_VIDEOIN_RAWFRAME_CAPS*, pOutBuf = NET_OUT_VIDEOIN_RAWFRAME_CAPS*
#define NET_COAXIAL_CONTROL_IO_CAPS     0x1e                // Get coaxial IO control caps, pInBuf = NET_IN_GET_COAXIAL_CONTROL_IO_CAPS*, pOutBuf = NET_OUT_GET_COAXIAL_CONTROL_IO_CAPS*
#define NET_FACEINFO_CAPS               0x1f                // Get accesscontrol face caps, pInBuf = NET_IN_GET_FACEINFO_CAPS*, pOutBuf = NET_OUT_GET_FACEINFO_CAPS*
#define NET_ACCESSCONTROL_CAPS          0x20                // Get accesscontrol server caps, pInBuf = NET_IN_AC_CAPS*, pOutBuf = NET_OUT_AC_CAPS*
#define NET_COAXIAL_CONTROL_IO_STATUS   0x21                // Get Coaxial Control IO Status, pInBuf = NET_IN_GET_COAXIAL_CONTROL_IO_STATUS*, pOutBuf = NET_OUT_GET_COAXIAL_CONTROL_IO_STATUS*
#define NET_LIGHTINGCONTROL_CAPS        0x22                // Get light caps(IPC/SD), pInBuf =NET_IN_LIGHTINGCONTROL_CAPS* ,pOutBuf=NET_OUT_LIGHTINGCONTROL_CAPS*
#define NET_SUPPORT_GET_AUDIO_DECODE_CAPS   0x23            // Get Whether support get audio decode caps, pInBuf =NET_IN_SUPPORT_GET_AUDIO_DECODE_CAPS* ,pOutBuf=NET_OUT_SUPPORT_GET_AUDIO_DECODE_CAPS*
#define NET_UNIFIEDINFOCOLLECT_CAPS     0x24                // Get support DMSS private protocol caps, pInBuf = NET_IN_UNIFIEDINFOCOLLECT_CAPS*, pOutBuf = NET_OUT_UNIFIEDINFOCOLLECT_CAPS*
#define NET_EXALARMBOX_CAPS             0x25                // Get ExAlarmBox caps, pInBuf = NET_IN_EXALARMBOX_CAPS*, pOutBuf = NET_OUT_EXALARMBOX_CAPS*
#define NET_ALARMBOXMANAGER_CAPS        0x26                // Get alarm box manager capspInBuf = NET_IN_ALARMBOXMANAGER_CAPS*, pOutBuf = NET_OUT_ALARMBOXMANAGER_CAPS* 
#define NET_GET_AUDIO_DETECT_CAPS       0x27                // Get audio detect caps, pInBuf = NET_IN_GET_AUDIO_DETECT_CAPS*, pOutBuf = NET_OUT_GET_AUDIO_DETECT_CAPS*                                       
#define NET_SUPPORT_FACEDB_DOWNLOAD     0x28                // Is support to download remote face data base or not, pInBuf = NET_IN_SUPPORT_FACEDB_DOWNLOAD_CAPS*, pOutBuf = NET_OUT_SUPPORT_FACEDB_DOWNLOAD_CAPS*
#define NET_GET_LENS_FUNC_CAPS          0x29                // Get adjust position caps, pInBuf = NET_IN_GET_LENS_FUNC_CAPS*, pOutBuf = NET_OUT_GET_LENS_FUNC_CAPS*
#define NET_VIDEO_IN_DEFOG_CAPS         0x30                // Capturing the Fog Permeability Set of Video, pInBuf = NET_IN_VIDEO_IN_DEFOG_CAPS*, pOutBuf = NET_OUT_VIDEO_IN_DEFOG_CAPS*       
#define NET_DIAGNOSIS_CAPS				0x31				// Get Fault Diagnose caps, pInBuf = NET_IN_DIAGNOSIS_CAPS*, pOutBuf = NET_OUT_DIAGNOSIS_CAPS*
#define NET_LOWRATEWPAN_CAPS			0x32				// Get LowRateWPAN caps, pInBuf = NET_IN_LOWRATEWPAN_CAPS*, pOutBuf = NET_OUT_LOWRATEWPAN_CAPS*
#define NET_GET_FILE_TRANSFER_CAPS      0x33                // Get file transfer caps, pInBuf = NET_IN_GET_FILE_TRANSFER_CAPS*, pOutBuf = NET_OUT_GET_FILE_TRANSFER_CAPS*

CLIENT_NET_API BOOL  CALL_METHOD CLIENT_GetDevCaps(LLONG lLoginID, int nType, void* pInBuf, void* pOutBuf, int nWaitTime);

// device info type, corresponding to CLIENT_QueryDevInfo port
#define NET_QUERY_DEV_STORAGE_NAMES                 0x01                // search device storage module name list , pInBuf=NET_IN_STORAGE_DEV_NAMES *, pOutBuf=NET_OUT_STORAGE_DEV_NAMES *
#define NET_QUERY_DEV_STORAGE_INFOS                 0x02                // search device storage info list, pInBuf=NET_IN_STORAGE_DEV_INFOS*, pOutBuf= NET_OUT_STORAGE_DEV_INFOS *
#define NET_QUERY_RECENCY_JNNCTION_CAR_INFO         0x03                // search recent ANPR vehicle info port, pInBuf=NET_IN_GET_RECENCY_JUNCTION_CAR_INFO*, pOutBuf=NET_OUT_GET_RECENCY_JUNCTION_CAR_INFO*
#define NET_QUERY_LANES_STATE                       0x04                // search lane info ,pInBuf = NET_IN_GET_LANES_STATE , pOutBuf = NET_OUT_GET_LANES_STATE
#define NET_QUERY_DEV_FISHEYE_WININFO               0x05                // search Fish eye window info , pInBuf= NET_IN_FISHEYE_WININFO*, pOutBuf=NET_OUT_FISHEYE_WININFO *
#define NET_QUERY_DEV_REMOTE_DEVICE_INFO            0x06                // search remote device info , pInBuf= NET_IN_GET_DEVICE_INFO*, pOutBuf= NET_OUT_GET_DEVICE_INFO *
#define NET_QUERY_SYSTEM_INFO                       0x07                // search system info , pInBuf= NET_IN_SYSTEM_INFO*, pOutBuf= NET_OUT_SYSTEM_INFO*
#define NET_QUERY_REG_DEVICE_NET_INFO               0x08                // query active register device network connection , pInBuf=NET_IN_REGDEV_NET_INFO * , pOutBuf=NET_OUT_REGDEV_NET_INFO *
#define NET_QUERY_DEV_THERMO_GRAPHY_PRESET          0x09                // query thermal preset info , pInBuf= NET_IN_THERMO_GET_PRESET_INFO*, pOutBuf= NET_OUT_THERMO_GET_PRESET_INFO *
#define NET_QUERY_DEV_THERMO_GRAPHY_OPTREGION       0x0a                // query thermal ROI info, pInBuf= NET_IN_THERMO_GET_OPTREGION*, pOutBuf= NET_OUT_THERMO_GET_OPTREGION *
#define NET_QUERY_DEV_THERMO_GRAPHY_EXTSYSINFO      0x0b                // query thermal external system info, pInBuf= NET_IN_THERMO_GET_EXTSYSINFO*, pOutBuf= NET_OUT_THERMO_GET_EXTSYSINFO *
#define NET_QUERY_DEV_RADIOMETRY_POINT_TEMPER       0x0c                // query the parameter value of temperature measurement point, pInBuf= NET_IN_RADIOMETRY_GETPOINTTEMPER*, pOutBuf= NET_OUT_RADIOMETRY_GETPOINTTEMPER *
#define NET_QUERY_DEV_RADIOMETRY_TEMPER             0x0d                // query parameter value of temperature measurement item, pInBuf= NET_IN_RADIOMETRY_GETTEMPER*, pOutBuf= NET_OUT_RADIOMETRY_GETTEMPER *
#define NET_QUERY_GET_CAMERA_STATE                  0x0e                // query camera state, pInBuf= NET_IN_GET_CAMERA_STATEINFO*, pOutBuf= NET_OUT_GET_CAMERA_STATEINFO *
#define NET_QUERY_GET_REMOTE_CHANNEL_AUDIO_ENCODE   0x0f                // acquire remote communication audio coding mode  , pInBuf= NET_IN_GET_REMOTE_CHANNEL_AUDIO_ENCODEINFO*, pOutBuf= NET_OUT_GET_REMOTE_CHANNEL_AUDIO_ENCODEINFO *
#define NET_QUERY_GET_COMM_PORT_INFO                0x10                // get comm port Info, pInBuf=NET_IN_GET_COMM_PORT_INFO* , pOutBuf=NET_OUT_GET_COMM_PORT_INFO* 
#define NET_QUERY_GET_LINKCHANNELS                  0x11                // query video linked channels for a single channel 
#define NET_QUERY_GET_VIDEOOUTPUTCHANNELS           0x12                // query video decode channel count statistics info, pInBuf=NET_IN_GET_VIDEOOUTPUTCHANNELS*, pOutBuf=NET_OUT_GET_VIDEOOUTPUTCHANNELS*
#define NET_QUERY_GET_VIDEOINFO                     0x13                // query video decode channel info, pInBuf=NET_IN_GET_VIDEOINFO*, pOutBuf=NET_OUT_GET_VIDEOINFO*
#define NET_QUERY_GET_ALLLINKCHANNELS               0x14                // query all linked video channel groups, pInBuf=NET_IN_GET_ALLLINKCHANNELS* , pOutBuf=NET_OUT_GET_ALLLINKCHANNELS*
#define NET_QUERY_VIDEOCHANNELSINFO                 0x15                // query video channel info, pInBuf=NET_IN_GET_VIDEOCHANNELSINFO* , pOutBuf=NET_OUT_GET_VIDEOCHANNELSINFO*
#define NET_QUERY_TRAFFICRADAR_VERSION              0x16                // query traffic radar version, pInBuf=NET_IN_TRAFFICRADAR_VERSION* , pOutBuf=NET_OUT_TRAFFICRADAR_VERSION*
#define NET_QUERY_WORKGROUP_NAMES                   0x17                // query all workgroups' names, pInBuf=NET_IN_WORKGROUP_NAMES* , pOutBuf=NET_OUT_WORKGROUP_NAMES*
#define NET_QUERY_WORKGROUP_INFO                    0x18                // query workgroup info, pInBuf=NET_IN_WORKGROUP_INFO* , pOutBuf=NET_OUT_WORKGROUP_INFO*
#define NET_QUERY_WLAN_ACCESSPOINT                  0x19                // query wlan access point info, pInBuf=NET_IN_WLAN_ACCESSPOINT* , pOutBuf=NET_OUT_WLAN_ACCESSPOINT*
#define NET_QUERY_GPS_INFO							0x1a				// query device GPS information,pInBuf=NET_IN_DEV_GPS_INFO* , pOutBuf=NET_OUT_DEV_GPS_INFO*
#define NET_QUERY_IVS_REMOTE_DEVICE_INFO            0x1b                // query IVS related remote device info, pInBuf = NET_IN_IVS_REMOTE_DEV_INFO*, pOutBuf = NET_OUT_IVS_REMOTE_DEV_INFO*
#define NET_QUERY_SMART_SWITCH_INFO                 0x1c                // query smart switch info, pInBuf = NET_IN_SMART_SWITCH_INFO*,  pOutBuf = NET_OUT_SMART_SWITCH_INFO*
#define NET_QUERY_UPGRADE_STATE                     0x1d                // query upgrade state, pInBuf = NET_IN_UPGRADE_STATE*, pOutBuf = NET_OUT_UPGRADE_STATE* 
#define NET_QUERY_VIDEO_ENCODE_CAPS					0x1e				// query video encode caps, pInBuf = NET_IN_VIDEO_ENCODE_CAPS*, pOutBuf = NET_OUT_VIDEO_ENCODE_CAPS* 
#define NET_QUERY_AUDIO_ENCODE_CAPS					0x1f				// query audio encode caps, pInBuf = NET_IN_AUDIO_ENCODE_CAPS*, pOutBuf = NET_OUT_AUDIO_ENCODE_CAPS* 
#define NET_QUERY_AUDIO_IN_CAPS						0x20				// query audio input channel caps, pInBuf = NET_IN_AUDIO_IN_CAPS*, pOutBuf = NET_OUT_AUDIO_IN_CAPS* 
#define NET_QUERY_SMART_ENCODE_CAPS					0x21				// query Smart encode caps, pInBuf = NET_IN_SMART_ENCODE_CAPS*, pOutBuf = NET_OUT_SMART_ENCODE_CAPS* 
#define NET_QUERY_HARDDISK_TEMPERATURE				0x22				// query hard disk temperature,pInBu f= NET_IN_HDD_TEMPERATURE*,pOutBuf = NET_OUT_HDD_TEMPERATURE*
#define NET_QUERY_RAWFRAMEDATA						0x23				// Gets YUV data in the specified format, pInBuf = NET_IN_RAWFRAMEDATA*, pOutBuf = NET_OUT_RAWFRAMEDARA*
#define NET_QUERY_GETSPLICEDATA						0x24				// get device splice date, pInBuf = NET_IN_GETSPLICEDATA*, pOutBuf = NET_OUT_GETSPLICEDATA*
#define NET_QUERY_AUDIO_DECODE_CAPS					0x25				// query audio decode caps, pInBuf = NET_IN_AUDIO_DECODE_CAPS*, pOutBuf = NET_OUT_AUDIO_DECODE_CAPS* 
#define	NET_QUERY_DEVICE_ID							0x26				// query device id, pInBuf = NET_IN_DEVICE_ID*, pOutBuf = NET_OUT_DEVICE_ID* 

// search device info,user malloc memory of pInBuf and pOutBuf,please refer to nQueryType to ensure structure,then ensure memory size
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_QueryDevInfo(LLONG lLoginID, int nQueryType, void* pInBuf, void* pOutBuf, void *pReserved );
//------------------------------------------------------------------------

// Reboot device 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RebootDev(LLONG lLoginID);

// Shut down devic e
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ShutDownDev(LLONG lLoginID);

// Device control,user malloc param's memory,please refer to the corresponding structure of type 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ControlDevice(LLONG lLoginID, CtrlType type, void *param, int waittime );

// Device control asynchronism,user malloc param's memory,please refer to the corresponding structure of type
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartControlDevice(LLONG lLoginID, CtrlType type, void *param);

// Set channel record status,user mallloc memory of pInBuf and pOutBuf,please refer to corresponding structure of emType.
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ControlDeviceEx(LLONG lLoginID, CtrlType emType, void* pInBuf, void* pOutBuf );

#define DH_POS_EXCHANGE_GOODS_MAX             4           //goods array number   
#define DH_POS_EXCHANGE_FUSSY_KEY_MAX		  4           //the key words'number of fuzzy pattern

// POS get exchange information   the key word type of Fuzzy pattern
typedef enum tagEM_NET_POS_EXCHANGE_FUSSY_KEY
{
    EM_NET_POS_EXCHANGE_KEY_NULL = 0,                      // not Fuzzy pattern
    EM_NET_POS_EXCHANGE_KEY_GOODS = 1,                     // key word = Goods(now only suport Goods when Fuzzy pattern)
} EM_NET_POS_EXCHANGE_FUSSY_KEY;
  
// Interface CLIENT_StartFind  command NET_FIND_POS_EXCHANGE in param       
typedef struct tagNET_IN_POSEXCHANGE_STARTFIND       
{       
    DWORD							dwSize;														//struct size       
    int								nChannel;													//channel number, 0 - first channel, -1 - all channel       
    NET_TIME_EX						stuStartTime;												//start time       
    NET_TIME_EX				        stuEndTime;													//end time       
    char							szGoods[DH_POS_EXCHANGE_GOODS_MAX][DH_COMMON_STRING_32];    //goods       
    EM_NET_POS_EXCHANGE_FUSSY_KEY   szFuzzyPattern[DH_POS_EXCHANGE_FUSSY_KEY_MAX];			    //Fuzzy pattern       
    int                             nPosId;                                                     //Pos id, -1 means all pos
} NET_IN_POSEXCHANGE_STARTFIND;       
        
// Interface CLIENT_StartFind command NET_FIND_POS_EXCHANGE out param       
typedef struct tagNET_OUT_POSEXCHANGE_STARTFIND       
{       
    DWORD                dwSize;                         // struct size       
    unsigned int		 nToken;						 // Token
    DWORD                dwTotalCount;                   // total count       
}NET_OUT_POSEXCHANGE_STARTFIND;       
        
// Interface CLIENT_DoFind command NET_FIND_POS_EXCHANGE in param       
typedef struct tagNET_IN_POSEXCHANGE_DOFIND       
{       
    DWORD                dwSize;                         // struct size       
    unsigned int		 nToken;						 // Search handle       
    unsigned int		 nBeginNumber;                   // begin number    0<=dwBeginNumber<=dwTotalCount-1       
    unsigned int         nCount;                         // count of get exchange information       
} NET_IN_POSEXCHANGE_DOFIND;       
        
// POS exchange information       
typedef struct tagNET_POSEXCHANGE_INFO       
{       
    NET_TIME            stuExchangeTime;                //exchange time       
}NET_POSEXCHANGE_INFO;       

// POS exchange info 
typedef struct tagNET_POSEXCHANGE_INFO_EX
{
    int                 nPosId;                         // Pos id
    char                cDetail[512];                   // exchange detail info
    int                 nDetailLen;                     // length of cDetail
    BYTE                reserved[1024];                 // reserved
} NET_POSEXCHANGE_INFO_EX;
        
// Interface CLIENT_DoFind command NET_FIND_POS_EXCHANGE out param       
typedef struct tagNET_OUT_POSEXCHANGE_DOFIND       
{       
    DWORD                       dwSize;                                             // struct size       
    DWORD                       dwFound;                                            // found number       
    NET_POSEXCHANGE_INFO        arrPOSExchangeInfo[DH_MAX_POS_EXCHANGE_INFO];       // pos exchange information array       
    NET_POSEXCHANGE_INFO_EX     stuInfoEx[DH_MAX_POS_EXCHANGE_INFO];                // exchange info detail
}NET_OUT_POSEXCHANGE_DOFIND;       
        
// Interface CLIENT_StopFind command NET_FIND_POS_EXCHANGE in param       
typedef struct tagNET_IN_POSEXCHANGE_STOPFIND       
{          
    DWORD               dwSize;                             // struct size       
    unsigned int        nToken;								// Search handle       
} NET_IN_POSEXCHANGE_STOPFIND;       
        
// Interface CLIENT_StopFind command NET_FIND_POS_EXCHANGE out param       
typedef struct tagNET_OUT_POSEXCHANGE_STOPFIND       
{          
    DWORD               dwSize;                             // struct size       
} NET_OUT_POSEXCHANGE_STOPFIND;       

typedef enum tagNET_FIND {
    NET_FIND_RADIOMETRY,                            // thermal temperature query, pInBuf= NET_IN_RADIOMETRY_*FIND*, pOutBuf= NET_OUT_RADIOMETRY_*FIND*    
	NET_FIND_POS_EXCHANGE,							// POS Exchange Info Find,pInBuf = NET_IN_POSEXCHANGE_*FIND*,pOutBuf= NET_OUT_POSEXCHANGE_*FIND*
} NET_FIND;

// decode callback type
typedef enum tagNET_VIDEOSTREAM_TYPE
{
	NET_VIDEOSTREAM_NORMAL,							// normal
	NET_VIDEOSTREAM_YUV,							// YUV
} NET_VIDEOSTREAM_TYPE;


#define MAX_EVENT_LINK_QUERY_CODE_NUMBER	8		// max number of query code
#define MAX_EVENT_LINK_NAME_NUMBER			16		// max number of event link name

typedef enum tagEM_NET_QUERY_CODE {
		EM_NET_QUERY_CODE_UNKNOWN,					// Unknown
		EM_NET_QUERY_CODE_CROSSLINEDETECTION,		// CrossLineDetection
		EM_NET_QUERY_CODE_CROSSREGIONDETECTION,		// CrossRegionDetection
		EM_NET_QUERY_CODE_TAKENAWAYDETECTION,		// TakenAwayDetection
		EM_NET_QUERY_CODE_LEFTDETECTION,			// LeftDetection
		EM_NET_QUERY_CODE_PARKINGDETECTION,			// ParkingDetection
		EM_NET_QUERY_CODE_WANDERDETECTION,			// WanderDetection
		EM_NET_QUERY_CODE_MOVEDETECTION,			// MoveDetection
		EM_NET_QUERY_CODE_FACEDETECTION,			// FaceDetection
		EM_NET_QUERY_CODE_RETROGRADEDETECTION,		// RetrogradeDetection
		EM_NET_QUERY_CODE_NUMBERSTAT,				// NumberStat
		EM_NET_QUERY_CODE_TRAFFICJUNCTION,			// TrafficJunction
		EM_NET_QUERY_CODE_RIOTERDETECTION,			// RioterDetection
		EM_NET_QUERY_CODE_ALARMLOCAL,				// AlarmLocal
		EM_NET_QUERY_CODE_VIDEOMOTION,				// VideoMotion
		EM_NET_QUERY_CODE_VIDEOBLIND,				// VideoBlind
		EM_NET_QUERY_CODE_AUDIODETECT,				// AudioDetect
		EM_NET_QUERY_CODE_AUDIOANOMALY,				// AudioAnomaly
		EM_NET_QUERY_CODE_AUDIOMUTATION,			// AudioMutation
		EM_NET_QUERY_CODE_SCENECHANGE,				// SceneChange
		EM_NET_QUERY_CODE_VIDEOUNFOCUS,				// VideoUnFocus
		EM_NET_QUERY_CODE_STORAGELOWSPACE,			// StorageLowSpace
		EM_NET_QUERY_CODE_STORAGEFAILURE,			// StorageFailure
		EM_NET_QUERY_CODE_LOGINFAILURE,				// LoginFailure
		EM_NET_QUERY_CODE_STORAGENOTEXIST,			// StorageNotExist
		EM_NET_QUERY_CODE_IPCONFLICT,				// IPConflict
		EM_NET_QUERY_CODE_NETABORT,					// NetAbort
		EM_NET_QUERY_CODE_HOTPLUG,					// HotPlug
		EM_NET_QUERY_CODE_STORAGEFORMAT,			// StorageFormat
		EM_NET_QUERY_CODE_EMERGENCYRECORDPULL,		// EmergencyRecordPull
} EM_NET_QUERY_CODE;

typedef enum tagEM_NET_LINK_NAME {
		EM_NET_LINK_NAME_UNKNOWN,				// Unknown
		EM_NET_LINK_NAME_DEFAULT,				// default, base on eventManager.getCaps
		EM_NET_LINK_NAME_TIMESECTIONENABLE,		// TimeSectionEnable
		EM_NET_LINK_NAME_RECORDENABLE,			// RecordEnable
		EM_NET_LINK_NAME_RECORDCLOUDENABLE,		// RecordCloudEnable
		EM_NET_LINK_NAME_ALARMOUTENABLE,		// AlarmOutEnable
		EM_NET_LINK_NAME_PTZLINKENABLE,			// PtzLinkEnable
		EM_NET_LINK_NAME_SNAPSHOTENABLE,		// SnapshotEnable
		EM_NET_LINK_NAME_SNAPSHOTCLOUDENABLE,	// SnapshotCloudEnable
		EM_NET_LINK_NAME_MAILENABLE,			// MailEnable
		EM_NET_LINK_NAME_BEEPENABLE,			// BeepEnable
		EM_NET_LINK_NAME_DEJITTERENABLE,		// DejitterEnable
		EM_NET_LINK_NAME_TIPENABLE,				// TipEnable
		EM_NET_LINK_NAME_MONITORTOURENABLE,		// MonitorTourEnable
		EM_NET_LINK_NAME_MMSENABLE,				// MMSEnable
		EM_NET_LINK_NAME_SUPPORTALARMBELL,		// SupportAlarmBell
		EM_NET_LINK_NAME_SUPPORTACCESSCONTROL,	// SupportAccessControl
		EM_NET_LINK_NAME_SIPCALLENABLE,			// SipCallEnable
		EM_NET_LINK_NAME_SUPPORTALARMSERVER,	// SupportAlarmServer
		EM_NET_LINK_NAME_SUPPORTPTZLINKDELAY,	// SupportPtzLinkDelay
		EM_NET_LINK_NAME_SUPPORTPSTNALARMSERVER,// SupportPSTNAlarmServer
		EM_NET_LINK_NAME_SUPPORTICR,			// SupportICR
		EM_NET_LINK_NAME_BEEPTIME,				// BeepTime
		EM_NET_LINK_NAME_DEJITTERRANGE,			// DejitterRange
		EM_NET_LINK_NAME_ALARMOUTLATCH,			// AlarmOutLatch
		EM_NET_LINK_NAME_RECORDLATCH,			// RecordLatch
		EM_NET_LINK_NAME_VOICEENABLE,			// VoiceEnable
		EM_NET_LINK_NAME_LOGENABLE,				// LogEnable
		EM_NET_LINK_NAME_SUPPORTLIGHTCONTROL,	// SupportLightControl
		EM_NET_LINK_NAME_SUPPORTVIDEOMATRIX,	// SupportVideoMatrix
} EM_NET_LINK_NAME;

// CLIENT_getEventLink in param
typedef struct tagNET_IN_EVENT_LINK
{   
    DWORD               dwSize;					// struct size
	int					nCodeNum;				// query code number
	EM_NET_QUERY_CODE	szCodeName[MAX_EVENT_LINK_QUERY_CODE_NUMBER];		// query code name
} NET_IN_EVENT_LINK;

// CLIENT_getEventLink out param
typedef struct tagNET_OUT_EVENT_LINK
{   
    DWORD               dwSize;					// struct size
	EM_NET_LINK_NAME	szLinkName[MAX_EVENT_LINK_QUERY_CODE_NUMBER][MAX_EVENT_LINK_NAME_NUMBER];		// event link names
} NET_OUT_EVENT_LINK;

// input parameter of CLIENT_GetVideoInAnalyseEnableChannels
typedef struct tagNET_IN_VIDEOINANALYSE_GET_ENABLECHANNELS
{
	DWORD               dwSize;					// struct size
} NET_IN_VIDEOINANALYSE_GET_ENABLECHANNELS;

// output parameter of CLIENT_GetVideoInAnalyseEnableChannels
typedef struct tagNET_OUT_VIDEOINANALYSE_GET_ENABLECHANNELS
{
	DWORD               dwSize;										// struct size
	int					nLocalChnNum;								// number of the local channels that have been enabled
	int					nLocalChannel[DH_MAX_CAMERA_CHANNEL_NUM];	// list of the local channels that have been enabled
	int					nRemoteChnNum;								// number of the remote channels that have been enabled
	int					nRemoteChannel[DH_MAX_CAMERA_CHANNEL_NUM];	// list of the remote channels that have been enabled
} NET_OUT_VIDEOINANALYSE_GET_ENABLECHANNELS;

// start find information,user malloc memory of pInBuf and pOutBuf,please refer to emType to ensure structure,then ensure memory size
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartFind(LLONG lLoginID, NET_FIND emType, void* pInBuf, void* pOutBuf, int nWaitTime );
// find information,user malloc memory of pInBuf and pOutBuf,please refer to emType to ensure structure,then ensure memory size
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoFind(LLONG lLoginID, NET_FIND emType, void* pInBuf, void* pOutBuf, int nWaitTime );
// stop find information,user malloc memory of pInBuf and pOutBuf,please refer to emType to ensure structure,then ensure memory size
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFind(LLONG lLoginID, NET_FIND emType, void* pInBuf, void* pOutBuf, int nWaitTime );
//set channel record status
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetupRecordState(LLONG lLoginID, char *pRSBuffer, int nRSBufferlen);

// set channel extra record status
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetupExtraRecordState(LLONG lLoginID, char *pRSBuffer, int nRSBufferlen, void* pReserved);

// Search IO status
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryIOControlState(LLONG lLoginID, DH_IOTYPE emType, 
                                           void *pState, int maxlen, int *nIOCount, int waittime);

// IO control,user malloc memory of pState, please refer to corresponding structure of emType
CLIENT_NET_API BOOL CALL_METHOD CLIENT_IOControl(LLONG lLoginID, DH_IOTYPE emType, void *pState, int maxlen);

// Compulsive I frame
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MakeKeyFrame(LLONG lLoginID, int nChannelID, int nSubChannel);

// public agency registration
typedef void (CALLBACK *fConnectMessCallBack)(LLONG lConnectHandle, NET_CLOUDSERVICE_CONNECT_RESULT* pConnectResult, void* pReserved, LDWORD dwUser);
//public agency registration, user malloc and free pConnectParm's memory,apply to sizeof(NET_CLOUDSERVICE_CONNECT_PARAM)
CLIENT_NET_API LLONG CALL_METHOD CLIENT_ConnectCloudService(LLONG lLoginID, NET_CLOUDSERVICE_CONNECT_PARAM* pConnectParm, fConnectMessCallBack pConnectMessCB, LDWORD dwUser, void* pReserved);
//------------------------------------------------------------------------

// Search user information,user malloc and free info's memory,apply to sizeof(USER_MANAGE_INFO) 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryUserInfo(LLONG lLoginID, USER_MANAGE_INFO *info, int waittime);

// Search user information--extensive,user malloc and free info's memory,apply to sizeof(USER_MANAGE_INFO_EX) 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryUserInfoEx(LLONG lLoginID, USER_MANAGE_INFO_EX *info, int waittime);

// Search device info--Max supports device of 64-ch
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryUserInfoNew(LLONG lLoginID, USER_MANAGE_INFO_NEW *info, void* pReserved, int waittime );
// Device operation user,user malloc memory of opParam and subParam,please refer to nOperateType to ensure structure,then ensure memory size
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateUserInfo(LLONG lLoginID, int nOperateType, void *opParam, void *subParam, int waittime);

// Device operation user--extensive,user malloc memory of opParam and subParam,please refer to nOperateType to ensure structure,then ensure memory size
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateUserInfoEx(LLONG lLoginID, int nOperateType, void *opParam, void *subParam, int waittime);

// User operates the device--Max supports device of 64-ch,user malloc memory of opParam and subParam,please refer to nOperateType to ensure structure,then ensure memory size
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateUserInfoNew(LLONG lLoginID, int nOperateType, void *opParam, void *subParam, void* pRetParam, int waittime );

//------------------------------------------------------------------------

// Create transparent COM channel ,TransComType: high 2 bytes represent the serial number,low 2 bytes of serail type,type 0: serial,1:485
CLIENT_NET_API LLONG CALL_METHOD CLIENT_CreateTransComChannel(LLONG lLoginID, int TransComType, unsigned int baudrate, unsigned int databits, unsigned int stopbits, unsigned int parity, fTransComCallBack cbTransCom, LDWORD dwUser);

// Transparent COM send out data 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SendTransComData(LLONG lTransComChannel, char *pBuffer, DWORD dwBufSize);

// Release transparent COM channel 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DestroyTransComChannel(LLONG lTransComChannel);

// Query the status of a transparent serial port
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryTransComParams(LLONG lLoginID, int TransComType, DH_COMM_STATE* pCommState, int nWaitTime );

//------------------------------------------------------------------------

// Begin upgrading device program,user malloc pchFileName's memory,size is MAX_PATH 
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartUpgrade(LLONG lLoginID, char *pchFileName, fUpgradeCallBack cbUpgrade, LDWORD dwUser);

// Begin upgrading device program--extensive,user malloc pchFileName's memory,size is MAX_PATH 
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartUpgradeEx(LLONG lLoginID, EM_UPGRADE_TYPE emType, char *pchFileName, fUpgradeCallBack cbUpgrade, LDWORD dwUser);

// Begin upgrading device program--extensive,support large file  upgrade,for example G bytes file 
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartUpgradeEx2(LLONG lLoginID, EM_UPGRADE_TYPE emType, char *pchFileName, fUpgradeCallBackEx cbUpgrade, LDWORD dwUser);
// Send out data
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SendUpgrade(LLONG lUpgradeID);

// Stop upgrading device program 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopUpgrade(LLONG lUpgradeID);

//------------------------------------------------------------------------
// RemoteUpgrade callback type
typedef enum tagEM_REMOTE_UPGRADE_CB_TYPE
{
	EM_REMOTE_UPGRADE_CB_TYPE_APPENDING,				// appending callback	nParam1:total file size, nParam2:send file size
	EM_REMOTE_UPGRADE_CB_TYPE_EXECUTE,					// execute callback	nParam1 result of execute
	EM_REMOTE_UPGRADE_CB_TYPE_FAILED,					// failed callback nParam1 error code
	EM_REMOTE_UPGRADE_CB_TYPE_CANCEL,					// cancel callback
}EM_REMOTE_UPGRADE_CB_TYPE;

// RemoteUpgrade callback
typedef void (CALLBACK *fRemoteUpgradeCallBack) (LLONG lLoginID, LLONG lUpgradeID, EM_REMOTE_UPGRADE_CB_TYPE emState, INT64 nParam1, INT64 nParam2, LDWORD dwUser);

// Remote channel information
typedef struct tagNET_REMOTE_UPGRADE_CHNL_INFO
{
	UINT				nChannel;					// Channel id
	BYTE				byReserved[512];			// Reserved
}NET_REMOTE_UPGRADE_CHNL_INFO;

// CLIENT_StartRemoteUpgrade-input param
typedef struct tagNET_IN_START_REMOTE_UPGRADE_INFO
{
	DWORD							dwSize;						// Struct size
	UINT							nListNum;					// The number of list
	NET_REMOTE_UPGRADE_CHNL_INFO	*pstuList;					// The list of channel information which need to upgrade
	void							*pReserved;					// Reserved
	char							szFileName[256];			// The file path name of upgrade
	fRemoteUpgradeCallBack			cbRemoteUpgrade;			// The callback of remote upgrade
	LDWORD							dwUser;						// User data
}NET_IN_START_REMOTE_UPGRADE_INFO;

// CLIENT_StartRemoteUpgrade-output param
typedef struct tagNET_OUT_START_REMOTE_UPGRADE_INFO
{
	DWORD							dwSize;						// Struct size
}NET_OUT_START_REMOTE_UPGRADE_INFO;

// Remote Upgrade state
typedef enum tagEM_REMOTE_UPGRADE_STATE
{
	EM_REMOTE_UPGRADE_STATE_UNKNOWN,							// Unknown
	EM_REMOTE_UPGRADE_STATE_INIT,								// Init
	EM_REMOTE_UPGRADE_STATE_DOWNLOADING,						// Downloading
	EM_REMOTE_UPGRADE_STATE_UPGRADING,							// Upgradeing
	EM_REMOTE_UPGRADE_STATE_FAILED,								// Failed
	EM_REMOTE_UPGRADE_STATE_SUCCEEDED,							// Successed
	EM_REMOTE_UPGRADE_STATE_CANCELLED,							// Cancelled
	EM_REMOTE_UPGRADE_STATE_PREPARING,							// Preparing
}EM_REMOTE_UPGRADE_STATE;

// Remote Upgrade state information
typedef struct tagNET_REMOTE_UPGRADER_STATE
{
	int								nChannel;					// Channel id
	EM_REMOTE_UPGRADE_STATE			emState;					// State
	int								nProgress;					// Progress
}NET_REMOTE_UPGRADER_STATE;

// Remote Upgrade notify information
typedef struct tagNET_REMOTE_UPGRADER_NOTIFY_INFO
{
	LDWORD							nStateNum;					// The number of states
	NET_REMOTE_UPGRADER_STATE*		pstuStates;					// The list of states
	BYTE							byReserved[1024];			// Reserved
}NET_REMOTE_UPGRADER_NOTIFY_INFO;

// Callback of remote upgrade state
typedef void (CALLBACK *fRemoteUpgraderStateCallback) (LLONG lLoginId, LLONG lAttachHandle, NET_REMOTE_UPGRADER_NOTIFY_INFO* pBuf, DWORD dwBufLen, void* pReserved, LDWORD dwUser);

// CLIENT_AttachRemoteUpgradeState-input param
typedef struct tagNET_IN_ATTACH_REMOTEUPGRADE_STATE
{
	DWORD							dwSize;						// Struct size
	fRemoteUpgraderStateCallback	cbCallback;					// Callback
	LDWORD							dwUser;						// User data
}NET_IN_ATTACH_REMOTEUPGRADE_STATE;

// CLIENT_AttachRemoteUpgradeState-output param
typedef struct tagNET_OUT_ATTACH_REMOTEUPGRADE_STATE
{
	DWORD							dwSize;						//  Struct size
}NET_OUT_ATTACH_REMOTEUPGRADE_STATE;

//Start remote upgrade
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartRemoteUpgrade(LLONG lLoginID, const NET_IN_START_REMOTE_UPGRADE_INFO* pInParam, NET_OUT_START_REMOTE_UPGRADE_INFO* pOutParam, int nWaitTime );

//Stop remote upgrade
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopRemoteUpgrade(LLONG lUpgradeID);

// Attach remote upgrade state
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachRemoteUpgradeState( LLONG lLoginID, const NET_IN_ATTACH_REMOTEUPGRADE_STATE* pInParam, NET_OUT_ATTACH_REMOTEUPGRADE_STATE* pOutParam, int nWaitTime );

// Detach remote upgrade state
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachRemoteUpgradeState( LLONG lAttachHandle );
//------------------------------------------------------------------------

// Search configuration information 
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_GetDevConfig(LLONG lLoginID, DWORD dwCommand, LONG lChannel, LPVOID lpOutBuffer, DWORD dwOutBufferSize, LPDWORD lpBytesReturned,int waittime);

// Set configuration information 
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_SetDevConfig(LLONG lLoginID, DWORD dwCommand, LONG lChannel, LPVOID lpInBuffer, DWORD dwInBufferSize, int waittime);

// New configuration interface, Search configuration information(using Json protocol, see configuration SDK)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetNewDevConfig(LLONG lLoginID, char* szCommand, int nChannelID, char* szOutBuffer, DWORD dwOutBufferSize, int *error, int waittime);

// New configuration interface, Set configuration information(using Json protocol, see configuration SDK)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetNewDevConfig(LLONG lLoginID, char* szCommand, int nChannelID, char* szInBuffer, DWORD dwInBufferSize, int *error, int *restart, int waittime);

// Delete configuration interface(Json format)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DeleteDevConfig(LLONG lLoginID, NET_IN_DELETECFG* pInParam, NET_OUT_DELETECFG* pOutParam, int waittime);

// Get the configuration member name interface(Json format)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetMemberNames(LLONG lLoginID, NET_IN_MEMBERNAME* pInParam, NET_OUT_MEMBERNAME* pOutParam, int waittime);

// get net card info,user malloc the memory of lpInParam and lpOutParam,please refer to the corresponding structure of emType
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryNetStat(LLONG lLoginID , EM_NET_QUERY_TYPE emType , void *lpInParam , int nInParamLen , void *lpOutParam , int nOutParamLen , int *pError );

// Get VideoInAnalyse info(users apply for and release the memory of szOutBuffer)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetVideoInAnalyse(LLONG 	lLoginID, char* szCommand, int nChannelID, EM_SCENE_CLASS_TYPE emClassType, char* szOutBuffer, DWORD dwOutBufferSize, int *error, int waittime);

// Get Event link name(users apply for and release the memory of pInParam and pOutParam)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetEventLink(LLONG lLoginID, NET_IN_EVENT_LINK* pInParam, NET_OUT_EVENT_LINK* pOutParam, int nWaitTime);

// get list of the channels that have been enabled
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetVideoInAnalyseEnableChannels(LLONG lLoginID, const NET_IN_VIDEOINANALYSE_GET_ENABLECHANNELS* pInParam, 
																	   NET_OUT_VIDEOINANALYSE_GET_ENABLECHANNELS* pOutParam, int nWaitTime);
//------------------------------------------------------------------------

// Search device channel name 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryChannelName(LLONG lLoginID, char *pChannelName, int maxlen, int *nChannelCount, int waittime);

// Set device channel name,user malloc pbuf's memory,size is 512 byte at least
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_SetupChannelName(LLONG lLoginID,char *pbuf, int nbuflen);

// Set device channel character overlay 
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_SetupChannelOsdString(LLONG lLoginID, int nChannelNo, DH_CHANNEL_OSDSTRING* struOsdString, int nbuflen);

// Search device current time
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDeviceTime(LLONG lLoginID, LPNET_TIME pDeviceTime, int waittime);

// Set device current time
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetupDeviceTime(LLONG lLoginID, LPNET_TIME pDeviceTime);

// Search device current time extension interface
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDeviceTimeEx(LLONG lLoginID, LPNET_TIME_EX pDeviceTime, int waittime);

// Set device current time extension interface
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetupDeviceTimeEx(LLONG lLoginID, LPNET_TIME_EX pDeviceTime);

// Search device current utc extension interface
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDeviceUTC(LLONG lLoginID, LPNET_UTCTIME pDeviceTime, int waittime);

// Set device current utc extension interface
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDeviceUTC(LLONG lLoginID, LPNET_UTCTIME pDeviceTime);

// Set device max bit stream
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetMaxFlux(LLONG lLoginID, WORD wFlux);

//------------------------------------------------------------------------

// Import configuration file,user malloc szFileName's memory,size is MAX_PATH
CLIENT_NET_API LLONG CALL_METHOD CLIENT_ImportConfigFile(LLONG lLoginID, char *szFileName, fDownLoadPosCallBack cbUploadPos, LDWORD dwUserData, DWORD param);

// Stop importing configuration file
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopImportCfgFile(LLONG lImportHandle);

// Exporting configuration file
CLIENT_NET_API LLONG CALL_METHOD CLIENT_ExportConfigFile(LLONG lLoginID, DH_CONFIG_FILE_TYPE emConfigFileType, char *szSavedFilePath, fDownLoadPosCallBack cbDownLoadPos, LDWORD dwUserData);

// top exporting configuration file
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopExportCfgFile(LLONG lExportHandle);

//------------------------------------------------------------------------

// Search device IP in DDBS by device name or device serial number
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDVRIPByResolveSvr(char *pchDVRIP, WORD wDVRPort, BYTE *sDVRName, WORD wDVRNameLen, BYTE *sDVRSerialNumber, WORD wDVRSerialLen, char* sGetIP);

// Search IPC,NVS and etc in LAN 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SearchDevices(char* szBuf, int nBufLen, int* pRetLen, DWORD dwSearchTime, char* szLocalIp);

// asynchronism search IPC, NVS and etc in LAN,user malloc pUserData means user data: not support multi-thread
// search command will be send once when interface called
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartSearchDevices(fSearchDevicesCB cbSearchDevices, void* pUserData, char* szLocalIp);

// stop asynchronism search IPC, NVS and etc in LAN
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopSearchDevices(LLONG lSearchHandle);

// modify Device ip: not support multi-thread
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ModifyDevice(DEVICE_NET_INFO_EX *pDevNetInfo, DWORD dwWaitTime, int *iError );

// send search type
typedef enum tagEM_SEND_SEARCH_TYPE
{
    EM_SEND_SEARCH_TYPE_MULTICAST_AND_BROADCAST,        // multicast and broadcast search
    EM_SEND_SEARCH_TYPE_MULTICAST,                      // multicast search
    EM_SEND_SEARCH_TYPE_BROADCAST,                      // broadcast search
}EM_SEND_SEARCH_TYPE;

// input of CLIENT_StartSearchDevicesEx
typedef struct tagNET_IN_STARTSERACH_DEVICE
{
    DWORD                   dwSize;                         // struct size 
    char                    szLocalIp[MAX_LOCAL_IP_LEN];    // local IP                 
    fSearchDevicesCBEx      cbSearchDevices;                // search device call back
    void*                   pUserData;                      // user data
    EM_SEND_SEARCH_TYPE     emSendType;                     // send search type
}NET_IN_STARTSERACH_DEVICE;

// output of CLIENT_StartSearchDevicesEx
typedef struct tagNET_OUT_STARTSERACH_DEVICE
{
    DWORD                   dwSize;							// struct size 
}NET_OUT_STARTSERACH_DEVICE;

// asynchronism search device 
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartSearchDevicesEx(NET_IN_STARTSERACH_DEVICE* pInBuf, NET_OUT_STARTSERACH_DEVICE* pOutBuf);

// input of CLIENT_ModifyDeviceEx
typedef struct tagNET_IN_MODIFY_IP
{
    DWORD                   dwSize;			// struct size 
    DEVICE_NET_INFO_EX2     stuDevNetInfo;	// device net info
}NET_IN_MODIFY_IP;

//output of CLIENT_ModifyDeviceEx
typedef struct tagNET_OUT_MODIFY_IP
{
    DWORD                   dwSize;			// struct size 
}NET_OUT_MODIFY_IP;

// modify deivce ip
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ModifyDeviceEx(NET_IN_MODIFY_IP* pInBuf, NET_OUT_MODIFY_IP* pOutBuf, int nWaitTime);

// search device ip cross VLAN
// search command will be send once when interface called
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SearchDevicesByIPs(DEVICE_IP_SEARCH_INFO* pIpSearchInfo, fSearchDevicesCB cbSearchDevices, LDWORD dwUserData, char* szLocalIp, DWORD dwWaitTime);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDeviceSearchParam(const NET_DEVICE_SEARCH_PARAM* pstParam);
//------------------------------------------------------------------------

// Platform embedded interface
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetPlatFormInfo(LLONG lLoginID, DWORD dwCommand, int nSubCommand, int nParam, LPVOID lpOutBuffer, DWORD dwOutBufferSize, LPDWORD lpBytesReturned,int waittime);
// lpInBuffer managed by user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetPlatFormInfo(LLONG lLoginID, DWORD dwCommand, int nSubCommand, int nParam, LPVOID lpInBuffer, DWORD dwInBufferSize, int waittime);

// control focus 
//	dwFocusCommand = 0 focus adjucy
//	dwFocusCommand = 1continuous focus adjustment
//	dwFocusCommand = 2 auto adjust ,adjust to the best position,nFocus and nZoominvalid
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FocusControl(LLONG lLoginID, int nChannelID, DWORD dwFocusCommand, double nFocus, double nZoom, void *reserved );

///////////////////////////////Mobile DVR interface///////////////////////////////

// Set snapshot callback function 
CLIENT_NET_API void CALL_METHOD CLIENT_SetSnapRevCallBack(fSnapRev OnSnapRevMessage, LDWORD dwUser);

// Snapshot request
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SnapPicture(LLONG lLoginID, SNAP_PARAMS par);

// Snapshot request--extensive
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SnapPictureEx(LLONG lLoginID, SNAP_PARAMS *par, int *reserved );

// Set GPS subscription callback function,user malloc and free memory of pInParam and  pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SnapPictureToFile(LLONG lLoginID, const NET_IN_SNAP_PIC_TO_FILE_PARAM* pInParam, NET_OUT_SNAP_PIC_TO_FILE_PARAM* pOutParam, int nWaitTime);
CLIENT_NET_API void CALL_METHOD CLIENT_SetSubcribeGPSCallBack(fGPSRev OnGPSMessage, LDWORD dwUser);

// Set GPS subscription callback function - extensive
CLIENT_NET_API void CALL_METHOD CLIENT_SetSubcribeGPSCallBackEX(fGPSRevEx OnGPSMessage, LDWORD dwUser);

// Set GPS subscription callback function - extensive2
CLIENT_NET_API void CALL_METHOD CLIENT_SetSubcribeGPSCallBackEX2(fGPSRevEx2 OnGPSMessage, LDWORD dwUser);

/**************************************************************************************
*   Funcname: CLIENT_SubcribeGPS
*   Purpose:GPS inforamtion subscribe
*   InputParam:   LLONG  :lLoginID    //login handle
*   InputParam:   BOOL   :bStart      //TRUE:subscribe  FALSE:cancle subscribe
*   InputParam:   LONG   :KeepTime    // subscribe time last (unit second) value:-1  means indefinite duration last


*   InputParam:   LONG   :InterTime   // GPS send rate in subscribe time
*   Return: BOOL
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SubcribeGPS (LLONG lLoginID, BOOL bStart, LONG KeepTime, LONG InterTime);

// Set GPS subscription of temperature and humidity callback function
CLIENT_NET_API void CALL_METHOD CLIENT_SetSubcribeGPSTHCallBack(fGPSTempHumidityRev OnGPSMessage, LDWORD dwUser);

// GPS subscription of temperature and humidity
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SubcribeGPSTempHumidity (LLONG lLoginID, BOOL bStart,	int InterTime, void* Reserved);

//GPS log query
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryGPSLog(LLONG lLoginID,QUERY_GPS_LOG_PARAM *pQueryParam, char *pLogBuffer, int nLogBufferLen, int *pRecLogNum, BOOL *bContinue, int waittime);

// subscription task
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AttachMission(LLONG lLoginID, NET_IN_ATTACH_MISSION_PARAM *pInParam, NET_OUT_ATTACH_MISSION_PARAM *pOutParam, int nWaitTime);

// cancen subscription
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachMission(LLONG lAttachHandle);

// vehicle emergency alarm confirm
CLIENT_NET_API BOOL CALL_METHOD CLIENT_BusConfirmEvent(LLONG lLoginID, const NET_IN_BUS_CONFIRM_EVENT* pInParam, NET_OUT_BUS_CONFIRM_EVENT* pOutParam, int nWaitTime );

// set device address information
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDevicePosition(LLONG lLoginID, const NET_IN_SET_DEVICE_POSITION* pInParam, NET_OUT_SET_DEVICE_POSITION* pOutParam, int nWaitTime);

// get device address information
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDevicePosition(LLONG lLoginID, const NET_IN_GET_DEVICE_POSITION* pInParam, NET_OUT_GET_DEVICE_POSITION* pOutParam, int nWaitTime);

// snapshoot by event 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SnapPictureByEvent(LLONG lLoginID, const NET_IN_SNAP_BY_EVENT* pInParam, NET_OUT_SNAP_BY_EVENT* pOutParam, int nWaitTime);
//////////////////////////////NVD interface//////////////////////////////

// Query decoder information
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDecoderInfo(LLONG lLoginID, LPDEV_DECODER_INFO lpDecInfo, int waittime);

// Query decoder TV information
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDecoderTVInfo(LLONG lLoginID, int nMonitorID, LPDEV_DECODER_TV lpMonitorInfo, int waittime);

// Query decoder channel information
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDecEncoderInfo(LLONG lLoginID, int nDecoderID, LPDEV_ENCODER_INFO lpEncoderInfo, int waittime);

// Set decoder TV enable
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDecTVOutEnable(LLONG lLoginID, BYTE *pDecTVOutEnable, int nBufLen, int waittime);

// set decoder tip layout enable, channel number start at 0
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDecLayOutEnable(LLONG lLoginID, BYTE bDecLayOutEnable, int nChannel, int waittime);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDecLayOutEnable(LLONG lLoginID, BYTE *pDecLayOutEnable, int nChannel, int waittime);
//------------------------------------------------------------------------

// Set up asynchronous callback function
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetOperateCallBack(LLONG lLoginID, fMessDataCallBack cbMessData, LDWORD dwUser);

// Control decoder TV screen partition,Interface is asynchronous
CLIENT_NET_API LLONG CALL_METHOD CLIENT_CtrlDecTVScreen(LLONG lLoginID, int nMonitorID, BOOL bEnable, int nSplitType, BYTE *pEncoderChannel, int nBufLen, void* userdata);

// Switch decoder TV screen,Interface is asynchronous
// According to nMonitorID(TV ID) nWndID(Screen ID) Convert to nDecoderID(decoder channel) formula:nEncoderID nMonitorID*nSplitNum(Partition number)+nWndID
CLIENT_NET_API LLONG CALL_METHOD CLIENT_SwitchDecTVEncoder(LLONG lLoginID, int nDecoderID, LPDEV_ENCODER_INFO lpEncoderInfo, void* userdata);

//------------------------------------------------------------------------

// Add combination of screen
CLIENT_NET_API int CALL_METHOD CLIENT_AddTourCombin(LLONG lLoginID, int nMonitorID, int nSplitType, BYTE *pEncoderChannnel, int nBufLen, int waittime);

// Delete combination of screen
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DelTourCombin(LLONG lLoginID, int nMonitorID, int nCombinID, int waittime);

// Modify combination of screen
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetTourCombin(LLONG lLoginID, int nMonitorID, int nCombinID, int nSplitType, BYTE *pEncoderChannel, int nBufLen, int waittime);

// Query combination of screen,nCombinID: 0-32
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryTourCombin(LLONG lLoginID, int nMonitorID, int nCombinID, LPDEC_COMBIN_INFO lpDecCombinInfo, int waittime);

// Set up tour operation
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDecoderTour(LLONG lLoginID, int nMonitorID, LPDEC_TOUR_COMBIN lpDecTourInfo, int waittime);

// Query tour operation
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDecoderTour(LLONG lLoginID, int nMonitorID, LPDEC_TOUR_COMBIN lpDecTourInfo, int waittime);

// Query the current flux information of decoding channel
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDecChannelFlux(LLONG lLoginID, int nDecoderID, LPDEV_DECCHANNEL_STATE lpChannelStateInfo, int waittime);

// control decoder tour operation
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CtrlDecoderTour(LLONG lLoginID, int nMonitorID, DEC_CTRL_TOUR_TYPE emActionParam, int waittime );
//------------------------------------------------------------------------

typedef void (CALLBACK *fDecPlayBackPosCallBack)(LLONG lLoginID, int nEncoderID, DWORD dwTotalSize, DWORD dwPlaySize, LDWORD dwUser);

// Set the playback progress callback function
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDecPlaybackPos(LLONG lLoginID, fDecPlayBackPosCallBack cbPlaybackPos, LDWORD dwUser);

// Decoder TV screen playback,Interface is asynchronous
CLIENT_NET_API LLONG CALL_METHOD CLIENT_DecTVPlayback(LLONG lLoginID, int nDecoderID, DEC_PLAYBACK_MODE emPlaybackMode, LPVOID lpInBuffer, DWORD dwInBufferSize, void* userdata);

// Control TV screen playback
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CtrlDecPlayback(LLONG lLoginID, int nDecoderID, DEC_CTRL_PLAYBACK_TYPE emCtrlType, int nValue, int waittime);

///////////////////////////////intelligent device interface///////////////////////////////

// real load picture of intelligent analysis 
CLIENT_NET_API LLONG CALL_METHOD CLIENT_RealLoadPicture(LLONG lLoginID, int nChannelID, DWORD dwAlarmType, fAnalyzerDataCallBack cbAnalyzerData, LDWORD dwUser);

// real load picture of intelligent analysis(expand interface: 'bNeedPicFile == true' instruct load picture file, 'bNeedPicFile == false' instruct not load picture file ) 
CLIENT_NET_API LLONG CALL_METHOD CLIENT_RealLoadPictureEx(LLONG lLoginID, int nChannelID, 
													 DWORD dwAlarmType, 
													 BOOL bNeedPicFile, 
													 fAnalyzerDataCallBack cbAnalyzerData, 
													 LDWORD dwUser, 
													 void* Reserved);

// stop load picture of intelligent analysis
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopLoadPic(LLONG lAnalyzerHandle);

// Confirm if picture upload is complete--picture
// This port better not be in the same thread with  CLIENT_RealLoadPictureEx/CLIENT_RealLoadPicture's call function, otherwise will cause jam, and must call in another thread
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SnapManagerConfirmUpload(LLONG lLoginID, const NET_IN_SNAP_MANAGER_CONFIRM_UPLOAD* pstInParam, NET_OUT_SNAP_MANAGER_CONFIRM_UPLOAD* pstOutParam, int waittime);

// Search according to the criteria,user malloc and free pQueryCondition's memory,please refer to emType to ensure structure,then ensure memory size
CLIENT_NET_API LLONG	CALL_METHOD CLIENT_FindFileEx(LLONG lLoginID, EM_FILE_QUERY_TYPE emType, void* pQueryCondition, void *reserved, int waittime);	

// Search file:nFilecount:the searched amount. The return value is media file amount. The search in the specified time completed if return <nFilecount.
CLIENT_NET_API int	CALL_METHOD CLIENT_FindNextFileEx(LLONG lFindHandle, int nFilecount, void* pMediaFileInfo, int maxlen, void *reserved, int waittime);

// End the file search
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FindCloseEx(LLONG lFindHandle);

// get matched search filter file total
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetTotalFileCount(LLONG lFindHandle, int* pTotalCount, void *reserved, int waittime);

// set search jump filter, user malloc and free pOption's memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetFindingJumpOption(LLONG lFindHandle, NET_FINDING_JUMP_OPTION_INFO* pOption, void *reserved, int waittime);

// Download the specified intelligent analytics data-image,user malloc and free lpMediaFileInfo's memory,please refer to the corresponding structure of emType
CLIENT_NET_API LLONG CALL_METHOD CLIENT_DownloadMediaFile(LLONG lLoginID,EM_FILE_QUERY_TYPE emType, void* lpMediaFileInfo, char *sSavedFileName, fDownLoadPosCallBack cbDownLoadPos, LDWORD dwUserData,  void *reserved);

// Stop downloading the data
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopDownloadMediaFile(LLONG lFileHandle);

// batch download file
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DownLoadMultiFile(LLONG lLoginID, NET_IN_DOWNLOAD_MULTI_FILE *pstInParam, NET_OUT_DOWNLOAD_MULTI_FILE *pstOutParam, int waittime);

// stop download
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopLoadMultiFile(LLONG lDownLoadHandle);

// download picture of intelligent analysis when being off line
CLIENT_NET_API LLONG CALL_METHOD CLIENT_LoadOffLineFile(LLONG lLoginID, int nChannelID, DWORD dwAlarmType, LPNET_TIME_EX lpStartTime, LPNET_TIME_EX lpEndTime, fAnalyzerDataCallBack cbAnalyzerData, LDWORD dwUser);

//Pause IVS data download(bPause=TRUE, it is to stop download , bPause=FALSE , it is to resume download.)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PauseLoadPic(LLONG lLoadHadle, BOOL bPause);

// traffic snap--snapshot by network,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_TrafficSnapByNetwork(LLONG lLoginID, int nChannelID, NET_IN_SNAPSHOT* pstInParam, NET_OUT_SNAPSHOT* pstOutParam);
// start traffic flux state
// traffic control --forced the red light,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_TrafficForceLightState(LLONG lLoginID, int nChannelID, NET_IN_FORCELIGHTSTATE* pstInParamg, NET_OUT_FORCELIGHTSTATE* pstOutParam, int waittime);

//  balck/white list operation,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateTrafficList(LLONG lLoginID ,  NET_IN_OPERATE_TRAFFIC_LIST_RECORD* pstInParam , NET_OUT_OPERATE_TRAFFIC_LIST_RECORD *pstOutParam );

// start traffic flux state,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartTrafficFluxStat(LLONG lLoginID, NET_IN_TRAFFICFLUXSTAT* pstInParam,NET_OUT_TRAFFICFLUXSTAT* pstOutParam);

// stop traffic flux state
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopTrafficFluxStat(LLONG lFluxStatHandle);

// start find flux state,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartFindFluxStat(LLONG lLoginID, NET_IN_TRAFFICSTARTFINDSTAT* pstInParam, NET_OUT_TRAFFICSTARTFINDSTAT* pstOutParam);

// do find flux state,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API int	CALL_METHOD CLIENT_DoFindFluxStat(LLONG lFindHandle, NET_IN_TRAFFICDOFINDSTAT* pstInParam,NET_OUT_TRAFFICDOFINDSTAT* pstOutParam);

// stop find flux state
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindFluxStat(LLONG lFindHandle);
// start find number state,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartFindNumberStat(LLONG lLoginID, NET_IN_FINDNUMBERSTAT* pstInParam, NET_OUT_FINDNUMBERSTAT* pstOutParam);

// do find number state,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API int	CALL_METHOD CLIENT_DoFindNumberStat(LLONG lFindHandle, NET_IN_DOFINDNUMBERSTAT* pstInParam, NET_OUT_DOFINDNUMBERSTAT* pstOutParam);

// stop find number state
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindNumberStat(LLONG lFindHandle);

// subscribe video statistical summary,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachVideoStatSummary(LLONG lLoginID, const NET_IN_ATTACH_VIDEOSTAT_SUM* pInParam, NET_OUT_ATTACH_VIDEOSTAT_SUM* pOutParam, int nWaitTime);

// unsubscribe video statistical summary
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachVideoStatSummary(LLONG lAttachHandle);

// Subscribe heatmap data,user malloc and free (pInParam's and pOutParam's) memory
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachVideoStatHeatMap(LLONG lLoginID, const NET_IN_ATTACH_VIDEOSTAT_HEATMAP* pInParam, NET_OUT_ATTACH_VIDEOSTAT_HEATMAP* pOutParam, int nWaitTime);

// Get heatmap data,user malloc and free (pInParam's and pOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetVideoStatHeatMap(LLONG lAttachHandle, const NET_IN_GET_VIDEOSTAT_HEATMAP* pInParam, NET_OUT_GET_VIDEOSTAT_HEATMAP* pOutParam, int nWaitTime);

// Unsubscribe heatmap data
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachVideoStatHeatMap(LLONG lAttachHandle);


// Call of the analysis device method,user malloc and free (pstInParam's and pstOutParam's) memory,please refer to the corresponding structure of szCmd
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateVideoAnalyseDevice(LLONG lLoginID, int nChannelID, char* szCmd, void *pstInParam, void *pstOutParam, int waittime);

// Access to video analysis object,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_VideoAnalyseGetTemplateImage(LLONG lLoginID, const NET_IN_VIDEOANALYSE_GETTEMPLATEIMAGE* pstInParam, NET_OUT_VIDEOANALYSE_GETTEMPLATEIMAGE* pstOutParam, int nWaitTime);

// Set the video analysis object,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_VideoAnalyseSetTemplateImage(LLONG lLoginID, const NET_IN_VIDEOANALYSE_SETTEMPLATEIMAGE* pstInParam, NET_OUT_VIDEOANALYSE_SETTEMPLATEIMAGE* pstOutParam, int nWaitTime);

// serial device method call
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateCommDevice(LLONG lLoginID, int nChannelID, char* szCmd, void *pstInParam, void *pstOutParam, int waittime);

// Intelligent track speed dome control port.
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ControlIntelliTracker(LLONG lLoginID, NET_IN_CONTROL_INTELLITRACKER* pstInParam, NET_OUT_CONTROL_INTELLITRACKER* pstOutParam);

// master-slave device method,look for CLIENT_OperateMasterSlaveDevice,user malloc and free (pstInParam's and pstOutParam's) memoryp,please refer to the corresponding structure of szCmd
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateMasterSlaveDevice(LLONG lLoginID, int nChannelID, char* szCmd, void *pstInParam, void *pstOutParam, int waittime);

// video splicing method call,user malloc and free (pstInParam's and pstOutParam's) memory,please refer to the corresponding structure of emType
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateVideoJoin(LLONG lLoginID, NET_VIDEOJOIN_OPERATE_TYPE emType, void* pstInParam, void* pstOutParam, int nWaitTime);

////////////////////////////////  Video analysis /////////////////////////////////
// Real-time get video analysis result,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartVideoDiagnosis(LLONG lLoginID, NET_IN_VIDEODIAGNOSIS *pstInParam, NET_OUT_VIDEODIAGNOSIS *pstOutParam);

// Stop video analysis result report
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopVideoDiagnosis(LLONG hDiagnosisHandle);

// Start video analysis result search,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartFindDiagnosisResult(LLONG lLoginID, NET_IN_FIND_DIAGNOSIS* pstInParam, NET_OUT_FIND_DIAGNOSIS* pstOutParam);

// Get video analysis result info,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoFindDiagnosisResult(LLONG hFindHandle,NET_IN_DIAGNOSIS_INFO* pstInParam, NET_OUT_DIAGNOSIS_INFO* pstOutParam);

// End video analysis result search
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindDiagnosis(LLONG hFindHandle);

// enable real time disgnosis plan,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartRealTimeProject(LLONG lLoginID,NET_IN_START_RT_PROJECT_INFO* pstInParam, NET_OUT_START_RT_PROJECT_INFO* pstOutParam, int nWaitTime);

// stop real time diagnosis plan,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopRealTimeProject(LLONG lLoginID,NET_IN_STOP_RT_PROJECT_INFO* pstInParam, NET_OUT_STOP_RT_PROJECT_INFO* pstOutParam, int nWaitTime);

// Start the manual video diagnosis plan, pstInParam and pstOutParam are requested an released by user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartManualDiagnosisProject(LLONG lLoginID, NET_IN_START_MANUAL_PROJECT_INFO* pstInParam, NET_OUT_START_MANUAL_PROJECT_INFO* pstOutParam, int nWaitTime);
// Stop the manual video diagnosis, pstInParam and pstOutParam are requested an released by user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopManualDiagnosisProject(LLONG lLoginID, NET_IN_STOP_MANUAL_PROJECT_INFO* pstInParam, NET_OUT_STOP_MANUAL_PROJECT_INFO* pstOutParam, int nWaitTime);

// update the diagnostic background of a plan or task, user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_UpdateProjectBackGround(LLONG lLoginID, const NET_IN_UPDATE_PROJECT_BACKGROUND_INFO* pstInParam, NET_OUT_UPDATE_PROJECT_BACKGROUND_INFO* pstOutParam, int nWaitTime);

// get parking space status,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetParkingSpaceStatus(LLONG lLoginID, NET_IN_GET_PARKINGSPACE_STATUS* pstInParam, NET_OUT_GET_PARKINGSPACE_STATUS* pstOutParam);

// attach parking space data,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachParkingSpaceData(LLONG lLoginID, NET_IN_ATTACH_PARKINGSPACE* pstInParam, NET_OUT_ATTACH_PARKINGSPACE* pstOutParam);

// detach parking space data,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachParkingSpaceData(NET_IN_DETACH_PARKINGSPACE* pstInParam, NET_OUT_DETACH_PARKINGSPACE* pstOutParam);

// Subscribed to the car information,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachCarPassInfo(LLONG lLoginID, NET_IN_ATTACH_CAR_PASS_INFO* pstInParam, NET_OUT_ATTACH_CAR_PASS_INFO* pstOutParam , int nWaitTime);

// Unsubscribe car information lCarPassInfoHandle is CLIENT_AttachCarPassInfo returns a handle 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachCarPassInfo(LLONG lCarPassInfoHandle);

// order specific lane info ,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachLanesState(LLONG lLoginID, NET_IN_ATTACH_LANES_STATE* pstInParam, NET_OUT_ATTACH_LANES_STATE* pstOutParam, int nWaitTime);

// cancel order of specific lane info lLanesStateHandle is CLIENT_AttachLanesStatereturn handle
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachLanesState(LLONG lLanesStateHandle);

// get car port light status,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetCarPortLightStatus(LLONG lLoginID, NET_IN_GET_CARPORTLIGHT_STATUS* pstInParam, NET_OUT_GET_CARPORTLIGHT_STATUS* pstOutParam, int waittime);

// ser car port light status,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetCarPortLightStatus(LLONG lLoginID, NET_IN_SET_CARPORTLIGHT_STATUS* pstInParam, NET_OUT_SET_CARPORTLIGHT_STATUS* pstOutParam, int waittime);

// get parking lock state
CLIENT_NET_API BOOL CALL_METHOD	CLIENT_GetParkingLockState(LLONG lLoginID, const NET_IN_GET_PARKINGLOCK_STATE_INFO *pstInParam, NET_OUT_GET_PARKINGLOCK_STATE_INFO *pstOutParam, int nWaitTime);

// set parking lock state
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetParkingLockState(LLONG lLoginID, const NET_IN_SET_PARKINGLOCK_STATE_INFO *pstInParm, NET_OUT_SET_PARKINGLOCK_STATE_INFO *pstOutParam, int nWaitTIme);

// Set parking rule
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetParkingRule(LLONG lLoginID, const NET_IN_SET_PARKINGRULE_INFO *pstInParm, NET_OUT_SET_PARKINGRULE_INFO *pstOutParam, int nWaitTime);

// subscribe intelligent analysis porogress, for video analysis source is record file, ,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AttachVideoAnalyseState(LLONG lLoginID, NET_IN_ATTACH_VIDEOANALYSE_STATE* pstInParam, NET_OUT_ATTACH_VIDEOANALYSE_STATE* pstOutParam, int nWaittime);

// stop subscription
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachVideoAnalyseState(LLONG lAttachHandle);

// subscribe front-end device talk state,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachTalkState(LLONG lLoginID, NET_IN_ATTACH_TALK_STATE* pstInParam, NET_OUT_ATTACH_TALK_STATE* pstOutParam, int nWaitTime );

// cancel subscribing front-end device talk state, lAttachHandle is the returned handle of  CLIENT_AttachTalkState
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachTalkState(LLONG lAttachHandle);

////////////////////////////////synopsis video' interface////////////////////////////////

// add video synopsis task,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddVideoSynopsisTask(LLONG lLoginID,	NET_IN_ADD_VIDEOSYNOPSIS* pstInParam, NET_OUT_ADD_VIDEOSYNOPSIS* pstOutParam);

// video Synopsis task pretreatment,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PreHandleVideoSynopsisTask(LLONG lLoginID,  const NET_IN_PRE_HANDLE_VIDEOSYNOPSIS* pstInParam, NET_OUT_PRE_HANDLE_VIDEOSYNOPSIS* pstOutParam);

// Access by Channel
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddPreTaskByChannel(LLONG lLoginID, const NET_IN_PRETASK_BYCHANNEL* pstInParam, NET_OUT_PRETASK_BYCHANNEL* pstOutParam);

// Get synopsis task progress
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetVideoSynopsisState(LLONG lLoginID, const NET_IN_GET_VIDEOSYNOPSIS_STATE* pstInParam, NET_OUT_GET_VIDEOSYNOPSIS_STATE* pstOutParam);

// Begin to search intelligent video synopsis history
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartFindVideoSynopsisHistory(LLONG lLoginID, const NET_IN_VIDEOSYNOPSIS_STARTFIND* pstInParam, NET_OUT_VIDEOSYNOPSIS_STARTFIND* pstOutParam);

// Get historical search result information
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoFindVideoSynopsisHistory(LLONG lLoginID, const NET_IN_VIDEOSYNOPSIS_DOFIND* pstInParam, NET_OUT_VIDEOSYNOPSIS_DOFIND* pstOutParam);

// End synopsis history query
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindVideoSynopsisHistory(LLONG lLoginID, const NET_IN_VIDEOSYNOPSIS_STOPFIND* pstInParam, NET_OUT_VIDEOSYNOPSIS_STOPFIND* pstOutParam);

// video Synopsis task handle ,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RunVideoSynopsisTask(LLONG lLoginID, const NET_IN_RUN_VIDEOSYNOPSIS_TASK* pstInParam, NET_OUT_RUN_VIDEOSYNOPSIS_TASK* pstOutParam);
// pause video Synopsis task,user malloc and free pstInParam's memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PauseVideoSynopsisTask(LLONG lLoginID, NET_IN_PAUSE_VIDEOSYNOPSIS* pstInParam);

// remove video synopsis task,user malloc and free pstInParam's memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RemoveVideoSynopsisTask(LLONG lLoginID, NET_IN_REMOVE_VIDEOSYNOPSIS* pstInParam);

// subscibe real load object data,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RealLoadObjectData(LLONG lLoginID, NET_IN_REALLOAD_OBJECTDATA* pstInParam, NET_OUT_REALLOAD_OBJECTDATA* pstOutParam);

// stop load object data,user malloc and free pstInParam's memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopLoadObjectData(LLONG lRealLoadHandle, NET_IN_STOPLOAD_OBJECTDATA* pstInParam);

// subscribe real synopsis progress state,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RealLoadSynopsisState(LLONG lLoginID, NET_IN_REALLAOD_SYNOPSISSTATE* pstInParam, NET_OUT_REALLOAD_SYNOPSISSTATE* pstOutParam);

// stop subscribe real synopsis progress state,user malloc and free pstInParam's memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopLoadSynopsisState(LLONG lRealLoadHandle, NET_IN_STOPLOAD_SYNOPSISSTATE* pstInParam);

// query real synopsis video state,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryVideoSynopsisInfo(LLONG lLoginID, NET_IN_QUERY_VIDEOSYNOPSIS* pstInParam, NET_OUT_QUERY_VIDEOSYNOPSIS* pstuOutParam);

// according to the query criteria query synopsis file,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL	CALL_METHOD CLIENT_FindSynopsisFile(LLONG lLoginID, NET_IN_FIND_SYNOPSISFILE *pstInParam, NET_OUT_FIND_SYNOPSISFILE *pstOutParam);	

// query synopsis file,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL	CALL_METHOD CLIENT_FindNextSynopsisFile(LLONG lFindHandle, NET_IN_FINDNEXT_SYNOPSISFILE *pstInParam, NET_OUT_FINDNEXT_SYNOPSISFILE *pstOutParam);

// close query synopsis file
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SynopsisFindClose(LLONG lFindHandle);

// download synosis file,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DownLoadSynosisFile(LLONG lLoginID, NET_IN_DOWNLOAD_SYNOPSISFILE *pstInParam, NET_OUT_DOWNLOAD_SYNOPSISFILE *pstOutParam);

// stop load synosis file
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopLoadSynosisFile(LLONG lDownLoadHandle);

// according to the path to the file request video service,generate the file information,,user malloc and free pstInParam's memory
CLIENT_NET_API BOOL	CALL_METHOD	CLIENT_SetFilePathInfo(LLONG lLoginID, NET_IN_SET_FILEPATHINFO* pstInParam);

// attach add file state,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachAddFileState(LLONG lLoginID, const NET_IN_ADDFILE_STATE* pstInParam, NET_OUT_ADDFILE_STATE *pstOutParam, int nWaitTime );

// cancel attach add file state,  CLIENT_AttacAddFileState return lAttachHandle
CLIENT_NET_API LLONG CALL_METHOD CLIENT_DetachAddFileState(LLONG lAttachHandle);

/////////////////////////////////face recognition port/////////////////////////////////////////
// face recognition database info operation, including add and delete, ,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateFaceRecognitionDB(LLONG lLoginID, const NET_IN_OPERATE_FACERECONGNITIONDB* pstInParam, NET_OUT_OPERATE_FACERECONGNITIONDB *pstOutParam, int nWaitTime );

// batch append persons, user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_BatchAppendFaceRecognition(LLONG lLoginID, const NET_IN_BATCH_APPEND_FACERECONGNITION* pstInParam, NET_OUT_BATCH_APPEND_FACERECONGNITION *pstOutParam, const int nWaitTime);

// by filter search face recognition result ,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartFindFaceRecognition(LLONG lLoginID, const NET_IN_STARTFIND_FACERECONGNITION* pstInParam, NET_OUT_STARTFIND_FACERECONGNITION *pstOutParam, int nWaitTime );

// start face detection / registry multi channel query
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartMultiFindFaceRecognition(LLONG lLoginID, const NET_IN_STARTMULTIFIND_FACERECONGNITION* pstInParam, NET_OUT_STARTMULTIFIND_FACERECONGNITION *pstOutParam, int nWaitTime);

// search face recognition result:nFilecount: need search item,  return value is media file item  return value<nFilecount then corresponding period file search complete(search max of 20 records each time)
// user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoFindFaceRecognition(const NET_IN_DOFIND_FACERECONGNITION* pstInParam, NET_OUT_DOFIND_FACERECONGNITION *pstOutParam, int nWaitTime );

// end search
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindFaceRecognition(LLONG lFindHandle);

// multimodal face recognition
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartMultiFindFaceRecognitionRecord(LLONG lLoginID, const NET_IN_STARTMULTIFIND_FACERECONGNITIONRECORD* pstInParam, NET_OUT_STARTMULTIFIND_FACERECONGNITIONRECORD *pstOutParam, int nWaitTime);

// multi channel Search file:nFilecount:the searched amount. The return value is media file amount. The search in the specified time completed if return <nFilecount.
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoFindFaceRecognitionRecord(const NET_IN_DOFIND_FACERECONGNITIONRECORD* pstInParam, NET_OUT_DOFIND_FACERECONGNITIONRECORD *pstOutParam, int nWaitTime);

// extension interface about multi channel Search file (nTotalCount:the searched amount. The return value is media file amount. The search in the specified time completed if return <nTotalCount.)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoFindFaceRecognitionRecordEx(const NET_IN_DOFIND_FACERECONGNITIONRECORD_EX* pstInParam, NET_OUT_DOFIND_FACERECONGNITIONRECORD_EX *pstOutParam, int nWaitTime);

// end search
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindFaceRecognitionRecord(LLONG lFindHandle);

// Attach the result of searching history database by picture, Use after CLIENT_StartFindFaceRecognition, pstInParam and pstOutParam are aoolicationed and released by user.
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachResultOfFindHistoryByPic(LLONG lLoginID, NET_IN_ATTACH_RESULT_FINDHISTORY_BYPIC* pstInParam, NET_OUT_ATTACH_RESULT_FINDHISTORY_BYPIC* pstOutParam, int nWaitTime);
// Detach the result of searching history database by picture. lFindHandleis returned by CLIENT_AttachResultOfFindRegisterByPic
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachResultOfFindHistoryByPic(LLONG lFindHandle);

// Attach the result of searching human history database by picture, Use after CLIENT_StartFindFaceRecognition, pstInParam and pstOutParam are aoolicationed and released by user.
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachResultOfHumanHistoryByPic(LLONG lLoginID, NET_IN_ATTACH_RESULT_HUMAN_HISTORY_BYPIC* pstInParam, NET_OUT_ATTACH_RESULT_HUMAN_HISTORY_BYPIC* pstOutParam, int nWaitTime);
// Detach the result of searching human history database by picture. lFindHandleis returned by CLIENT_AttachResultOfHumanHistoryByPic
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachResultOfHumanHistoryByPic(LLONG lFindHandle);

// face recognition(input one big graph, input big graph detected face picture),user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetectFace(LLONG lLoginID, const NET_IN_DETECT_FACE* pstInParam, NET_OUT_DETECT_FACE *pstOutParam, int nWaitTime );

// face recognition staff group operation, including add, modify and delete, ,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateFaceRecognitionGroup(LLONG lLoginID, const NET_IN_OPERATE_FACERECONGNITION_GROUP* pstInParam, NET_OUT_OPERATE_FACERECONGNITION_GROUP *pstOutParam, int nWaitTime );

// face recognition person type operation, including add, modify and delete, user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateFaceRecognitionPersonType(LLONG lLoginID, const NET_IN_OPERATE_FACERECOGNITION_PERSON_TYPE* pstInParam, NET_OUT_OPERATE_FACERECOGNITION_PERSON_TYPE *pstOutParam, int nWaitTime);

// face recognition get person type, user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetFaceRecognitionPersonType(LLONG lLoginID, const NET_IN_GET_FACERECOGNITION_PERSON_TYPE* pstInParam, NET_OUT_GET_FACERECOGNITION_PERSON_TYPE *pstOutParam, int nWaitTime);

// search face recognition staff group info ,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FindGroupInfo(LLONG lLoginID, const NET_IN_FIND_GROUP_INFO* pstInParam, NET_OUT_FIND_GROUP_INFO *pstOutParam, int nWaitTime );

// get arm channel staff group info, user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetGroupInfoForChannel(LLONG lLoginID, const NET_IN_GET_GROUPINFO_FOR_CHANNEL* pstInParam, NET_OUT_GET_GROUPINFO_FOR_CHANNEL *pstOutParam, int nWaitTime );

// arm channel staff group info ,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetGroupInfoForChannel(LLONG lLoginID, const NET_IN_SET_GROUPINFO_FOR_CHANNEL* pstInParam, NET_OUT_SET_GROUPINFO_FOR_CHANNEL *pstOutParam, int nWaitTime );

// set picture information,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachFaceFindState(LLONG lLoginID, const NET_IN_FACE_FIND_STATE* pstInParam, NET_OUT_FACE_FIND_STATE *pstOutParam, int nWaitTime );
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachFaceFindState(LLONG lAttachHandle);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FaceRecognitionSetSearchImageInfo(LLONG lLoginID, const NET_IN_FACE_RECOGNITION_SET_SEARCH_IMAGE_INFO* pstInParam, NET_OUT_FACE_RECOGNITION_SET_SEARCH_IMAGE_INFO *pstOutParam, int nWaitTime );

// put disposition to face recognition, user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FaceRecognitionPutDisposition(LLONG lLoginID, const NET_IN_FACE_RECOGNITION_PUT_DISPOSITION_INFO* pstInParam, NET_OUT_FACE_RECOGNITION_PUT_DISPOSITION_INFO *pstOutParam, int nWaitTime );

// delete disposition from face recognition, user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FaceRecognitionDelDisposition(LLONG lLoginID, const NET_IN_FACE_RECOGNITION_DEL_DISPOSITION_INFO* pstInParam, NET_OUT_FACE_RECOGNITION_DEL_DISPOSITION_INFO *pstOutParam, int nWaitTime );

// submit multiple large images to the server, and detect face images from it, user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD	CLIENT_FaceRecognitionDetectMultiFace(LLONG lLoginID, const NET_IN_FACE_RECOGNITION_DETECT_MULTI_FACE_INFO* pstInParam, NET_OUT_FACE_RECOGNITION_DETECT_MULTI_FACE_INFO *pstOutParam, int nWaitTime);

// attach the progress of detect face images form the big images, cooperate with CLIENT_FaceRecognitionDetectMultiFace, user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachDetectMultiFaceState(LLONG lLoginID, const NET_IN_MULTIFACE_DETECT_STATE* pstInParam, NET_OUT_MULTIFACE_DETECT_STATE *pstOutParam, int nWaitTime);

// detach the progress of detect face images form the big images, lAttachHandleis returned by CLIENT_AttachDetectMultiFaceState 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachDetectMultiFaceState(LLONG lAttachHandle);

// remodeling about person, user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FaceRecognitionReAbstract(LLONG lLoginID, const NET_IN_FACE_RECOGNITION_REABSTRACT_INFO* pstInParam, NET_OUT_FACE_RECOGNITION_REABSTRACT_INFO *pstOutParam, int nWaitTime);

// remodeling about face recognition group, user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FaceRecognitionGroupReAbstract(LLONG lLoginID, const NET_IN_FACE_RECOGNITION_GROUP_REABSTRACT_INFO* pstInParam, NET_OUT_FACE_RECOGNITION_GROUP_REABSTRACT_INFO *pstOutParam, int nWaitTime);

// stop remodeling about face recognition group, user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FaceRecognitionStopGroupReAbstract(LLONG lLoginID, const NET_IN_FACE_RECOGNITION_STOP_GROUP_REABSTRACT_INFO* pstInParam, NET_OUT_FACE_RECOGNITION_STOP_GROUP_REABSTRACT_INFO *pstOutParam, int nWaitTime);

// get face parameter (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetFaceParam(LLONG lLoginID, const NET_IN_GET_FACE_PARAM* pstInParam, NET_OUT_GET_FACE_PARAM *pstOutParam, int nWaitTime);

// set face parameter (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetFaceParam(LLONG lLoginID, const NET_IN_SET_FACE_PARAM* pstInParam, NET_OUT_SET_FACE_PARAM *pstOutParam, int nWaitTime);

//////////////////////////////// burn the upload interface /////////////////////////////////

// open burning session, return to burning session handle,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartBurnSession(LLONG lLoginID, const NET_IN_START_BURN_SESSION* pstInParam, NET_OUT_START_BURN_SESSION *pstOutParam, int nWaitTime);

// close burning session
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopBurnSession(LLONG lBurnSession);

// start burning,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartBurn(LLONG lBurnSession, const NET_IN_START_BURN* pstInParam, NET_OUT_START_BURN *pstOutParam, int nWaitTime);

// stop burning
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopBurn(LLONG lBurnSession);

// pause/recover burning
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PauseBurn(LLONG lBurnSession, BOOL bPause);

// key mark,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_BurnMarkTag(LLONG lBurnSession, const NET_IN_BURN_MARK_TAG* pstInParam, NET_OUT_BURN_MARK_TAG *pstOutParam, int nWaitTime);

// change disk,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_BurnChangeDisk(LLONG lBurnSession, const NET_IN_BURN_CHANGE_DISK* pstInParam, NET_OUT_BURN_CHANGE_DISK *pstOutParam, int nWaitTime);

// get burning status,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_BurnGetState(LLONG lBurnSession, const NET_IN_BURN_GET_STATE* pstInParam, NET_OUT_BURN_GET_STATE *pstOutParam, int nWaitTime);

// attach burn state,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachBurnState(LLONG lLoginID, const NET_IN_ATTACH_STATE* pstInParam, NET_OUT_ATTACH_STATE *pstOutParam, int nWaitTime );

// cancel listening burning status, lAttachHandle is CLIENT_AttachBurnState return value
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachBurnState(LLONG lAttachHandle);

// start burn upload,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartUploadFileBurned(LLONG lLoginID, const NET_IN_FILEBURNED_START* pstInParam, NET_OUT_FILEBURNED_START *pstOutParam, int nWaitTime );

// send file burned,CLIENT_StartUploadFileBurned return lUploadHandle
CLIENT_NET_API BOOL	CALL_METHOD	CLIENT_SendFileBurned(LLONG lUploadHandle);

// stop upload 
CLIENT_NET_API BOOL	CALL_METHOD	CLIENT_StopUploadFileBurned(LLONG lUploadHandle);

// listening burning parity status,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachBurnCheckState(LLONG lLoginID, const NET_IN_ATTACH_BURN_CHECK* pstInParam, NET_OUT_ATTACH_BURN_CHECK* pstOutParam, int nWaitTime );

// cancle attach burn state,CLIENT_DetachBurnCheckState return lAttachHandle
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachBurnCheckState(LLONG lAttachHandle);

// subscribe burning case info,user malloc and free (pInParam's and pOutParam's) memory
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachBurnCase(LLONG lLoginID, const NET_IN_ATTACH_BURN_CASE* pInParam, NET_OUT_ATTACH_BURN_CASE* pOutParam, int nWaitTime);

// cancel subscribe burning case info, lAttachHandle is CLIENT_AttachBurnCase return value
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachBurnCase(LLONG lAttachHandle);

// subscribe burning device state,user malloc and free (pInParam's and pOutParam's) memory
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachBurnDevState(LLONG lLoginID, const NET_IN_ATTACH_BURN_DEV_STATE* pInParam, NET_OUT_ATTACH_BURN_DEV_STATE* pOutParam, int nWaitTime );

// cancel subscribe burning device state, lAttachHandle is CLIENT_AttachBurnDevState return value
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachBurnDevState(LLONG lAttachHandle);

// body mind data info
typedef struct tagNET_BODY_MIND_DATA_INFO
{
    DWORD       dwSize;
    UINT        nECG;               // ecg value,unit: bpm
    UINT        nECGMax;            // ecg max value,unit: bpm
    UINT        nECGMin;            // ecg min value,unit: bpm
    UINT        nSPO2;              // spo2 value,unit: %
    UINT        nSPO2Max;           // spo2 max value,unit: %
    UINT        nSPO2Min;           // spo2 min value,unit: %
    UINT        nRESP;              // resp value,unit: BrPM
    UINT        nRESPMax;           // resp max value,unit: BrPM
    UINT        nRESPMin;           // resp min value,unit: BrPM
    UINT        nNIBP_SYS;          // system nibp value,unit: mmHg
    UINT        nNIBP_SYSMax;       // system nibp max value,unit: mmHg
    UINT        nNIBP_SYSMin;       // system nibp min value,unit: mmHg
    UINT        nNIBP_AVG;          // average nibp value,unit: mmHg
    UINT        nNIBP_AVGMax;       // average nibp max value,unit: mmHg
    UINT        nNIBP_AVGMin;       // average nibp min value,unit: mmHg
    UINT        nNIBP_DIA;          // diastole nibp value,unit: mmHg
    UINT        nNIBP_DIAMax;       // diastole nibp max value,unit: mmHg
    UINT        nNIBP_DIAMin;       // diastole nibp min value,unit: mmHg
} NET_BODY_MIND_DATA_INFO;

// call back of body mind data,lAttachHandle is th return value of CLIENT_AttachBodyMindData
typedef void (CALLBACK *fBodyMindDataCallBack) (LLONG lAttachHandle, const NET_BODY_MIND_DATA_INFO* pBuf, int nBufLen, LDWORD dwUser);

// the input param of CLIENT_AttachBodyMindData
typedef struct tagNET_IN_ATTACH_BODY_MIND_DATA
{
    DWORD                       dwSize;
    fBodyMindDataCallBack       cbBodyMindData;                    // call back function
    LDWORD                      dwUser;                            // user data
} NET_IN_ATTACH_BODY_MIND_DATA;

// the output param of CLIENT_AttachBodyMindData
typedef struct tagNET_OUT_ATTACH_BODY_MIND_DATA
{
    DWORD                dwSize;
} NET_OUT_ATTACH_BODY_MIND_DATA;

// the input param of CLIENT_DetachBodyMindData
typedef struct tagNET_IN_DETACH_BODY_MIND_DATA
{
    DWORD                dwSize;
} NET_IN_DETACH_BODY_MIND_DATA;

// the output param of CLIENT_DetachBodyMindData
typedef struct tagNET_OUT_DETACH_BODY_MIND_DATA
{
    DWORD                dwSize;
} NET_OUT_DETACH_BODY_MIND_DATA;


// attach the body mind data
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachBodyMindData(LLONG lLoginID, const NET_IN_ATTACH_BODY_MIND_DATA* pstInParam, NET_OUT_ATTACH_BODY_MIND_DATA* pstOutParam, int nWaitTime);

// detach the body mind data,lAttachHandle is the return value of CLIENT_AttachBodyMindData
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachBodyMindData(LLONG lAttachHandle, const NET_IN_DETACH_BODY_MIND_DATA* pstInParam, NET_OUT_DETACH_BODY_MIND_DATA *pstOutParam, int nWaitTime);


//////////////////////////////// logical device /////////////////////////////////////////

// attach camerastate,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachCameraState(LLONG lLoginID, const NET_IN_CAMERASTATE* pstInParam, NET_OUT_CAMERASTATE *pstOutParam, int nWaitTime );

// detach camera state,CLIENT_AttachCameraState return lAttachHandle
CLIENT_NET_API BOOL	CALL_METHOD	CLIENT_DetachCameraState(LLONG lAttachHandle);

//get all valid display source,user malloc and free (pInParam's and pOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MatrixGetCameras(LLONG lLoginID, const DH_IN_MATRIX_GET_CAMERAS* pInParam, DH_OUT_MATRIX_GET_CAMERAS* pOutParam, int nWaitTime );

// add logical device,user malloc and free (pInParam's and pOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MatrixAddCameras(LLONG lLoginID, const DH_IN_ADD_LOGIC_DEVICE_CAMERA* pInParam, DH_OUT_ADD_LOGIC_DEVICE_CAMERA* pOutParam, int nWaitTime );

// add logical device bydeviceinfo,user malloc and free (pInParam's and pOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MatrixAddCamerasByDevice(LLONG lLoginID, const DH_IN_ADD_LOGIC_BYDEVICE_CAMERA* pInParam, DH_OUT_ADD_LOGIC_BYDEVICE_CAMERA* pOutParam, int nWaitTime );

// add logical cameras by group,user malloc and free (pInParam's and pOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MatrixAddCamerasByGroup(LLONG lLoginID, const NET_IN_ADD_LOGIC_BYGROUP_CAMERA* pInParam, NET_OUT_ADD_LOGIC_BYGROUP_CAMERA* pOutParam, int nWaitTime );

////////////////////////////////  Matrix interface /////////////////////////////////

// Search product definition,user malloc and free pstuProdDef's memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryProductionDefinition(LLONG lLoginID, DH_PRODUCTION_DEFNITION* pstuProdDef, int nWaitTime );

// Search matri sub card info,user malloc and free pstuCardList's memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryMatrixCardInfo(LLONG lLoginID, DH_MATRIX_CARD_LIST* pstuCardList, int nWaitTime );

// Search system status,user malloc and free pstuStatus's memory
CLIENT_NET_API BOOL CALL_METHOD	CLIENT_QuerySystemStatus(LLONG lLoginID, DH_SYSTEM_STATUS* pstuStatus, int nWaitTime );

// Search split mode,user malloc and free pstuCaps's memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSplitCaps(LLONG lLoginID, int nChannel, DH_SPLIT_CAPS* pstuCaps, int nWaitTime );

// Search/set display source,user malloc and free pstuSplitSrc's memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSplitSource(LLONG lLoginID, int nChannel, int nWindow, DH_SPLIT_SOURCE* pstuSplitSrc, int nMaxCount, int* pnRetCount, int nWaitTime );
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetSplitSource(LLONG lLoginID, int nChannel, int nWindow, const DH_SPLIT_SOURCE* pstuSplitSrc, int nSrcCount, int nWaitTime );
// set display source, support output parameter,user malloc and free (pInparam's and pOutParam's)memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetSplitSourceEx(LLONG lLoginID, const NET_IN_SET_SPLIT_SOURCE* pInparam, NET_OUT_SET_SPLIT_SOURCE* pOutParam, int nWaitTime );

// Used in custom NVR, exchange two windows' display source
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SplitExchangeSource(LLONG lLoginID, const NET_IN_SPLIT_EXCHANGE_SOURCE* pInParam, NET_OUT_SPLIT_EXCHANGE_SOURCE* pOutParam, int nWaitTime );

// Search/set split mode,user malloc and free pstuSplitInfo's memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSplitMode(LLONG lLoginID, int nChannel, DH_SPLIT_MODE_INFO* pstuSplitInfo, int nWaitTime );
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetSplitMode(LLONG lLoginID, int nChannel, const DH_SPLIT_MODE_INFO* pstuSplitInfo, int nWaitTime );

// Search split group amount
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSplitGroupCount(LLONG lLoginID, int nChannel, DH_SPLIT_MODE emSplitMode, int* pnGroupCount, int nWaitTime );

// Search video output capability,user malloc and free pstuCaps's memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetVideoOutCaps(LLONG lLoginID, int nChannel, DH_VIDEO_OUT_CAPS* pstuCaps, int nWaitTime );

// Set video output option,user malloc and free pstuVideoOut's memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetVideoOutOption(LLONG lLoginID, int nChannel, const DH_VIDEO_OUT_OPT* pstuVideoOut, int nWaitTime );

// Search the current window of video input channel,user malloc and free pstuWnds's memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryVideoOutWindows(LLONG lLoginID, int nChannel, DH_VIDEO_OUT_WINDOW* pstuWnds, int nMaxWndCount, int* pnRetWndCount, int nWaitTime );

// set windown position,user malloc and free (pInParam's and pOutParam's)memory
CLIENT_NET_API BOOL CALL_METHOD	CLIENT_SetSplitWindowRect(LLONG lLoginID, const DH_IN_SPLIT_SET_RECT* pInParam, DH_OUT_SPLIT_SET_RECT* pOutParam, int nWaitTime );
CLIENT_NET_API BOOL	CALL_METHOD	CLIENT_GetSplitWindowRect(LLONG lLoginID, const DH_IN_SPLIT_GET_RECT* pInParam, DH_OUT_SPLIT_GET_RECT* pOutParam, int nWaitTime );

// open or close window,user malloc and free (pInParam's and pOutParam's)memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OpenSplitWindow(LLONG lLoginID, const DH_IN_SPLIT_OPEN_WINDOW* pInParam, DH_OUT_SPLIT_OPEN_WINDOW* pOutParam, int nWaitTime );
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CloseSplitWindow(LLONG lLoginID, const DH_IN_SPLIT_CLOSE_WINDOW* pInParam, DH_OUT_SPLIT_CLOSE_WINDOW* pOutParam, int nWaitTime );

// set window order,user malloc and free (pInParam's and pOutParam's)memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetSplitTopWindow(LLONG lLoginID, const DH_IN_SPLIT_SET_TOP_WINDOW* pInParam, DH_OUT_SPLIT_SET_TOP_WINDOW* pOutParam, int nWaitTime );

// get windows info,user malloc and free (pInParam's and pOutParam's)memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSplitWindowsInfo(LLONG lLoginID, const DH_IN_SPLIT_GET_WINDOWS* pInParam, DH_OUT_SPLIT_GET_WINDOWS* pOutParam, int nWaitTime );

// load or save collection,user malloc and free (pInParam's and pOutParam's)memory
CLIENT_NET_API BOOL CALL_METHOD	CLIENT_LoadSplitCollection(LLONG lLoginID, const DH_IN_SPLIT_LOAD_COLLECTION* pInParam, DH_OUT_SPLIT_LOAD_COLLECTION* pOutParam, int nWaitTime );
CLIENT_NET_API BOOL CALL_METHOD	CLIENT_SaveSplitCollection(LLONG lLoginID, const DH_IN_SPLIT_SAVE_COLLECTION* pInParam, DH_OUT_SPLIT_SAVE_COLLECTION* pOutParam, int nWaitTime );

// get collection info,user malloc and free (pInParam's and pOutParam's)memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSplitCollections(LLONG lLoginID, const DH_IN_SPLIT_GET_COLLECTIONS* pInParam, DH_OUT_SPLIT_GET_COLLECTIONS* pOutParam, int nWaitTime );

// rename collection,user malloc and free (pInParam's and pOutParam's)memory
CLIENT_NET_API BOOL	CALL_METHOD CLIENT_RenameSplitCollection(LLONG lLoginID, const DH_IN_SPLIT_RENAME_COLLECTION* pInParam, DH_OUT_SPLIT_RENAME_COLLECTION* pOutParam, int nWaitTime );

// delete collection,user malloc and free (pInParam's and pOutParam's)memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DeleteSplitCollection(LLONG lLoginID, const DH_IN_SPLIT_DELETE_COLLECTION* pInParam, DH_OUT_SPLIT_DELETE_COLLECTION* pOutParam, int nWaitTime );

// decode policy,user malloc and free (pInParam's and pOutParam's)memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDecodePolicy(LLONG lLoginID, const DH_IN_SET_DEC_POLICY* pInParam, DH_OUT_SET_DEC_POLICY* pOutParam, int nWaitTime );
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDecodePolicy(LLONG lLoginID, const DH_IN_GET_DEC_POLICY* pInParam, DH_OUT_GET_DEC_POLICY* pOutParam, int nWaitTime );

// mode of audio output,user malloc and free (pInParam's and pOutParam's)memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetSplitAudioOuput(LLONG lLoginID, const DH_IN_SET_AUDIO_OUTPUT* pInParam, DH_OUT_SET_AUDIO_OUTPUT* pOutParam, int nWaitTime );
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSplitAudioOuput(LLONG lLoginID, const DH_IN_GET_AUDIO_OUTPUT* pInParam, DH_OUT_GET_AUDIO_OUTPUT* pOutParam, int nWaitTime );

// set display source,user malloc and free (pInParam's and pOutParam's)memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MatrixSetCameras(LLONG lLoginID, const DH_IN_MATRIX_SET_CAMERAS* pInParam, DH_OUT_MATRIX_SET_CAMERAS* pOutParam, int nWaitTime );

// get video in ability,user malloc and free (pInParam's and pOutParam's)memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetVideoInCaps(LLONG lLoginID, const DH_IN_GET_VIDEO_IN_CAPS* pInParam, DH_OUT_GET_VIDEO_IN_CAPS* pOutParam, int nWaitTime );

// get mode of video out,user malloc and free (pInParam's and pOutParam's)memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_EnumVideoOutModes(LLONG lLoginID, const DH_IN_ENUM_VIDEO_OUT_MODES* pInParam, DH_OUT_ENUM_VIDEO_OUT_MODES* pOutParam, int nWaitTime );

// get or set splite output OSD info,user malloc and free (pInParam's and pOutParam's)memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSplitOSD(LLONG lLoginID, const DH_IN_SPLIT_GET_OSD* pInParam, DH_OUT_SPLIT_GET_OSD* pOutParam, int nWaitTime );
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetSplitOSD(LLONG lLoginID, const DH_IN_SPLIT_SET_OSD* pInParam, DH_OUT_SPLIT_SET_OSD* pOutParam, int nWaitTime );

// get or set splite output OSD info ----expand interface (the memory of pInParam and pOutParam applyed and released by user),user malloc and free (pInParam's and pOutParam's)memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSplitOSDEx(LLONG lLoginID, const NET_IN_SPLIT_GET_OSD_EX* pInParam, NET_OUT_SPLIT_GET_OSD_EX* pOutParam, int nWaitTime );
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetSplitOSDEx(LLONG lLoginID, const NET_IN_SPLIT_SET_OSD_EX* pInParam, NET_OUT_SPLIT_SET_OSD_EX* pOutParam, int nWaitTime );

// set window tour display source,user malloc and free (pInParam's and pOutParam's)memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetTourSource(LLONG lLoginID, const NET_IN_SET_TOUR_SOURCE* pInParam, NET_OUT_SET_TOUR_SOURCE* pOutParam, int nWaitTime );
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetTourSource(LLONG lLoginID, const NET_IN_GET_TOUR_SOURCE* pInParam, NET_OUT_GET_TOUR_SOURCE* pOutParam, int nWaitTime);

// order tour status ,user malloc and free (pInParam's and pOutParam's)memory
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachSplitTour(LLONG lLoginID, const NET_IN_ATTACH_SPLIT_TOUR* pInParam, NET_OUT_ATTACH_SPLIT_TOUR* pOutParam, int nWaitTime);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachSplitTour(LLONG lAttachHandle);

// low matrix switch,user malloc and free (pInParam's and pOutParam's)memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MatrixSwitch(LLONG lLoginID, const NET_IN_MATRIX_SWITCH* pInParam, NET_OUT_MATRIX_SWITCH* pOutParam, int nWaitTime);

// set display source, support multiple window at same time,user malloc and free (pInParam's and pOutParam's)memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SplitSetMultiSource(LLONG lLoginID, const NET_IN_SPLIT_SET_MULTI_SOURCE* pInParam, NET_OUT_SPLIT_SET_MULTI_SOURCE* pOutParam, int nWaitTime);

// video split operation,user malloc and free (pInParam's and pOutParam's)memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateSplit(LLONG lLoginID, NET_SPLIT_OPERATE_TYPE emType, void* pInParam, void* pOutParam, int nWaitTime);
// attach windows source info, user malloc and free(pInParam's and pOutParam's) memory
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachWindowsSource( LLONG lLoginID, const NET_IN_ATTACH_WINDOW_SOURCE* pInParam, NET_OUT_ATTACH_WINDOW_SOURCE* pOutParam, int nWaitTime );
// deteach windows  source info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachWindowsSource( LLONG lAttachHandle );

// enlarge region of the window, user malloc and free(pInParam's and pOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_WindowRegionEnlarge(LLONG lLoginID, const NET_IN_WINDOW_REGION_ENLARGE* pInParam, NET_OUT_WINDOW_REGION_ENLARGE* pOutParam, int nWaitTime);

// restore the window which is be enlarged, user malloc and free(pInParam's and pOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_WindowEnlargeReduction(LLONG lLoginID, const NET_IN_WINDOW_ENLARGE_REDUCTION* pInParam, NET_OUT_WINDOW_ENLARGE_REDUCTION* pOutParam, int nWaitTime);

// the operation of mouse on matrix window, user malloc and free(pInParam's and pOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_WindowButtonAction(LLONG lLoginID, const NET_IN_WINDOW_ONBUTTON_ACTION* pInParam, NET_OUT_WINDOW_ONBUTTON_ACTION* pOutParam, int nWaitTime);

// split window play operaton type 
typedef enum tagNET_PLAYER_OPERATE_TYPE
{
    NET_PLAYER_OPERATE_OPEN,                // open playuer,NET_IN_PLAYER_OPEN
    NET_PLAYER_OPERATE_CLOSE,               // close player,NET_IN_PLAYER_CLOSE
    NET_PLAYER_OPERATE_START,               // start play,NET_IN_PLAYER_START
    NET_PLAYER_OPERATE_STOP,                // stop play,NET_IN_PLAYER_STOP
    NET_PLAYER_OPERATE_PAUSE,               // pause/restore play,NET_IN_PLAYER_PAUSE
    NET_PLAYER_OPERATE_SEEK_TIME,           // go to specific time play,NET_IN_PLAYER_SEEK_TIME
    NET_PLAYER_OPERATE_STEP_FRAME,          // single frame playback, need to be used after pause,NET_IN_PLAYER_STEP_FRAME
    NET_PLAYER_OPERATE_GET_STATE,           // take current playback status,NET_IN_PLAYER_GET_STATE
    NET_PLAYER_OPERATE_GET_TIME,            // Get  current playback time,NET_IN_PLAYER_GET_TIME and NET_OUT_PLAYER_GET_TIME
    NET_PLAYER_OPERATE_GET_SPEED,           // Get play speed,NET_IN_PLAYER_GET_SPEED and NET_OUT_PLAYER_GET_SPEED
    NET_PLAYER_OPERATE_SET_SPEED,           // Set play speed,NET_IN_PLAYER_SET_SPEED
    NET_PLAYER_OPERATE_GET_VOLUME,          // Get volume,NET_IN_PLAYER_GET_VOLUME and NET_OUT_PLAYER_GET_VOLUME
    NET_PLAYER_OPERATE_SET_VOLUME,          // Set volume,NET_IN_PLAYER_SET_VOLUME
    NET_PLAYER_OPERATE_GET_PLAYLIST,        // Get file list,NET_IN_PLAYER_GET_PLAYLIST and NET_OUT_PLAYER_GET_PLAYLIST
    NET_PLAYER_OPERATE_GET_PLAYLIST_TS,     // Get current file list all period info,NET_IN_PLAYER_GET_PLAYLIST_TS and NET_OUT_PLAYER_GET_PLAYLIST_TS
}NET_PLAYER_OPERATE_TYPE;

// play criteria 
typedef struct tagNET_PLAYER_OPEN_CONDITION 
{
    DWORD               dwSize;
    char                szDevice[DH_DEV_ID_LEN];        // point remote device 
    int                 nChannel;                       // channel no.
    NET_TIME            stuStartTime;                   // start time
    NET_TIME            stuEndTime;                     // end time
    NET_STREAM_TYPE     emStreamType;                   // stream type 
    int                 nEventNum;                      // Event type number
    int                 nEvent[MAX_IVS_EVENT_NUM];      // Event type
}NET_PLAYER_OPEN_CONDITION;

// stream transmission mode
typedef enum tagNET_EM_SPLIT_TRANS_MODE
{
	NET_EM_SPLIT_TRANS_DIRECT,			// direct
	NET_EM_SPLIT_TRANS_TRANSFER,			// transfer
} NET_EM_SPLIT_TRANS_MODE;

// remotevice of matrix device connect type
typedef enum tagNET_EM_SPLIT_CONNECT_TYPE
{
	NET_EM_SPLIT_CONNECT_TCP,				// tcp
	NET_EM_SPLIT_CONNECT_UDP,				// udp
} NET_EM_SPLIT_CONNECT_TYPE;

//open player input parameter , corresponding to NET_PLAYER_OPERATE_OPEN
typedef struct tagNET_IN_PLAYER_OPEN 
{
	DWORD						dwSize;
	LLONG						lPlayerID;		// play example ID
	const char*					pszDevice;		// take record from local or remote end, as null represents to take record from local, 
												// it is valid when bDeviceInfo is FALSE
												// if from remote device, need to maintain with NET_PLAYER_OPEN_CONDITION szDevice identical
	NET_PLAYER_OPEN_CONDITION 	stuCondition;	// search criteria 
	BOOL						bDeviceInfo;	// it means that the "stuDeviceInfo" is valid or not
	DH_REMOTE_DEVICE			stuDeviceInfo;	// device info, it is valid when bDeviceInfo is TRUE
	NET_EM_SPLIT_TRANS_MODE		emTransferMode;	// stream transmission mode
	NET_EM_SPLIT_CONNECT_TYPE	emConnectType;	// connect type, it is effective when emTransferMode is NET_EM_SPLIT_TRANS_TRANSFER, otherwise using pull stream mode
	EM_SRC_PUSHSTREAM_TYPE  	emPushStream;   // stream type, it is effective when emTransferMode is NET_EM_SPLIT_TRANS_TRANSFER, and emConnectType is TCP or UDP
}NET_IN_PLAYER_OPEN;

// open player  output parameter , corresponding to NET_PLAYER_OPERATE_OPEN
typedef struct tagNET_OUT_PLAYER_OPEN 
{
  DWORD        dwSize;
}NET_OUT_PLAYER_OPEN;

// close player input parameter , corresponding to NET_PLAYER_OPERATE_CLOSE
typedef struct tagNET_IN_PLAYER_CLOSE
{
  DWORD        dwSize;
  LLONG        lPlayerID;           // play example ID
}NET_IN_PLAYER_CLOSE;

// close player output parameter , corresponding to NET_PLAYER_OPERATE_CLOSE
typedef struct tagNET_OUT_PLAYER_CLOSE
{
  DWORD        dwSize;
}NET_OUT_PLAYER_CLOSE;

//  start  play input parameter , corresponding to NET_PLAYER_OPERATE_START
typedef struct tagNET_IN_PLAYER_START
{
  DWORD        dwSize;
  LLONG        lPlayerID;           //  play example ID
}NET_IN_PLAYER_START;

//  start  play  output parameter , corresponding to NET_PLAYER_OPERATE_START
typedef struct tagNET_OUT_PLAYER_START
{
  DWORD        dwSize;
}NET_OUT_PLAYER_START;

// stop play input parameter , corresponding to NET_PLAYER_OPERATE_STOP
typedef struct tagNET_IN_PLAYER_STOP
{
  DWORD        dwSize;
  LLONG        lPlayerID;           //  play example ID
}NET_IN_PLAYER_STOP;

// stop play  output parameter , corresponding to NET_PLAYER_OPERATE_STOP
typedef struct tagNET_OUT_PLAYER_STOP
{
  DWORD        dwSize;
}NET_OUT_PLAYER_STOP;

//  pause /recover  play input parameter , corresponding to NET_PLAYER_OPERATE_PAUSE
typedef struct tagNET_IN_PLAYER_PAUSE
{
  DWORD        dwSize;
  LLONG        lPlayerID;         	// play example ID
  BOOL         bPause;             	// pause or not, TRUE- pause  play , FALSE-recover  play 
}NET_IN_PLAYER_PAUSE;

//  pause /recover  play  output parameter , corresponding to NET_PLAYER_OPERATE_PAUSE
typedef struct tagNET_OUT_PLAYER_PAUSE
{
  DWORD        dwSize;
}NET_OUT_PLAYER_PAUSE;

// go to specific time play input parameter , corresponding to NET_PLAYER_OPERATE_SEEK_TIME
typedef struct tagNET_IN_PLAYER_SEEK_TIME
{
  DWORD        dwSize;
  LLONG        lPlayerID;           // play example ID
  NET_TIME     stuTime;            	// go to time
}NET_IN_PLAYER_SEEK_TIME;

// go to specific time play  output parameter , corresponding to NET_PLAYER_OPERATE_SEEK_TIME
typedef struct tagNET_OUT_PLAYER_SEEK_TIME
{
  DWORD        dwSize;
}NET_OUT_PLAYER_SEEK_TIME;

// single frame play input parameter , corresponding to NET_PLAYER_OPERATE_STEP_FRAME
typedef struct tagNET_IN_PLAYER_STEP_FRAME
{
  DWORD        dwSize;
  LLONG        lPlayerID;           //  play example ID
  BOOL         bForward;            //  positive direction, TRUE-positive direction, FALSE-negative direction
}NET_IN_PLAYER_STEP_FRAME;

// single frame play  output parameter , corresponding to NET_PLAYER_OPERATE_STEP_FRAME
typedef struct tagNET_OUT_PLAYER_STEP_FRAME
{
  DWORD        dwSize;
}NET_OUT_PLAYER_STEP_FRAME;

//  play status 
typedef enum tagNET_PLAYER_STATE 
{
  NET_PLAYER_STATE_UNKNOWN,        	// unknown 
  NET_PLAYER_STATE_ERROR,         	// error occur
  NET_PLAYER_STATE_READING,        	// ready, may start palyabck
  NET_PLAYER_STATE_STANDBY,        	// current file playback stop, only can start playback from beginningart
  NET_PLAYER_STATE_RUNNING,        	// running
  NET_PLAYER_STATE_PAUSED,        	// paused , may continue from pause point
  NET_PLAYER_STATE_CLOSED,        	// closed, cannot play, must open and enter Reading status again
}NET_PLAYER_STATE;

// search  play status input parameter , corresponding to NET_PLAYER_OPERATE_GET_STATE
typedef struct tagNET_IN_PLAYER_GET_STATE
{
  DWORD        dwSize;
  LLONG        lPlayerID;           //  play example ID
}NET_IN_PLAYER_GET_STATE;

// search  play status  output parameter , corresponding to NET_PLAYER_OPERATE_GET_STATE
typedef struct tagNET_OUT_PLAYER_GET_STATE
{
  DWORD        dwSize;
  NET_PLAYER_STATE  emState;            // status 
}NET_OUT_PLAYER_GET_STATE;

// Get  current  playback timeinput parameter , corresponding to NET_PLAYER_OPERATE_GET_TIME
typedef struct tagNET_IN_PLAYER_GET_TIME
{
  DWORD        dwSize;
  LLONG        lPlayerID;           //  play example ID
}NET_IN_PLAYER_GET_TIME;

// Get  current  playback time output parameter , corresponding to NET_PLAYER_OPERATE_GET_TIME
typedef struct tagNET_OUT_PLAYER_GET_TIME
{
  DWORD        dwSize;
  NET_TIME     stuTime;            //  current  play time
}NET_OUT_PLAYER_GET_TIME;

// Get  play speed input parameter , corresponding to NET_PLAYER_OPERATE_GET_SPEED
typedef struct tagNET_IN_PLAYER_GET_SPEED
{
  DWORD        dwSize;
  LLONG        lPlayerID;           //  play example ID
}NET_IN_PLAYER_GET_SPEED;

// Get  play speed output parameter , corresponding to NET_PLAYER_OPERATE_GET_SPEED
typedef struct tagNET_OUT_PLAYER_GET_SPEED
{
  DWORD        dwSize;
  float        fSpeed;             	//  play speed, >0 positive direction  play , <0 direction  play 
									//  absolute value means speed, =1 nornal speed, >1 quick, <1 slow
}NET_OUT_PLAYER_GET_SPEED;

// set play speedinput parameter , corresponding to NET_PLAYER_OPERATE_SET_SPEED
typedef struct tagNET_IN_PLAYER_SET_SPEED
{
  DWORD        dwSize;
  LLONG        lPlayerID;           //  play example ID
  float        fSpeed;             	//  play speed, >0 positive direction  play , <0 direction  play 
									//  absolute value means speed, =1 normal speed, >1 quick, <1 slow
}NET_IN_PLAYER_SET_SPEED;

// set play speed output parameter , corresponding to NET_PLAYER_OPERATE_SET_SPEED
typedef struct tagNET_OUT_PLAYER_SET_SPPED
{
  DWORD        dwSize;
}NET_OUT_PLAYER_SET_SPEED;

// Get  play  volume input parameter , corresponding to NET_PLAYER_OPERATE_GET_VOLUME
typedef struct tagNET_IN_PLAYER_GET_VOLUME
{
  DWORD        dwSize;
  LLONG        lPlayerID;           //  play example ID
}NET_IN_PLAYER_GET_VOLUME;

// Get  play  volume  output parameter , corresponding to NET_PLAYER_OPERATE_GET_VOLUME
typedef struct tagNET_OUT_PLAYER_GET_VOLUME
{
  DWORD        dwSize;
  int          nVolume;            //  play  volume , 0~100
}NET_OUT_PLAYER_GET_VOLUME;

// set play  volume input parameter , corresponding to NET_PLAYER_OPERATE_SET_VOLUME
typedef struct tagNET_IN_PLAYER_SET_VOLUME
{
  DWORD        dwSize;
  LLONG        lPlayerID;           //  play example ID
  int          nVolume;             //  play  volume , 0~100
}NET_IN_PLAYER_SET_VOLUME;

// set play  volume  output parameter , corresponding to NET_PLAYER_OPERATE_SET_VOLUME
typedef struct tagNET_OUT_PLAYER_SET_VOLUME
{
  DWORD        dwSize;
}NET_OUT_PLAYER_SET_VOLUME;

//  play listinfo 
typedef struct tagNET_PLAYER_PLAYLIST
{
  DWORD        	dwSize;
  char         	szFilePath[MAX_PATH];      	// file path, select either Url
  char         	szUrl[MAX_PATH];        	// URL, and FilePath wither one
  DH_DEVICE_PROTOCOL emUrlProtocol;         // URL protocol type 
  NET_TIME      stuStartTime;          		// start time
  NET_TIME      stuEndTime;           		// end time
}NET_PLAYER_PLAYLIST;

// Get  current  play listinput parameter , corresponding to NET_PLAYER_OPERATE_GET_PLAYLIST
typedef struct tagNET_IN_PLAYER_GET_PLAYLIST
{
  DWORD         dwSize;
  LLONG         lPlayerID;           	// play example ID
  NET_TIME      stuStartTime;          	// start time
  NET_TIME      stuEndTime;           	// end time
  int           nLimit;             	// search file quantity limit, 0 means no limit
}NET_IN_PLAYER_GET_PLAYLIST;

// Get  current  play list output parameter , corresponding to NET_PLAYER_OPERATE_GET_PLAYLIST
typedef struct tagNET_OUT_PLAYER_GET_PLAYLIST
{
  DWORD       dwSize;
  NET_PLAYER_PLAYLIST* pstuPlayLists;  // play list, user allocate memory
  int         nMaxPlayListCount;       // max play list quantity, user fill in
  int         nRetPlayListCount;       // return play list quantity
}NET_OUT_PLAYER_GET_PLAYLIST;

// Get current file list all time period info input parameter, corresponding  NET_PLAYER_OPERATE_GET_PLAYLIST_TS
typedef struct tagNET_IN_PLAYER_GET_PLAYLIST_TS
{
    DWORD               dwSize;
    LLONG               lPlayerID;                      // Play actual ID
}NET_IN_PLAYER_GET_PLAYLIST_TS;

typedef struct tagNET_PLAYLIST_TIMESECTION
{
    DWORD               dwSize;
    int                 nEvent;                         // Record event type,  currently have
                                                        // EVENT_ALARM_COMMON, EVENT_ALARM_VIDEOBLIND, EVENT_ALARM_VIDEOLOSS, 
                                                        // EVENT_ALARM_MOTIONDETECT, EVENT_ALARM_LOCALALARM
    LPDH_TSECT          pstuTSs;                        // Time period info
    DWORD               unMaxTS;                        // Time period max number
    DWORD               unRetTS;                        // Actual returned time period number
}NET_PLAYLIST_TIMESECTION;

// Get current file list all time period info output parameters, corresponding  NET_PLAYER_OPERATE_GET_PLAYLIST_TS
typedef struct tagNET_OUT_PLAYER_GET_PLAYLIST_TS
{
    DWORD                    dwSize;
    DWORD                    dwEventNum;                // Record type quantity
    NET_PLAYLIST_TIMESECTION stuTS[MAX_IVS_EVENT_NUM];  // Current playback list time period info
}NET_OUT_PLAYER_GET_PLAYLIST_TS;

// split window  play ,user malloc and free (pInParam's and pOutParam's)memory,please refer to the corrsponding structure of emType
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateSplitPlayer(LLONG lLoginID, NET_PLAYER_OPERATE_TYPE emType, void* pInParam, void* pOutParam, int nWaitTime);

// NET_ACCESS_LOCK_VER input parameter 
typedef struct tagNET_ACCESS_LOCK_VER_IN
{
    int                 nChannel;                       // channel number 
    char                reserved[128];                  // reserve 
} NET_ACCESS_LOCK_VER_IN;

// NET_ACCESS_LOCK_VER output parameter 
typedef struct tagNET_ACCESS_LOCK_VER_OUT
{
    char                szVersion[32];                  // version 
    NET_TIME            stuTime;                        // time 
    char                reserved[512];                  // reserve 
} NET_ACCESS_LOCK_VER_OUT;

// door lock version number, CLIENT_QueryDevState query type
typedef struct tagNET_ACCESS_LOCK_VER
{
    DWORD                    dwSize;
    NET_ACCESS_LOCK_VER_IN   stuIn;                     // input parameter 
    NET_ACCESS_LOCK_VER_OUT  stuOut;                    // output parameter 
} NET_ACCESS_LOCK_VER;

//////////////////////////////////// TV wall control  //////////////////////////////////////

// power control,user malloc memory of pInParam and pOutParam 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PowerControl(LLONG lLoginID, const DH_IN_WM_POWER_CTRL* pInParam, DH_OUT_WM_POWER_CTRL* pOutParam, int nWaitTime );

// get or set mode of display ,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDisplayMode(LLONG lLoginID, const DH_IN_WM_SET_DISPLAY_MODE* pInParam, DH_OUT_WM_SET_DISPLAY_MODE* pOutParam, int nWaitTime );
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDisplayMode(LLONG lLoginID, const DH_IN_WM_GET_DISPLAY_MODE* pInParam, DH_OUT_WM_GET_DISPLAY_MODE* pOutParam, int nWaitTime );

// load or save plan,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD	CLIENT_LoadMonitorWallCollection(LLONG lLoginID, const DH_IN_WM_LOAD_COLLECTION* pInParam, DH_OUT_WM_LOAD_COLLECTION* pOutParam, int nWaitTime );
CLIENT_NET_API BOOL CALL_METHOD	CLIENT_SaveMonitorWallCollection(LLONG lLoginID, const DH_IN_WM_SAVE_COLLECTION* pInParam, DH_OUT_WM_SAVE_COLLECTION* pOutParam, int nWaitTime );

// get plan of monitor wall,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetMonitorWallCollections(LLONG lLoginID, const DH_IN_WM_GET_COLLECTIONS* pInParam, DH_OUT_WM_GET_COLLECTIONS* pOutParam, int nWaitTime );

// rename monitor wall's plan,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL	CALL_METHOD CLIENT_RenameMonitorWallCollection(LLONG lLoginID, const DH_IN_WM_RENAME_COLLECTION* pInParam, DH_OUT_WM_RENAME_COLLECTION* pOutParam, int nWaitTime );

// get or set scene of monitor wall ,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallGetScene(LLONG lLoginID, const DH_IN_MONITORWALL_GET_SCENE* pInParam, DH_OUT_MONITORWALL_GET_SCENE* pOutParam, int nWaitTime );
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallSetScene(LLONG lLoginID, const DH_IN_MONITORWALL_SET_SCENE* pInParam, DH_OUT_MONITORWALL_SET_SCENE* pOutParam, int nWaitTime );

// CLIENT_MonitorWallSetScene's interface input param(Get the number of TV wall scenes)
typedef struct tagNET_IN_GET_COUNT_MONITORWALL_SCENE
{
    DWORD                   dwSize;
    int                     nMonitorWallID;                 // TV Wall Number
} NET_IN_GET_COUNT_MONITORWALL_SCENE;

// CLIENT_MonitorWallSetScene's interface output param(Get the number of TV wall scenes)
typedef struct tagNET_OUT_GET_COUNT_MONITORWALL_SCENE
{
    DWORD                   dwSize;
    unsigned int            nSplitSceneCount;           // Getting the Number of Spliced Screen Scenes
    unsigned int            nSplitWndCount[300];        // An array of window information, each element of which represents the number of window information in each mosaic screen scene.
} NET_OUT_GET_COUNT_MONITORWALL_SCENE;

// Get the number of TV wall scenes
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetCountOfMonitorWallScene(LLONG lLoginID, const NET_IN_GET_COUNT_MONITORWALL_SCENE* pInParam, NET_OUT_GET_COUNT_MONITORWALL_SCENE* pOutParam, int nWaitTime);


// get attribute caps of monitor wall
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallGetAttributeCaps(LLONG lLoginID, const DH_IN_MONITORWALL_GET_ARRT_CAPS* pInParam, DH_OUT_MONITORWALL_GET_ARRT_CAPS* pOutParam, int nWaitTime );

// auto adjust of monitor wall,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallAutoAdjust(LLONG lLoginID, const DH_IN_MONITORWALL_AUTO_ADJUST* pInParam, DH_OUT_MONITORWALL_AUTO_ADJUST* pOutParam, int nWaitTime );

// set attribute of monitor wall ,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallSetAttribute(LLONG lLoginID, const DH_IN_MONITORWALL_SET_ATTR* pInParam, DH_OUT_MONITORWALL_SET_ATTR* pOutParam, int nWaitTime );

// set mode of backlight,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallSetBackLight(LLONG lLoginID, const DH_IN_MONITORWALL_SET_BACK_LIGHT* pInParam, DH_OUT_MONITORWALL_SET_BACK_LIGHT* pOutParam, int nWaitTime );

// search/set screen on/off plan,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallGetPowerSchedule(LLONG lLoginID, const NET_IN_MW_GET_POWER_SCHEDULE* pInParam, NET_OUT_MW_GET_POWER_SCHEDULE* pOutParam, int nWaitTime);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallSetPowerSchedule(LLONG lLoginID, const NET_IN_MW_SET_POWER_SCHEDULE* pInParam, NET_OUT_MW_SET_POWER_SCHEDULE* pOutParam, int nWaitTime);

// search/set screen control parameter,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallGetScrnCtrlParam(LLONG lLoginID, const NET_IN_MW_GET_SCRN_CTRL_PARAM* pInParam, NET_OUT_MW_GET_SCRN_CTRL_PARAM* pOutParam, int nWaitTime);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallSetScrnCtrlParam(LLONG lLoginID, const NET_IN_MW_SET_SCRN_CTRL_PARAM* pInParam, NET_OUT_MW_SET_SCRN_CTRL_PARAM* pOutParam, int nWaitTime);

// search/set screen and window background color,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallGetBackgroudColor(LLONG lLoginID, const NET_IN_MW_GET_BACKGROUDND_COLOR* pInParam, NET_OUT_MW_GET_BACKGROUDND_COLOR* pOutParam, int nWaitTime);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallSetBackgroudColor(LLONG lLoginID, const NET_IN_MW_SET_BACKGROUD_COLOR* pInParam, NET_OUT_MW_SET_BACKGROUD_COLOR* pOutParam, int nWaitTime);

// order scheme tour status,user malloc memory of pInParam and pOutParam
CLIENT_NET_API LLONG CALL_METHOD CLIENT_MonitorWallAttachTour(LLONG lLoginID, const NET_IN_WM_ATTACH_TOUR* pInParam, NET_OUT_WM_ATTACH_TOUR* pOutParam, int nWaitTime);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallDetachTour(LLONG lAttachHandle);

// operate Monitor Wall,user malloc memory of pInParam and pOutParam,please refer to the corresponding structure of emType
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateMonitorWall(LLONG lLoginID, NET_MONITORWALL_OPERATE_TYPE emType, void* pInParam, void* pOutParam, int nWaitTime);

// switch Monitor Wall display sigal,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallSwitchDisplaySignal(LLONG lLoginID, const NET_IN_MW_SWITCH_DISPLAY_SIGNAL* pInParam, NET_OUT_MW_SWITCH_DISPLAY_SIGNAL* pOutParam, int nWaitTime);

//get monitorwall window info input parameter
typedef struct tagNET_IN_MW_GET_WINODW_INFO
{
	DWORD                      dwSize;                     //dwSize must be initialized,dwSize is sizeof(NET_IN_MW_GET_WINODW_INFO)
	int				           nMonitorWallID;			   //monitor wall ID
	const char*		           pszCompositeID;			   //composite ID
}NET_IN_MW_GET_WINODW_INFO;

//compression
typedef enum tagEM_NET_ENCODE_COMPRESSION
{
	EM_NET_ENCODE_COMPRESSION_UNKNOWN,                     //Unknown
	EM_NET_ENCODE_COMPRESSION_H264,                        //H264
	EM_NET_ENCODE_COMPRESSION_MPEG4,                       //MPEG4
	EM_NET_ENCODE_COMPRESSION_MJPEG,                       //MJPEG
	EM_NET_ENCODE_COMPRESSION_SVAC,                        //SVAC
	EM_NET_ENCODE_COMPRESSION_HIK,                         //HIK
	EM_NET_ENCODE_COMPRESSION_H265,                        //H265
}EM_NET_ENCODE_COMPRESSION;

//video window info
typedef struct tagNET_MW_GET_WINDOW_INFO
{
	BOOL                       bEnable;                    //the state of window enable
	NET_VIDEOCHANNEL_STATE     emState;                    //video window state
	UINT                       unNetflow;                  //net flow(unit: kbps)
	UINT                       unBitrate;                  //bit rate(unit: kbps)
	UINT                       nFrame;                     //frame
	CAPTURE_SIZE               emResolution;               //resolution
	UINT                       unRealTimeFrame;            //realTime frame
	EM_NET_ENCODE_COMPRESSION  emCompression;              //compression
	BYTE                       byReserved[512];            //reserve
}NET_MW_GET_WINDOW_INFO;

//get monitorwall window info output parameter
typedef struct tagNET_OUT_MW_GET_WINDOW_INFO
{
	DWORD                      dwSize;                     //dwSize must be initialized,dwSize is sizeof(NET_OUT_MW_GET_WINDOW_INFO)
	int                        nVideoInfoNum;              //the video info num which user need to gain,gain from 0 by user
	NET_MW_GET_WINDOW_INFO*    pNetVideoChannelInfo;       //the list of net video channel info,user malloc memory,the list num is in keeping with nVideoInfoNum, memory size is sizeof(NET_MW_GET_WINDOW_INFO)*nVideoInfoNum
	int                        nRetVideoInfoNum;           //return video info num actually by SDK
}NET_OUT_MW_GET_WINDOW_INFO;

//get monitorwall window info,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallGetWindowInfo(LLONG lLoginID, const NET_IN_MW_GET_WINODW_INFO* pInParam, NET_OUT_MW_GET_WINDOW_INFO* pOutParam,int nWaitTime);

///////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////Interface of panoramic composite group(start )///////////////////////////////////////////////////
/////////////////////////////////////////////////////// ///////////////////////////////////////////////
// Panoramic composite group info
typedef struct tagPANO_COMPOSITE_GROUP_INFO
{
    char                szGroupName[64];                // Panoramic composite group name
    /*The value of nRow times nColumn should be greater than or equal to 1 and less than 65*/
    int                 nRow;                           // Row 
    int                 nColumn;                        // Column
    int                 nEncChannel;                    // Associated encoding channel number, It can be obtained through the CLIENT_QueryMatrixCardInfo interface
    BYTE                byReserved[1028];               //Reserved
} PANO_COMPOSITE_GROUP_INFO;

// Input param of creating panoramic composite group
typedef struct tagNET_IN_ADD_PANO_COMPOSITE_GROUP
{
    DWORD                       dwSize;                         // Struct size
    BYTE                        byReserved[4];                  // Byte alignment
    PANO_COMPOSITE_GROUP_INFO   stuPanoCompositeGroup;          // Panoramic composite group info
} NET_IN_ADD_PANO_COMPOSITE_GROUP;

// Output param of creating panoramic composite group
typedef struct tagNET_OUT_ADD_PANO_COMPOSITE_GROUP
{
    DWORD                       dwSize;                         // Struct size
    BYTE                        byReserved[4];                  // Byte alignment
    char                        szGroupID[32];                  // Panoramic composite group ID
} NET_OUT_ADD_PANO_COMPOSITE_GROUP;

// Input param of removing panoramic composite group
typedef struct tagNET_IN_REMOVE_PANO_COMPOSITE_GROUP
{
    DWORD                       dwSize;                         // Struct size
    UINT                        nGroupNum;                      // Number of groups to remove
    char                        szGroupIdList[16][32];          //The id of groups to remove
} NET_IN_REMOVE_PANO_COMPOSITE_GROUP;

// Output param of removing panoramic composite group
typedef struct tagNET_OUT_REMOVE_PANO_COMPOSITE_GROUP
{
    DWORD                       dwSize;                         // Struct size
} NET_OUT_REMOVE_PANO_COMPOSITE_GROUP;

// Input param of modifying panoramic composite group
typedef struct tagNET_IN_MODIFY_PANO_COMPOSITE_GROUP
{
    DWORD                       dwSize;                         // Struct size
    BYTE                        byReserved[4];                  // Byte alignment
    char                        szGroupID[32];                  // Panoramic composite group ID
    PANO_COMPOSITE_GROUP_INFO   stuPanoCompositeGroup;          // Panoramic composite group info
} NET_IN_MODIFY_PANO_COMPOSITE_GROUP;

// Output param of modifying panoramic composite group
typedef struct tagNET_OUT_MODIFY_PANO_COMPOSITE_GROUP
{
    DWORD                       dwSize;                         // Struct size
} NET_OUT_MODIFY_PANO_COMPOSITE_GROUP;

// Input param of getting all panoramic composite group info
typedef struct tagNET_IN_GET_ALL_PANO_COMPOSITE_GROUP
{
    DWORD                       dwSize;                         // Struct size
} NET_IN_GET_ALL_PANO_COMPOSITE_GROUP;

// List of panoramic composite groups
typedef struct tagPANO_COMPOSITE_GROUP_LIST_INFO
{
    char                        szGroupID[32];                  // Panoramic composite group ID
    PANO_COMPOSITE_GROUP_INFO   stuPanoCompositeGroup;          // Panoramic composite group info
    BYTE                        byReserved[1024];               // Reserved
} PANO_COMPOSITE_GROUP_LIST_INFO;

// Output param of getting all panoramic composite group info
typedef struct tagNET_OUT_GET_ALL_PANO_COMPOSITE_GROUP
{
    DWORD                           dwSize;                         // Struct size
    UINT                            nGroupNum;                      // Panoramic composite group number
    PANO_COMPOSITE_GROUP_LIST_INFO  stuGroupInfoList[16];           // List of panoramic composite groups
} NET_OUT_GET_ALL_PANO_COMPOSITE_GROUP;

// Source stream type
typedef enum tagEM_SOURCE_STREAM_TYPE
{
    EM_SOURCE_STREAM_UNKNOWN     = -1,  // Unknown
    EM_SOURCE_STREAM_MAIN,              // Main stream
    EM_SOURCE_STREAM_EXTRA1,            // Extra stream 1
    EM_SOURCE_STREAM_EXTRA2,            // Extra stream 2
    EM_SOURCE_STREAM_EXTRA3,            // Extra stream 3
    EM_SOURCE_STREAM_AUTO,              // Automatically select  right stream
    EM_SOURCE_STREAM_PREVIEW,           // Preview stream
} EM_SOURCE_STREAM_TYPE;

// Source device info
typedef struct tagNET_SOURCE_DEVICE_INFO
{
    int                         nDefinition;                        // Definition, 0-standard definition, 1-high definition
    DH_DEVICE_PROTOCOL          emProtocol;                         // Protocol type
    char                        szIp[32];                           // IP, empty means no setting
    char                        szUser[64];                         // User name
    char                        szPwd[64];                          // Password
    int                         nPort;                              // Port
    int                         nVideoInputChannelNum;              // Input video channel numbers
    int                         nAudioInputChannelNum;              // Input audio channel numbers
    DWORD                       dwHttpPort;                         // Http port, 0-65535
    DWORD                       dwRtspPort;                         // Rtsp port, 0-65535
    int                         nHint;                              // 0-normal video source, 1-alarm video source
    char                        szDevClass[DH_DEV_TYPE_LEN];        // Device class, for example:IPC, DVR, NVR and so on
    char                        szDevType[DH_DEV_TYPE_LEN];         // Device type, for example:IPC-HF3300
    char                        szMainStreamUrl[MAX_PATH];          // Url address of main stream
    BYTE                        byReserved[1028];                   // Reserved
} NET_SOURCE_DEVICE_INFO;

// Display source of panoramic composite group
typedef struct tagPANO_COMPOSITE_GROUP_SOURCE_INFO
{
    UINT                            nChannelID;                     // video channel
    EM_SOURCE_STREAM_TYPE           emStreamType;                   // Source video stream
    char                            szDeviceID[64];                 // Device ID,  stuDeviceInfo is invalid if the ID is not empty
    NET_SOURCE_DEVICE_INFO          stuDeviceInfo;                  // Source device info, It is effective if the szDeviceID is empty
    BYTE                            byReserved[1024];               // Reserved
} PANO_COMPOSITE_GROUP_SOURCE_INFO;

// Input param of setting panoramic composite group display source
typedef struct tagNET_IN_SET_PANO_COMPOSITE_GROUP_SOURCE
{
    DWORD                               dwSize;                         // Struct size
    char                                szGroupID[32];                  // Panoramic composite group ID
    UINT                                nGroupSourceNum;                // Panoramic composite group number, same as the value of nRow times nColumn in PANO_COMPOSITE_GROUP_INFO, Layout from left to right, top to bottom
    PANO_COMPOSITE_GROUP_SOURCE_INFO    *pstGroupSourceInfo;            //  Panoramic composite group display source info, Resources are requested and released by users, an the size is nGroupSourceNum * sizeof(PANO_COMPOSITE_GROUP_SOURCE_INFO)
} NET_IN_SET_PANO_COMPOSITE_GROUP_SOURCE;

// Output param of setting panoramic composite group display source
typedef struct tagNET_OUT_SET_PANO_COMPOSITE_GROUP_SOURCE
{
    DWORD                               dwSize;                         // Struct size
} NET_OUT_SET_PANO_COMPOSITE_GROUP_SOURCE;

// Input param of getting panoramic composite group display source
typedef struct tagNET_IN_GET_PANO_COMPOSITE_GROUP_SOURCE
{
    DWORD                               dwSize;                         // Struct size
} NET_IN_GET_PANO_COMPOSITE_GROUP_SOURCE;

// List of panoramic composite group display source
typedef struct tagNET_COMPOSITE_GROUP_SOURCE_LIST
{
    char                                szGroupID[32];                  // Panoramic composite group ID
    UINT                                nMaxGroupSrcNum;                // Panoramic composite group display source number, Up to 64 supported
    UINT                                nGroupSourceNum;                // Number of  composite group display source actually returned
    PANO_COMPOSITE_GROUP_SOURCE_INFO    *pstGroupSourceInfo;            // Panoramic composite group display source info
    BYTE                                byReserved[1024];               //Reserved
} NET_COMPOSITE_GROUP_SOURCE_LIST;

// Output param of getting panoramic composite group display source
typedef struct tagNET_OUT_GET_PANO_COMPOSITE_GROUP_SOURCE
{
    DWORD                               dwSize;                         // Struct size
    UINT                                nGroupSourceListNum;            // Panoramic composite group display source number
    NET_COMPOSITE_GROUP_SOURCE_LIST     stuGroupSourceList[16];         // List of panoramic composite group display source info
} NET_OUT_GET_PANO_COMPOSITE_GROUP_SOURCE;

// Operatr type of panoramic composite group
typedef enum tagEM_PANOCOMPOSITE_GROUP_OPERATE_TYPE
{
    EM_PANOCOMPOSITE_GROUP_OPERATE_ADD,                 // Add panoramic composite group,  corresponding NET_IN_ADD_PANO_COMPOSITE_GROUP and NET_OUT_ADD_PANO_COMPOSITE_GROUP
    EM_PANOCOMPOSITE_GROUP_OPERATE_REMOVE,              // Remove panoramic composite group, corresponding NET_IN_REMOVE_PANO_COMPOSITE_GROUP and NET_OUT_REMOVE_PANO_COMPOSITE_GROUP
    EM_PANOCOMPOSITE_GROUP_OPERATE_MODIFY,              // Modify panoramic composite group, corresponding NET_IN_MODIFY_PANO_COMPOSITE_GROUP and NET_OUT_MODIFY_PANO_COMPOSITE_GROUP
    EM_PANOCOMPOSITE_GROUP_OPERATE_GET_ALL,             // Get all panoramic composite groups info, corresponding NET_IN_GET_ALL_PANO_COMPOSITE_GROUP and NET_OUT_GET_ALL_PANO_COMPOSITE_GROUP
    EM_PANOCOMPOSITE_GROUP_OPERATE_SET_SOURCE,          // Set panoramic composite group display source, corresponding NET_IN_SET_PANO_COMPOSITE_GROUP_SOURCE  and NET_OUT_SET_PANO_COMPOSITE_GROUP_SOURCE
    EM_PANOCOMPOSITE_GROUP_OPERATE_GET_SOURCE,          // Get panoramic composite group display source info, corresponding NET_IN_GET_PANO_COMPOSITE_GROUP_SOURCE and NET_OUT_GET_PANO_COMPOSITE_GROUP_SOURCE
} EM_PANOCOMPOSITE_GROUP_OPERATE_TYPE;

// Operate function of panoramic composite group
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperatePanoCompositeGroup(LLONG lLoginID, EM_PANOCOMPOSITE_GROUP_OPERATE_TYPE emOperateType, void* pInParam, void* pOutParam, int nWaitTime);
///////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////Interface of panoramic composite group(end) ////////////////////////////////////////////////
/////////////////////////////////////////////////////// ///////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// Interfaces of LED///////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////

// the control command type of setting LED output
typedef enum tagEM_LED_SET_CMD_TYPE
{
	EM_LED_SET_CMD_DISPLAY_ENABLE,		// switch screen command
	EM_LED_SET_CMD_DISPLAY_LOCK,		// screen lock command
	EM_LED_SET_CMD_DISPLAY_TEST,		// screen test command
} EM_LED_SET_CMD_TYPE;

// the type of LED output screen
typedef enum tagEM_LED_IMAGE_TYPE
{
	EM_LED_IMAGE_UNKNOWN	= -1,	// unknown
	EM_LED_IMAGE_NORMAL,			// normal video
	EM_LED_IMAGE_RED,				// red screen
	EM_LED_IMAGE_GREEN,				// green screen
	EM_LED_IMAGE_BLUE,				// blue screen
	EM_LED_IMAGE_WHITE,				// white screen
	EM_LED_IMAGE_BLACK,				// black screen
	EM_LED_IMAGE_TRANSVERSE,		// transverse stripe
	EM_LED_IMAGE_VERTICAL,			// vertical stripe
	EM_LED_IMAGE_DIAGONAL,			// diagonal stripe
	EM_LED_IMAGE_256GREY,			// 256 grey screen
	EM_LED_IMAGE_AGINGSCREEN,		// aging screen
} EM_LED_IMAGE_TYPE;

// input parameter of interface CLIENT_SetLedDisplayCtrlParams
typedef struct tagNET_IN_LED_SET_DISPLAY_CTRL_PARAMS
{
	DWORD                      	dwSize;             // dwSize needs to assign the size of the struct when using this struct
	int							nChannel;			// channel ID
	EM_LED_SET_CMD_TYPE			emCmdType;			// the control command type of setting LED output
	BOOL						bDisplayEnable;		// switch screen enabled, it is effective when emCmdType is EM_LED_SET_CMD_DISPLAY_ENABLE
	BOOL						bDisplayBlack;		// screen black enabled, it is effective when emCmdType is EM_LED_SET_CMD_DISPLAY_ENABLE
	BOOL						bDisplayLock;		// screen lock enabled, it is effective when emCmdType is EM_LED_SET_CMD_DISPLAY_LOCK
	EM_LED_IMAGE_TYPE			emImageType;		// the type of LED output screen, it is effective when emCmdType is EM_LED_SET_CMD_DISPLAY_TEST
} NET_IN_LED_SET_DISPLAY_CTRL_PARAMS;

// output parameter of interface CLIENT_SetLedDisplayCtrlParams
typedef struct tagNET_OUT_LED_SET_DISPLAY_CTRL_PARAMS
{
	DWORD                      	dwSize;             // dwSize needs to assign the size of the struct when using this struct
} NET_OUT_LED_SET_DISPLAY_CTRL_PARAMS;

// input parameter of interface CLIENT_GetLedDisplayCtrlParams
typedef struct tagNET_IN_LED_GET_DISPLAY_CTRL_PARAMS
{
	DWORD                      	dwSize;             // dwSize needs to assign the size of the struct when using this struct
	int							nChannel;			// channel ID
} NET_IN_LED_GET_DISPLAY_CTRL_PARAMS;

// output parameter of interface CLIENT_GetLedDisplayCtrlParams
typedef struct tagNET_OUT_LED_GET_DISPLAY_CTRL_PARAMS
{
	DWORD                      	dwSize;             // dwSize needs to assign the size of the struct when using this struct
	BOOL						bDisplayEnable;		// switch screen enabled
	BOOL						bDisplayBlack;		// screen black enabled
	BOOL						bDisplayLock;		// screen lock enabled
	EM_LED_IMAGE_TYPE			emImageType;		// the type of LED output screen, it is effective when emCmdType is EM_LED_SET_CMD_DISPLAY_TEST
} NET_OUT_LED_GET_DISPLAY_CTRL_PARAMS;

// set the control parameters of the LED output screen(the resources of pInParam and pOutParam are applied and released by user)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetLedDisplayCtrlParams(LLONG lLoginID, const NET_IN_LED_SET_DISPLAY_CTRL_PARAMS* pInParam, NET_OUT_LED_SET_DISPLAY_CTRL_PARAMS* pOutParam,int nWaitTime);

// get the control parameters of the LED output screen(the resources of pInParam and pOutParam are applied and released by user)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetLedDisplayCtrlParams(LLONG lLoginID, const NET_IN_LED_GET_DISPLAY_CTRL_PARAMS* pInParam, NET_OUT_LED_GET_DISPLAY_CTRL_PARAMS* pOutParam,int nWaitTime);

///////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// Interfaces of guid screen///////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////
#define MAX_PLAYDATES_COUNT		32		// the max count of dates
#define	MAX_SCREENTIME_COUNT	8		// the max count of switch screen time of guid screen
#define MAX_WINDOWS_COUNT		16		// the max count of windows of guid screen
#define MAX_ELEMENTS_COUNT		8		// the max count of elements of windows
#define MAX_ELEMENTTEXT_LENGTH	512		// the max length of text element
#define MAX_NOTE_COUNT			4		// the max count of notes
#define MAX_PROGRAMMES_COUNT	32		// the max count of programes

// the type of screen date
typedef enum tagEM_SCREEN_DATE_TYPE
{
	EM_SCREEN_DATE_UNKNOWN,				// unknown
	EM_SCREEN_DATE_MONTH,				// per month
	EM_SCREEN_DATE_WEEK,				// per week
	EM_SCREEN_DATE_DAY,					// per day
} EM_SCREEN_DATE_TYPE;

// the time info of programme
typedef struct tagNET_PROGRAMME_TIME_INFO
{
	DWORD                dwHour;                  // hour
    DWORD                dwMinute;                // minute
    DWORD                dwSecond;                // second
} NET_PROGRAMME_TIME_INFO;

// the info of switch screen time
typedef struct tagNET_SCREEN_TIME_INFO
{
	BOOL					bEnable;							// is it enable
	EM_SCREEN_DATE_TYPE		emDateType;							// the type of screen date
	UINT					nDateCount;							// the count of screen date
	UINT					nPlayDates[MAX_PLAYDATES_COUNT];	// the data of screen date
	NET_PROGRAMME_TIME_INFO	stuOpenTime;						// the time of open screen
	NET_PROGRAMME_TIME_INFO	stuCloseTime;						// the time of close screen
	BYTE        			byReserved[128];                 	// reserved bytes
} NET_SCREEN_TIME_INFO;

// the rect info of window
typedef struct NET_GUIDESCREEN_WINDOW_RECT_INFO
{
	char				szWindowID[MAX_COMMON_STRING_64];			// window ID
	NET_RECT			stuRect;									// rect info
	UINT				nWindowBright;								// the bright of this window0 means that the bright of this window is same as the bright of the screen
	BYTE        		byReserved[132];                 			// reserved bytes
} NET_GUIDESCREEN_WINDOW_RECT_INFO;

// the status of switch screen
typedef enum tagEM_SCREEN_STATUS_TYPE
{
	EM_SCREEN_STATUS_UNKNOWN,		// unknown
	EM_SCREEN_STATUS_ON,			// on
	EM_SCREEN_STATUS_OFF,			// off
} EM_SCREEN_STATUS_TYPE;

#define MAX_MONTH_COUNT	12    // the count of months of one year

// the sunrise and sunset time of this guide screen
typedef struct tagNET_SUN_RISE_SET_TIME
{
	/*The sunrise and sunset time is 24-hour.  The default value is used when the sunrise and sunset time is 0*/
	UINT					nSunrise;					// sunrise time, default time:6 AM
	UINT					nSunset;					// sunset time, default time:6 PM
	BYTE        			byReserved[32];				// reserved bytes
} NET_SUN_RISE_SET_TIME;

// the auto bright info of this guide screen
typedef struct tagNET_GUIDESCREEN_AUTO_BRIGHT
{
	BOOL					bEnable;							// enable
	UINT					nLightBright;						// the light bright
	UINT					nDarkBright;						// the dark bright
	NET_SUN_RISE_SET_TIME	stuSunTime[MAX_MONTH_COUNT];		// the time of sunrise and sunset
	BYTE        			byReserved[128];					// reserved bytes
} NET_GUIDESCREEN_AUTO_BRIGHT;

// the configure of guid screen
typedef struct tagNET_GUIDESCREEN_ATTRIBUTE_INFO
{
	DWORD           					dwSize;
	char								szScreenID[MAX_COMMON_STRING_64];		// screen ID
	EM_SCREEN_STATUS_TYPE				emStatus;								// the status of switch screen
	BOOL								bIsForeverOpen;							// is forever open
	UINT								nScreenTime;							// count of switch screen time
	NET_SCREEN_TIME_INFO				stuScreenTime[MAX_SCREENTIME_COUNT];	// data of switch screen time
	UINT								nBright;								// bright of guid screen, 1-100 
	UINT								nContrast;								// contrast of guid screen, 1-100
	UINT								nSaturation;							// saturation of guid screen, 1-100
	UINT								nVolume;								// the volume of this screen
	UINT								nWidth;									// width of guid screen
	UINT								nHeight;								// height of guid screen
	UINT								nWindowsCount;							// count of windows
	NET_GUIDESCREEN_WINDOW_RECT_INFO	stuWindows[MAX_WINDOWS_COUNT];			// windows info
	NET_GUIDESCREEN_AUTO_BRIGHT			stuAutoBright;							// the auto bright info of this guide screen
	BYTE        						byReserved[512];						// reserved bytes
} NET_GUIDESCREEN_ATTRIBUTE_INFO;

// input parameter of the interface of setting guid screen config
typedef struct tagNET_IN_SET_GUIDESCREEN_CFG
{
	DWORD           				dwSize;
	UINT							nScreenCount;		// the count of configuration of the guid screen, it's specified by user
	NET_GUIDESCREEN_ATTRIBUTE_INFO	*pstGuideScreenCfg;	// the information of guid screen, it's specified by user,
														// the size is (nScreenCount*NET_GUIDSCREEN_ATTRIBUTE_INFO)
} NET_IN_SET_GUIDESCREEN_CFG;

// output parameter of th interface of setting guid screen config
typedef struct tagNET_OUT_SET_GUIDESCREEN_CFG
{
	DWORD           				dwSize;
} NET_OUT_SET_GUIDESCREEN_CFG;

/**************************************************************************************
*   Funcname: CLIENT_SetGuideScreenCfg
*   Purpose: interface of setting guid screen config
*   InputParam:	LLONG							:lLoginID		// login handle
*   InputParam:	NET_IN_SET_GUIDESCREEN_CFG*		:pInParam 		// input parameter
*   OutParam:	NET_OUT_SET_GUIDESCREEN_CFG*	:pstOutPqram	// output parameter
*   InputParam:	int								:nWaitTime		// wait time
*   Return:		BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetGuideScreenCfg(LLONG lLoginID, const NET_IN_SET_GUIDESCREEN_CFG* pInParam, NET_OUT_SET_GUIDESCREEN_CFG *pstOutPqram, const int nWaitTime);


// the input parameter of the interface of getting guid screen config by ID
typedef struct tagNET_IN_GET_GUIDESCREEN_CFG_BYID
{
	DWORD           				dwSize;
	char							szScreenID[MAX_COMMON_STRING_64];		// screen ID
} NET_IN_GET_GUIDESCREEN_CFG_BYID;

// the output parameter of the interface of getting guid screen config by ID
typedef struct tagNET_OUT_GET_GUIDESCREEN_CFG_BYID
{
	DWORD           				dwSize;
	NET_GUIDESCREEN_ATTRIBUTE_INFO	stuGuideScreenCfg;			// the config of guid screen
} NET_OUT_GET_GUIDESCREEN_CFG_BYID;

/**************************************************************************************
*   Funcname: CLIENT_GetOneGuideScreenCfgById
*   Purpose: interface of getting guid screen config by ID
*   InputParam:	LLONG								:lLoginID	// login handle
*   InputParam:	NET_IN_GET_GUIDESCREEN_CFG_BYID*	:pInParam	// input parameter
*   OutPutParam:NET_OUT_GET_GUIDESCREEN_CFG_BYID*	:pOutParam 	// output parameter
*   InputParam:	int									:nWaitTime	// wait time
*   Return:		BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetOneGuideScreenCfgById(
										LLONG lLoginID, const NET_IN_GET_GUIDESCREEN_CFG_BYID *pInParam, 
										NET_OUT_GET_GUIDESCREEN_CFG_BYID* pOutParam, const int nWaitTime);



// the input parameter of the interface of getting config of all guid screen
typedef struct tagNET_IN_GET_ALL_GUIDESCREEN_CFG
{
	DWORD           				dwSize;
} NET_IN_GET_ALL_GUIDESCREEN_CFG;

// the output parameter of the interface of getting config of all guid screen
typedef struct tagNET_OUT_GET_ALL_GUIDESCREEN_CFG
{
	DWORD           				dwSize;
	UINT							nMaxScreen;					// max counts of guis screen, it's specified by user
	UINT							nRetScreen;					// the conut of guid screen actual return
	NET_GUIDESCREEN_ATTRIBUTE_INFO	*pstGuideScreenCfg;			// the config of all guid screen,  applyed by user
																// the size if (nMaxScreen *NET_GUIDSCREEN_ATTRIBUTE_INFO)
} NET_OUT_GET_ALL_GUIDESCREEN_CFG;

/**************************************************************************************
*   Funcname: CLIENT_GetAllGuideScreenCfg
*   Purpose: interface of getting config of all guid screen
*   InputParam:	LLONG								:lLoginID	// login handle
*   InputParam:	NET_IN_GET_ALL_GUIDESCREEN_CFG*		:pInParam	// input parameter
*   OutPutParam:NET_OUT_GET_ALL_GUIDESCREEN_CFG*	:pOutParam 	// output parameter
*   InputParam:	int									:nWaitTime	// wait time
*   Return:		BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetAllGuideScreenCfg(
										LLONG lLoginID, const NET_IN_GET_ALL_GUIDESCREEN_CFG *pInParam, 
										NET_OUT_GET_ALL_GUIDESCREEN_CFG* pOutParam, const int nWaitTime);

// the type of horizontal alignment
typedef enum tagEM_HORI_ALIGN_TYPE
{
	EM_HORI_ALIGN_UNKNOWN,				// unknown
	EM_HORI_ALIGN_LEFT,					// left
	EM_HORI_ALIGN_CENTER,				// center
	EM_HORI_ALIGN_RIGHT,				// right
} EM_HORI_ALIGN_TYPE;

// the type of vertical alignment
typedef enum tagEM_VERT_ALIGN_TYPE
{
	EM_VERT_ALIGN_UNKNOWN,				// unknown
	EM_VERT_ALIGN_UP,					// up
	EM_VERT_ALIGN_CENTER,				// center
	EM_VERT_ALIGN_DOWN,					// down
} EM_VERT_ALIGN_TYPE;

// enter(exit) style
typedef enum tagEM_PIC_STYLE_TYPE
{
	EM_PIC_STYLE_UNKNOWN,		// unknown
	EM_PIC_STYLE_DEFAULT,		// default
	EM_PIC_STYLE_UP,			// up
	EM_PIC_STYLE_DOWN,			// down
	EM_PIC_STYLE_LEFT,			// left
	EM_PIC_STYLE_RIGHT,			// right
} EM_PIC_STYLE_TYPE;


//  text info
typedef struct tagNET_GUIDESCREEN_TEXT_INFO
{
	char					szContent[MAX_ELEMENTTEXT_LENGTH];		// content
	UINT					nFontSize;								// font size
	NET_COLOR_RGBA			stuFontColor;							// font color
	char					szFontStyle[MAX_COMMON_STRING_32];		// font style
	double					dbLineHeight;							// height of line
	EM_HORI_ALIGN_TYPE		emHoriAlign;							// the type of horizontal alignment
	EM_VERT_ALIGN_TYPE		emVertAlign;							// the type of vertical alignment	
	UINT					nPlayTime;								// play time, unit:second
	UINT					nPlayCount;								// play count
	UINT					nStayTime;								// stay time, (the interval of enter or exit), unit:s
	EM_PIC_STYLE_TYPE		emEnterStyle;							// enter style
	EM_PIC_STYLE_TYPE		emExitStyle;							// exit style
	BYTE        			byReserved[128];                 		//  reserved bytes
} NET_GUIDESCREEN_TEXT_INFO;

// the note info of element
typedef struct tagNET_GUIDESCREEN_NOTE_INFO
{
	BOOL						bEnable;			// is it enable
	NET_GUIDESCREEN_TEXT_INFO	stuTextInfo;		// the text info
	NET_RECT					stuRect;			// rect info
	BYTE        				byReserved[128];    // reserved bytes
} NET_GUIDESCREEN_NOTE_INFO;

// the info of video element
typedef struct tagNET_VIDEO_ELEMENT_INFO
{
	char 						szName[MAX_COMMON_STRING_64];			// element name
	BOOL						bFillerState;							// the filler state:If there is no elemetent to play between the two elements, and if the filler is set, then the filler is played.
	char						szPath[MAX_COMMON_STRING_128];			// the address of video file
	UINT						nPlayCount;								// play count
	UINT						nNote;									// the count notes
	NET_GUIDESCREEN_NOTE_INFO	stuNoteInfo[MAX_NOTE_COUNT];			// the notes of element
	BYTE        				byReserved[128];                 		// reserved bytes
} NET_VIDEO_ELEMENT_INFO;

// the info of picture element
typedef struct tagNET_PICTURE_ELEMENT_INFO
{
	char 						szName[MAX_COMMON_STRING_64];			// element name
	BOOL						bFillerState;							// the filler state:If there is no elemetent to play between the two elements, and if the filler is set, then the filler is played.
	char						szPath[MAX_COMMON_STRING_128];			// the address of picture file
	UINT						nPlayTime;								// play time, unit:s
	UINT						nPlayCount;								// play count
	UINT						nDiaphaneity;							// Diaphaneity, 0-100
	UINT						nStayTime;								// stay time, unit:s
	EM_PIC_STYLE_TYPE			emEnterStyle;							// enter style
	EM_PIC_STYLE_TYPE			emExitStyle;							// exit style
	UINT						nNote;									// the count of notes
	NET_GUIDESCREEN_NOTE_INFO	stuNoteInfo[MAX_NOTE_COUNT];			// the notes of element
	BYTE        				byReserved[128];                 		// reserved bytes
} NET_PICTURE_ELEMENT_INFO;

// the info of text element
typedef struct tagNET_TEXT_ELEMENT_INFO
{
	char 						szName[MAX_COMMON_STRING_64];			// element name
	BOOL						bFillerState;							// the filler state:If there is no elemetent to play between the two elements, and if the filler is set, then the filler is played.
	NET_GUIDESCREEN_TEXT_INFO	stuElementsText;						// text info
	UINT						nNote;									// the count of notes
	NET_GUIDESCREEN_NOTE_INFO	stuNoteInfo[MAX_NOTE_COUNT];			// the notes of element
	BYTE        				byReserved[128];                 		// reserved bytes
} NET_TEXT_ELEMENT_INFO;

// the info of place holder element
typedef struct tagNET_PLACEHOLDER_ELEMENT_INFO
{
	char 						szName[MAX_COMMON_STRING_64];			// element name
	BOOL						bFillerState;							// the filler state:If there is no elemetent to play between the two elements, and if the filler is set, then the filler is played.
	UINT						nNote;									// the count of notes
	NET_GUIDESCREEN_NOTE_INFO	stuNoteInfo[MAX_NOTE_COUNT];			// the notes of element
	BYTE        				byReserved[128];                 		// reserved bytes
} NET_PLACEHOLDER_ELEMENT_INFO;

// capture type
typedef enum tagEM_CAPTURE_TYPE
{
	EM_CAPTURE_UNKNOWN,			// unknown
	EM_CAPTURE_VIDEO,			// video
	EM_CAPTURE_PICTURE,			// picture
} EM_CAPTURE_TYPE;

// osd info
typedef struct tagNET_CAPTURE_OSD_INFO
{
    BOOL                        bEnable;                                // enable
	NET_COLOR_RGBA		        stuFontColor;					        // font color
	NET_COLOR_RGBA		        stuBackGroundColor;					    // bcak ground color
	UINT                        nFontSize;                              // font size
	char                        szContent[MAX_COMMON_STRING_512];       // OSD content
	BYTE        				byReserved[1024];						// reserved bytes
} NET_CAPTURE_OSD_INFO;

// the info of place capture element
typedef struct tagNET_CAPTURE_ELEMENT_INFO
{
	
	char 						szName[MAX_COMMON_STRING_64];			// element name
	BOOL						bFillerState;							// the filler state:If there is no elemetent to play between the two elements, and if the filler is set, then the filler is played.
	char						szUserName[DH_USER_NAME_LEN_EX];		// user name
	char						szPassWord[DH_USER_PSW_LEN_EX];			// password
	char						szIP[DH_MAX_IPADDR_LEN_EX];				// IP address
	UINT						nPort;									// port 
	UINT						nChannel;								// channel
	EM_CAPTURE_TYPE				emCaptureType;							// capture type
	UINT						nPlayTime;								// play time, unit:s
	UINT						nNote;									// the count of notes
	NET_GUIDESCREEN_NOTE_INFO	stuNoteInfo[MAX_NOTE_COUNT];			// the notes of element
	NET_CAPTURE_OSD_INFO        *pstOsdInfo;                            // OSD overlay information, whose memory is requested and released by user. If it is NULL, OSD information will not be sent or acquired.
	BYTE        				byReserved[124];                 		// reserved bytes
} NET_CAPTURE_ELEMENT_INFO;

// the info of PDF element
typedef struct tagNET_PDF_ELEMENT_INFO
{
    char 						szName[MAX_COMMON_STRING_64];			// element name
	BOOL						bFillerState;							// the filler state:If there is no elemetent to play between the two elements, and if the filler is set, then the filler is played.
	char                        szPdfPath[MAX_COMMON_STRING_128];       // the path of PDF file
	UINT                        nPlayTime;                              // play time, unit:s
	UINT                        nPlayCount;                             // play count
	UINT                        nStayTime;                              // stay time, unit:s
	EM_PIC_STYLE_TYPE			emEnterStyle;							// enter style
	EM_PIC_STYLE_TYPE			emExitStyle;							// exit style
	UINT						nTextNote;								// the count of text notes
	NET_GUIDESCREEN_NOTE_INFO	stuNoteInfo[MAX_NOTE_COUNT];			// the text notes of element
	BYTE        				byReserved[1024];						// reserved bytes
} NET_PDF_ELEMENT_INFO;

// the info of audio element
typedef struct tagNET_AUDIO_ELEMENT_INFO
{
    char 						szName[MAX_COMMON_STRING_64];			// element name
	BOOL						bFillerState;							// the filler state:If there is no elemetent to play between the two elements, and if the filler is set, then the filler is played.
	char                        szAudioPath[MAX_COMMON_STRING_128];     // the path of audio file
	UINT                        nPlayCount;                             // play count
	UINT						nTextNote;								// the count of text notes
	NET_GUIDESCREEN_NOTE_INFO	stuNoteInfo[MAX_NOTE_COUNT];			// the yext notes of element
	BYTE        				byReserved[1024];						// reserved bytes
} NET_AUDIO_ELEMENT_INFO;

// the type of elemetns
typedef enum tagEM_ELEMENTS_TYPE
{
	EM_ELEMENTS_UNKNOWN,			// unknown
	EM_ELEMENTS_VIDEO,				// video element, corresponding to  NET_ELEMENTS_VIDEO_INFO
	EM_ELEMENTS_PICTURE,			// picture element, corresponding to NET_ELEMENTS_PICTURE_INFO
	EM_ELEMENTS_TEXT,				// text element, corresponding to NET_ELEMENTS_TEXT_INFO
	EM_ELEMENTS_PLACEHOLDER,		// place holder element, corresponding to NET_ELEMENTS_PLACEHOLDER_INFO
	EM_ELEMENTS_CAPTURE,			// capture element, corresponding to NET_ELEMENTS_CAPTURE_INFO
    EM_ELEMENTS_PDF,                // PDF element, corresponding to NET_PDF_ELEMENT_INFO
	EM_ELEMENTS_AUDIO,              // audio element, corresponding to NET_AUDIO_ELEMENT_INFO
} EM_ELEMENTS_TYPE;

//the type of tour period
typedef enum tagEM_TOURPERIOD_TYPE
{
	EM_TOURPERIOD_UNKNOWN,		// unknown
	EM_TOURPERIOD_PROGRAMME,	// programme
	EM_TOURPERIOD_PLAN,			// programme plan
	EM_TOURPERIOD_CUSTOM,		// custom
} EM_TOURPERIOD_TYPE;

// the common info of the elements
typedef struct tagNET_ELEMENT_COMMON_INFO
{
	EM_ELEMENTS_TYPE	emElementsType;								// the type of the element
	BYTE        		byReserved[128];							// reserved bytes
} NET_ELEMENT_COMMON_INFO;

// windows info
typedef struct tagNET_GUIDESCREEN_WINDOW_INFO
{
	char				szWindowID[MAX_COMMON_STRING_64];			// windows ID
	int					nVolume;									// the volume of the window, the percentage of the screen volume
	NET_COLOR_RGBA		stuColor;									// background color
	UINT				nDiaphaneity;								// the diaphaneity of background(0-100)
	EM_TOURPERIOD_TYPE	emTourPeriodType;							// the type of tour period
	UINT				nTourPeriodTime;							// custom tour period time(unit:s)it's effective when emTourPeriodType is EM_TOURPERIOD_CUSTOM
	BOOL				bAutoPlay;									// is it auto play(it's effective when the element is video)
	BOOL				bLoopPlay;									// is it loop play(it's effective when the element is video)
	UINT				nElementsCount;								// the count of elements
	char*				pstElementsBuf;								// the buf of elements, the struct data according to the elements type
																	// fill in multiple elements info, the info of each element is NET_ELEMENT_COMMON_INFO and it's struct
	UINT				nBufLen;									// the size of this buf
	BYTE        		byReserved[128];                 			// reserved bytes															
} NET_GUIDESCREEN_WINDOW_INFO;

// the ordinary programme info 
typedef struct tagNET_ORDINARY_INFO
{
	BOOL						bTempletState;							// is it templet
	char						szDescription[MAX_COMMON_STRING_128];	// the description of this programme
	UINT						nWhnCount;								// the count of windows
	NET_GUIDESCREEN_WINDOW_INFO	stuWindowsInfo[MAX_WINDOWS_COUNT];		// the info of windows
	BYTE        				byReserved[128];                 		// reserved bytes
} NET_ORDINARY_INFO;

// the programme info of the guid screen
typedef struct tagNET_PROGRAMME_INFO
{
	char						szProgrammeName[MAX_COMMON_STRING_64];	// programme name
	char						szProgrammeID[MAX_COMMON_STRING_64];	// programme ID, when adding a program, it does not need to be filled and generated by the device
	BOOL						bEnable;								// is it enable	
	NET_ORDINARY_INFO			stuOrdinaryInfo;						// the ordinary programme info
	BYTE        				byReserved[512];                 		// reserved bytes
} NET_PROGRAMME_INFO;

// input paramer of the interface of getting programme info by ID
typedef struct tagNET_IN_GET_PROGRAMME_BYID
{
	DWORD           			dwSize;
	char						szProgrammeID[MAX_COMMON_STRING_64];	// programme ID
} NET_IN_GET_PROGRAMME_BYID;

// output paramer of the interface of getting programme info by ID
typedef struct tagNET_OUT_GET_PROGRAMME_BYID
{
	DWORD           			dwSize;
	NET_PROGRAMME_INFO			stuProgrammeInfo;			// programme info
} NET_OUT_GET_PROGRAMME_BYID;

/**************************************************************************************
*   Funcname: CLIENT_GetOneProgrammeById
*   Purpose: interface of getting programme info by ID
*   InputParam:	LLONG							:lLoginID	// login handle
*   InputParam:	NET_IN_GET_PROGRAMME_BYID*		:pInParam	// input parameter
*   OutPutParam:NET_OUT_GET_PROGRAMME_BYID*		:pOutParam 	// output parameter
*   InputParam:	int								:nWaitTime	// wait time
*   Return:		BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetOneProgrammeById(LLONG lLoginID, const NET_IN_GET_PROGRAMME_BYID *pInParam, NET_OUT_GET_PROGRAMME_BYID *pOutParam, const int nWaitTime);


// input parameter of the interface of getting all programmes
typedef struct tagNET_IN_GET_ALL_PROGRAMMES
{
	DWORD           			dwSize;
} NET_IN_GET_ALL_PROGRAMMES;

// output parameter of the interface of getting all programmes
typedef struct tagNET_OUT_GET_ALL_PROGRAMMES
{
	DWORD           			dwSize;
	UINT						nMaxCnt;					// the max count of pstProgrammeInfo
	UINT						nRetCnt;					// the count of pstProgrammeInfo actual return
	NET_PROGRAMME_INFO			*pstProgrammeInfo;			// th programmes info, this memory is applyed and released by user
} NET_OUT_GET_ALL_PROGRAMMES;

/**************************************************************************************
*   Funcname: CLIENT_GetAllProgrammes
*   Purpose: interface of getting all programmes
*   InputParam:	LLONG							:lLoginID		// login handle
*   InputParam:	NET_IN_GET_ALL_PROGRAMMES*		:pInParam		// input parameter
*   OutPutParam:NET_OUT_GET_ALL_PROGRAMMES*		:pOutParam 		// output parameter
*   InputParam:	int								:nWaitTime		// wait time
*   Return:		BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetAllProgrammes(
												LLONG lLoginID, const NET_IN_GET_ALL_PROGRAMMES* pInParam, 
												NET_OUT_GET_ALL_PROGRAMMES* pOutParam, const int nWaitTime);

// the type of briefly programme
typedef enum tagEM_BRIEFLYPROGRAM_TYPE
{
	EM_BRIEFLYPROGRAM_UNKNOWN,		// unknown
	EM_BRIEFLYPROGRAM_BAR,			// bar
	EM_BRIEFLYPROGRAM_ORDINARY,		// ordinary programme
}EM_BRIEFLYPROGRAM_TYPE;

// briefly info of programme
typedef struct tagNET_BRIEFLY_PROGRAMME_INFO
{
	char					szProgrammeName[MAX_COMMON_STRING_64];	// programme name
	char					szProgrammeID[MAX_COMMON_STRING_64];	// programme ID
	EM_BRIEFLYPROGRAM_TYPE	emProgrammeType;						// the type of briefly programme
	BOOL					bEnable;								// is it enable
	BOOL					bTempletState;							// is it templetState
	BYTE        			byReserved[512];                 		// reserved bytes	
} NET_BRIEFLY_PROGRAMME_INFO;

// input parameter of  the interface of getting all briefly programmes 
typedef struct tagNET_IN_GET_ALL_BRIEFLYPROGRAMMES
{
	DWORD           				dwSize;
} NET_IN_GET_ALL_BRIEFLYPROGRAMMES;

// output parameter of  the interface of getting all briefly programmes 
typedef struct tagNET_OUT_GET_ALL_BRIEFLYPROGRAMMES
{
	DWORD           				dwSize;
	UINT							nRetCnt;									// th count actual return
	NET_BRIEFLY_PROGRAMME_INFO		stuBriProgrammes[MAX_PROGRAMMES_COUNT];		// briefly info of programme
} NET_OUT_GET_ALL_BRIEFLYPROGRAMMES;


/**************************************************************************************
*   Funcname: CLIENT_GetAllBrieflyProgrammes
*   Purpose: interface of getting all briefly programmes 
*   InputParam:	LLONG									:lLoginID		// login handle
*   InputParam:	NET_IN_GET_ALL_BRIEFLYPROGRAMMES*		:pInParam		// input parameter
*   OutPutParam:NET_OUT_GET_ALL_BRIEFLYPROGRAMMES*		:pOutParam 		// output parameter
*   InputParam:	int										:nWaitTime		// wait time
*   Return:		BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetAllBrieflyProgrammes(
												LLONG lLoginID, const NET_IN_GET_ALL_BRIEFLYPROGRAMMES* pInParam, 
												NET_OUT_GET_ALL_BRIEFLYPROGRAMMES* pOutParam, const int nWaitTime);


// input parameter of the interface of adding a programme
typedef struct tagNET_IN_ADD_ONE_PROGRAMME
{
	DWORD           			dwSize;
	NET_PROGRAMME_INFO			stuProgrammeInfo;	// programme info
} NET_IN_ADD_ONE_PROGRAMME;


// output parameter  of the interface of adding a programme
typedef struct tagNET_OUT_ADD_ONE_PROGRAMME
{
	DWORD           			dwSize;
	char						szProgrammeID[MAX_COMMON_STRING_64];	// programme ID
} NET_OUT_ADD_ONE_PROGRAMME;

/**************************************************************************************
*   Funcname: CLIENT_AddOneProgramme
*   Purpose: interface of adding a programme
*   InputParam:	LLONG						:lLoginID		// login handle
*   InputParam:	NET_IN_ADD_ONE_PROGRAMME*	:pInParam 		// input parameter
*   OutPutParam:NET_OUT_ADD_ONE_PROGRAMME* 	:pOutParam		// output parameter
*   InputParam:	int							:nWaitTime		// wait time
*   Return:		BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddOneProgramme(LLONG lLoginID, const NET_IN_ADD_ONE_PROGRAMME* pInParam, NET_OUT_ADD_ONE_PROGRAMME *pOutParam, const int nWaitTime);


// input parameter of the interface of modify a programme
typedef struct tagNET_IN_MODIFY_ONE_PROGRAMME
{
	DWORD           			dwSize;
	NET_PROGRAMME_INFO			stuProgrammeInfo;	// programme info
} NET_IN_MODIFY_ONE_PROGRAMME;


// output parameter of the interface of modify a programme
typedef struct tagNET_OUT_MODIFY_ONE_PROGRAMME
{
	DWORD           			dwSize;
} NET_OUT_MODIFY_ONE_PROGRAMME;

/**************************************************************************************
*   Funcname: CLIENT_ModifyOneProgrammeByID
*   Purpose: interface of modify a programme
*   InputParam:	LLONG							:lLoginID		// login handle
*   InputParam:	NET_IN_MODIFY_ONE_PROGRAMME*	:pInParam 		// input parameter
*   OutputParam:NET_OUT_MODIFY_ONE_PROGRAMME*	:pOutParam 		// output parameter
*   InputParam:	int								:nWaitTime		// wait time
*   Return:		BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ModifyOneProgrammeByID(LLONG lLoginID, const NET_IN_MODIFY_ONE_PROGRAMME* pInParam, NET_OUT_MODIFY_ONE_PROGRAMME* pOutParam, const int nWaitTime);


// input parameter of the interface of delete some programmes
typedef struct tagNET_IN_DEL_PROGRAMMES
{
	DWORD           dwSize;
	UINT			nProgrammeID;													// the count of programmes which are need to delete
	char			szProGrammeIdList[MAX_PROGRAMMES_COUNT][MAX_COMMON_STRING_64];	// the IDs of these programmes which are need to delete, "all" means delete all programmes
} NET_IN_DEL_PROGRAMMES;

// output parameter of the interface of delete some programmes
typedef struct tagNET_OUT_DEL_PROGRAMMES
{
	DWORD           dwSize;
} NET_OUT_DEL_PROGRAMMES;

/**************************************************************************************
*   Funcname: CLIENT_DelMultiProgrammesById
*   Purpose: interface of delete some programmes
*   InputParam:	LLONG						:lLoginID	// login handle
*   InputParam:	NET_IN_DEL_PROGRAMMES*		:pInParam 	// input parameter
*   InputParam:	NET_OUT_DEL_PROGRAMMES*		:pOutParam 	// output parameter
*   InputParam:	int							:nWaitTime	// wait time
*   Return:		BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DelMultiProgrammesById(
											LLONG lLoginID, const NET_IN_DEL_PROGRAMMES* pInParam, 
											NET_OUT_DEL_PROGRAMMES *pOutParam, const int nWaitTime);

// the infos of immediately programme plan
typedef struct tagNET_IMMEDIATELY_PLAN_INFO
{
	char			szPlanName[MAX_COMMON_STRING_64];			// programme plan name
	char			szPlanID[MAX_COMMON_STRING_64];				// programme plan ID, when adding a program plan, it does not need to be filled and generated by the device
	char			szSplitScreenID[MAX_COMMON_STRING_64];		// split screen ID
	BOOL			bEnable;									// is it enable
	UINT			nPlayTime;									// play time, unit:minute
	char			szProgrammeName[MAX_COMMON_STRING_64];		// programme name
	char			szProgrammeID[MAX_COMMON_STRING_64];		// programme ID
	BYTE        	byReserved[512];                 			// reserved bytes
} NET_IMMEDIATELY_PLAN_INFO;

// the data struct of programme
typedef struct tagNET_PROGRAMME_DATA
{
	DWORD                dwYear;                  // year
    DWORD                dwMonth;                 // month
    DWORD                dwDay;                	  // day
} NET_PROGRAMME_DATA;

// state of review
typedef enum tagEM_REVIES_STATE
{
	EM_REVIES_UNKNOWN,			// unknown
	EM_REVIES_PASS,				// pass 
	EM_REVIES_NOTPASS,			// not pass
} EM_REVIES_STATE;

// the info of programme in plan
typedef struct tagNET_PROGRAMME_OF_PLAN
{
	char						szProgrammeName[MAX_COMMON_STRING_64];	// programme name
	char						szProgrammeID[MAX_COMMON_STRING_64];	// programme ID
	BOOL						bIsBgProgramme;							// is it background
	NET_PROGRAMME_TIME_INFO		stuSatrtTime;							// start time
	NET_PROGRAMME_TIME_INFO		stuEndTime;								// end time
	BYTE        				byReserved[128];                 		// reserved bytes
} NET_PROGRAMME_OF_PLAN;

// the data type of timer plan
typedef enum tagEM_TIMERPLAN_DATE_TYPE
{
	EM_TIMERPLAN_DATE_UNKNOWN,				// unknown
	EM_TIMERPLAN_DATE_MONTH,				// per month
	EM_TIMERPLAN_DATE_WEEK,				    // per week
	EM_TIMERPLAN_DATE_DAY,					// per day
	EM_TIMERPLAN_DATE_CUSTOM,				// per day
} EM_TIMERPLAN_DATE_TYPE;

// the infos of timer programme plan
typedef struct tagNET_TIMER_PLAN_INFO
{
	char					szPlanName[MAX_COMMON_STRING_64];			// programme plan name
	char					szPlanID[MAX_COMMON_STRING_64];				// programme plan ID
	char					szSplitScreenID[MAX_COMMON_STRING_64];		// split screen ID
	EM_TIMERPLAN_DATE_TYPE	emDataType;									// the type of data
	UINT					nDataCount;									// the count of data
	UINT					nPlayDates[MAX_PLAYDATES_COUNT];			// the list of data
	NET_PROGRAMME_DATA		stuSatrtDate;								// start time
	NET_PROGRAMME_DATA		stuEndDate;									// end time
	EM_REVIES_STATE			emReviewState;								// state of review
	char					szReviewOpinion[MAX_COMMON_STRING_64];		// the options of review
	BOOL					bOverdue;									// is it overdue
	UINT					nProgrammes;								// the count of programmes
	NET_PROGRAMME_OF_PLAN	stuProgrammes[MAX_PROGRAMMES_COUNT];		// the list of programmes
	BYTE        			byReserved[512];                 			// resverd bytes
} NET_TIMER_PLAN_INFO;

// input parameter of the interface of getting all programme plans
typedef struct tagNET_IN_GET_ALL_PROGRAMMEPLANS
{
	DWORD           			dwSize;
} NET_IN_GET_ALL_PROGRAMMEPLANS;

// output parameter of the interface of getting all programme plans
typedef struct tagNET_OUT_GET_ALL_PROGRAMMEPLANS
{
	DWORD           			dwSize;
	UINT						nMaxPlanCnt;			// the max count of immediately programmes and timer programmes
	UINT						nRetImmCnt;				// the count of immediately programmes actual return
	NET_IMMEDIATELY_PLAN_INFO*	pstImmePlan;			// the info of immediately programmes
	UINT						nRetTimerCnt;			// the count of timer programmes actual return
	NET_TIMER_PLAN_INFO*		pstTimerPlan;			// the info of timer programmes
} NET_OUT_GET_ALL_PROGRAMMEPLANS;

/**************************************************************************************
*   Funcname: CLIENT_GetAllProgrammePlans
*   Purpose: interface of getting all programme plans
*   InputParam:	LLONG								:lLoginID		// login handle 
*   InputParam:	NET_IN_GET_ALL_PROGRAMMEPLANS*		:pInParam		// input parameter
*   OutPutParam:NET_OUT_GET_ALL_PROGRAMMEPLANS*		:pOutParam  	// output parameter
*   InputParam:	int									:nWaitTime		// wait time
*   Return:		BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetAllProgrammePlans(
											LLONG lLoginID, const NET_IN_GET_ALL_PROGRAMMEPLANS *pInParam,
											NET_OUT_GET_ALL_PROGRAMMEPLANS *pOutParam, const int nWaitTime);


// the type of programme plan
typedef enum tagEM_PROGRAMMEPLAN_TYPE
{
	EM_PROGRAMMEPLAN_UNKNOWN,		// unknown
	EM_PROGRAMMEPLAN_IMME,			// immediately plan
	EM_PROGRAMMEPLAN_TIMER,			// timer plan
} EM_PROGRAMMEPLAN_TYPE;

// input parameter of the interface of getting programme plan by ID
typedef struct tagNET_IN_GET_PROGRAMMEPLAN_BYID
{
	DWORD           			dwSize;
	char						szPlanID[MAX_COMMON_STRING_64];		// programme planID
} NET_IN_GET_PROGRAMMEPLAN_BYID;

// output parameter of the interface of getting programme plan by ID
typedef struct tagNET_OUT_GET_PROGRAMMEPLAN_BYID
{
	DWORD           			dwSize;
	EM_PROGRAMMEPLAN_TYPE		emPlanType;		// the type of programme plan
	NET_IMMEDIATELY_PLAN_INFO	stuImmePlan;	// the info of immediately programme, it's effective when emPlanType is EM_PROGRAMMEPLAN_IMME
	NET_TIMER_PLAN_INFO			stuTimerPlan;	// the info of timer programme,  it's effective when emPlanType is EM_PROGRAMMEPLAN_TIMER
} NET_OUT_GET_PROGRAMMEPLAN_BYID;

/**************************************************************************************
*   Funcname: CLIENT_GetOneProgrammePlanByID
*   Purpose: interface of getting programme plan by ID
*   InputParam:	LLONG								:lLoginID	// login handle
*   InputParam:	NET_IN_GET_PROGRAMMEPLAN_BYID*		:pInParam	// input parameter
*   OutPutParam:NET_OUT_GET_PROGRAMMEPLAN_BYID*		:pOutParam  // output parameter
*   InputParam:	int									:nWaitTime	// wait time
*   Return:		BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetOneProgrammePlanByID(
										LLONG lLoginID,  NET_IN_GET_PROGRAMMEPLAN_BYID *pInParam,
										NET_OUT_GET_PROGRAMMEPLAN_BYID* pOutParam, const int nWaitTime);

// input parameter of the interface of adding a  immediately programme plan
typedef struct tagNET_IN_ADD_IMME_PROGRAMMEPLAN
{
	DWORD           			dwSize;
	NET_IMMEDIATELY_PLAN_INFO	stuImmePlan;		// the info of immediately programme
} NET_IN_ADD_IMME_PROGRAMMEPLAN;

// input parameter of the interface of adding a  timer programme plan
typedef struct tagNET_IN_ADD_TIMER_PROGRAMMEPLAN
{
	DWORD           			dwSize;
	NET_TIMER_PLAN_INFO			stuTimerPlan;		// the info of timer programme
} NET_IN_ADD_TIMER_PROGRAMMEPLAN;

// output parameter of the interface of adding a programme plan
typedef struct tagNET_OUT_ADD_PROGRAMMEPLAN
{
	DWORD           		dwSize;
	char					szPlanID[MAX_COMMON_STRING_64];				// programme plan ID
} NET_OUT_ADD_PROGRAMMEPLAN;

/**************************************************************************************
*   Funcname: CLIENT_AddOneImmediProgrammePlan
*   Purpose: interface of adding a  immediately programme plan
*   InputParam:	LLONG							:lLoginID		// login handle
*   InputParam:	NET_IN_ADD_IMME_PROGRAMMEPLAN*	:pInParam  		// input parameter
*   OutPutParam:NET_OUT_ADD_PROGRAMMEPLAN*		:pstOutParam  	// output parameter
*   InputParam:	int								:nWaitTime		// wait time
*   Return:		BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddOneImmediProgrammePlan(
										LLONG lLoginID,  const NET_IN_ADD_IMME_PROGRAMMEPLAN* pInParam, 
										NET_OUT_ADD_PROGRAMMEPLAN* pOutParam, const int nWaitTime);


/**************************************************************************************
*   Funcname: CLIENT_AddOneTimerProgrammePlan
*   Purpose: interface of adding a  timer programme plan
*   InputParam:	LLONG								:lLoginID		// login handle
*   InputParam:	NET_IN_ADD_TIMER_PROGRAMMEPLAN*		:pInParam		// input parameter
*   OutPutParam:NET_OUT_ADD_PROGRAMMEPLAN*			:pOutParam  	// output parameter
*   InputParam:	int									:nWaitTime		// wait time
*   Return:		BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddOneTimerProgrammePlan(
										LLONG lLoginID,  const NET_IN_ADD_TIMER_PROGRAMMEPLAN* pInParam, 
										NET_OUT_ADD_PROGRAMMEPLAN* pOutParam, const int nWaitTime);

// input parameter of the interface of modify a  immediately programme plan
typedef struct tagNET_IN_MODIFY_IMME_PROGRAMMEPLAN
{
	DWORD           			dwSize;
	NET_IMMEDIATELY_PLAN_INFO	stuImmePlan;		// the info of immediately programme
} NET_IN_MODIFY_IMME_PROGRAMMEPLAN;

// output parameter of the interface of modify a  immediately programme plan
typedef struct tagNET_OUT_MODIFY_IMME_PROGRAMMEPLAN
{
	DWORD           			dwSize;
} NET_OUT_MODIFY_IMME_PROGRAMMEPLAN;


/**************************************************************************************
*   Funcname: CLIENT_ModifyOneImmediProgrammePlan
*   Purpose: interface of modify a  immediately programme plan
*   InputParam:	LLONG									:lLoginID	// login handle
*   InputParam:	NET_IN_MODIFY_IMME_PROGRAMMEPLAN*		:pInParam  	// input parameter
*   OutPutParam:NET_OUT_MODIFY_IMME_PROGRAMMEPLAN*		:pOutParam  // output parameter
*   InputParam:	int										:nWaitTime	// wait time
*   Return:		BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ModifyOneImmediProgrammePlan(
										LLONG lLoginID,  const NET_IN_MODIFY_IMME_PROGRAMMEPLAN* pInParam,
										NET_OUT_MODIFY_IMME_PROGRAMMEPLAN* pOutParam, const int nWaitTime);


// input parameter of the interface of modify a  timer programme plan
typedef struct tagNET_IN_MODIFY_TIMER_PROGRAMMEPLAN
{
	DWORD           			dwSize;
	NET_TIMER_PLAN_INFO			stuTimerPlan;		// the info of timer programme
} NET_IN_MODIFY_TIMER_PROGRAMMEPLAN;

// output parameter of the interface of modify a  timer programme plan
typedef struct tagNET_OUT_MODIFY_TIMER_PROGRAMMEPLAN
{
	DWORD           			dwSize;
} NET_OUT_MODIFY_TIMER_PROGRAMMEPLAN;

/**************************************************************************************
*   Funcname: CLIENT_ModifyOneTimerProgrammePlan
*   Purpose: interface of modify a  timer programme plan
*   InputParam:	LLONG									:lLoginID	// login handle
*   InputParam:	NET_IN_MODIFY_TIMER_PROGRAMMEPLAN*		:pInParam  	// input parameter
*   OutputParam:NET_OUT_MODIFY_TIMER_PROGRAMMEPLAN*		:pOutParam  // output parameter
*   InputParam:	int										:nWaitTime	// wait time
*   Return:		BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ModifyOneTimerProgrammePlan(
										LLONG lLoginID,  const NET_IN_MODIFY_TIMER_PROGRAMMEPLAN* pInParam, 
										NET_OUT_MODIFY_TIMER_PROGRAMMEPLAN* pOutParam, const int nWaitTime);

// input parameter of the interface of delete same programme plans
typedef struct tagNET_IN_DEL_PROGRAMMEPLANS
{
	DWORD		dwSize;
	UINT		nPlanIDNum;												// the count of plans which are need to delete
	char		szPlanID[MAX_PROGRAMMES_COUNT][MAX_COMMON_STRING_64];	// the list of plans which are need to delete, "all" means delete all plans
} NET_IN_DEL_PROGRAMMEPLANS;

// output parameter of the interface of delete same programme plans
typedef struct tagNET_OUT_DEL_PROGRAMMEPLANS
{
	DWORD		dwSize;
} NET_OUT_DEL_PROGRAMMEPLANS;

/**************************************************************************************
*   Funcname: CLIENT_DelMultiProgrammePlans
*   Purpose: interface of delete same programme plans
*   InputParam:	LLONG							:lLoginID		// login handle
*   InputParam:	NET_IN_DEL_PROGRAMMEPLANS*		:pInParam  		// input parameter
*   InputParam:	NET_OUT_DEL_PROGRAMMEPLANS*		:pOutParam  	// output parameter
*   InputParam:	int								:nWaitTime		// wait time
*   Return:		BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DelMultiProgrammePlans(
										LLONG lLoginID,  const NET_IN_DEL_PROGRAMMEPLANS* pInParam, 
										NET_OUT_DEL_PROGRAMMEPLANS* pOutParam, const int nWaitTime);

#define MAX_GD_COUNT	170

// the color type of light band
typedef enum tagEM_GD_COLOR_TYPE
{
	EM_GD_COLOR_RED,		// red 
	EM_GD_COLOR_GREEN,		// green
	EM_GD_COLOR_YELLOW,		// yellow
} EM_GD_COLOR_TYPE;

// input paramerter of interface of setting the status of light band
typedef struct tagNET_IN_SET_GD_STATUS
{
	DWORD				dwSize;
	char				szScreenID[MAX_COMMON_STRING_64];		// screen ID(windows ID)
	UINT				nGDNum;									// the count of light bands
	EM_GD_COLOR_TYPE	emStatus[MAX_GD_COUNT];					// the info of these light bands
} NET_IN_SET_GD_STATUS;

// output paramerter of interface of setting the status of light band
typedef struct tagNET_OUT_SET_GD_STATUS
{
	DWORD				dwSize;
} NET_OUT_SET_GD_STATUS;

/**************************************************************************************
*   Funcname: CLIENT_SetGuideScreenGDStatus
*   Purpose: interface of setting the status of light band
*   InputParam:	LLONG						:lLoginID			// login handle
*   InputParam:	NET_IN_SET_GD_STATUS*		:pInParam  		// input parameter
*   InputParam:	NET_OUT_SET_GD_STATUS*		:pOutParam  		// output parameter
*   InputParam:	int							:nWaitTime		// wait time
*   Return:		BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetGuideScreenGDStatus(
										LLONG lLoginID,  const NET_IN_SET_GD_STATUS* pInParam, 
										NET_OUT_SET_GD_STATUS* pOutParam, const int nWaitTime);

//////////////////////////////////////////////////////////////////////////////////////////////////////
/////interfaces of play box(the interfaces about program plans are same as these interfaces about guid screen)
/////the interfaces about deleteing same programme plans and getting all briefly programmes are same as the interfaces under guid screen
/////////////////////////////////////////////////////////////////////////////////////////////////////
// LOGO info
typedef struct tagNET_PROGRAM_LOGO_INFO
{
	char		szLogoPath[MAX_COMMON_STRING_128];			// logo path
	NET_RECT	stuBackgroundRect;							// logo rect
	UINT		nDiaphaneity;								// diaphaneity, 0-100
	BYTE        byReserved[128];							// reserved bytes
} NET_PROGRAM_LOGO_INFO;

// bar info
typedef struct tagNET_PROGRAM_BAR_INFO
{
	char			szContent[MAX_COMMON_STRING_512];		// bar content
	NET_COLOR_RGBA	stuFontColor;							// font color
	UINT			nFontSize;								// font size
	char			szFontStyle[MAX_COMMON_STRING_32];		// font type
	UINT			nPlaySpeed;								// play speed
	NET_RECT		stuBackgroundRect;						// bar rect
	NET_COLOR_RGBA	stuBackColor;							// background color
	UINT			nDiaphaneity;							// diaphaneity, 0-100
	BYTE        	byReserved[128];						// reserved bytes
} NET_PROGRAM_BAR_INFO;

// the windwos info on play box
typedef struct tagNET_PLAYBOX_WINDOWS_INFO
{
	NET_RECT			stuRect;							// windows rect
	UINT				nZorder;							// windows zorder
	int					nVolume;							// the volume of the window, the percentage of the screen volume
	NET_COLOR_RGBA		stuBackColor;						// background color
	UINT				nDiaphaneity;						// diaphaneity, 0-100
	EM_TOURPERIOD_TYPE	emTourPeriodType;					// the type of tour period
	UINT				nTourPeriodTime;					// custom tour period time(unit:s)it's effective when emTourPeriodType is EM_TOURPERIOD_CUSTOM
	BOOL				bAutoPlay;							// is it auto play(it's effective when the element is video)
	BOOL				bLoopPlay;							// is it loop play(it's effective when the element is video)
	UINT				nElementsCount;						// the count of elements
	char*				pstElementsBuf;						// the buf of elements, the struct data according to the elements type
															// fill in multiple elements info, the info of each element is NET_ELEMENT_COMMON_INFO and it's struct
	UINT				nBufLen;							// the size of this buf
	BYTE        		byReserved[128];					// reserved bytes
} NET_PLAYBOX_WINDOWS_INFO;

// ordinary program info
typedef struct tagNET_PROGRAM_ORDINARY_INFO
{
	BOOL						bTempletState;							// is it templet
	char						szDescription[MAX_COMMON_STRING_128];	// the description of this programme
	UINT						nWidth;									// the width of canvas
	UINT						nHeight;								// the height of canvas
	int							nWinCount;								// windows count
	NET_PLAYBOX_WINDOWS_INFO	stuWindowsInfo[MAX_WINDOWS_COUNT];		// windwos info
	BYTE        				byReserved[128];						// reserved bytes
} NET_PROGRAM_ORDINARY_INFO;

// the type of program on play box
typedef enum tagEM_PLAYBOXPROGRAM_TYPE
{
	EM_PROGRAM_ON_PLAYBOX_LOGO,			// LOGO, Corresponding to NET_PROGRAM_LOGO_INFO
	EM_PROGRAM_ON_PLAYBOX_BAR,			// Bar, Corresponding to NET_PROGRAM_BAR_INFO
	EM_PROGRAM_ON_PLAYBOX_ORDINARY,		// Ordinary program, Corresponding to NET_PROGRAM_ORDINARY_INFO
}EM_PLAYBOXPROGRAM_TYPE;

// programme info on play box
typedef struct tagNET_PROGRAM_ON_PLAYBOX
{
	char						szProgrammeName[MAX_COMMON_STRING_64];	// programme name
	char						szProgrammeID[MAX_COMMON_STRING_64];	// programme ID
	BOOL						bEnable;								// is it enable
	EM_PLAYBOXPROGRAM_TYPE		emProgramType;							// programme type
	NET_PROGRAM_LOGO_INFO		stuLogoInfo;							// LOGO info, effective when emProgramType is EM_PROGRAM_ON_PLAYBOX_LOGO
	NET_PROGRAM_BAR_INFO		stuBarInfo;								// bar info, effective when emProgramType is EM_PROGRAM_ON_PLAYBOX_BAR
	NET_PROGRAM_ORDINARY_INFO	stuOrdinaryInfo;						// ordinary program info, effective when emProgramType is EM_PROGRAM_ON_PLAYBOX_ORDINARY
	BYTE        				byReserved[512];						// reserved bytes
} NET_PROGRAM_ON_PLAYBOX;

// input parameter of get all programmes on the playbox
typedef struct tagNET_IN_GET_ALL_PLAYBOX_PROGRAM
{
	DWORD           			dwSize;
} NET_IN_GET_ALL_PLAYBOX_PROGRAM;

// output parameter of get all programmes on the playbox
typedef struct tagNET_OUT_GET_ALL_PLAYBOX_PROGRAM
{
	DWORD           			dwSize;
	UINT						nMaxProgramCount;			// the max count of programmes, specified by user
	UINT						nRetProgramCount;			// the count of programmes actual returns
	NET_PROGRAM_ON_PLAYBOX		*pstProgramInfo;			// programmes info on play box, the resource is maintained bt user
} NET_OUT_GET_ALL_PLAYBOX_PROGRAM;

// input parameter of get programme on the playbox by ID
typedef struct tagNET_IN_GET_PLAYBOX_PROGRAM_BYID
{
	DWORD           			dwSize;
	char						szProgrammeID[MAX_COMMON_STRING_64];	// programme ID
} NET_IN_GET_PLAYBOX_PROGRAM_BYID;

// output parameter of get programme on the playbox by ID
typedef struct tagNET_OUT_GET_PLAYBOX_PROGRAM_BYID
{
	DWORD           			dwSize;
	NET_PROGRAM_ON_PLAYBOX		stuPlayBoxProgram;						// programme info
} NET_OUT_GET_PLAYBOX_PROGRAM_BYID;

// input parameter of add a playbox programme
typedef struct tagNET_IN_ADD_ONE_PLAYBOX_PRAGROM
{
	DWORD           			dwSize;
	NET_PROGRAM_ON_PLAYBOX		stuPlayBoxProgram;			// playbox programme info
} NET_IN_ADD_ONE_PLAYBOX_PRAGROM;

// output parameter of add a playbox programme
typedef struct tagNET_OUT_ADD_ONE_PLAYBOX_PRAGROM
{
	DWORD           			dwSize;
	char						szProgrammeID[MAX_COMMON_STRING_64];	// programme ID
} NET_OUT_ADD_ONE_PLAYBOX_PRAGROM;

// input parameter of modify a playbox programme
typedef struct tagNET_IN_MODIFY_PLAYBOX_PROGRAM_BYID
{
	DWORD           			dwSize;
	NET_PROGRAM_ON_PLAYBOX		stuPlayBoxProgram;			// playbox programme info
} NET_IN_MODIFY_PLAYBOX_PROGRAM_BYID;

// output parameter of modify a playbox programme
typedef struct tagNET_OUT_MODIFY_PLAYBOX_PROGRAM_BYID
{
	DWORD           			dwSize;
} NET_OUT_MODIFY_PLAYBOX_PROGRAM_BYID;


// get all programmes on the playbox
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetAllProgramOnPlayBox(
										LLONG lLoginID,  const NET_IN_GET_ALL_PLAYBOX_PROGRAM* pInParam, 
										NET_OUT_GET_ALL_PLAYBOX_PROGRAM* pOutParam, const int nWaitTime);

// get a programme on the playbox by ID
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetOneProgramByIdOnPlayBox(
										LLONG lLoginID,  const NET_IN_GET_PLAYBOX_PROGRAM_BYID* pInParam, 
										NET_OUT_GET_PLAYBOX_PROGRAM_BYID* pOutParam, const int nWaitTime);

// add a programme to playbox
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddOneProgramToPlayBox(
										LLONG lLoginID,  const NET_IN_ADD_ONE_PLAYBOX_PRAGROM* pInParam, 
										NET_OUT_ADD_ONE_PLAYBOX_PRAGROM* pOutParam, const int nWaitTime);


// modify a programme on playbox
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ModifyProgramOnPlayBoxById(
										LLONG lLoginID,  const NET_IN_MODIFY_PLAYBOX_PROGRAM_BYID* pInParam, 
										NET_OUT_MODIFY_PLAYBOX_PROGRAM_BYID* pOutParam, const int nWaitTime);



///////////////////////////////// directory management /////////////////////////////////////////

// add nodes,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OrganizationAddNodes(LLONG lLoginID, const DH_IN_ORGANIZATION_ADD_NODES* pInParam, DH_OUT_ORGANIZATION_ADD_NODES* pOutParam, int nWaitTime );

// delete nodes,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OrganizationDeleteNodes(LLONG lLoginID, const DH_IN_ORGANIZATION_DELETE_NODES* pInParam, DH_OUT_ORGANIZATION_DELETE_NODES* pOutParam, int nWaitTime );

// get info of nodes,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OrganizationGetNodes(LLONG lLoginID, const DH_IN_ORGANIZATION_GET_NODES* pInParam, DH_OUT_ORGANIZATION_GET_NODES* pOutParam, int nWaitTime );

//set node,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OrganizationSetNode(LLONG lLoginID, const DH_IN_ORGANIZATION_SET_NODE* pInParam, DH_OUT_ORGANIZATION_SET_NODE* pOutParam, int nWaitTime );


//////////////////////////////// network caught /////////////////////////////////

// start caught,user malloc memory of pInParam and pOutParam
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartSniffer(LLONG lLoginID, const DH_IN_START_SNIFFER* pInParam, DH_OUT_START_SNIFFER* pOutParam, int nWaitTime );

// stop caught
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopSniffer(LLONG lLoginID, LLONG lSnifferID);

// get caught state,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSnifferInfo(LLONG lLoginID, const DH_IN_GET_SNIFFER_INFO* pInParam, DH_OUT_GET_SNIFFER_INFO* pOutParam, int nWaitTime );

//////////////////////////////// Play Library Related Port /////////////////////////////////

//Snapshot JPEG
CLIENT_NET_API BOOL CALL_METHOD  CLIENT_GetPicJPEG(LLONG lPlayHandle, BYTE* pJpegBuf, DWORD dwBufSize,DWORD *pJpegSize,int quality);


//////////////////////////////// manage remote file /////////////////////////////////

// create file,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CreateRemoteFile(LLONG lLoginID, const DH_IN_CREATE_REMOTE_FILE* pInParam, DH_OUT_CREATE_REMOTE_FILE* pOutParam, int nWaitTime );

// remove file,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RemoveRemoteFiles(LLONG lLoginID, const DH_IN_REMOVE_REMOTE_FILES* pInParam, DH_OUT_REMOVE_REMOTE_FILES* pOutParam, int nWaitTime );

// rename,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RenameRemoteFile(LLONG lLoginID, const DH_IN_RENAME_REMOTE_FILE* pInParam, DH_OUT_RENAME_REMOTE_FILE* pOutParam, int nWaitTime );

// display files and subdirectories in a directory,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ListRemoteFile(LLONG lLoginID, const DH_IN_LIST_REMOTE_FILE* pInParam, DH_OUT_LIST_REMOTE_FILE* pOutParam, int nWaitTime );

// sybcgribize fule upload,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_UploadRemoteFile(LLONG lLoginID, const DH_IN_UPLOAD_REMOTE_FILE* pInParam, DH_OUT_UPLOAD_REMOTE_FILE* pOutParam, int nWaitTime );

// CLIENT_StartUploadRemoteFile callback function, lUploadFileHandle is CLIENT_StartUploadRemoteFile return value
typedef void (CALLBACK *fUploadFileCallBack) (LLONG lUploadFileHandle, int nTotalSize, int nSendSize, LDWORD dwUser);
// start upload remote file,user malloc memory of pInParam and pOutParam
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartUploadRemoteFile(LLONG lLoginID, const DH_IN_UPLOAD_REMOTE_FILE* pInParam, DH_OUT_UPLOAD_REMOTE_FILE* pOutParam, fUploadFileCallBack cbUploadFile, LDWORD dwUser);

// stop upload remote file
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopUploadRemoteFile(LLONG lUploadFileID);

// remote project, play audio file on device end,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PlayAudioFile(LLONG lLoginID, const NET_IN_PLAY_AUDIO_FILE* pInParam, NET_OUT_PLAY_AUDIO_FILE* pOutParam, int nWaitTime );

// file download, only for small file,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DownloadRemoteFile(LLONG lLoginID, const DH_IN_DOWNLOAD_REMOTE_FILE* pInParam, DH_OUT_DOWNLOAD_REMOTE_FILE* pOutParam, int nWaitTime );

// set file property,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetFileAttribute(LLONG lLoginID, const DH_IN_SET_FILEATTRIBUTE* pInParam, DH_OUT_SET_FILEATTRIBUTE* pOutParam, int nWaitTime );

CLIENT_NET_API BOOL CALL_METHOD CLIENT_DownloadPieceFile(LLONG lLoginID, const NET_IN_DOWNLOAD_PIECE_FILE* pInParam, NET_OUT_DOWNLOAD_PIECE_FILE* pOutParam,int nWaitTime );
////////////////////////////////// manage storage device ////////////////////////////////////////

// Get ISCSI target list,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD	CLIENT_GetISCSITargets(LLONG lLoginID, const DH_IN_ISCSI_TARGETS* pInParam, DH_OUT_ISCSI_TARGETS* pOutParam, int nWaitTime );
// user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetBitmap(LLONG lLoginID , const DH_IN_BITMAP* pInParam, DH_OUT_BITMAP* pOutParam, int nWaitTime );

// Get storage device name list,user malloc memory of pstuNames
CLIENT_NET_API BOOL CALL_METHOD	CLIENT_GetStorageDeviceNames(LLONG lLoginID, DH_STORAGE_DEVICE_NAME* pstuNames, int nMaxCount, int* pnRetCount, int nWaitTime );

// Get storage device info,user malloc memory of pDevice
CLIENT_NET_API BOOL CALL_METHOD	CLIENT_GetStorageDeviceInfo(LLONG lLoginID, const char* pszDevName, DH_STORAGE_DEVICE* pDevice, int nWaitTime );

// subscribe record file update info,user malloc memory of pInParam and pOutParam
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachRecordInfo(LLONG lLoginID, const NET_IN_ATTACH_RECORD_INFO* pInParam, NET_OUT_ATTACH_RECORD_INFO* pOutParam, int nWaitTime );

// cancel subscribe record file update info, lAttachHandle is CLIENT_AttachRecordInfo return value
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachRecordInfo(LLONG lAttachHandle);

// subscribe writing in remote torage info status,user malloc memory of pInParam and pOutParam
CLIENT_NET_API LLONG CALL_METHOD CLIENT_NetStorageAttachWriteInfo(LLONG lLoginID, const NET_IN_STORAGE_ATTACH_WRITE_INFO* pInParam, NET_OUT_STORAGE_ATTACH_WRITE_INFO* pOutParam, int nWaitTime);

// cancel writing in remote device info, lAttachHandle is the return value of CLIENT_NetStorageAttachWriteInfo 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_NetStorageDetachWriteInfo(LLONG lAttachHandle);

// search remote storage wiring in info status,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_NetStorageGetWriteInfo(LLONG lLoginID, const NET_IN_STORAGE_GET_WRITE_INFO* pInParam, NET_OUT_STORAGE_GET_WRITE_INFO* pOutParam, int nWaitTime);

// RAID operation, different operation type corresponding different structures,user malloc memory of pInBuf and pOutBuf,please refer to the corresponding structure of emType
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateRaid(LLONG lLoginID, NET_RAID_OPERATE_TYPE emType, void* pInBuf, void* pOutBuf, int nWaitTime);

/////////////////////////////////// cascade device ///////////////////////////////////////

// search cascade video,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MatrixSearch(LLONG lLoginID, const DH_IN_MATRIX_SEARCH* pInParam, DH_OUT_MATRIX_SEARCH* pOutParam, int nWaitTime );

// get cascade tree,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetMatrixTree(LLONG lLoginID, const DH_IN_GET_MATRIX_TREE* pInParam, DH_OUT_GET_MATRIX_TREE* pOutParam, int nWaitTime );

// get superior cascade device list info,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSuperiorMatrixList(LLONG lLoginID, const DH_IN_GET_SUPERIOR_MATRIX_LIST* pInParam, DH_OUT_GET_SUPERIOR_MATRIX_LIST* pOutParam, int nWaitTime );

/************************************************************************/
/*							backup record comes back
/************************************************************************/

// start record backup restore
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartRecordBackupRestore(LLONG lLoginID);

// stop record backup restore
CLIENT_NET_API void CALL_METHOD CLIENT_StopRecordBackupRestore(LLONG lRestoreID);

// add record backup restore task,user malloc memory of pInParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddRecordBackupRestoreTask(LLONG lRestoreID, const DH_IN_ADD_REC_BAK_RST_TASK* pInParam, int nWaitTime );

// remove record backup restore task,user malloc memory of pInParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RemoveRecordBackupRestoreTask(LLONG lRestoreID, const DH_IN_REMOVE_REC_BAK_RST_TASK* pInParam, int nWaitTime );

// get record backup restore task,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryRecordBackupRestoreTask(LLONG lRestoreID, const DH_IN_QUERY_REC_BAK_RST_TASK* pInParam, DH_OUT_QUERY_REC_BAK_RST_TASK* pOutParam, int nWaitTime );

//////////////////////////////// Encode Manager  ////////////////////////////////
// judicial burn in plan parameter coding,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetEncodePlan(LLONG lLoginID, const DH_IN_GET_ENCODE_PLAN* pInParam, DH_OUT_GET_ENCODE_PLAN* pOutParam, int nWaitTime );

// get expect time by resolution and CD capacity, pInParam and pOutParam application an release by use
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetEncodePlanByResolution(LLONG lLoginID, const NET_IN_GET_ENCODEPLANE_BY_RESOLUTION* pInParam, NET_OUT_GET_ENCODEPLANE_BY_RESOLUTION* pOutParam, int nWaitTime);

/************************************************************************/
/*                           database record operation                         */
/************************************************************************/
// by search filter search record,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FindRecord(LLONG lLoginID, NET_IN_FIND_RECORD_PARAM* pInParam, NET_OUT_FIND_RECORD_PARAM* pOutParam,int waittime);    

// search record :nFilecount: need search items,  return value as media file items  return value<nFilecountas corresponding period file search complete,user malloc memory of pInParam and pOutParam
CLIENT_NET_API int    CALL_METHOD CLIENT_FindNextRecord(NET_IN_FIND_NEXT_RECORD_PARAM* pInParam, NET_OUT_FIND_NEXT_RECORD_PARAM* pOutParam, int waittime);

// search record items,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL    CALL_METHOD CLIENT_QueryRecordCount(NET_IN_QUEYT_RECORD_COUNT_PARAM* pInParam, NET_OUT_QUEYT_RECORD_COUNT_PARAM* pOutParam, int waittime);

// end record search
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FindRecordClose(LLONG lFindHandle);

/************************************************************************/
/*                            PTZ metadata port subcribe
/************************************************************************/
// subscribe PTZ metadata port,user malloc memory of pstuInPtzStatusProc and pstuOutPtzStatusProc
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachPTZStatusProc(LLONG lLoginID, NET_IN_PTZ_STATUS_PROC *pstuInPtzStatusProc,  NET_OUT_PTZ_STATUS_PROC *pstuOutPtzStatusProc, int nWaitTime );

// stop subscribe PTZ metadata port, lAttachHandle is CLIENT_AttachPTZStatusProc return value
CLIENT_NET_API BOOL    CALL_METHOD    CLIENT_DetachPTZStatusProc(LLONG lAttachHandle);

/************************************************************************/
/*                            PTZ visual domain subcribe
/************************************************************************/
// subscribe PTZ visual domain,user malloc memory of pstuInViewRange and pstuOutViewRange
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachViewRangeState(LLONG lLoginID, NET_IN_VIEW_RANGE_STATE *pstuInViewRange, NET_OUT_VIEW_RANGE_STATE *pstuOutViewRange, int nWaitTime );

// stop subscribe PTZ visual domain, lAttachHandle is CLIENT_AttachViewRangeState return value
CLIENT_NET_API BOOL    CALL_METHOD    CLIENT_DetachViewRangeState(LLONG lAttachHandle);

// subscribe PTZ weather info,user malloc memory of pstuInParam and pstuOutParam
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachWeatherInfo(LLONG lLoginID, NET_IN_WEATHER_INFO *pstuInParam, NET_OUT_WEATHER_INFO *pstuOutParam, int nWaitTime);

//stop subscribe PTZ weather info,lAttachHandle is CLIENT_AttachWeatherInfo return value
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachWeatherInfo(LLONG lAttachHandle);

// configuration of set view range by object,user malloc memory of pInstuParam and pstuOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetViewRangeByObject(LLONG lLoginID, NET_IN_SET_VIEW_RANGE_BY_OBJECT *pInstuParam, NET_OUT_SET_VIEW_RANGE_BY_OBJECT *pstuOutParam,  int nWaitTime );

// configuration of set view range by GPS,user malloc memory of pInstuParam and pstuOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetViewRangeByGPS(LLONG lLoginID, NET_IN_SET_VIEW_RANGE_BY_GPS *pInstuParam, NET_OUT_SET_VIEW_RANGE_BY_GPS *pstuOutParam,  int nWaitTime);

// Get information list
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ScenicSpotGetPointInfos(LLONG lLoginID, NET_IN_SCENICSPOT_GETPOINTINFOS_INFO *pInstuParam, NET_OUT_SCENICSPOT_GETPOINTINFOS_INFO *pstuOutParam,  int nWaitTime);

// set the scene, the original number will be covered
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ScenicSpotSetPointInfo(LLONG lLoginID,  NET_IN_SCENICSPOT_SETPOINTINFO_INFO *pInstuParam,  NET_OUT_SCENICSPOT_SETPOINTINFO_INFO *pstuOutParam,  int nWaitTime);

// Get the ability to support the scene points
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ScenicSpotGetCaps(LLONG lLoginID,  const NET_IN_SCENICSPOT_GETCAPS_INFO *pInstuParam,  NET_OUT_SCENICSPOT_GETCAPS_INFO *pstuOutParam,  int nWaitTime);

// Focus on the point of view,three dimensional positioning(rate constant)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ScenicSpotTurnToPoint(LLONG lLoginID,  const NET_IN_SCENICSPOT_TURNTOPOINT_INFO *pInParam,  NET_OUT_SCENICSPOT_TURNTOPOINT_INFO *pOutParam,  int nWaitTime);

// Set Backup Sources
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetBackupSources(LLONG lLoginID, const NET_IN_SETBACKUP_SOURCES_INFO *pInstuParam, NET_OUT_SETBACKUP_SOURCES_INFO* pstuOutParam, int nWaitTime);
/************************************************************************/
/*                            BUS order                                   */
/************************************************************************/
// order Bus status,user malloc memory of pstuInBus and pstuOutBus
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachBusState(LLONG lLoginID, NET_IN_BUS_ATTACH *pstuInBus, NET_OUT_BUS_ATTACH *pstuOutBus, int nWaitTime );

// stop order Bus status, lAttachHandle is CLIENT_AttachBusState return value
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachBusState(LLONG lAttachHandle);

/************************************************************************/
/*                            analog alarm channel data subcribe
/************************************************************************/

// subscribe analog alarm channel data,user malloc memory of pInParam and pOutParam
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachAnalogAlarmData(LLONG lLoginID, const NET_IN_ANALOGALARM_DATA* pInParam, NET_OUT_ANALOGALARM_DATA* pOutParam, int nWaitTime);

// stop subscribe analog alarm channel data
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachAnalogAlarmData(LLONG lAttachHandle);

/************************************************************************/
/*               record  change port order              */
/************************************************************************/

// order record  change port,user malloc memory of pInParam and pOutParam
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachRecordUpdater(LLONG lLoginID, const NET_IN_RECORDUPDATER_DATA* pInParam, NET_OUT_RECORDUPDATER_DATA* pOutParam, int nWaitTime);

// stoporder record  change port 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachRecordUpdater(LLONG lAttachHandle);

////////////////////////////Special Version Interface///////////////////////////////
// open log function,user malloc memory of pstLogPrintInfo 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_LogOpen(LOG_SET_PRINT_INFO *pstLogPrintInfo);

// close log function
CLIENT_NET_API BOOL CALL_METHOD CLIENT_LogClose();

// Search device log--extensive,user malloc memory of pLogBuffer
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryLogEx(LLONG lLoginID, DH_LOG_QUERY_TYPE logType, char *pLogBuffer, int maxlen, int *nLogBufferlen, void* reserved, int waittime);

// Start query log(support BSC only),user malloc memory of pInParam and pOutParam
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartQueryLog(LLONG lLoginID, const NET_IN_START_QUERYLOG* pInParam, NET_OUT_START_QUERYLOG* pOutParam, int nWaitTime);

// Query next log(support BSC only),user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryNextLog(LLONG lLogID, NET_IN_QUERYNEXTLOG* pInParam, NET_OUT_QUERYNEXTLOG* pOutParam, int nWaitTime);

// Stop query log(support BSC only)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopQueryLog(LLONG lLogID);

// Active registered redirect function,establish directed connections
CLIENT_NET_API LONG CALL_METHOD CLIENT_ControlConnectServer(LLONG lLoginID, char* RegServerIP, WORD RegServerPort, int TimeOut);

// Establish active registered connection
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ControlRegisterServer(LLONG lLoginID, LONG ConnectionID, int waittime);

// Disconnected directional connection
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ControlDisconnectRegServer(LLONG lLoginID, LONG ConnectionID);

// Query active registered server information
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryControlRegServerInfo(LLONG lLoginID, LPDEV_SERVER_AUTOREGISTER lpRegServerInfo, int waittime);

// according to CLIENT_ControlRegisterOtherServer ,input parameter
typedef struct tagNET_IN_REGISTER_INFO 
{
	DWORD               dwSize;										 	 // struct size
    char                szRegServerIP[DH_MAX_IPADDR_LEN_EX];             // register ip address
    int                 nRegServerPort;                                  // register port
} NET_IN_REGISTER_INFO;

// according to CLIENT_ControlRegisterOtherServer output parameter
typedef struct tagNET_OUT_REGISTER_INFO 
{
    DWORD       dwSize;			// struct size
}NET_OUT_REGISTER_INFO;

// auto register to server,vehicle group talk requirement,control device register to other server
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ControlRegisterOtherServer(LLONG lLoginID, NET_IN_REGISTER_INFO* pInParam, NET_OUT_REGISTER_INFO* pOutParam , int waittime);

// Upload file
CLIENT_NET_API LLONG CALL_METHOD CLIENT_FileTransmit(LLONG lLoginID, int nTransType, char* szInBuf, int nInBufLen, fTransFileCallBack cbTransFile, LDWORD dwUserData, int waittime);

// web info trasmit
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_TransmitInfoForWeb(LLONG lLoginID, char* szInBuffer, DWORD dwInBufferSize, char* szOutBuffer, DWORD dwOutBufferSize, void* pExtData, int waittime);


// watermark verify for picture *nResult = 0-means no verify *nResult = 1-means has verify
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_WatermarkVerifyForPicture(char* szFilePath, int* nResult, void* pReserved);

// multi realplay,user malloc memory of pInBuf and pOutBuf
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_MultiRealPlay(LLONG lLoginID, DHDEV_IN_MULTIPLAY_PARAM* pInBuf, int nInBufLen, DHDEV_OUT_MULTIPLAY_PARAM* pOutBuf, int nOutBufLen, int* pRetLen);
 
// stop multi realplay
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_StopMultiRealPlay(LLONG* lRealHandles, int nNumOfHandles);

// when hwnd != null,set playback yuv data callback 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetPlaybackYUVCallBack(LLONG lPlayHandle, fYUVDataCallBack cYUVData, LDWORD dwUser);

// get web configuration
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetNewDevConfigForWeb(LLONG lLoginID, char* szCommand, int nChannelID, char* szOutBuffer, DWORD dwOutBufferSize, int *error, int waittime);

// set configuration for web
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetNewDevConfigForWeb(LLONG lLoginID, char* szCommand, int nChannelID, char* szInBuffer, DWORD dwInBufferSize, int *error, int *restart, int waittime);

// set play strategy parameter, only valid for real time
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetPlayMethod(LLONG lRealHandle, int nStartTime, int nSlowTime, int nFastTime, int nFailedTime);

// close device auto registration link
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CloseRegConnect(LLONG lHandle, char *pIp, WORD wPort, void *pParam);

// by file playback input parameter-proxy use
typedef struct tagNET_IN_PLAYBACK_BYFILE_PROXY 
{
    DWORD                   dwSize;
    LPNET_RECORDFILE_INFO   lpRecordFile;                   // record file info
    HWND                    hWnd;                           // window handle
    fDownLoadPosCallBack    cbDownLoadPos;                  // playback progress call
    LDWORD                  dwPosUser;                      // progress call user data
    fDataCallBack           fDownLoadDataCallBack;          // playback data call
    LDWORD                  dwDataUser;                     // data call user data
    char                    szDstIP[DH_COMMON_STRING_128];  // device IP
}NET_IN_PLAYBACK_BYFILE_PROXY;

// by file playback output parameter - proxy use
typedef struct tagNET_OUT_PLAYBACK_BYFILE_PROXY 
{
    DWORD                   dwSize;
}NET_OUT_PLAYBACK_BYFILE_PROXY;

// by time playback input parameter-proxy use
typedef struct tagNET_IN_PLAYBACK_BYTIME_PROXY 
{
    DWORD                   dwSize;
    int                     nChannelID;                     // channel no.
    LPNET_TIME              lpStartTime;                    // start time
    LPNET_TIME              lpStopTime;                     // end time
    HWND                    hWnd;                           // window handlw
    fDownLoadPosCallBack    cbDownLoadPos;                  // playback progress call
    LDWORD                  dwPosUser;                      // progress call user data
    fDataCallBack           fDownLoadDataCallBack;          // playback data call
    LDWORD                  dwDataUser;                     // data call user data
    char                    szDstIP[DH_COMMON_STRING_128];  // device IP
}NET_IN_PLAYBACK_BYTIME_PROXY;

// by time playback output parameter-proxy use
typedef struct tagNET_OUT_PLAYBACK_BYTIME_PROXY 
{
    DWORD                   dwSize;
}NET_OUT_PLAYBACK_BYTIME_PROXY;

// by file playback - attached device IP, proxy use only,user malloc memory of pInParam and pOutParam
CLIENT_NET_API LLONG CALL_METHOD CLIENT_PlayBackByRecordFileProxy(LLONG lLoginID, NET_IN_PLAYBACK_BYFILE_PROXY* pInParam, NET_OUT_PLAYBACK_BYFILE_PROXY* pOutParam);

// by time playback - attached device IP, proxy use only,user malloc memory of pInParam and pOutParam
CLIENT_NET_API LLONG CALL_METHOD CLIENT_PlayBackByTimeProxy(LLONG lLoginID, NET_IN_PLAYBACK_BYTIME_PROXY* pInParam, NET_OUT_PLAYBACK_BYTIME_PROXY* pOutParam);

// Cascade call type
typedef enum tagEM_CASCADE_TYPE
{
    EM_CASCADE_TYPE_UNKNOWN     = -1,   // Unknown
    EM_CASCADE_TYPE_CHANNEL,            // channel
} EM_CASCADE_TYPE;

// Cascade call param info
typedef struct tagNET_CASCADE_CALL_INFO
{
    BOOL                bCascadeCall;           // Is cascade or not
    EM_CASCADE_TYPE     emType;                 // Cascade type
    UINT                nChannel;               // Cascade channel
    BYTE                bReserved[1020];        // Reserved
} NET_CASCADE_CALL_INFO;

// Extend param of CLIENT_ImportConfigFileJson
typedef struct tagNET_IMPORT_CONFIG_EXTEND_PARAM
{
    DWORD                   dwSize;                 // Struct size
    NET_CASCADE_CALL_INFO   stuCascadeCallInfo;     // Cascade info
} NET_IMPORT_CONFIG_EXTEND_PARAM;

// Import configuration file (JSON) pSendBuf: To send data, the user allocates memory, nSendBufLen: The length of the sent, reserved: retention parameter
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ImportConfigFileJson(LLONG lLoginID, char *pSendBuf, int nSendBufLen, void* reserved);
// Export the configuration file (JSON) pOutBuffer: Receive buffer, The user allocates memory, maxlen: Receive buffer length, nRetlen: The actual length derived, reserved: retention parameter
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ExportConfigFileJson(LLONG lLoginID, char *pOutBuffer, int maxlen, int *nRetlen, void* reserved, int nWaitTime);

CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetSecurityKey(LLONG lPlayHandle, char* szKey, DWORD nKeyLen);

// RPC capacity search
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryRpcMethod(LLONG lLoginID, const char* pszMethod, BOOL* pResult, int nWaitTime);

// open or close privacy cover
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetPrivacyRecover(LLONG lPlayHandle, BOOL bRecover);

//////////////////////////////////////////////////////////////////////////
// Public transport business relevant interface
//////////////////////////////////////////////////////////////////////////

// check bus route,user malloc memory of pstInParam and pstOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CheckBusLine(LLONG lLoginID, const NET_IN_CHECK_BUS_LINE* pstInParam, NET_OUT_CHECK_BUS_LINE* pstOutParam, int nWaitTime );

// send bus route info,user malloc memory of pstInParam and pstOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DispatchBusLineInfo(LLONG lLoginID, const NET_IN_DISPATCH_BUS_LINE_INFO* pstInParam, NET_OUT_DISPATCH_BUS_LINE_INFO* pstOutParam, int nWaitTime );

// send bus route info extend interface,user malloc memory of pstInParam and pstOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DispatchBusLineInfoEx(LLONG lLoginID, const NET_IN_DISPATCH_BUS_LINE_INFO_EX* pstInParam, NET_OUT_DISPATCH_BUS_LINE_INFO_EX* pstOutParam, int nWaitTime);

// vehicle operation dispatch ,user malloc memory of pstInParam and pstOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_BusSchedule(LLONG lLoginID, const NET_IN_BUS_SCHEDULE_INFO* pstInParam, NET_OUT_BUS_SCHEDULE_INFO* pstOutParam, int nWaitTime );

// Issued by the vehicle scheduling plan,user malloc memory of pstInParam and pstOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DispatchWorkPlan(LLONG lLoginID, const NET_IN_BUS_DISPATCH_WORK_PLAN* pstInParam, NET_OUT_BUS_DISPATCH_WORK_PLAN* pstOutParam, int nWaitTime);

// Weather forecast info
typedef struct tagNET_WEATHERFORCAST_INFO
{
	int								nHighTemperature;					// High temperaturethe day, unitDegree Celsius
	int								nLowTemperature;					// Low temperaturethe day, unit: Degree Celsius
	int								nCurrentTemperature;				// Current temperature, unit: Degree Celsius
	char							szWeatherState[64];					// Weather State
	int								nWeatherCode;						// Weather code 
	BYTE							byReserved[1024];					// reserved
}NET_WEATHERFORCAST_INFO;
// push weather forecast in Param
typedef struct tagNET_IN_PUSH_WEATHERFORCAST
{
	DWORD							dwSize;
	NET_WEATHERFORCAST_INFO			stuWeatherInfo;						// Weather forecast Infomation
}NET_IN_PUSH_WEATHERFORCAST;
// push weather forecast Out Param
typedef struct tagNET_OUT_PUSH_WEATHERFORCAST
{
	DWORD							dwSize;
}NET_OUT_PUSH_WEATHERFORCAST;

// Push weather forecast
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PushWeatherForecast(LLONG lLoginID, const NET_IN_PUSH_WEATHERFORCAST* pstInParam, NET_OUT_PUSH_WEATHERFORCAST* pstOutParam, int nWaitTime);
//////////////////////////////////////////////////////////////////////////

// add feedback type after task
typedef enum tagNET_MISSION_FEEDBACK_TYPE
{
    NET_MISSION_FEEDBACK_NO = 0,                        // no feedback needed
    NET_MISSION_FEEDBACK_YES,                           // need feedback, shall replay DH_ALARM_MISSION_CONFIRM task confirmed event
}NET_MISSION_FEEDBACK_TYPE;

// message type (mobile)
typedef enum tagNET_MISSION_MESSAGE_TYPE
{
    NET_MISSION_MESSAGE_TEXT = 0 ,      //text info 
    NET_MISSION_MESSAGE_AD ,            //ad info 
    NET_MISSION_MESSAGE_BROAD ,         //broadcast info
    NET_MISSION_MESSAGE_DRIVER ,        //driver info
    NET_MISSION_MESSAGE_DISPATCH ,      //dispatch command
    NET_MISSION_MESSAGE_TRANSPARENT ,   //transparent data   
    NET_MISSION_MESSAGE_URGENT,         //emergency
    NET_MISSION_MESSAGE_MAX ,
}NET_MISSION_MESSAGE_TYPE;

// CLIENT_AddMission()port input parameter
typedef struct tagNET_IN_ADD_MISSION 
{
    DWORD           dwSize;
    char            szTitle[DH_COMMON_STRING_256];      // task name
    char            szMissionID[DH_COMMON_STRING_256];  // task ID
    char            szComment[DH_COMMON_STRING_256];    // replay content
    NET_MISSION_FEEDBACK_TYPE   emFeedBack;             // feedback type after adding
    NET_MISSION_MESSAGE_TYPE    emMessageType;          // message type 
	BOOL            bComment;                           // FALSE, szComment is walid, TRUE, szCommentEx is valid
	char            szCommentEx[DH_COMMON_STRING_2048]; // replay content, no null
	int				nChannel[DH_MAX_CHANNEL_COUNT];		// In which several channels are superimposed, Supports multi-channel simultaneous stacking
	int				nDuration;							// Overlay display duration, Unit:second; 0 indicates that it has been stacked until the next time
	int				nCount;								// nChannel length
}NET_IN_ADD_MISSION;

// CLIENT_AddMission() port output parameter
typedef struct tagNET_OUT_ADD_MISSION 
{
    DWORD           dwSize;
}NET_OUT_ADD_MISSION;
// user malloc memory of pstInParam and pstOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddMission(LLONG lLoginID, const NET_IN_ADD_MISSION* pstInParam, NET_OUT_ADD_MISSION* pstOutParam, int nWaitTime );

// CLIENT_ParkingControlStartFind port input parameter
typedef struct tagNET_IN_PARKING_CONTROL_START_FIND_PARAM
{
    DWORD                     dwSize;          // structure size
    BOOL                      bSearchCount;    // Search if record call is valid
    DWORD                     dwSearchCount;   // Search record item, value range is 1~100
    BOOL                      bBegin;          // Search if start time is valid
    NET_TIME                  stuBegin;        // Search start time
    BOOL                      bEnd;            // Search if end time is valid
    NET_TIME                  stuEnd;          // Search end time
    BOOL                      bCardType;       // If card type is valid
    NET_ECK_IC_CARD_USER_TYPE emCardType;      // Card type
    BOOL                      bFlag;           // If car pass mark is valid
    NET_ECK_CAR_PASS_FLAG     emFlag;          // Car pass mark
} NET_IN_PARKING_CONTROL_START_FIND_PARAM;

// CLIENT_ParkingControlStartFind port output parameter
typedef struct tagNET_OUT_PARKING_CONTROL_START_FIND_PARAM
{
    DWORD                     dwSize;          // structure size
    DWORD                     dwTotalCount;    // Result number match the search criteria
} NET_OUT_PARKING_CONTROL_START_FIND_PARAM;

// CLIENT_ParkingControlDoFind port input parameter
typedef struct tagNET_IN_PARKING_CONTROL_DO_FIND_PARAM
{
    DWORD                     dwSize;          // structure size
    DWORD                     dwFileCount;     // Currently record item number to search
} NET_IN_PARKING_CONTROL_DO_FIND_PARAM;

// Car pass record info
typedef struct tagNET_CAR_PASS_ITEM
{
    DWORD                      dwSize; 
    NET_TIME                   stuTime;          // Car pass time
    DWORD                      dwCardNo;         // Card no.
    NET_ECK_IC_CARD_USER_TYPE  emCardType;       // Card type
    NET_ECK_CAR_PASS_FLAG      emFlag;           // Car pass record type
} NET_CAR_PASS_ITEM;

// CLIENT_ParkingControlDoFind port output parameter
typedef struct tagNET_OUT_PARKING_CONTROL_DO_FIND_PARAM
{
    DWORD                     dwSize;          // structure size
    NET_CAR_PASS_ITEM        *pstuRecordList;  // Record list, user allocate memory,memory size is sizeof(NET_CAR_PASS_ITEM)*nMaxRecordNum
    int                       nMaxRecordNum;   // List record number
    int                       nRetRecordNum;   // Searched record items, current searched item number is lower than designated item number, search end
} NET_OUT_PARKING_CONTROL_DO_FIND_PARAM;

// Start car pass record search,user malloc memory of pInParam and pOutParam
CLIENT_NET_API LLONG CALL_METHOD CLIENT_ParkingControlStartFind(LLONG lLoginID, NET_IN_PARKING_CONTROL_START_FIND_PARAM* pInParam, NET_OUT_PARKING_CONTROL_START_FIND_PARAM* pOutParam, int waittime);

// Get car pass record,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ParkingControlDoFind(LLONG lFindeHandle, NET_IN_PARKING_CONTROL_DO_FIND_PARAM* pInParam, NET_OUT_PARKING_CONTROL_DO_FIND_PARAM* pOutParam, int waittime);

// End car pass record search
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ParkingControlStopFind(LLONG lFindHandle);

// Order car pass record data call function origin
typedef void (CALLBACK *fParkingControlRecordCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_CAR_PASS_ITEM *pInfo, int nBufLen, LDWORD dwUser);

// CLIENT_ParkingControlAttachRecord() port input parameter
typedef struct tagNET_IN_PARKING_CONTROL_PARAM
{
    DWORD                           dwSize;
    fParkingControlRecordCallBack   cbCallBack;                 // Data call function
    LDWORD                          dwUser;                     // User custom parameter
} NET_IN_PARKING_CONTROL_PARAM;

// CLIENT_ParkingControlDetachRecord() port output parameter
typedef struct tagNET_OUT_PARKING_CONTROL_PARAM
{
    DWORD    dwSize;
} NET_OUT_PARKING_CONTROL_PARAM;

// Car pass record order,user malloc memory of pInParam and pOutParam
CLIENT_NET_API LLONG CALL_METHOD CLIENT_ParkingControlAttachRecord(LLONG lLoginID, const NET_IN_PARKING_CONTROL_PARAM* pInParam, NET_OUT_PARKING_CONTROL_PARAM* pOutParam, int nWaitTime);

// Cancel car pass record order
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ParkingControlDetachRecord(LLONG lAttachHandle);

// Vehicle detector status
typedef enum tagNET_CAR_DETECTOR_STATE
{
    NET_CAR_DETECTOR_STATE_UNKNOWN = -1,
    NET_CAR_DETECTOR_STATE_OFFLINE = 0,                   // Offline
    NET_CAR_DETECTOR_STATE_ONLINE,                        // Online
    NET_CAR_DETECTOR_STATE_LOOPOFFLINE,                   // Senser coil offline
} NET_CAR_DETECTOR_STATE;

// Sub device general status
typedef enum tagNET_AUXILIARY_DEV_STATE
{
    NET_AUXILIARY_DEV_STATE_UNKNOWN = -1,
    NET_AUXILIARY_DEV_STATE_OFFLINE = 0,                   // offline
    NET_AUXILIARY_DEV_STATE_ONLINE,                        // online
} NET_AUXILIARY_DEV_STATE;

// Device IC card quantity condition
typedef enum tagNET_IC_CARD_STATUS
{
    NET_IC_CARD_STATUS_UNKNOWN = -1,
    NET_IC_CARD_STATUS_NORMAL = 0,                         // Normal
    NET_IC_CARD_STATUS_NOCARD,                             // No card
    NET_IC_CARD_STATUS_LOWCARD,                            // Few
    NET_IC_CARD_STATUS_FULLCARDS,                          // Full
} NET_IC_CARD_STATUS;

// auxiliary work mode type
typedef enum tagNET_AUXILIARY_WORK_MODE
{
    NET_AUXILIARY_WORK_MODE_UNKNOWN = 0,
    NET_AUXILIARY_WORK_MODE_OFFLINE,                       // working offline
    NET_AUXILIARY_WORK_MODE_ONLINE,                        // working online
} NET_AUXILIARY_WORK_MODE;

// Alarm event type DH_ALARM_AUXILIARY_DEV_STATE(sub device status event)corresponding data description info
typedef struct tagALARM_AUXILIARY_DEV_STATE
{
    DWORD                   dwSize;
    NET_CAR_DETECTOR_STATE  emDetector;                   // Vehicle detector status
    NET_AUXILIARY_DEV_STATE emLed;                        // LED status lattice screen status
    NET_AUXILIARY_DEV_STATE emICDetectBoard;              // Panel swiping card board
    NET_AUXILIARY_DEV_STATE emICSenderBoard;              // Issuing card swiping cardboard
    NET_IC_CARD_STATUS      emICCardStatus;               // Device IC card quantity condition
    NET_AUXILIARY_WORK_MODE emWorkMode;                   // working mode
} ALARM_AUXILIARY_DEV_STATE;

// Parking issuing card swiping card type
typedef enum tagNET_PARKING_CARD_TYPE
{
    NET_PARKING_CARD_TYPE_UNKNOWN,
    NET_PARKING_CARD_TYPE_SEND,                             // Issue card
    NET_PARKING_CARD_TYPE_DETECT,                           // Swipe card
} NET_PARKING_CARD_TYPE;

// Alarm event type DH_ALARM_PARKING_CARD(parking swipe card event)corresponding data description info
typedef struct tagALARM_PARKING_CARD
{
    DWORD                   dwSize;
    NET_PARKING_CARD_TYPE   emType;                       // Type
    DWORD                   dwCardNo;                     // Card no.
    char                    szPlate[DH_COMMON_STRING_16]; // Plate
} ALARM_PARKING_CARD;

// The type of alarm source device
typedef enum tagEM_ALARM_TRANSMIT_DEV_SRC_TYPE
{
    EM_ALARM_TRANSMIT_DEV_SRC_TYPE_UNKNOWN,             // Unknown    
	EM_ALARM_TRANSMIT_DEV_SRC_TYPE_DIGIT,               // Digit   
    EM_ALARM_TRANSMIT_DEV_SRC_TYPE_ANALOG,              // Analog 
    EM_ALARM_TRANSMIT_DEV_SRC_TYPE_SMARTLOCK,           // SmartLock
}EM_ALARM_TRANSMIT_DEV_SRC_TYPE;

// alarm transmit alarm type
typedef enum tagEM_ALARM_TRANSMIT_ALARM_TYPE
{
    EM_ALARM_TRANSMIT_ALARM_TYPE_UNKNOWN,               // unknown
    EM_ALARM_TRANSMIT_ALARM_TYPE_PREVENTREMOVE,         // PreventRemove
    EM_ALARM_TRANSMIT_ALARM_TYPE_LOWERPOWER,            // LowerPower
    EM_ALARM_TRANSMIT_ALARM_TYPE_KEY,                   // Key
    EM_ALARM_TRANSMIT_ALARM_TYPE_DURESS,                // Duress
}EM_ALARM_TRANSMIT_ALARM_TYPE;

// Alarm transmission event (Corresponding structure ALARM_PROFILE_ALARM_TRANSMIT_INFO)
typedef struct tagALARM_PROFILE_ALARM_TRANSMIT_INFO
{
    DWORD                           dwSize;
    int					            nChannelID;								// channel number
    int					            nAction;								// 0:Start 1:Stop
    NET_TIME                        stuTime;                                // time-to-event
    NET_SENSE_METHOD                emSenseMethod;                          // Sensor Type
    char                            szUserID[DH_COMMON_STRING_128];         // Alarm users, to distinguish    
	EM_ALARM_TRANSMIT_DEV_SRC_TYPE  emDevSrcType;                           // The type of alarm source device 
    EM_ALARM_TRANSMIT_ALARM_TYPE    emAlarmType;                            // alarm transmit alarm type
}ALARM_PROFILE_ALARM_TRANSMIT_INFO;

// EVENT_IVS_PROFILEALARMTRANSMIT(Corresponding to data block description) 
typedef struct tagDEV_EVENT_PROFILE_ALARM_TRANSMIT_INFO
{
    int                             nChannelID;                             // channel number
    int                             nEventID;                               // event id
    char                            szName[128];                            // event name
    double                          PTS;                                    // PTS
    int                             nAction;                                // 0:Start 1:Stop
    NET_TIME_EX                        stuTime;                                // time-to-event
    NET_SENSE_METHOD                emSenseMethod;                          // Sensor Type   
    EM_ALARM_TRANSMIT_DEV_SRC_TYPE  emDevSrcType;                           // The type of alarm source device 
    char                            szUserID[32];                           // Alarm users, to distinguish 
    EM_ALARM_TRANSMIT_ALARM_TYPE    emAlarmType;                            // alarm transmit alarm type
    BYTE                            reserved[1020];                         // reserved
}DEV_EVENT_PROFILE_ALARM_TRANSMIT_INFO;

// order monitor spot info,user malloc memory of pInParam and pOutParam
CLIENT_NET_API LLONG CALL_METHOD CLIENT_SCADAAttachInfo(LLONG lLoginID, const NET_IN_SCADA_ATTACH_INFO* pInParam, NET_OUT_SCADA_ATTACH_INFO* pOutParam, int nWaitTime);

// cancel monitor spot info order
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SCADADetachInfo(LLONG lAttachHandle);

// scada get threshold,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SCADAGetThreshold(LLONG lLoginID, const NET_IN_SCADA_GET_THRESHOLD* pInParam, NET_OUT_SCADA_GET_THRESHOLD* pOutParam, int nWaitTime);

// scada set threshold,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SCADASetThreshold(LLONG lLoginID, const NET_IN_SCADA_SET_THRESHOLD* pInParam, NET_OUT_SCADA_SET_THRESHOLD* pOutParam, int nWaitTime);

// scada start find history info,user malloc memory of pInParam and pOutParam
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartFindSCADA(LLONG lLoginID, const NET_IN_SCADA_START_FIND* pInParam, NET_OUT_SCADA_START_FIND* pOutParam, int nWaitTime);

// scada do find history info,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoFindSCADA(LLONG lFindHandle, const NET_IN_SCADA_DO_FIND* pInParam, NET_OUT_SCADA_DO_FIND* pOutParam, int nWaitTime);

// scada stop find history info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindSCADA(LLONG lFindHandle);

// scada attach alarm event,user malloc memory of pInParam and pOutParam
CLIENT_NET_API LLONG CALL_METHOD CLIENT_SCADAAlarmAttachInfo(LLONG lLoginID, const NET_IN_SCADA_ALARM_ATTACH_INFO* pInParam, NET_OUT_SCADA_ALARM_ATTACH_INFO* pOutParam, int nWaitTime );

// scada detach alarm event
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SCADAAlarmDetachInfo(LLONG lAttachHandle);

// scada set point info,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SCADASetInfo(LLONG lLoginID, const NET_IN_SCADA_POINT_SET_INFO_LIST* pInParam, NET_OUT_SCADA_POINT_SET_INFO_LIST* pOutParam, int nWaitTime );

//////////////////////////////////////////////////////////////////////////

// Order wireless code info port,user malloc memory of pstInBuf and pstOutBuf
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachLowRateWPAN(LLONG lLoginID, const NET_IN_ATTACH_LOWRATEWPAN* pstInParam, NET_OUT_ATTACH_LOWRATEWPAN* pstOutParam, int nWaitTime );

// Cancel order wireless info port, lAttachHandle is CLIENT_AttachLowRateWPAN return value
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachLowRateWPAN(LLONG lAttachHandle);

//Get play library port used to decode and display in preview, close resource type of gotten port,it will affect normal operaton
CLIENT_NET_API LONG CALL_METHOD CLIENT_GetRealPlayPort(LLONG lRealPlayHandle);

// Get play library port used to decode and display in preview, close resource type of gotten port,it will affect normal operaton
CLIENT_NET_API LONG CALL_METHOD  CLIENT_GetPlayBackPort(LLONG lPlayBackHandle);

// Parking Spaces of the intelligent parking systems 
typedef enum tagNET_ECK_PARK_STATE
{
    NET_ECK_PARK_STATE_UNKOWN,
    NET_ECK_PARK_STATE_PARK,                     // Parking cars
    NET_ECK_PARK_STATE_NOPARK,                   // No car parking Spaces
} NET_ECK_PARK_STATE;

// Parking information
typedef struct tagNET_PARK_INFO_ITEM
{
    DWORD                      dwSize; 
    char                       szParkNo[DH_COMMON_STRING_32];   // Parking number
    NET_ECK_PARK_STATE         emState;                         // Parking state
    DWORD                      dwScreenIndex;                   // GuideScreen index according to parking number
    DWORD                      dwFreeParkNum;                   // Free count of parking space
} NET_PARK_INFO_ITEM;

// Subscribe to the parking information callback function prototypes
typedef void (CALLBACK *fParkInfoCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_PARK_INFO_ITEM *pInfo, int nBufLen, LDWORD dwUser);

// Parking space detector type
typedef enum tagNET_ECK_PARK_DETECTOR_TYPE
{
    NET_ECK_PARK_DETECTOR_TYPE_SONIC,                     // ultrasonic detector
    NET_ECK_PARK_DETECTOR_TYPE_CAMERA,                    // The camera detector
    NET_ECK_PARK_DETECTOR_TYPE_ALL,
} NET_ECK_PARK_DETECTOR_TYPE;

// Parking space detector information query condition

typedef struct tagNET_PARK_INFO_FILTER
{
    DWORD                      dwSize; 
    DWORD                      dwNum;                                  // Parking space detector type number
    NET_ECK_PARK_DETECTOR_TYPE emType[NET_ECK_PARK_DETECTOR_TYPE_ALL]; // Parking space detector type 
} NET_PARK_INFO_FILTER;

// CLIENT_ParkingControlAttachParkInfo()Interface input parameters
typedef struct tagNET_IN_PARK_INFO_PARAM
{
    DWORD                           dwSize;
    NET_PARK_INFO_FILTER            stuFilter;
    fParkInfoCallBack               cbCallBack;                 // Data callback function
    LDWORD                          dwUser;                     // User defined parameters 
} NET_IN_PARK_INFO_PARAM;

// CLIENT_ParkingControlAttachParkInfo()Interface output parameters
 typedef struct tagNET_OUT_PARK_INFO_PARAM
{
    DWORD    dwSize;
} NET_OUT_PARK_INFO_PARAM;

// Parking state subscription,user malloc memory of pInParam and pOutParam
CLIENT_NET_API LLONG CALL_METHOD CLIENT_ParkingControlAttachParkInfo(LLONG lLoginID, const NET_IN_PARK_INFO_PARAM* pInParam, NET_OUT_PARK_INFO_PARAM* pOutParam, int nWaitTime);

// Cancel the parking state subscription
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ParkingControlDetachParkInfo(LLONG lAttachHandle);

// Subscribe to the video phone status information,user malloc memory of pInBuf and pOutBuf
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachVTPCallState(LLONG lLoginID, const NET_IN_VTP_CALL_STATE_ATTACH* pInParam, NET_OUT_VTP_CALL_STATE_ATTACH* pOutParam, int nWaitTime);

// Unsubscribe video phone status information
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachVTPCallState(LLONG lCallStateHandle);

// set mobile push notification, use RegisterID to identify the config info,user malloc and free pstuCfg's memory 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetMobileSubscribe(LLONG lLoginID, const NET_MOBILE_PUSH_NOTIFY *pstuCfg, int *nError, int *nRestart, int nWaitTime );

// delete mobile push notification, use RegisterID to identify the config info,user malloc and free memory of pstuIn and pstuOut
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DelMobileSubscribe(LLONG lLoginID, const NET_MOBILE_PUSH_NOTIFY_DEL *pstuIn, NET_OUT_DELETECFG* pstuOut, int nWaitTime );

// get mobile push notification config, use RegisterID+AppID to identify the info, AppID cannot include ".", use "_" instead of ".",user malloc and free memory of pstuCfg
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetMobileSubscribeCfg(LLONG lLoginID, NET_MOBILE_PUSH_NOTIFY_CFG *pstuCfg, int *nError, int nWaitTime );

// set mobile push notification config, use RegisterID+AppID to identify the info, AppID cannot include ".", use "_" instead of ".",user malloc and free memory of pstuCfg
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetMobileSubscribeCfg(LLONG lLoginID, const NET_MOBILE_PUSH_NOTIFY_CFG *pstuCfg, int *nError, int *nRestart, int nWaitTime );

// delete mobile push notification config, use RegisterID+AppID to identify the info, AppID cannot include ".", use "_" instead of ".",user malloc and free memory of pstuIn and pstuOut
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DelMobileSubscribeCfg(LLONG lLoginID, const NET_MOBILE_PUSH_NOTIFY_CFG_DEL *pstuIn, NET_OUT_DELETECFG* pstuOut, int nWaitTime );

////////////////////////////////////////////////////////////////////////////////
// Net applications, operation type
typedef enum tagEM_RPC_NETAPP_TYPE
{
    EM_RPC_NETAPP_TYPE_GET_NET_RESOURCE_STAT,      //  get statistics of net resource, pstuIn: NET_IN_NETAPP_GET_NET_RESOURCE_STAT*, pstuOut: NET_OUT_NETAPP_GET_NET_RESOURCE_STAT*
}EM_RPC_NETAPP_TYPE;

// EM_RPC_NETAPP_TYPE_GET_NET_RESOURCE_STAT, input param
typedef struct tagNET_IN_NETAPP_GET_NET_RESOURCE_STAT
{
    DWORD               dwSize;
}NET_IN_NETAPP_GET_NET_RESOURCE_STAT;

// EM_RPC_NETAPP_TYPE_GET_NET_RESOURCE_STAT, output param
typedef struct tagNET_OUT_NETAPP_GET_NET_RESOURCE_STAT
{
    DWORD               dwSize;
    int                 nIPChanneIn;             // IP channel in bandwidth, unit: kbps
    int                 nNetRemain;              // Net remain bandwidth, unit: kbps
    int                 nNetCapability;          // Net total bandwidth, unit: Mbps
    int                 nRemotePreview;          // Remote preview bandwidth, unit: kbps
    int                 nRemotePlayAndDownload;  // Remote playback and download bandwidth, unit: kbps
    int                 nRemoteSendRemain;       // Remote send remain bandwidth, unit: kbps
    int                 nRemoteSendCapability;   // Remote send total bandwidth, unit: Mbps
}NET_OUT_NETAPP_GET_NET_RESOURCE_STAT;

// network application component, company internal customized port 
// used to acquire network source data of front-end device,user malloc and free memory of pstuIn and pstuOut,please refer to corresponding structure of emType
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RPC_NetApp(LLONG lLoginID, EM_RPC_NETAPP_TYPE emType, const void* pstuIn, void* pstuOut, int nWaitTime );

// Set optimize mode,user malloc and free pParam's memory,please refer to corresponding structure of emType
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetOptimizeMode(EM_OPTIMIZE_TYPE emType, void *pParam);

// panoramic PTZ operation type 
typedef enum tagEM_NET_WIDE_VIEW_CTRL
{
    EM_NET_WIDE_VIEW_CTRL_START,                      // begin to generate panoramic view, startGenerateWideView, structure NET_IN_WIDE_VIEW_GENERATE_START and NET_OUT_WIDE_VIEW_GENERATE_START
    EM_NET_WIDE_VIEW_CTRL_STOP,                       // stop generating panoramic view, stopGenerateWideView, structure NET_IN_WIDE_VIEW_GENERATE_STOP and NET_OUT_WIDE_VIEW_GENERATE_STOP
    EM_NET_WIDE_VIEW_CTRL_PROGRESS,                   // acquire current progress generated by panoramic view, getWideViewProgress, structure NET_IN_WIDE_VIEW_PROGRESS and NET_OUT_WIDE_VIEW_PROGRESS
    EM_NET_WIDE_VIEW_CTRL_IMAGEINFO,                  // acquire panoramic view info, getImageInfo, structure NET_IN_WIDE_VIEW_IMAGE and NET_OUT_WIDE_VIEW_IMAGE
    EM_NET_WIDE_VIEW_CTRL_WV_COORD,                   // switch from PTZ coordinate to panoramic view coordinate, getWideViewCoordinates, structure NET_IN_WIDE_VIEW_WV and NET_OUT_WIDE_VIEW_WV
    EM_NET_WIDE_VIEW_CTRL_PTZ_COORD,                  // switch from panoramic view to PTZ absolute coordinate, getPtzCoordinates, structure NET_IN_WIDE_VIEW_PTZ and NET_OUT_WIDE_VIEW_PTZ 
} EM_NET_WIDE_VIEW_CTRL;

// begin to generate panoramic view input parameter 
typedef struct tagNET_IN_WIDE_VIEW_GENERATE_START
{
    DWORD                    dwSize;
    int                      nChannel;                // channel number 
} NET_IN_WIDE_VIEW_GENERATE_START;

// begin to generate panoramic view output parameter 
typedef struct tagNET_OUT_WIDE_VIEW_GENERATE_START
{
    DWORD                    dwSize;
} NET_OUT_WIDE_VIEW_GENERATE_START;

//  stop generating panoramic view input parameter 
typedef struct tagNET_IN_WIDE_VIEW_GENERATE_STOP
{
    DWORD                    dwSize;
    int                      nChannel;                // channel number 
} NET_IN_WIDE_VIEW_GENERATE_STOP;

//  stop generating panoramic view output parameter 
typedef struct tagNET_OUT_WIDE_VIEW_GENERATE_STOP
{
    DWORD                    dwSize;
} NET_OUT_WIDE_VIEW_GENERATE_STOP;

//  acquire current progress input parameter generated by panoramic view
typedef struct tagNET_IN_WIDE_VIEW_PROGRESS
{
    DWORD                    dwSize;
    int                      nChannel;                // channel number 
} NET_IN_WIDE_VIEW_PROGRESS;

//  acquire current progress output parameter generated by panoramic view 
typedef struct tagNET_OUT_WIDE_VIEW_PROGRESS
{
    DWORD                    dwSize;
    int                      nProgress;               // current progress generated by panoramic view, range 0-100 
} NET_OUT_WIDE_VIEW_PROGRESS;

//  acquire panoramic view info input parameter 
typedef struct tagNET_IN_WIDE_VIEW_IMAGE
{
    DWORD                    dwSize;
    int                      nChannel;                // channel number 
} NET_IN_WIDE_VIEW_IMAGE;

//  panoramic view info 
typedef struct tagNET_WIDE_VIEW_IMAGE_INFO
{
    char                     szImageUrl[MAX_PATH];    // channel number 
} NET_WIDE_VIEW_IMAGE_INFO;

// acquire panoramic view info output parameter
typedef struct tagNET_OUT_WIDE_VIEW_IMAGE
{
    DWORD                    dwSize;
    NET_WIDE_VIEW_IMAGE_INFO stuImageInfo;             // panoramic view info 
} NET_OUT_WIDE_VIEW_IMAGE;

#define NET_WIDE_VIEW_COORDINATES_MAX (64)

//  switch from PTZ coordinate to panoramic view coordinate input parameter 
typedef struct tagNET_IN_WIDE_VIEW_WV
{
    DWORD                    dwSize;
    int                      nChannel;                // channel number 
    int                      nNum;                    // effective PTZ coordinate number 
    PTZ_SPEED_UNIT           stuPTZ[NET_WIDE_VIEW_COORDINATES_MAX];   // PTZ direction and zoom rate 
} NET_IN_WIDE_VIEW_WV;

//  switch from PTZ coordinate to panoramic view coordinate output parameter 
typedef struct tagNET_OUT_WIDE_VIEW_WV
{
    DWORD                    dwSize;
    NET_RECT                 stuRect[NET_WIDE_VIEW_COORDINATES_MAX];  // panoramic view coordinate 
} NET_OUT_WIDE_VIEW_WV;

//  switch from panoramic view to PTZ absolute coordinate input parameter 
typedef struct tagNET_IN_WIDE_VIEW_PTZ
{
    DWORD                    dwSize;
    int                      nChannel;                // channel number 
    int                      nNum;                    // effective panoramic coordinate number 
    NET_RECT                 stuRect[NET_WIDE_VIEW_COORDINATES_MAX];  // panoramic view coordinate 
} NET_IN_WIDE_VIEW_PTZ;

//  switch from panoramic view to PTZ absolute coordinate output parameter 
typedef struct tagNET_OUT_WIDE_VIEW_PTZ
{
    DWORD                    dwSize;
    PTZ_SPEED_UNIT           stuPTZ[NET_WIDE_VIEW_COORDINATES_MAX];   // PTZ direction and zoom rate 
} NET_OUT_WIDE_VIEW_PTZ;

// panoramic PTZ relevant operation port, operation type refers to EM_NET_WIDE_VIEW_CTRL,user malloc memory of pstuInParam and pstuOutParam,please refer to corresponding structure of emCtrlType
CLIENT_NET_API BOOL CALL_METHOD CLIENT_WideViewCtrl(LLONG lLoginID, EM_NET_WIDE_VIEW_CTRL emCtrlType, const void *pstuInParam, void *pstuOutParam, int nWaitTime );
// ,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetMarkFile(LLONG lLoginID,const NET_IN_SET_MARK_FILE* pInParam, NET_OUT_SET_MARK_FILE* pOutParam, int nWaitTime );
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetMarkFileByTime(LLONG lLoginID, const NET_IN_SET_MARK_FILE_BY_TIME* pInParam, NET_OUT_SET_MARK_FILE_BY_TIME* pOutParam, int nWaitTime );

//record according to time stamp &&C5

//acquire sign video info ,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetMarkInfo(LLONG lLoginID, const NET_IN_GET_MARK_INFO* pInParam, NET_OUT_GET_MARK_INFO* pOutParam, int nWaitTime );

// record stream type 
typedef enum tagEM_NET_AUDIO_REC_STREAM
{
    EM_NET_AUDIO_REC_STREAM_UNKNOWN,
    EM_NET_AUDIO_REC_STREAM_MAIN,                    // Main
    EM_NET_AUDIO_REC_STREAM_EXTRA1,                  // Extra1
    EM_NET_AUDIO_REC_STREAM_EXTRA2,                  // Extra2
    EM_NET_AUDIO_REC_STREAM_EXTRA3,                  // Extra3
    EM_NET_AUDIO_REC_STREAM_TALKBACK,                // Talkback
} EM_NET_AUDIO_REC_STREAM;

// enable/disable audio record and acquire record name input parameter, corresponding command DH_CTRL_AUDIO_REC_START_NAME and DH_CTRL_AUDIO_REC_STOP_NAME 
typedef struct tagNET_IN_AUDIO_REC_MNG_NAME
{
    DWORD                    dwSize;                 // structure size 
    int                      nChannel;               // audio channel number 
    EM_NET_AUDIO_REC_STREAM  emStream;               // code stream type 
} NET_IN_AUDIO_REC_MNG_NAME;

// enable /disable audio record and acquire record name output parameter, corresponding command DH_CTRL_AUDIO_REC_START_NAME and DH_CTRL_AUDIO_REC_STOP_NAME 
typedef struct tagNET_OUT_AUDIO_REC_MNG_NAME
{
    DWORD                    dwSize;                 // structure size 
    char                     szFileName[MAX_PATH];   // recording file name 
} NET_OUT_AUDIO_REC_MNG_NAME;

// enable record type 
typedef enum tagEM_NET_REC_EVENT
{
    EM_NET_REC_EVENT_UNKNOWN,                       // unknown 
    EM_NET_REC_EVENT_ALARM,                         // Alarm
} EM_NET_REC_EVENT;

// enable/disable designated channel video input parameter, able to designate record type 
typedef struct tagNET_IN_REC_MNG_CTRL_MPT300
{
    DWORD                    dwSize;                 // the structure size
    int                      nChannel;               // channel number 
    EM_NET_REC_EVENT         emType;                 // record type, it is valid when nAction is 0 
    int                      nAction;                // 0:enable, 1:disable 
} NET_IN_REC_MNG_CTRL_MPT300;

// enable/disable designated channel record output parameter 
typedef struct tagNET_OUT_REC_MNG_CTRL_MPT300
{
    DWORD                    dwSize;                 // the structure size 
} NET_OUT_REC_MNG_CTRL_MPT300;

// realtime snapshot (manual snapshot) input parameter, corresponding command DH_CTRL_SNAP_MNG_SNAP_SHOT 
typedef struct tagNET_IN_SNAP_MNG_SHOT
{
    DWORD                    dwSize;                 // the structure size 
    int                      nChannel;               // channel number 
    int                      nTime;                  // continuous snapshot times, 0 means stopping snapshot, positive number means the number of continuous snapshot 
} NET_IN_SNAP_MNG_SHOT;

// realtime snapshot (manual snapshot) output parameter, corresponding command DH_CTRL_SNAP_MNG_SNAP_SHOT 
typedef struct tagNET_OUT_SNAP_MNG_SHOT
{
    DWORD                    dwSize;                 // the structure size
} NET_OUT_SNAP_MNG_SHOT;

// and close database/resume database input parameter, corresponding command DH_CTRL_LOG_STOP and DH_CTRL_LOG_RESUME
typedef struct tagNET_IN_LOG_MNG_CTRL
{
    DWORD                    dwSize;                 // the structure size 
} NET_IN_LOG_MNG_CTRL;

// and close database/resume database output parameter, corresponding command DH_CTRL_LOG_STOP and DH_CTRL_LOG_RESUME
typedef struct tagNET_OUT_LOG_MNG_CTRL
{
    DWORD                    dwSize;                 // the structure size 
} NET_OUT_LOG_MNG_CTRL;

// direct unvarnished transmission input parameter 
typedef struct tagNET_IN_TRANSMIT_DIRECTLY
{
    DWORD                    dwSize;                  // the structure size 
    char                    *szInBuffer;              // data transmitted to device 
    DWORD                    dwInBufferSize;          // data size transmitted to device
    NET_TRANSMIT_EXT_INFO    stExtData;               // data expansion transmitted to device, binary data 
} NET_IN_TRANSMIT_DIRECTLY;

// direct unvarnished output parameter 
typedef struct tagNET_OUT_TRANSMIT_DIRECTLY
{
    DWORD                    dwSize;                  // the structure size 
    char                    *szOutBuffer;             // device returned data 
    DWORD                    dwOutBufferSize;         // device returned data buffering size 
    DWORD                    dwRetBufferSize;         // actual returned data size 
} NET_OUT_TRANSMIT_DIRECTLY;

//remove anti-submarine alarm ,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ClearRepeatEnter(LLONG lLoginID, const NET_IN_CLEAR_REPEAT_ENTER* pInParam, NET_OUT_CLEAR_REPEAT_ENTER* pOutParam, int nWaitTime );

//remove anti-submarine alarm ,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetOperatorName(LLONG lLoginID, const NET_IN_GET_OPERATOR_NAME* pInParam, NET_OUT_GET_OPERATOR_NAME* pOutParam, int nWaitTime );

// POS connection type
typedef enum tagEM_CONN_TYPE
{
    EM_CONN_TYPE_UNKNOWN,                            // unknown
    EM_CONN_TYPE_NET,                                // tcp/ip
    EM_CONN_TYPE_RS232,                              // RS232
    EM_CONN_TYPE_RS485,                              // RS485
} EM_CONN_TYPE;

// POS protocol type
typedef enum tagEM_CONN_PROT
{
    EM_CONN_PROT_UNKNOWN,                            // unknown
    EM_CONN_PROT_NONE,                               // custom
    EM_CONN_PROT_POS,                                // POS
} EM_CONN_PROT;

// POS status type
typedef enum tagEM_POS_STATUS
{
    EM_POS_STATUS_OTHER = -1,                        // other error
    EM_POS_STATUS_NO,                                // no error
    EM_POS_STATUS_PROT_FORMAT,                       // protocol format error
    EM_POS_STATUS_NET_ADDR_CONFLICT,                 // net address conflict
    EM_POS_STATUS_RS232_ADDR_CONFLICT,               // rs232 address conflict
    EM_POS_STATUS_RS485_ADDR_CONFLICT,               // rs485 address conflict
    EM_POS_STATUS_LINK_CHANNEL_CONFLICT,             // linked channel conflict
    EM_POS_STATUS_NOT_EXIST,                         // POS does not exist
    EM_POS_STATUS_NUM_LIMIT,                         // POS number is out of limit
    EM_POS_STATUS_NAME_CONFLICT,                     // POS name conflict
} EM_POS_STATUS;

// POS tcp/ip connection attribute
typedef struct tagNET_POS_NET_ATT
{
    char                     szSrcIp[DH_MAX_IPADDR_LEN_EX];              // POS ip addr
    int                      nSrcPort;                                   // POS port
    char                     szDstIp[DH_MAX_IPADDR_LEN_EX];              // NVR ip addr
    int                      nDstPort;                                   // NVR port
} NET_POS_NET_ATT;

// POS COM connection attribute, RS232, RS485
typedef struct tagNET_POS_COM_ATT
{
    int                      nCommChannel;                               // comm channel (sub index of CFG_CMD_COMM)
    int                      nAddress;                                   // RS485 address
    DH_COMM_PROP             stuAttr;                                    // RS485 attr
} NET_POS_COM_ATT;

// POS custom protocol
typedef struct tagNET_POS_CUSTOM_PROT
{
    char                     szStartStr[DH_COMMON_STRING_32];            // start string
    BOOL                     bAnyCharater;                               // whether use szStartStr as prefix, TRUE: use any string as prefix, FALSE: use szStartStr as prefix
    char                     szEndStr[DH_COMMON_STRING_32];              // end string
    char                     szLineDelimiter[DH_COMMON_STRING_32];       // line delimiter
    int                      nMoreLine;                                  // count of POS trade info lines
    char                     szIgnoreStr[DH_COMMON_STRING_32];           // string to ignore
    BOOL                     bCaseSensitive;                             // whether case sensitive
    BYTE                     reserved[1024];                             // reserved
} NET_POS_CUSTOM_PROT;

// Ptz link type
typedef enum tagEM_PTZ_LINK_TYPE
{
	EM_PTZ_LINK_TYPE_NONE,							// none
	EM_PTZ_LINK_TYPE_PRESET,						// "Preset" 
	EM_PTZ_LINK_TYPE_TOUR,							// "Tour" 
	EM_PTZ_LINK_TYPE_PATTERN,						// "Pattern" 
	EM_PTZ_LINK_TYPE_ZOOM,							// "Zoom" 
	EM_PTZ_LINK_TYPE_SINGLESCENE,					// "SingleScene" 
	EM_PTZ_LINK_TYPE_QUICKFOCUS,					// "QuickFocus" 
} EM_PTZ_LINK_TYPE;

// Linkage PTZ information
typedef struct tagNET_CFG_PTZ_LINK
{
	EM_PTZ_LINK_TYPE		emType;						// Linkage type
	int						nValue;						// The linkage value corresponds to the preset number,cruise number,and so on.
} NET_CFG_PTZ_LINK;

// pos ptz link
typedef struct tagNET_PTZ_LINK
{
	EM_PTZ_LINK_TYPE		emType;					// ptz link type
	int						nParam1;				// link param 1
	int						nParam2;				// link param 2
	int						nParam3;				// link param 3
	int						nChannelID;				// ptz link channelID
} NET_PTZ_LINK;


// monitor tour config
typedef struct tagNET_MONITOR_TOUR
{
	BOOL					bEnable;				// monitor tour enable
	int						nChannels[256];			// monitor tour channels 
	int						nChannelCount;			// monitor tour channel number
	BYTE					reserved[32];			// reserved
} NET_MONITOR_TOUR;


#define MAX_NUMBER_PTZLINK		256	// max number ptzlink
#define	MAX_NUMBER_TOUR			32	// max number of monitor Tour 

// POS event link
typedef struct tagNET_POS_EVENT_LINK
{
	DWORD					dwSize;									// struct size
	DH_TSECT				stuTimeSection[DH_TSCHE_DAY_NUM][DH_TSCHE_SEC_NUM];		// time schedule
	BOOL					bRecordEnable;							// RecordEnable
	BOOL					bRecordCloudEnable;						// RecordCloudEnable
	DWORD					dwRecordMask[DH_MAX_CHANNUM];			// record channels
	int						nRecordLatch;							// RecordLatch unit:second
	BOOL					bAlarmOutEnable;						// AlarmOutEnable
	DWORD					dwAlarmOutMask[DH_MAX_CHANNUM];			// Alarm Out channels
	int						nAlarmOutLatch;							// AlarmOutLatch unit:second
	int						nPtzLinkNum;							// Ptz Link Number
	NET_PTZ_LINK			stuPtzLink[MAX_NUMBER_PTZLINK];			// pos ptz link
	BOOL					bPtzLinkEnable;							// Ptz Link Enable
	int						nPtzLinkDelay;							// Ptz Link Delay unit:second
	BOOL					bSnapshotEnable;						// SnapshotEnable
	BOOL					bSnapshotCloudEnable;					// SnapshotCloudEnable
	DWORD					dwSnapshotMask[DH_MAX_CHANNUM];			// Snapshot channels
	int						nSnapshotPeriod;						// SnapshotPeriod
	int						nSnapshotTimes;							// SnapshotTimes
	BOOL					bTipEnable;								// TipEnable
	BOOL					bMailEnable;							// MailEnable
	BOOL					bMessageEnable;							// MessageEnable
	BOOL					bBeepEnable;							// BeepEnable
	BOOL					bVoiceEnable;							// VoiceEnable
	DWORD					dwVoiceMask[DH_MAX_CHANNUM];			// Voice channels
	char					szAudioFileName[MAX_PATH];				// AudioFileName
	int						nPlayTimes;								// PlayTimes
	
	int						nDejitter;								// Dejitter unit:second 
	BOOL					bLogEnable;								// LogEnable
	int						nMonitorTourNum;                        // MonitorTourNumber
	NET_MONITOR_TOUR		stuMonitorTour[MAX_NUMBER_TOUR];		// MonitorTour config
} NET_POS_EVENT_LINK;

// POS info
typedef struct tagNET_POS_INFO
{
    BOOL                     bEnable;                // enable
    DWORD                    dwPosId;                // POS ID, invalid wheth adding POS
    char                     szName[64];             // POS name
    EM_CONN_TYPE             emConnType;             // connection type
    NET_POS_NET_ATT          stuNetAtt;              // net connection attr, valid if emConnType is EM_CONN_TYPE_NET
    NET_POS_COM_ATT          stuComAtt;              // comm attr, valid if emConnType is EM_CONN_TYPE_RS232 or EM_CONN_TYPE_RS485
    EM_CONN_PROT             emConnProt;             // connection protocol type
    NET_POS_CUSTOM_PROT      stuCustom;              // valid if emConnProt is EM_CONN_PROT_NONE
    int                      nTimeOut;               // time out for recv msg, unit: sec
    int                      nLinkChannel[32];       // linked channel
    int                      nLinkChannelNum;        // valid count in nLinkChannel
    int                      nPlayBackTime;          // POS msg assocated video playback time, unit: sec

	BOOL					 bPreviewBlend;			 // preview blend
    BYTE                     reserved[1020];         // reserved
} NET_POS_INFO;

// The input parameters of adding POS Device parameter, corresponding to DH_CTRL_POS_ADD/DH_CTRL_POS_MODIFY
typedef struct tagNET_IN_POS_ADD
{
    DWORD                    dwSize;                 // struct size
    NET_POS_INFO             stuPosInfo;             // POS info
	NET_POS_EVENT_LINK		 stuPosEventLink;		 // POS EventLink 
} NET_IN_POS_ADD;

// The output parameters of adding POS Device parameter, corresponding to DH_CTRL_POS_ADD/DH_CTRL_POS_MODIFY
typedef struct tagNET_OUT_POS_ADD
{
    DWORD                    dwSize;                 // struct size
    DWORD                    dwPosId;                // POS ID
    EM_POS_STATUS            emStatus;               // Status
} NET_OUT_POS_ADD;

// The input parameters of removing POS Device parameter, corresponding to DH_CTRL_POS_REMOVE
typedef struct tagNET_IN_POS_REMOVE
{
    DWORD                    dwSize;                 // struct size
    DWORD                    dwPosId;                // POS ID
} NET_IN_POS_REMOVE;

// The input parameters of moving POS Device parameter, corresponding to DH_CTRL_POS_REMOVE
typedef struct tagNET_OUT_POS_REMOVE
{
    DWORD                    dwSize;                 // struct size
    EM_POS_STATUS            emStatus;               // Status
} NET_OUT_POS_REMOVE;

// The input parameters of multi-removing POS Device parameter, corresponding to DH_CTRL_POS_REMOVE_MULTI
typedef struct tagNET_IN_POS_REMOVE_MULTI
{
    DWORD                    dwSize;                 // struct size
    DWORD                    dwPosId[16];            // Pos ID, -1 means all
    int                      nPosNum;                // number of POS ID
} NET_IN_POS_REMOVE_MULTI;

// The output parameters of multi-removing POS Device parameter, corresponding to DH_CTRL_POS_REMOVE_MULTI
typedef struct tagNET_OUT_POS_REMOVE_MULTI
{
    DWORD                    dwSize;                 // struct size
    EM_POS_STATUS            emStatus;               // Status
    DWORD                    dwPosIdFailed[16];      // Failed POS ID
    int                      nPosNum;                // number of Failed POS ID
} NET_OUT_POS_REMOVE_MULTI;

// The input parameters of Getting all POS Devices parameter, corresponding to DH_DEVSTATE_GET_ALL_POS
typedef struct tagNET_POS_ALL_INFO
{
    DWORD                    dwSize;                 // struct size
	int						 nMaxNum;				 // POS max num
    int                      nRetPosNum;             // pos return number
    NET_POS_INFO             stuPos[256];            // pos information
	NET_POS_EVENT_LINK		 *pstuPosEventLink;		 // POS EventLink, it matches with stuPos, user malloc the memory,apply to sizeof(NET_POS_EVENT_LINK)*nMaxNum
} NET_POS_ALL_INFO;

// info of event type DH_ALARM_LOCK_BREAK (POS Manage Event)
typedef struct tagALARM_POS_MANAGE_INFO
{
    int                      nEventAction;                   // Event Action, 0:Pulse, 1:Start, 2:Stop
    int                      nType;                          // Type, 0:add, 1:remove, 2:modify
    DWORD                    dwPosId;                        // Pos ID
    char                     szName[DH_COMMON_STRING_64];    // Pos Name
    int                      nLinkChannel[32];               // Link Channels
    int                      nLinkChannelNum;                // number of link channel
    EM_CONN_PROT             emConnProt;                     // Connect protocol
    BYTE                     reserved[1024];                 // reserved
} ALARM_POS_MANAGE_INFO;

// info of event type DH_ALARM_LOCK_BREAK (lock break event)
typedef struct tagALARM_LOCK_BREAK_INFO
{
    int                      nDoor;                          // door channel, start from 0
    int                      nAction;                        // 0:start, 1:stop
    NET_TIME_EX              UTC;                            // event time
    BYTE                     reserved[1024];                 // revered
}ALARM_LOCK_BREAK_INFO;

// Pos data type
typedef enum tagEM_POS_DATA_TYPE
{
	EM_POS_DATA_TYPE_UNKNOWN,				// unknown
	EM_POS_DATA_TYPE_STORE_INF0,			// store info
	EM_POS_DATA_TYPE_PRODUCT_INFO,			// product info
}EM_POS_DATA_TYPE;

// Store info
typedef struct tagNET_STORE_INFO
{
	char					 szDealNum[MAX_DEAL_NUM_LEN];				// Store deal num,used to identify which ticket items belong to the product
	char					 szNo[MAX_STORE_NO_LEN];					// Store name No
	char					 szName[MAX_STORE_NAME_LEN];				// Store name
	char					 szEmPloyeeID[MAX_STORE_EMPLOYEE_ID_LEN];	// Store employee ID 
	unsigned int			 nSeviceType;								// Store sevice type,0-market,1-return goods
	unsigned int			 nAmount;									// Store amount, Unit:cent
	BYTE					 byReserved[1024];							// reserved
}NET_STORE_INFO;

// Product info
typedef struct tagNET_PRODUCT_INFO
{
	char					 szDealNum[MAX_DEAL_NUM_LEN];			// product deal num,used to identify which ticket items belong to the product
	char					 szNo[MAX_PRODUCT_NO_LEN];				// product name No
	char					 szName[MAX_PRODUCT_NAME_LEN];			// product name
	char					 szCategory[MAX_PRODUCT_CATEGORY_LEN];	// product category
	unsigned int			 nPrice;								// product price,Unit:point
	double					 dbQuantity;							// product quantity,piece or kg
	BYTE					 byReserved[1024];						// reserved
}NET_PRODUCT_INFO;


// POS trade info
typedef struct tagNET_POS_TRADE_INFO
{
    DWORD                    dwPosId;                        // POS ID
    NET_TIME                 stuTime;                        // trading time
    BYTE                    *pbyComment;                     // trading content
    DWORD                    dwCommentLen;                   // pbyComment length
	EM_POS_DATA_TYPE		 emDataType;					 // data type
	BOOL					 bEnd;							 // End flag,judge whether a small ticket is over.End value, true means a small ticket ends.
	void*					 pPosData;						 // pos data
															 // if emDataType is EM_POS_DATA_TYPE_STORE_INF0,transfer store info,corresponding to NET_STORE_INFO
															 // if emDataType is EM_POS_DATA_TYPE_PRODUCT_INFO,transfer product info,corresponding to NET_PRODUCT_INFO
	char					szOSDInfo[2048];					 // OSD info
	BYTE					reserved[1024];					 // reserved
} NET_POS_TRADE_INFO;

// POS trade info callback prototype
typedef void (CALLBACK *fPosTradeCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_POS_TRADE_INFO *pInfo, int nBufLen, LDWORD dwUser);

// input param of attaching POS trade info
typedef struct tagNET_IN_POS_TRADE_ATTACH 
{
    DWORD                       dwSize;                 // struct size
    fPosTradeCallBack           cbCallState;            // trade info callback
    LDWORD                      dwUser;                 // callback user's param
} NET_IN_POS_TRADE_ATTACH;

// output param of attaching POS trade info
typedef struct tagNET_OUT_POS_TRADE_ATTACH 
{
    DWORD                       dwSize;                 // struct size
} NET_OUT_POS_TRADE_ATTACH;

// input param of CLIENT_GetDevCaps according to NET_POS_CAPS 
typedef struct tagNET_IN_POS_GETCAPS
{
    DWORD               dwSize;
} NET_IN_POS_GETCAPS;

// output param of CLIENT_GetDevCaps according to NET_POS_CAPS 
typedef struct tagNET_OUT_POS_GETCAPS
{
    DWORD               dwSize;
    EM_CONN_TYPE        emConnType[10];                    // connection type
    int                 nConnTypeNum;                      // connection type count in emConnType
    EM_CONN_PROT        emConnProt[10];                    // connect protocol type
    int                 nConnProtNum;                      // connect protocol count in emConnProt
    int                 nMaxPos;                           // max POS count supported
	BOOL				bSupportPosRecord;				   // support pos record

} NET_OUT_POS_GETCAPS;

// attach POS trade info,user malloc memory of pInParam and pOutParam
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachPosTrade(LLONG lLoginID, const NET_IN_POS_TRADE_ATTACH* pInParam, NET_OUT_POS_TRADE_ATTACH* pOutParam, int nWaitTime);

// detach POS trade info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachPosTrade(LLONG lAttachHandle);

// CLIENT_GetDevCaps interface NET_USER_MNG_CAPS command parameter
typedef struct tagNET_IN_USER_MNG_GETCAPS
{
    DWORD               dwSize;
} NET_IN_USER_MNG_GETCAPS;

// CLIENT_GetDevCaps interface NET_USER_MNG_CAPS command parameter
typedef struct tagNET_OUT_USER_MNG_GETCAPS
{
    DWORD               dwSize;
    BOOL                bAccountLimitation;							// Account Limitation
    BOOL                bIndividualAccessFilter;					// Individual Access Filter
    DWORD               dwMaxPageSize;								// Max number of Page Size
	unsigned int		nMaxPwdLen;									// max passwd len
	unsigned int		nMinPwdLen;									// min passwd len	
	char				szType[MAX_PWD_BASIC_CHARS_ARRAY_LEN];		// basic chars supportedNumber,Lower case,Capital. such as :"Number,Lower,Upper"
	char				szCharList[MAX_PWD_SPEC_CHARS_ARRAY_LEN];	// special chars supported, as"~!@#$%^" 
	int					nCombine;									// chars combine style0-no special request, 1-special char must be included, 2-at least two style included (number, capital, lower case, special char)
} NET_OUT_USER_MNG_GETCAPS;

//CLIENT_GetDevCaps interface NET_EXTERNALSENSOR_CAPS command parameter
typedef struct tagNET_IN_EXTERNALSENSOR_CAPS
{
	DWORD				dwSize;
}NET_IN_EXTERNALSENSOR_CAPS;

// CLIENT_GetDevCaps interface NET_GET_MASTERSLAVEGROUP_CAPS command parameter
typedef struct tagNET_IN_GET_MASTERSLAVEGROUP_CAPS
{
	DWORD				dwSize;
	int					nChannel;			// Video channel ID, start from 0.(if not a multi-channel device, set 0)
}NET_IN_GET_MASTERSLAVEGROUP_CAPS;

typedef enum tagEM_MASTERSLAVEGROUP_MODE
{
	EM_MASTERSLAVEGROUP_MODE_UNKNOWN,		//  Unknown
	EM_MASTERSLAVEGROUP_MODE_COMMANDER,	    //  Commander
	EM_MASTERSLAVEGROUP_MODE_PROPOSER,      //  Proposer 
	EM_MASTERSLAVEGROUP_MODE_JUDGE,			//  Judge
	EM_MASTERSLAVEGROUP_MODE_HAWKEYE,		//  HawkEye
	EM_MASTERSLAVEGROUP_MODE_MULTISENSOR,	//  MultiSensor
	EM_MASTERSLAVEGROUP_MODE_GLOBALCAMERA,	//  GlobalCamera
	EM_MASTERSLAVEGROUP_MODE_NEWCOMMANDER,  //  NewCommander
	EM_MASTERSLAVEGROUP_MODE_NEWHAWEYE,     //  NewHawEye
	EM_MASTERSLAVEGROUP_MODE_GLOBALCAMERA2,	//  GlobalCamera2, Use CalibrateMatrix(MultiMode) Config
	EM_MASTERSLAVEGROUP_MODE_CLOSEUP,       //  CloseUp, Use CalibrateMatrix(MultiSensor) Config
}EM_MASTERSLAVEGROUP_MODE;

//calibration mode
typedef enum tagEM_MASTERSLAVE_CALIBRATIONMODES
{
	EM_MASTERSLAVE_CALIBRATIONMODES_UNKNOWN,                  //unknown
	EM_MASTERSLAVE_CALIBRATIONMODES_AUTO,                     //Auto
	EM_MASTERSLAVE_CALIBRATIONMODES_MANUAL,                   //Manual
}EM_MASTERSLAVE_CALIBRATIONMODES;

//calibration scene split type
typedef enum tagEM_MASTERSLAVE_CALISCENCESPLIT
{
	EM_MASTERSLAVE_CALISCENCESPLIT_UNKNOWN,                   //unknown
	EM_MASTERSLAVE_CALISCENCESPLIT_NOSPLIT,                   //no split
	EM_MASTERSLAVE_CALISCENCESPLIT_HORIZONTALSPLIT,           //horizontal split
}EM_MASTERSLAVE_CALISCENCESPLIT;

// Intelligent scheme support mode
typedef enum tagEM_INTELLIGENT_SCHEME_SUPPORTMODE
{
    EM_INTELLIGENT_SCHEME_SUPPORTMODE_UNKNOWN,              // unknown
    EM_INTELLIGENT_SCHEME_SUPPORTMODE_LINK,                 // just link
    EM_INTELLIGENT_SCHEME_SUPPORTMODE_INDEPENT,             // just indepent
    EM_INTELLIGENT_SCHEME_SUPPORTMODE_DEFAULT,              // both link and indepent(if no "SupportMode", this is default value)
}EM_INTELLIGENT_SCHEME_SUPPORTMODE;

//master-slave track
typedef struct tagNET_MASTERSLAVE_TRACK
{
	BOOL                                    bSupport;         //is support master-slave track
	int                                     nMasterCount;     //master count
	int                                     nMasterChn[16];   //master according to channel, from 0
	int                                     nSlaverCount;     //slaver count
	int                                     nSlaverChn[16];   //slaver according to channel, from 0
    EM_INTELLIGENT_SCHEME_SUPPORTMODE       emSupportMode;    //Intelligent scheme support mode
	BYTE                                    bReserved[508];   //Reserved byte
}NET_MASTERSLAVE_TRACK;

// CLIENT_GetDevCaps interface NET_GET_MASTERSLAVEGROUP_CAPS command parameter
typedef struct tagNET_OUT_GET_MASTERSLAVEGROUP_CAPS
{
	DWORD									dwSize;
	EM_MASTERSLAVEGROUP_MODE				emRole;             //master-slave track role
	int                                     nCalibrationModeCount;     //calibration mode count
	EM_MASTERSLAVE_CALIBRATIONMODES         emCalibrationModes[4];     //calibration mode
	int                                     nCaliSceneCnt;      //calibration scene count
	EM_MASTERSLAVE_CALISCENCESPLIT          emCaliSceneSplit;   //calibration scene split type
	NET_MASTERSLAVE_TRACK                   stuMasterSlaveTrack;//master-slave track
}NET_OUT_GET_MASTERSLAVEGROUP_CAPS;

// CLIENT_GetDevCaps interface NET_STORAGE_CAPS command parameter
typedef struct tagNET_IN_STORAGE_CAPS
{
	DWORD									dwSize;
}NET_IN_STORAGE_CAPS;

// Whether need to reboot after formatting
typedef enum tagNET_EM_FORMAT_NEEDREBOOT
{
	EM_FORMAT_NEEDREBOOT_UNKNOWN,					// unknown
	EM_FORMAT_NEEDREBOOT_NOREBOOT,					// doesn't need reboot
	EM_FORMAT_NEEDREBOOT_REBOOT						// Need reboot, call CLIENT_ControlDevice formatting using the command DH_CTRL_SDCARD or DH_CTRL_DISK Automatic restart
													// using the command DH_CTRL_FORMAT_PATITION requires client to restart 
}NET_EM_FORMAT_NEEDREBOOT;

// CLIENT_GetDevCaps interface NET_STORAGE_CAPS command parameter
typedef struct tagNET_OUT_STORAGE_CAPS
{
	DWORD									dwSize;
	NET_EM_FORMAT_NEEDREBOOT				emReboot;
}NET_OUT_STORAGE_CAPS;

// external sensor networking mode
typedef enum tagEM_SENSOR_NERWORKING_MODE
{
	EM_SENSOR_NERWORKING_MODE_UNKNOWN,			// unknow mode
	EM_SENSOR_NETWORKING_MODE_RS485,			// RS-485
	EM_SENSOR_NETWORKING_MODE_RFID,				// RFID
}EM_SENSOR_NERWORKING_MODE;
// CLIENT_GetDevCaps interface NET_EXTERNALSENSOR_CAPS command parameter
typedef struct tagNET_OUT_EXTERNALSENSOR_CAPS
{
	DWORD								dwSize;
	BOOL								bIsSupport;					// whether to support external sensor data acquisition
	EM_SENSOR_NERWORKING_MODE			emNetworkingMode;			// external sensor networking
	int									nChannel;					// the maximum number of channels supported
}NET_OUT_EXTERNALSENSOR_CAPS;

// Wireless control work mode
typedef enum tagEM_WIRELESS_CTRL_WORK_MODE
{
    EM_WIRELESS_CTRL_WORK_MODE_UNKNOWN,                     // unknown
    EM_WIRELESS_CTRL_WORK_MODE_NORMAL,                      // Normal
    EM_WIRELESS_CTRL_WORK_MODE_POLLING,                     // Polling
} EM_WIRELESS_CTRL_WORK_MODE;


// info of event type DH_ALARM_REMOTE_CTRL_STATUS ( Wireless control work Event)
typedef struct tagALARM_REMOTE_CTRL_STATUS
{
    NET_TIME_EX              UTC;                            // time of Event 
    DWORD                    dwID;                           // control ID
    char                     szName[32];                     // Name
    char                     szUser[32];                     // User
    EM_WIRELESS_CTRL_WORK_MODE emMode;                       // Work mode
    BYTE                     reserved[1024];                 // reserved
} ALARM_REMOTE_CTRL_STATUS;

typedef enum tagEM_PASSENGER_CARD_CHECK_TYPE
{
    EM_PASSENGER_CARD_CHECK_TYPE_UNKOWN = 0,                // Unkown
    EM_PASSENGER_CARD_CHECK_TYPE_SIGNIN,                    // Signin
    EM_PASSENGER_CARD_CHECK_TYPE_SIGNOUT,                   // Signout
    EM_PASSENGER_CARD_CHECK_TYPE_NORMAL,                    // Normal
}EM_PASSENGER_CARD_CHECK_TYPE;

// The description information of event type DH_ALARM_PASSENGER_CARD_CHECK corresponding data block
typedef struct tagALARM_PASSENGER_CARD_CHECK
{
    BOOL                     bEventConfirm;                  // Need confirm or not
    char                     szCardNum[DH_MAX_BUSCARD_NUM];  // Buscard number
    NET_GPS_STATUS_INFO      stuGPS;                         // GPS information
    NET_TIME_EX              UTC;                            // Time of card check
    int                      nTime;                          // UTC time. unit:second 
    EM_PASSENGER_CARD_CHECK_TYPE    emType;                  // Type of card check
    char                     szMac[DH_MAX_POS_MAC_NUM];      // POS Mac code(default "0000")
    BYTE                     reserved[1012];                 // reserved
} ALARM_PASSENGER_CARD_CHECK;

// The description information of event type DH_ALARM_BUS_TIRED_DRIVE_CHECK corresponding data block
typedef struct tagALARM_TIRED_DRIVE_CHECK_INFO
{
    BOOL                     bEventConfirm;                  // Need confirm or not
    int                      nAction;                        // 0:Start, 1:Stop
    int                      nDriveTime;                     // Drive time     unit:minutes
    NET_GPS_STATUS_INFO      stuGPS;                         // GPS information
    NET_TIME_EX              UTC;                            // Time of the event happens
    int                      nTime;                          // Time of the event happens  UTC time. unit:second
    BYTE                     reserved[1024];                 // reserved
} ALARM_TIRED_DRIVE_CHECK_INFO;


// info of event type DH_ALARM_SOUND ( Sound Event)
typedef struct tagALARM_SOUND
{
    int                      nChannel;                       // Channel
    NET_TIME_EX              UTC;                            // Time
    BYTE                     reserved[1024];                 // reserved
} ALARM_SOUND;

// The input parameters of Sound Alarm parameter, corresponding to DH_CTRL_SET_SOUND_ALARM
typedef struct tagNET_IN_SOUND_ALARM
{
    DWORD                    dwSize;                 // struct size
} NET_IN_SOUND_ALARM;

// The output parameters of Set FishEye parameter, corresponding to DH_CTRL_SET_SOUND_ALARM
typedef struct tagNET_OUT_SOUND_ALARM
{
    DWORD                    dwSize;                 // struct size
} NET_OUT_SOUND_ALARM;

// the output channesl which should to be silenced
typedef struct tagNET_SILENCE_CHANNEL
{
	int				nMatrix;			// the index of matrix
	int				nOutChannel;		// the counts of  output channels which should to be  silenced
	int				nOutPutChannel[DH_MAX_AUDIO_MATRIX_OUTPUT];	// the output channels which should to be  silenced
	BYTE			bReserved[512];	
}NET_SILENCE_CHANNEL;

//Audio matrix silence input parameter
typedef struct tagNET_IN_AUDIO_MATRIX_SILENCE
{
	DWORD					dwSize;				// the data is sizeof(NET_IN_AUDIO_MATRIX_SILENCE)
	BOOL					bEnable;			// enbale(true:close voice     false:open voice)
	int						nListCount;			// the counts of  output channels lists which should to be  silenced
	NET_SILENCE_CHANNEL*	pstSlienceChannel;	// the output channels lists which should to be silenced,memory size is sizeof(NET_SILENCE_CHANNEL)*nListCount
} NET_IN_AUDIO_MATRIX_SILENCE;





//Audio matrix silence output parameter
typedef struct tagNET_OUT_AUDIO_MATRIX_SILENCE
{
	DWORD					dwSize;		//the data is sizeof(NET_OUT_AUDIO_MATRIX_SILENCE)
} NET_OUT_AUDIO_MATRIX_SILENCE;

// target type
typedef enum tagEM_TARGET_TYPE
{
    EM_TARGET_TYPE_CLIENT,              // "client"
    EM_TARGET_TYPE_FTP_SERVER,          // "FTPServer"
}EM_TARGET_TYPE;

// fliter info
typedef struct tagNET_MANUAL_UPLOAD_FILTER_INFO
{
    EM_TARGET_TYPE           emTargetType;                      //target type, "Client" , "FTPServer"
    char                     szClientIP[DH_MAX_IPADDR_LEN];     //client IP address
    NET_TIME                 stuStartTime;                      //snap picture start time
    NET_TIME                 stuEndTime;                        //snap picture end time
}NET_MANUAL_UPLOAD_FILTER_INFO;

// event type DH_CTRL_MANUAL_UPLOAD_PICTURE, description of input parameter
typedef struct tagNET_IN_MANUAL_UPLOAD_PICTURE
{
    DWORD                                 dwSize;             // structure size
    NET_MANUAL_UPLOAD_FILTER_INFO         stuFilter;          // manual upload filter       
}NET_IN_MANUAL_UPLOAD_PICTURE;

// event type DH_CTRL_MANUAL_UPLOAD_PICTURE, description of output parameter
typedef struct tagNET_OUT_MANUAL_UPLOAD_PICTURE
{
    DWORD					dwSize;		                    // structure size
}NET_OUT_MANUAL_UPLOAD_PICTURE;

// description of reboot network decoding device input parameter, corresponding command DH_CTRL_REBOOT_NET_DECODING_DEV
typedef struct tagNET_IN_REBOOT_NET_DECODING_DEV
{
    DWORD               dwSize;                                 // structure size, need to be assigned sizeof(NET_IN_REBOOT_NET_DECODING_DEV)
    char				szDeviceID[DH_COMMON_STRING_64];	    // device ID
    int                 nRebootDelayTime;                       // reboot delay time, unit: second
}NET_IN_REBOOT_NET_DECODING_DEV;

//  description of input parameter,corresponding interface CLIENT_SetDefenceArmMode
typedef struct tagNET_IN_SET_DEFENCEMODE
{
    DWORD                   dwSize;
    char                    szPassword[DH_COMMON_STRING_64];           // login password
    int                     nChannel;                                  // channel id
    EM_DEFENCEMODE          emDefenceMode;                             // work status
}NET_IN_SET_DEFENCEMODE;

// description of output parameter,corresponding interface CLIENT_SetDefenceArmMode
typedef struct tagNET_OUT_SET_DEFENCEMODE 
{
    DWORD                   dwSize;
}NET_OUT_SET_DEFENCEMODE;

// description of input parameter,corresponding interface CLIENT_SetSubSystemArmMode
typedef struct tagNET_IN_SET_SUBSYSTEMMODE 
{
    DWORD                   dwSize;
    int                     nChannel;                                  // subsystem id,start 0
    char                    szPassword[DH_COMMON_STRING_64];           // login password
    EM_DEFENCEMODE          emDefenceMode;                             // work status
}NET_IN_SET_SUBSYSTEMMODE;

// description of output parameter,corresponding interface CLIENT_SetSubSystemArmMode
typedef struct tagNET_OUT_SET_SUBSYSTEMMODE
{
    DWORD               dwSize;
    DWORD               dwSourceNum;                        // alarm source input arming failed subsystem number 
    int                 nSource[ARM_DISARM_ZONE_MAX];       // alarm source input failed subsystem no.,subsystem no. start from 0
    DWORD               dwLinkNum;                          // link alarm arming failed subsystem number 
    int                 nLink[ARM_DISARM_ZONE_MAX];         // link alarm failed subsystem no., subsystem no. start from 0
}NET_OUT_SET_SUBSYSTEMMODE;

// description of input parameter,corresponding interface CLIENT_GetDefenceArmMode
typedef struct tagNET_IN_GET_DEFENCEMODE
{
    DWORD                    dwSize;
    int                      nDefenceNum;                            // Zone valid number
    int                      anDefence[DH_MAX_ALARMIN];              // Zone number to search
}NET_IN_GET_DEFENCEMODE;

// description of output parameter,corresponding interface CLIENT_GetDefenceArmMode
typedef struct tagNET_OUT_GET_DEFENCEMODE
{
    DWORD                    dwSize;
    int                      nDefenceNum;                            // Zone valid number
    EM_DEFENCEMODE           anDefenceState[DH_MAX_ALARMIN];         // Zone status info
}NET_OUT_GET_DEFENCEMODE;

// description of input parameter,corresponding interface CLIENT_GetSubSystemArmMode
typedef struct tagNET_IN_GET_SUBSYSTEMMODE
{
    DWORD                    dwSize;
}NET_IN_GET_SUBSYSTEMMODE;

// description of output parameter,corresponding interface  CLIENT_GetSubSystemArmMode
typedef struct tagNET_OUT_GET_SUBSYSTEMMODE
{
    DWORD                    dwSize;
    int                      nSubSystemNum;                            //subsystem valid number
    EM_SUBSYSTEMMODE         anSubSystemState[DH_MAX_ALARM_SUBSYSTEM_NUM];         // subsystem state info
}NET_OUT_GET_SUBSYSTEMMODE;

// description of Input parameter, corresponding interface CLIENT_ManualCheckPSTN
typedef struct tagNET_IN_PSTN_MANUALCHECK_STATE
{
    DWORD                    dwSize;
}NET_IN_PSTN_MANUALCHECK_STATE;

// description of Output parameter, corresponding interface CLIENT_ManualCheckPSTN
typedef struct tagNET_OUT_PSTN_MANUALCHECK_STATE
{
    DWORD                    dwSize;
    NET_THREE_STATUS_BOOL    emState;            //result 
}NET_OUT_PSTN_MANUALCHECK_STATE;

// description of reboot network decoding device ouput parameter, corresponding command DH_CTRL_REBOOT_NET_DECODING_DEV
typedef struct tagNET_OUT_REBOOT_NET_DECODING_DEV
{
    DWORD					dwSize;		                    // structure size, need to be assigned sizeof(NET_OUT_REBOOT_NET_DECODING_DEV)
}NET_OUT_REBOOT_NET_DECODING_DEV;

// event type DH_ALARM_DRIVE_AFTER_WORK (not work time event) data description
// ParkingControl set IC Sender input parameter, corresponding command DH_CTRL_SET_IC_SENDER
typedef struct tagNET_IN_SET_IC_SENDER
{
	DWORD					dwSize;				// the data is sizeof(NET_IN_SET_IC_SENDER)
	BOOL					bEnable;			// enbale(true: send IC card is allowed, false: forbidden)
}NET_IN_SET_IC_SENDER;
// ParkingControl set IC Sender input parameter, corresponding command DH_CTRL_SET_IC_SENDER
typedef struct tagNET_OUT_SET_IC_SENDER
{
	DWORD					dwSize;				// the data is sizeof(NET_OUT_SET_IC_SENDER)
}NET_OUT_SET_IC_SENDER;
typedef struct tagALARM_DVRIVE_AFTER_WORK
{
    BOOL                     bEventConfirm;                  // need confirm or not
    NET_GPS_STATUS_INFO      stuGPS;                         // GPS
    NET_TIME_EX              stuUtc;                         // check time
    DWORD                    dwUtc;                          // check time, value equal to stuUtc, format different, used to confirm
    BYTE                     reserved[1024];                 // reserved
} ALARM_DVRIVE_AFTER_WORK;

// event type DH_ALARM_UPLOAD_PIC_FAILED (break rules data upload failed) data description
typedef struct tagALARM_UPLOAD_PIC_FAILED_INFO
{
    int                      nAction;                        // 0:upload failed, 1:upload success after failed
    BYTE                     reserved[1024];                 // reserved
} ALARM_UPLOAD_PIC_FAILED_INFO;

// get city and road code info, CLIENT_QueryDevState, DH_DEVSTATE_GET_ROAD_LIST
typedef struct tagNET_ROAD_LIST_INFO
{
    DWORD                    dwSize;                 // structure size
    char                     szCity[32];             // city
    char                     szRoadList[2048][256];  // road code
    int                      nRoadNum;               // number of road code, first dimension of szRoadList
} NET_ROAD_LIST_INFO;

// wireless device type
typedef enum tagEM_WIRELESS_DEV_TYPE
{
    EM_WIRELESS_DEV_TYPE_UNKNOWN,                            // unknown
    EM_WIRELESS_DEV_TYPE_STATION,                            // "Station"
    EM_WIRELESS_DEV_TYPE_AP,                                 // "AccessPoint"
} EM_WIRELESS_DEV_TYPE;

// wireless authentication
typedef enum tagEM_WIRELESS_AUTHENTICATION
{
    EM_WIRELESS_AUTHENTICATION_UNKNOWN,                             // UnKnown
    EM_WIRELESS_AUTHENTICATION_OPEN,                                // OPEN
    EM_WIRELESS_AUTHENTICATION_SHARED,                              // SHARED
    EM_WIRELESS_AUTHENTICATION_WPA,                                 // WPA
    EM_WIRELESS_AUTHENTICATION_WPAPSK,                              // WPA-PSK
    EM_WIRELESS_AUTHENTICATION_WPA2,                                // WPA2
    EM_WIRELESS_AUTHENTICATION_WPA2PSK,                             // WPA2-PSK
    EM_WIRELESS_AUTHENTICATION_WPANONE,                             // WPA-NONE
    EM_WIRELESS_AUTHENTICATION_WPAPSK_WPA2PSK,                      // WPA-PSK|WPA2-PSK
    EM_WIRELESS_AUTHENTICATION_WPA_WPA2,                            // WPA|WPA2
    EM_WIRELESS_AUTHENTICATION_WPA_WPAPSK,                          // WPA | WPA-PSK
    EM_WIRELESS_AUTHENTICATION_WPA2_WPA2PSK,                        // WPA2|WPA2-PSK
    EM_WIRELESS_AUTHENTICATION_WPA_WPAPSK_WPA2_WPA2PSK,             // WPA|WPA-PSK|WPA2|WPA2-PSK
} EM_WIRELESS_AUTHENTICATION;

// Wireless data encryption 
typedef enum tagEM_WIRELESS_DATA_ENCRYPT
{
    EM_WIRELESS_DATA_ENCRYPT_UNKNOWN,                            // UnKnown
    EM_WIRELESS_DATA_ENCRYPT_NONE,                               // NONE
    EM_WIRELESS_DATA_ENCRYPT_WEP,                                // WEP
    EM_WIRELESS_DATA_ENCRYPT_TKIP,                               // TKIP
    EM_WIRELESS_DATA_ENCRYPT_AES,                                // AES(CCMP)
    EM_WIRELESS_DATA_ENCRYPT_TKIP_AES,                           // TKIP+AES
} EM_WIRELESS_DATA_ENCRYPT;

// wifi device info
typedef struct tagNET_WIFI_DEV_INFO
{
    char                     szMac[DH_MACADDR_LEN];          // mac address of wifi device
    int                      nLinkQuality;                   // link quality, 0~100
    NET_TIME_EX              stuEnterTime;                   // first searched time
    NET_TIME_EX              stuLeaveTime;                   // leave time
    int                      nSearchedCount;                 // searched count
    char                     szSSID[24];                     // SSID
    NET_TIME_EX              UTC;                            // event time
    EM_WIRELESS_DEV_TYPE     emDevType;                      // WIFI dev type
    int                      nChannel;                       // Wifi channel
    EM_WIRELESS_AUTHENTICATION emAuth;                       // authentication
    EM_WIRELESS_DATA_ENCRYPT emEncrypt;                      // data encrypt
    char                     szAPMac[DH_MACADDR_LEN];        // AP Mac
    int                      nAPChannel;                     // AP channel
    char                     szAPSSID[24];                   // AP SSID
    EM_WIRELESS_DATA_ENCRYPT emAPEncrypt;                    // AP data encrypt
	int						 nRssiQuality;                   // Signal strength
	char					 szManufacturer[MAX_MANUFACTURER_LEN];			// Manufacturer of mac address
	char					 szMacHistorySSID[MAX_MACHISTORY_SSID_NUM][MAX_MACHISTORY_SSID_LEN];     // History SSID list
	unsigned int			 nRetMacHistorySSIDNum;			 // actual num of mac history SSID
    BYTE                     reserved[264];                  // reserved
} NET_WIFI_DEV_INFO;

// basic wifi info
typedef struct tagNET_WIFI_BASIC_INFO
{
	UINT nPeriodUTC;      //start time of this notification period, indicates the same period; if device number notified in one notification is over the max value,several notification is needed.this value indicates the same notification period.
	int  nDeviceSum;      //the device sum notified during this period,several notifications during the same period have the same value. 
	int  nCurDeviceCount; //device number in one notification,the value should be the same as nWifiNum in struct ALARM_WIFI_SEARCH_INFO,several notifications during the same period sum up to nCurDeviceCount
	BYTE reserved[500];   //reserved
}NET_WIFI_BASIC_INFO;

// result of positioning
typedef enum tagNET_GPS_POSITION_RESULT
{				
	NET_GPS_POSITION_RESULT_UNKNOWN = 0,					// unknown
	NET_GPS_POSITION_RESULT_FAILED = 1,						// has GPS data,but orientation failed,data is inefficacy
	NET_GPS_POSITION_RESULT_SUCCEED = 2,					// has GPS data,and orientation succeed,data is efficacious
}NET_GPS_POSITION_RESULT;

// wifi place info
typedef struct tagNET_WIFI_GPS_INFO
{
	NET_GPS_POSITION_RESULT			emPositioningResult;	// result of positioning
	unsigned int					nLongitude;				// Longitude(unit:1/1000000 degree)
															// west Longitude: 0 - 180000000				practical value = 180*1000000 - dwLongitude
															// east Longitude: 180000000 - 360000000		practical value = dwLongitude - 180*1000000
															// eg: Longitude:300168866 (300168866 - 180*1000000)/1000000  equal east Longitude 120.168866 degree
	unsigned int					nLatidude;				// Latidude(unit:1/1000000 degree)
															// north Latidude: 0 - 90000000				practical value = 90*1000000 - dwLatidude
															// south Latidude: 90000000 - 180000000	practical value = dwLatidude - 90*1000000
															// eg: Latidude:120186268 (120186268 - 90*1000000)/1000000 equal south Latidude 30. 186268 degree
	unsigned int					nSpeed;					// speed(unit:0.001km/H)
	BYTE							reserved[112];			// reserved
}NET_WIFI_GPS_INFO;

// event type DH_ALARM_WIFI_SEARCH (search WIFI device) data description
typedef struct tagALARM_WIFI_SEARCH_INFO
{
    int                      nWifiNum;                       // WIFI number, indicate valid object in stuWifi
    NET_WIFI_DEV_INFO        stuWifi[1024];                  // wifi device info
	int                      nChannel;                       // channel 
	NET_WIFI_BASIC_INFO      stuWifiBasiInfo;				 // Wifi event basic info
	BOOL					 bGPSinfo;						 // is include GPS info 
	NET_WIFI_GPS_INFO		 stuWifiGPSInfo;				 // GPS info
    BYTE                     reserved[376];                  // reserved
} ALARM_WIFI_SEARCH_INFO;


// WIFI virtual informaion
typedef struct tagNET_WIFI_VIRTUALINFO
{
	NET_TIME_EX				stuAccessTime;								// access time, not accurate, just for your reference
	char					szSrcMac[DH_MACADDR_LEN];					// source MAC of virtual information,shown in capital letters,seperated by "-" 
    char					szDstMac[DH_MACADDR_LEN];					// destination MAC of virtual information,shown in capital letters,seperated by "-" 
	int						nProtocal;									// protocal code, which signals corresponding apps
	char					szUrl[DH_MAX_URL_LEN];						// url
	char					szDomain[MAX_VIRTUALINFO_DOMAIN_LEN];		// domain
	char					szTitle[MAX_VIRTUALINFO_TITLE_LEN];			// net title
	char					szUsrName[MAX_VIRTUALINFO_USERNAME_LEN];	// username
	char					szPassWord[MAX_VIRTUALINFO_PASSWORD_LEN];	// password
	char					szPhoneNum[MAX_VIRTUALINFO_PHONENUM_LEN];	// telephone number
	char					szImei[MAX_VIRTUALINFO_IMEI_LEN];			// international mobile device indicator
	char					szImsi[MAX_VIRTUALINFO_IMSI_LEN];			// international mobile user indicator
	char					szLatitude[MAX_VIRTUALINFO_LATITUDE_LEN];	// latitude
	char					szLongitude[MAX_VIRTUALINFO_LONGITUDE_LEN];	// longitude
	char					szSrcIP[DH_MAX_IPADDR_LEN_EX];				// source IP
	char					szDstIP[DH_MAX_IPADDR_LEN_EX];				// destination IP
	UINT					nSrcPort;									// source port 
	UINT					nDstPort;									// destination port
    char                    szSiteNum[MAX_COMMON_STRING_16];            // site number
    char                    szDevNum[MAX_COMMON_STRING_32];             // device Number
    char                    szUserID[MAX_COMMON_STRING_32];             // fictitious user ID
    char                    szIDFA[MAX_COMMON_STRING_64];               // IDFA of iphone
	BYTE                    reserved[368];								// reserved
}NET_WIFI_VIRTUALINFO;

// event type DH_ALARM_WIFI_VIRTUALINFO_SEARCH (search wifi virtual information)data description
typedef struct tagALARM_WIFI_VIRTUALINFO_SEARCH_INFO
{
    int                      nVirtualInfoNum;                // number of wifi virtual information,indicates valid number of stuVirtualInfo
    NET_WIFI_VIRTUALINFO     stuVirtualInfo[MAX_VIRTUALINFO_NUM];           // wifi virtual information
	int                      nChannel;                       // channel number
    BYTE                     reserved[512];                  // reserved
} ALARM_WIFI_VIRTUALINFO_SEARCH_INFO;

// event type DH_ALARM_USER_LOCK_EVENT (User Lock Alarm Event)data description
typedef struct tagALARM_USER_LOCK_EVENT_INFO
{	
    char                    szUser[DH_NEW_USER_NAME_LENGTH];       // user  name
	char					szGroup[DH_NEW_USER_NAME_LENGTH];	   // group name
	char                    szIP[DH_MAX_IPADDR_LEN_EX];            // device IP
	BYTE                    reserved[512];						   // reserved 
} ALARM_USER_LOCK_EVENT_INFO;

//wirelesstype
typedef enum tagNET_WIRELESSDEV_LOWPOWER_TYPE
{
    NET_WIRELESSDEV_UNKNOWN = 0,                                // unknowndevice
    NET_WIRELESSDEV_CONTROL = 1,                                // wirelesscontrol
    NET_WIRELESSDEV_DEFENCE = 2,                                // wirelessdefence
    NET_WIRELESSDEV_KEYBOARD = 3,                               // wirelessKeyBoard
    NET_WIRELESSDEV_MAGNETOMER = 4,                             // wirelessMagnetomer
	NET_WIRELESSDEV_ALARMBELL = 5,								// wirelessAlarmBell
    NET_WIRELESSDEV_SMARTLOCK = 6,                              // smartlock
} NET_WIRELESSDEV_LOWPOWER_TYPE;

//report event of lowpower wireless
typedef struct tagALARM_WIRELESSDEV_LOWPOWER_INFO
{
    NET_THREE_STATUS_BOOL         emResult;                  // lowpower event:true lowpower,false narmal, unknown Unknown
    NET_TIME                      stuTime;                   // event time
    int                           nId;                       // wirelessdevice ID
    NET_WIRELESSDEV_LOWPOWER_TYPE emType;                    // wirelessdevice type
    char                          szSN[32];                  // wirelessdevice Serial Number
    float                         fPercent;                  // battery percentage
    BYTE                          reserved[988];             // reserved
} ALARM_WIRELESSDEV_LOWPOWER_INFO;

// event type DH_ALARM_BUS_PAD_SHUTDOWN(PAD shut down event) data description
typedef struct tagALARM_BUS_PAD_SHUTDOWN_INFO
{
    int                nDelayTime;                      // delay time for shut down, unit: sec
    BOOL               bConfirm;                        // need confirme to shut down, TRUE: yes, FALSE: no
    NET_TIME_EX        stuUtcTime;                      // event time
    DWORD              dwUtc;                           // event time, for confirm
    BYTE               byReserved[512];                 // revervsed
} ALARM_BUS_PAD_SHUTDOWN_INFO;

// heat picture data type
typedef enum tagEM_HEAT_PIC_DATA_TYPE
{
	EM_HEAT_PIC_DATA_TYPE_UNKNOWN,					// Unknown
	EM_HEAT_PIC_DATA_TYPE_GRAYDATA,					// Gray data
	EM_HEAT_PIC_DATA_TYPE_SOURCEDATA,				// Source data
}EM_HEAT_PIC_DATA_TYPE;
// get heatmap information, input arguments
typedef struct tagNET_IN_QUERY_HEAT_MAP
{
    int                      nChannel;                       // channel id
    NET_TIME_EX              stuBegin;                       // begin time
    NET_TIME_EX              stuEnd;                         // end time
    UINT                     nPlanID;                        // Plan ID,Speed Dome use,start from 1, (used before unification of heat map, byPtzPresetID is used after unification of heat map)
	EM_HEAT_PIC_DATA_TYPE	 emDataType;					 // Desired Data type
	BYTE                     byPtzPresetID;                  // PTZ preset ID, used after unification of heat map
    BYTE                     reserved[1015];                 // reserved
} NET_IN_QUERY_HEAT_MAP;

// get heatmap information, output arguments
typedef struct tagNET_OUT_QUERY_HEAT_MAP
{
    int                      nWidth;                         // picture width
    int                      nHeight;                        // picture height
    char *                   pBufData;                       // heatmap picture data, user alloc this memory, size is nBufLen
															 // if emDataType is EM_HEAT_PIC_DATA_TYPE_GRAYDATA,a Byte means a point
															 // if emDataType is EM_HEAT_PIC_DATA_TYPE_SOURCEDATA,four Bytes mean a point
    int                      nBufLen;                        // pBufData max len
    int                      nBufRet;                        // data len
    int                      nAverage;                       // average info
    UINT					 nPlanID;						 // plan id, (used before unification of heat map, byPtzPresetID is used after unification of heat map)
	EM_HEAT_PIC_DATA_TYPE	 emDataType;					 // Obtained Data type
	UINT					 nPixelMax;						 // Max pixel value
	UINT					 nPixelMin;						 // Min pixel value
	BYTE                     byPtzPresetID;                  // PTZ preset ID, corresponding to byPtzPresetID in NET_IN_QUERY_HEAT_MAP, used after unification of heat map
    BYTE                     reserved[1003];                 // reserved
} NET_OUT_QUERY_HEAT_MAP;

// get heatmap information, type DH_DEVSTATE_GET_HEAT_MAP
typedef struct tagNET_QUERY_HEAT_MAP
{
    DWORD                    dwSize;                         // size of this structure
    NET_IN_QUERY_HEAT_MAP    stuIn;                          // heatmap search condition
    NET_OUT_QUERY_HEAT_MAP   stuOut;                         // heatmap search result
} NET_QUERY_HEAT_MAP;

//input parameter when getting GPS information
typedef struct tagNET_IN_DEV_GPS_INFO
{
	DWORD                    dwSize;                         // size of NET_IN_DEV_GPS_INFO
    int                      nChannel;                       // device channel number
} NET_IN_DEV_GPS_INFO;

//GPS work state
typedef enum tagNET_GPS_WORK_STATUS
{
	EM_WORK_STATE_UNKNOWN = 0,			//unknown work status
	EM_NO_POSITIONING,					//no positioning
	EM_NO_DIFFERENTIAL_POSITIONING,		//not differential positioning
	EM_DIFFERENTIAL_POSITIONING,		//differential positioning
	EM_INVALID_PPS,						//invalid PPS
	EM_EVALUATING,						//evalusting
}NET_GPS_WORK_STATUS;

typedef struct tagNET_OUT_DEV_GPS_INFO
{
	DWORD                   dwSize;                          // size of NET_OUT_DEV_GPS_INFO
    NET_TIME				stuLocalTime;                    // current time
	double                  dbLongitude;                     // longtitude(unit:1/1000000 degree, range:0-360 degree)
    double                  dbLatitude;                      // latitude(unit:1/1000000 degree, range:0-180 degree)
	double                  dbAltitude;                      // altitude(unit:metre)
	double                  dbSpeed;                         // speed(unit:km/H)
	double                  dbBearing;                       // bearing angle(unit:degree)
	NET_THREE_STATUS_BOOL   emAntennasStatus;				 // antennas status(0:bad 1:good)
	NET_THREE_STATUS_BOOL   emPositioningResult;             // fix a position or not(0:no 1:yes)
	DWORD					dwSatelliteCount;				 // count of satellites
	NET_GPS_WORK_STATUS     emworkStatus;                    // work state
	int                     nAlarmCount;					 // count of alarm
	int                     nAlarmState[128];                // places that alarm occur,maybe multiple values
	float					fHDOP;							 // horizontal precision factor
} NET_OUT_DEV_GPS_INFO;

// GPS status info
typedef struct tagNET_SET_GPS_STATUS_INFO
{
	EM_DATE_SOURCE          emDateSource;						// date source
	NET_TIME				stuLocalTime;						// current time
	double                  dbLongitude;						// longtitude(unit: degree, range:0-360 degree)
    double                  dbLatitude;							// latitude(unit: degree, range:0-180 degree)
	double                  dbAltitude;							// altitude(unit:metre)
	double                  dbSpeed;							// speed(unit:km/H)
	double                  dbBearing;							// bearing angle(unit:degree)
	NET_THREE_STATUS_BOOL   emAntennasStatus;					// antennas status(0:bad 1:good)
	NET_THREE_STATUS_BOOL   emPositioningResult;				// fix a position or not(0:no 1:yes)
	int						nSatelliteCount;					// count of satellites
	NET_GPS_WORK_STATUS     emWorkStatus;						// work state
	int                     nAlarmCount;						// count of alarm
	int                     nAlarmState[128];					// places that alarm occur,maybe multiple values
	double					dbHDOP;								// horizontal precision factor
	BYTE					byReserved[1024];					// Reserved byte
} NET_SET_GPS_STATUS_INFO;

// CLIENT_SetGPSStatus interface paramter input
typedef struct tagNET_IN_SET_GPS_STATUS
{
	DWORD						dwSize;								
	BOOL						bEnable;						// whether use setup data
	int							nChannel;						// channel
	NET_SET_GPS_STATUS_INFO		stGPSInfo;						// GPS status info
} NET_IN_SET_GPS_STATUS;

// CLIENT_SetPositionStatus interface paramter output
typedef struct tagNET_OUT_SET_GPS_STATUS
{
	DWORD					dwSize;								
} NET_OUT_SET_GPS_STATUS;

// set GPS status information
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetGPSStatus(LLONG lLoginID, const NET_IN_SET_GPS_STATUS* pInParam, NET_OUT_SET_GPS_STATUS* pOutParam, int nWaitTime);

// Query IVS related remote device information input parameter
typedef struct tagNET_IN_IVS_REMOTE_DEV_INFO
{
    DWORD                   dwSize;                         // size of this structure
    int                     nChannel;                       // channel
}NET_IN_IVS_REMOTE_DEV_INFO;

// Query IVS related remote device information output parameter
typedef struct tagNET_OUT_IVS_REMOTE_DEV_INFO
{
    DWORD                   dwSize;                         // size of this structure
    int                     nPort;                          // device port
    char                    szIP[64];                       // device ip   
    char                    szUser[64];                     // user name
    char                    szPassword[64];                 // password
    char                    szAddress[128];	                // deployment address of equipment
}NET_OUT_IVS_REMOTE_DEV_INFO;

// Query smart switch information input parameter
typedef struct tagNET_IN_SMART_SWITCH_INFO
{
    DWORD                   dwSize;                         // size of this structure
    char                    szSerialNumber[DH_WIRELESS_DEVICE_SERIAL_NUMBER_MAX_LEN]; // serial number of device
}NET_IN_SMART_SWITCH_INFO;

// Query smart switch information output parameter
typedef struct tagNET_OUT_SMART_SWITCH_INFO
{
    DWORD                   dwSize;                         // size of this structure
    BOOL                    bSwitchEable;                   // switch state , TRUE - on, FALSE - off
    double                  dbCurrentPower;                 // current power, unit: W 
    double                  dbHistoryPowerUsed;             // history power used, unit: kw/h
    double                  dbTodayPowerUsed;               // today power used, unit: kw/h
    double                  dbMonthPowerUsed[NET_MAX_MONTH_NUM]; // month power userd, unit: kw/h
}NET_OUT_SMART_SWITCH_INFO; 

// Query upgrade-state input parameter
typedef struct tagNET_IN_UPGRADE_STATE
{
    DWORD                   dwSize;                         // size of this structure
}NET_IN_UPGRADE_STATE;

// stream type
typedef enum tagCFG_EM_STREAM_TYPES
{
	CFG_EM_STREAMTYPE_ERR,                  // other
	CFG_EM_STREAMTYPE_MAIN,					// "Main"-main stream
	CFG_EM_STREAMTYPE_EXTRA_1,				// "Extra1"-sub stream1
	CFG_EM_STREAMTYPE_EXTRA_2,				// "Extra2"-sub stream2
	CFG_EM_STREAMTYPE_EXTRA_3,				// "Extra3"-sub stream3
	CFG_EM_STREAMTYPE_SNAPSHOT,				// "Snapshot"-snap stream
	CFG_EM_STREAMTYPE_TALKBACK,				// "Talkback"-talk stream
}CFG_EM_STREAM_TYPES;

// query video encode caps input parameters
typedef struct tagNET_IN_VIDEO_ENCODE_CAPS
{
	DWORD					dwSize;                         // structure size
	int						nChannel;						// channel NO.
	int						nGroup;							// group NO.
	CFG_EM_STREAM_TYPES		stStreamType;					// stream type
}NET_IN_VIDEO_ENCODE_CAPS;

// query video encode caps output parameters
typedef struct tagNET_OUT_VIDEO_ENCODE_CAPS
{
	DWORD					dwSize;																// structure size
	int						nSvcEncodeTypesNum;													// number of video formats which supports SVC encode
	char					szSvcEncodeTypes[DH_COMMON_STRING_32][DH_COMMON_STRING_32];			// formats which supports SVC encode
	int						nGOPCustomEncodesNum;												// number of streams which supports self-defined I frames gap
	char					szGOPCustomEncodes[DH_COMMON_STRING_32][DH_COMMON_STRING_32];		// streams which supports self-defined I frames gap
	int						nMaxSVCTLevel;														// max number of level which SVC-T supports
}NET_OUT_VIDEO_ENCODE_CAPS;

// query audio encode caps input parameters
typedef struct tagNET_IN_AUDIO_ENCODE_CAPS
{
	DWORD					dwSize;                         // structure size
	int						nChannel;						// channel NO.
	CFG_EM_STREAM_TYPES		stStreamType;					// stream type
}NET_IN_AUDIO_ENCODE_CAPS;

// query audio encode caps output parameters
typedef struct tagNET_OUT_AUDIO_ENCODE_CAPS
{
	DWORD					dwSize;														// structure size
	BOOL					bSupportSourceSelect;										// support multiple audio inputs or not
	int						nSourceTypeNum;												// audio resource type number
	char					szSourceType[DH_COMMON_STRING_32][DH_COMMON_STRING_32];		// audio resource type list
}NET_OUT_AUDIO_ENCODE_CAPS;

// query audio input channel caps input parameters
typedef enum tagEM_AUDIO_DATA_SOURCE_TYPE
{
	EM_AUDIO_DATA_SOURCE_TYPE_UNKNOWN = -1,		// unkonwn data type
	EM_AUDIO_DATA_SOURCE_TYPE_TALK,				// talk data
	EM_AUDIO_DATA_SOURCE_TYPE_NORMAL,			// normal audio data
	EM_AUDIO_DATA_SOURCE_TYPE_ALARM,			// alarm audio data
}EM_AUDIO_DATA_SOURCE_TYPE;
typedef struct tagNET_IN_AUDIO_DECODE_CAPS
{
	DWORD								dwSize;                         // struct sizeassigned to sizeof(NET_IN_AUDIO_DECODE_CAPS)
	int									nChannel;						// channel id
	EM_AUDIO_DATA_SOURCE_TYPE			emSourceType;					// data type
}NET_IN_AUDIO_DECODE_CAPS;
typedef struct tagNET_AUDIO_DECODE_FORMAT
{	
	NET_EM_AUDIO_FORMAT			emCompression;				// audio decode type
	int							nFrequency;					// sample frequency:8k ~ 192K
	int							nDepth;						// sample depth:8,16,24
	int							nPacketPeriod;				// packet period, [10, 250],ms
	BYTE						szReserved[512];			// reserved
}NET_AUDIO_DECODE_FORMAT;
typedef struct tagNET_OUT_AUDIO_DECODE_CAPS
{
	DWORD					dwSize;							// struct sizeassigned to sizeof(NET_OUT_AUDIO_DECODE_CAPS)
	NET_AUDIO_DECODE_FORMAT	stuDecodeFormats[64];			// audio decode info		
	int						nFormatsRet;					// audio decode number returned
}NET_OUT_AUDIO_DECODE_CAPS;

// Get arm mode input parameters
typedef struct tagNET_IN_GET_ARM_MODE
{
    DWORD                   dwSize;                         // struct size, assigned to sizeof(NET_IN_GET_ARM_MODE)
}NET_IN_GET_ARM_MODE;

// arm mode
typedef enum tagEM_ARM_MODE_MODE
{
    EM_ARM_MODE_MODE_UNKNOWN,                               // unknown
    EM_ARM_MODE_MODE_ARMING,                                // arming
    EM_ARM_MODE_MODE_DISARMING,                             // disarming
}EM_ARM_MODE_MODE;

// Get arm mode output parameters
typedef struct NET_OUT_GET_ARM_MODE
{
    DWORD                   dwSize;                         // struct size, assigned to sizeof(NET_OUT_GET_ARM_MODE)
    int                     nDelay;                         // delay
    EM_ARM_MODE_MODE        emMode;                         // arm mode
    BYTE                    byReserved[4];                  // reserved
}NET_OUT_GET_ARM_MODE;

typedef struct tagNET_IN_AUDIO_IN_CAPS
{
	DWORD					dwSize;                         // structure size
	int						nChannel;						// channel NO.
}NET_IN_AUDIO_IN_CAPS;

//  query audio input channel caps output parameters
typedef struct tagNET_IN_AUDIO_OUT_CAPS
{
	DWORD					dwSize;                         // structure size
	int						nMicNum;						// input mic number,>0 means supports talk input
	int						nLineInNum;						// input line number,>0 mean backing track input
}NET_OUT_AUDIO_IN_CAPS;

// Smart encode information
typedef struct tagSMART_ENCODE_INFO
{
	DWORD					dwSize;							    // structure size
	char					szCompression[MAX_COMMON_STRING_8]; // video encode format,as "H.264", "H.265"
	int						nPolicy;						    // Smart encode strategy
	bool					bEnable;						    // stream enable or not
	int						nWidth;							    // video width, optional
	int						nHeight;						    // video height, optional
	float					fFPS;							    // video frame rate, optional
}SMART_ENCODE_INFO;

// query Smart encode caps input parameters
typedef struct tagNET_IN_SMART_ENCODE_CAPS
{
	DWORD					dwSize;								// structure size
	int						nChannel;							// channel NO.
	int						nStreamNum;							// actural stream NO.
	SMART_ENCODE_INFO		stSmartEncodeInfo[MAX_STREAM_NUM];  // Smart encode information of each stream,if stream NO. is 3,array index 012 presents the encode information of main streamsub stream1sub stream2
}NET_IN_SMART_ENCODE_CAPS;

// Smart encode caps
typedef struct tagSMART_ENCODE_CAPS_INFO
{
	DWORD					dwSize;																// structure size
	int						nSmartEncodeCap;													// 1: supports open encode locate P frame function; 1: not support Smart encode; 2: not support encode
	
}SMART_ENCODE_CAPS_INFO;

//query Smart encode caps output parameters
typedef struct tagNET_OUT_SMART_ENCODE_CAPS
{
	DWORD						dwSize;																// structure size
	int							nSmartEncodeCapsNum;												// Smart encode caps group number
	SMART_ENCODE_CAPS_INFO		stSmartEncodeCaps[MAX_STREAM_NUM];									// encode caps of ezch stream smart encode information
}NET_OUT_SMART_ENCODE_CAPS;

// query Device ID input parameters
typedef struct tagNET_IN_DEVICE_ID
{
	DWORD						dwSize;																// struct size
}NET_IN_DEVICE_ID;

// query Device ID input parameters
typedef struct tagNET_OUT_DEVICE_ID
{
	DWORD						dwSize;																// struct size
	char						szDeviceID[48];														// device id
}NET_OUT_DEVICE_ID;

// uprade packege type
typedef enum tagEM_UPGRADE_PACKAGE_TYPE
{
    EM_UPGRADE_PACKAGE_TYPE_UNKNOWN,                                // unknown 
    EM_UPGRADE_PACKAGE_TYPE_REGULAR,                                // regular
    EM_UPGRADE_PACKAGE_TYPE_EMERGENCY,                              // emergency
}EM_UPGRADE_PACKAGE_TYPE;

// uprade package and uprade state
typedef enum tagEM_UPGRADE_STATE
{
    EM_UPGRADE_STATE_UNKNOWN,                               // unknown
    EM_UPGRADE_STATE_NONE,                                  // check none
    EM_UPGRADE_STATE_INVALID,                               // package invalid
    EM_UPGRADE_STATE_NOT_ENOUGH_MEMORY,                     // out of memory
    EM_UPGRADE_STATE_DOWNLOADING,                           // downloading package
    EM_UPGRADE_STATE_DOWNLOAD_FAILED,                       // download failed
    EM_UPGRADE_STATE_DOWNLOAD_SUCCESSED,                    // download successed
    EM_UPGRADE_STATE_PREPARING,                             // preparing
    EM_UPGRADE_STATE_UPGRADING,                             // upgrading
    EM_UPGRADE_STATE_UPGRADE_FAILED,                        // upgrade failed
    EM_UPGRADE_STATE_UPGRADE_SUCCESSED,                     // upgrade successed
    EM_UPGRADE_STATE_UPGRADE_CANCELLED,                     // upgrade cancelled
	EM_UPGRADE_STATE_FILE_UNMATCH,                          // file unmatch
}EM_UPGRADE_STATE;

// event of deivce upgrade
typedef struct tagALARM_UPGRADE_STATE
{
    EM_UPGRADE_STATE        emState;                        // uprade package and uprade state
    int                     nProgress;                      // upgrade progress, 0 ~ 100
    char                    szFileName[DH_COMMON_STRING_64];// upgrading file name
    BYTE		            byReserved[1024];
}ALARM_UPGRADE_STATE;

typedef enum tagEM_LABELDATA_STATE
{
	EM_LABELDATA_STATE_ENTER,									 // Enter
	EM_LABELDATA_STATE_LEAVE,									 // Leave
}EM_LABELDATA_STATE;

// IPC added new(2017.4),RFID tag information acquisition event 
typedef struct tagALARM_LABELINFO
{
	int						nChannelID;							// channel ID
	char					szIndexIs[DH_COMMON_STRING_8];		// The meaning of the event index representation, such as no field, cannot be cascaded
	int						nVideoIndex;						// Video channel
	UINT					nACK;								// Confirm ID. 
	char					szReceiverID[DH_COMMON_STRING_16];	// Receiver ID 
	char					szLabelID[DH_COMMON_STRING_16];		// RFID Label
	NET_TIME_EX				stuDateTime;						// Acquisition time UTC
	EM_LABELDATA_STATE		emLabelDataState;					// Label Data StateEnterLeave
	BYTE					byReserve[1024];					// reserve
}ALARM_LABELINFO;

// Query upgrade-state output parameter
typedef struct tagNET_OUT_UPGRADE_STATE
{
    DWORD                   dwSize;                         // size of this structure
    char                    szOldVersion[DH_COMMON_STRING_64]; 	// old version
    char                    szNewVersion[DH_COMMON_STRING_64];  // new version
    EM_UPGRADE_STATE        emState;                        // upgrade package and upgrade state
    EM_UPGRADE_PACKAGE_TYPE emType;                         // upgrade package type
    int                     nProgress;                      // progress of upgrading 0 - 100
}NET_OUT_UPGRADE_STATE;

//query hard disk temperature input parameter
typedef struct tagNET_IN_HDD_TEMPERATURE
{
	DWORD					dwSize;
	char					szHardDiskName[DH_COMMON_STRING_16];		// hard disk name
	
}NET_IN_HDD_TEMPERATURE;

//query hard disk temperature output parameter
typedef struct tagNET_OUT_HDD_TEMPERATURE
{
	DWORD					dwSize;
	int						nID;										// attribute ID
	char					szName[DH_COMMON_STRING_64];				// attribute name
	int						nCurrent;									// attribute value
	int						nWorst;										// maximum error value
	int						nThreshold;									// threshod
	char					szRaw[DH_COMMON_STRING_32];					// actual value
	int						nPredict;									// state
	int						nSync;										// synchronization status,0 is adaptive;1 is synchronous priority, I/O priority to raid synchronous; 
																		// 2 is business priority, I/O priority to the hard disk to write data; 3 is balanced
}NET_OUT_HDD_TEMPERATURE;

// Get the YUV data input parameter in the specified format 
typedef struct tagNET_IN_RAWFRAMEDATA
{
	DWORD					dwSize;										
	int						nChannel;									// video input channel
	int						nSensorID;									// sensor ID
	char					szRawFrameType[DH_COMMON_STRING_32];		// YUV data format, The supported scope is obtained through the CLIENT_GetDevCaps function, NET_VIDEOIN_RAWFRAME_CAPS;
}NET_IN_RAWFRAMEDATA;

// Get the YUV data output parameter in the specified format
typedef struct tagNET_OUT_RAWFRAMEDATA
{
	DWORD					dwSize;
	UINT					nHeight;									// The height of the image returned
	UINT					nWidth;										// the width of the image returned
	UINT					nDataLen;									// YUV binary datauint: byte
	char*					pszBuffer;									// YUV binary dataThe user applies for memorynBufferLen
	int						nBufferLen;									// User application memory size
}NET_OUT_RAWFRAMEDARA;

#define NET_MAX_NUM_CHANNEL_WATCHER 16     // the max channel number of the watcher
#define NET_MAX_NUM_SPLICEDATA 8           // the max splice data(sensor) number of the watcher

// get device splice data input param (according to NET_QUERY_GETSPLICEDATA)
typedef struct tagNET_IN_GETSPLICEDATA
{
	DWORD					dwSize;                                     // structure size
}NET_IN_GETSPLICEDATA;

// single splice data
typedef struct tagNET_SINGLE_SPLICEDATA
{
	int                     nScale;                                     // the scale of spherical model in splice data, unit:pixel
	int                     nOffsetX;                                   // the Offset_x of image is on the spherical expansion diagram, unit:pixel
	int                     nOffsetY;                                   // the Offset_y of image is on the spherical expansion diagram, unit:pixel
    BYTE                    byReserved[128];                            // reserved
}NET_SINGLE_SPLICEDATA;

// single channel splice data
typedef struct tagNET_MULTIVIDEO_SPLICEINFO
{
	UINT                    nChannelID;                                 // channel ID
	int                     nNumSplice;                                 // the num of splice data
	NET_SINGLE_SPLICEDATA   stuSpliceData[NET_MAX_NUM_SPLICEDATA];      // single splice data
	BYTE                    byReserved[512];                            // reserved
}NET_MULTIVIDEO_SPLICEINFO;

// get device splice data output param (according to NET_QUERY_GETSPLICEDATA)
typedef struct tagNET_OUT_GETSPLICEDATA
{
	DWORD					dwSize;                                     // structure size
	int                     nNumChannel;                                // the num of channel
	NET_MULTIVIDEO_SPLICEINFO   stuSpliceInfo[NET_MAX_NUM_CHANNEL_WATCHER];      // channel splice data
}NET_OUT_GETSPLICEDATA;

// input of Get Acceecontrol server caps
typedef struct tagNET_IN_AC_CAPS
{
    DWORD					dwSize;
}NET_IN_AC_CAPS;
// special day caps
typedef struct tagNET_SPECIAL_DAYS_SCHEDULE_CAPS
{
    BOOL								bSupport;						// enable to support
    int									nMaxSpecialDaysSchedules;		// max special days
    int									nMaxTimePeriodsPerDay;			// max periods perday
    int									nMaxSpecialDayGroups;			// max specialday groups
    int									nMaxDaysInSpecialDayGroup;		// max days inspecialday group
    BYTE								byReserved[128];				// reserved
} NET_SPECIAL_DAYS_SCHEDULE_CAPS;
// ACS Caps
typedef struct tagNET_AC_CAPS
{
    int                     nChannels;                                  // max channel number
    BOOL					bSupAccessControlAlarmRecord;               // support alarmrecord in accesscontrolrec
    int                     nCustomPasswordEncryption;		            // password encryption mode of AccessControlCustomPassword,0:Plaintext, 1:MD5
    int                 	nSupportFingerPrint;			            // Whether to support fingerprint,0:unknown,1:unsupport, 2:support
    BOOL                    bHasCardAuth;                               // Whether to support card auth
    BOOL                    bHasFaceAuth;                               // Whether to support face auth
    BOOL                    bOnlySingleDoorAuth;	                    // Only Single Door authorize
    BOOL					bAsynAuth;                                  // asynchronous return of authorize  
    BOOL                    bUserlsoLate;                               // is support to userisolate
    int                     nMaxInsertRate;                             // max insert rate
    NET_SPECIAL_DAYS_SCHEDULE_CAPS  stuSpecialDaysSchedule;			    // specailday caps 
    int                     nUnlockModes;                               // unlock mode number
    NET_ACCESS_DOOROPEN_METHOD  emUnlockModes[128];                     // unlock modes
    BYTE					byReserved[256];				            // reserved
}NET_AC_CAPS;
// user caps
typedef struct tagNET_ACCESS_USER_CAPS
{
    int                     nMaxInsertRate;                             // max insert rate
    int                     nMaxUsers;                                  // max users
    int                     nMaxFingerPrintsPerUser;                    // max fingerprint per user
    int                     nMaxCardsPerUser;                           // max card per user
    BYTE					byReserved[512];				            // reserved
}NET_ACCESS_USER_CAPS;
// card caps
typedef struct tagNET_ACCESS_CARD_CAPS
{
    int                     nMaxInsertRate;                             // max insert rate
    int                     nMaxCards;                                  // max cards
    BYTE					byReserved[512];				            // reserved
}NET_ACCESS_CARD_CAPS;
// fingerprint caps
typedef struct tagNET_ACCESS_FINGERPRINT_CAPS
{
    int                     nMaxInsertRate;                             // max insert rate
    int                     nMaxFingerprintSize;                        // max fingerprint size 
    int                     nMaxFingerprint;                            // max fingerprints
    BYTE					byReserved[512];				            // reserved
}NET_ACCESS_FINGERPRINT_CAPS;
// face caps
typedef struct tagNET_ACCESS_FACE_CAPS
{
    int                     nMaxInsertRate;                             // max insert rate
    int                     nMaxFace;                                   // max faces
    int                     nRecognitionType;                           // RecognitionType 0:white light 1:infrared
    int                     nRecognitionAlgorithm;                      // RecognitionAlgorithm0:unknonw,1:dahua,2:shangtang,3:yitu,4:hanwang,5:fireeye
    DWORD                   dwRecognitionVersion;                       // RecognitionVersion0x00010502 means 1.5.2
    int                     nMinPhotoSize;                              // MinPhotoSize ,unit KB
    int                     nMaxPhotoSize;                              // MaxPhotoSize ,unit KB
    int                     nMaxGetPhotoNumber;                         // max number of get photo in batches
    BOOL                    bIsSupportGetPhoto;                         // is support get photo, TRUE:yes, FAlSE:no
    BYTE					byReserved[504];				            // reserved
}NET_ACCESS_FACE_CAPS;
// output of Get acs caps
typedef struct tagNET_OUT_AC_CAPS
{
    DWORD					    dwSize;
    NET_AC_CAPS                 stuACCaps;                                  // ACCaps
    NET_ACCESS_USER_CAPS        stuUserCaps;                                // user caps
    NET_ACCESS_CARD_CAPS        stuCardCaps;                                // card caps
    NET_ACCESS_FINGERPRINT_CAPS stuFingerprintCaps;                         // fingerprint caps
    NET_ACCESS_FACE_CAPS        stuFaceCaps;                                // face caps
}NET_OUT_AC_CAPS;
//DoorWork mode
//input param of CLIENT_GetDevCaps(nType: NET_LIGHTINGCONTROL_CAPS)
typedef struct tagNET_IN_LIGHTINGCONTROL_CAPS
{
	DWORD						dwSize;										//struct size
	int 						nChannel;									// Channel
}NET_IN_LIGHTINGCONTROL_CAPS;
//Supported config version
typedef enum tagEM_LC_CONFIG_VERSION
{
	EM_LC_CONFIG_VERSION_UNKNOWN,					//Unknown	
	EM_LC_CONFIG_VERSION_LIGHTING,					//Default:Lighting
	EM_LC_CONFIG_VERSION_LIGHTING_V2,				//Lighting_V2
}EM_LC_CONFIG_VERSION;	
//light type
typedef enum tagEM_LC_LIGHT_TYPE
{
	EM_LC_LIGHT_TYPE_UNKNOWN,						//Unknown
	EM_LC_LIGHT_TYPE_INFRAREDLIGHT,					//Infrared
	EM_LC_LIGHT_TYPE_WIHTELIGHT,					//White
	EM_LC_LIGHT_TYPE_LASERLIGHT,					//Laser
}EM_LC_LIGHT_TYPE;
//Supported mode
typedef enum tagEM_LC_MODE
{
	EM_LC_MODE_UNKNOWN,								//Unknown
	EM_LC_MODE_MANUAL,								//Manual
	EM_LC_MODE_ZOOMPRIO,							//Zoom prio
	EM_LC_MODE_TIMING,								//Timing
	EM_LC_MODE_AUTO,								//Auto
	EM_LC_MODE_OFF,									//Off
	EM_LC_MODE_EXCLUSIVEMANUAL,						//Exclusive manual
	EM_LC_MODE_SMARTLIGHT,							//Smart
	EM_LC_MODE_LINKING,								//Linking
	EM_LC_MODE_DUSKTODAWN							//Dusk to down
}EM_LC_MODE;
#define SUPPORTED_LC_COMPLEX_MODES 3				//number of supported mode

//Supported mode's information
typedef struct tagNET_MODES_COMPLEX_LIGHT
{
	EM_LC_MODE		anInfraredLight[SUPPORTED_LC_COMPLEX_MODES];		//Mode of Infrared Light 
	int				nInfraredLightLen;									//Mode's number of Infrared Light 
	EM_LC_MODE		anWhiteLight[SUPPORTED_LC_COMPLEX_MODES];			//Mode of wight light 
	int				nWhiteLightLen;										//Mode's number of wight light 
	EM_LC_MODE		anLaserLight[SUPPORTED_LC_COMPLEX_MODES];			//Mode of laser Light 
	int				nLaserLightLen;										//Mode's number of laser Light 
	BYTE			byReserved[128];				            		//Reserved
}NET_MODES_COMPLEX_LIGHT;
#define LC_LIGHT_COUNT 4			//light's num of light group
//information of light group
typedef struct tagNET_LIGHT_TYPE_COMPLEX_DETAIL
{
	EM_LC_LIGHT_TYPE		anNearLight[LC_LIGHT_COUNT];		//type of near light
	int						nNearLightLen;						//number of near light
	EM_LC_LIGHT_TYPE		anMiddleLight[LC_LIGHT_COUNT];		//type of mid light
	int						nMiddleLightLen;					//number of mid light
	EM_LC_LIGHT_TYPE		anFarLight[LC_LIGHT_COUNT];			//type of far light
	int						nFarLightLen;						//number of far light
	BYTE					byReserved[128];				    //Reserved
}NET_LIGHT_TYPE_COMPLEX_DETAIL;
//Supported normal event
typedef enum tagEM_LC_SUPPORT_EVENTS
{
	EM_LC_SUPPORT_EVENTS_UNKNOWN,							//unknown
	EM_LC_SUPPORT_EVENTS_MOTIONDETECT,						//motion detect
	EM_LC_SUPPORT_EVENTS_MASK,								//mask
	EM_LC_SUPPORT_EVENTS_ALARM,								//alarm
	EM_LC_SUPPORT_EVENTS_ALL,								//all
}EM_LC_SUPPORT_EVENTS;
#define MAX_SUPPORT_EVENT_NUM 10					//number of normal event
#define MAX_SUPPORT_INTELLISCENE_NUM 40				//number of intelligent scene
//Ability of linking
typedef struct tagNET_LINKING_ABILITY
{
	EM_LC_SUPPORT_EVENTS		anSupportEvents[MAX_SUPPORT_EVENT_NUM];						//Supported normal event
	int							nSupportEventsLen;											//Number of supported normal event
	EM_SCENE_CLASS_TYPE			anSupportIntelliScence[MAX_SUPPORT_INTELLISCENE_NUM];		//Supported intelligent scene
	int							nSupportIntelliScenceLen;									//Number of intelligent scene
	BYTE						byReserved[128];				            				//Reserved
}NET_LINKING_ABILITY;
//information of flicker light
#define LC_LIGHT_TYPE_NUM 3							//
typedef struct tagNET_FILCKER_LIGHTING
{
	BOOL				bSupported;							//Is supported
	NET_LINKING_ABILITY	stuAbility;							//Ability
	EM_LC_LIGHT_TYPE	anLightType[LC_LIGHT_TYPE_NUM];		//light type
	int					nLightTypeLen;						//number of light
	int					anFilckerIntevalTime[2];			//inteval time
	int					anFilckerTimes[2];					//range of config times.[0]:min,[1] max.
	BYTE				byReserved[128];				    //Reserved
}NET_FILCKER_LIGHTING;
//information of normally on
typedef struct tagNET_KEEP_LIGHTING
{
	BOOL				bSupported;							//Is supported
	NET_LINKING_ABILITY	stuAbility;							//Ability
	EM_LC_LIGHT_TYPE	anLightType[LC_LIGHT_TYPE_NUM];		//light type
	int					nLightTypeLen;						//number of light
	BYTE				byReserved[128];				    //Reserved
}NET_KEEP_LIGHTING;
//light type of linking
typedef struct tagNET_LINKING_DETAIL
{
	NET_FILCKER_LIGHTING	stuFilckerLighting;			//Information of filcker light
	NET_KEEP_LIGHTING		stuKeepLighting;			//Information of keeping light
	BYTE					byReserved[128];			//Reserved
}NET_LINKING_DETAIL;
//information of correction
typedef struct tagNET_CORRECTION
{
	BOOL				bSupported;					//is supported
	int					nRange;						//Max of correction
	BYTE				byReserved[128];			//Reserved
}NET_CORRECTION;
//Information of sensitivity
typedef struct tagNET_SENSITIVITY
{
	BOOL				bSupported;					//is supported
	int					nRange;						//Max of sensitivity
	BYTE				byReserved[128];			//Reserved
}NET_SENSITIVITY;
//outparam of CLIENT_GetDevCaps(nType: NET_LIGHTINGCONTROL_CAPS)
#define LC_POWER_NUM 3								//
#define LC_ANGLECONTROL_NUM 3						//
#define LC_LIGHT_MODE_NUM 20						//
typedef struct tagNET_OUT_LIGHTINGCONTROL_CAPS
{
	DWORD							dwSize;										//struct size
	BOOL							bSupport;									//Is supported light control
	EM_LC_CONFIG_VERSION			emConfigVersion;							//supported light config version						
	EM_LC_LIGHT_TYPE				emLightType;								//light type
	EM_LC_LIGHT_TYPE				anLightTypeComplex[LC_LIGHT_TYPE_NUM];		//complex light type
	int								nLightTypeComplexLen;						//number of complex light type
	int								nNearLightNumber;							//number of near light 
	int								nMiddleLightNumber;							//number of near mid
	int								nFarLightNumber;							//number of near far 
	EM_LC_MODE						emDefaultMode;								//default mode
	EM_LC_MODE						anModes[LC_LIGHT_MODE_NUM];					//supported mode type
	int								nModesLen;									//supported mode number
	NET_MODES_COMPLEX_LIGHT			stuModesComplex;							//complex light's information
	NET_LIGHT_TYPE_COMPLEX_DETAIL	stuLightTypeComplexDetail;					//light's information
	NET_LINKING_DETAIL				stuLinkingDetail;							//Linking detail
	int								anPower[LC_POWER_NUM];							//power control code 
	int								anAngleControl[LC_ANGLECONTROL_NUM];			//angle control code
	NET_CORRECTION					stuCorrection;								//correction information
	NET_SENSITIVITY					stuSensitivity;								//sensitivity information
	BOOL							bSupportLaserLightMove;						//is supported laser light move
	int								nLightingTimeSectionNum;					//number of time section number
	BOOL							bSupportByTime;								//is supported config by time
}NET_OUT_LIGHTINGCONTROL_CAPS;

// CLIENT_GetDevCaps NET_COAXIAL_CONTROL_IO_STATUS input param
typedef struct tagNET_IN_GET_COAXIAL_CONTROL_IO_STATUS
{
	DWORD							dwSize;							// Struct Size
	UINT							nChannel;						// Channel
} NET_IN_GET_COAXIAL_CONTROL_IO_STATUS;

//  Coaxial Control IO Status
typedef enum tagEM_COAXIAL_CONTROL_IO_STATUS
{
	EM_COAXIAL_CONTROL_IO_STATUS_UNKNOWN,							// Unknown
	EM_COAXIAL_CONTROL_IO_STATUS_ON,								// On
	EM_COAXIAL_CONTROL_IO_STATUS_OFF,								// Off
} EM_COAXIAL_CONTROL_IO_STATUS;

// CLIENT_GetDevCaps NET_COAXIAL_CONTROL_IO_STATUS output param
typedef struct tagNET_OUT_GET_COAXIAL_CONTROL_IO_STATUS
{
	DWORD							dwSize;							// Struct Size
	EM_COAXIAL_CONTROL_IO_STATUS	emWhiteLight;					// White Light Status
	EM_COAXIAL_CONTROL_IO_STATUS	emSpeaker;						// Speaker Status
} NET_OUT_GET_COAXIAL_CONTROL_IO_STATUS;

typedef struct tagNET_IN_SUPPORT_GET_AUDIO_DECODE_CAPS
{
	DWORD							dwSize;							// struct sizeassigned to sizeof(NET_IN_SUPPORT_GET_AUDIO_DECODE_CAPS)
}NET_IN_SUPPORT_GET_AUDIO_DECODE_CAPS;
typedef struct tagNET_OUT_SUPPORT_GET_AUDIO_DECODE_CAPS
{
	DWORD							dwSize;							// struct sizeassigned to sizeof(NET_OUT_SUPPORT_GET_AUDIO_DECODE_CAPS)
	BOOL							bSupport;						// whether support get audio decode capsTRUE support
}NET_OUT_SUPPORT_GET_AUDIO_DECODE_CAPS;

// CLIENT_GetDevCaps NET_UNIFIEDINFOCOLLECT_CAPS input param 
typedef struct tagNET_IN_UNIFIEDINFOCOLLECT_CAPS
{
    DWORD                           dwSize;                         // Struct size
}NET_IN_UNIFIEDINFOCOLLECT_CAPS;

// CLIENT_GetDevCaps NET_UNIFIEDINFOCOLLECT_CAPS output param
typedef struct tagNET_OUT_UNIFIEDINFOCOLLECT_CAPS
{
    DWORD                           dwSize;                         // Struct size
    BOOL                            bSupportUnifiedInfoCollect;     // whether support DMSS private protocol or not         
}NET_OUT_UNIFIEDINFOCOLLECT_CAPS;

// CLIENT_GetDevCaps NET_EXALARMBOX_CAPS input param
typedef struct tagNET_IN_EXALARMBOX_CAPS
{
	DWORD							dwSize;							// Struct size
	int								nChannel;						// channel id
}NET_IN_EXALARMBOX_CAPS;


// CLIENT_GetDevCaps NET_EXALARMBOX_CAPS output param
typedef struct tagNET_OUT_EXALARMBOX_CAPS
{
	DWORD							dwSize;							// Struct size
	int								nAlarmIn;						// alarm in count supported
	int								nAlarmOut;						// alarm out count supported
	int								nRemoteControl;					// remote control count supported
}NET_OUT_EXALARMBOX_CAPS;


// CLIENT_GetDevCaps NET_ALARMBOXMANAGER_CAPS input param
typedef struct tagNET_IN_ALARMBOXMANAGER_CAPS
{
	DWORD							dwSize;							// Struct size
}NET_IN_ALARMBOXMANAGER_CAPS;


// CLIENT_GetDevCaps NET_ALARMBOXMANAGER_CAPS output param
typedef struct tagNET_OUT_ALARMBOXMANAGER_CAPS
{
	DWORD							dwSize;							// Struct size
	int								nMaxBoxNumber;					// max box number
	int								nMaxInputPerBox;				// max alarm in per box
	int								nMaxOutputPerBox;				// max alarm out per box
}NET_OUT_ALARMBOXMANAGER_CAPS;

// CLIENT_GetDevCaps NET_GET_AUDIO_DETECT_CAPS input param
typedef struct tagNET_IN_GET_AUDIO_DETECT_CAPS 
{
    DWORD                           dwSize;                         // Struct size
    int                             nChannel;                       // Channel num 
}NET_IN_GET_AUDIO_DETECT_CAPS;


// CLIENT_GetDevCaps NET_GET_AUDIO_DETECT_CAPS output param
typedef struct tagNET_OUT_GET_AUDIO_DETECT_CAPS
{
    DWORD                           dwSize;                                         // Struct size
    BOOL                            bVolumeDetect;                                  // Whether support volume detect or not
    BOOL                            bAnomalyDetect;                                 // Whether support anomaly detect or not
    unsigned int                    nAnomalySensitiveRange[2];                      // Anomaly sensitive range arr, first element is min, second element is max
    BOOL                            bMutationDetect;                                // Whether support mutation detect or not
    unsigned int                    nMutationThresholdRange[2];                     // Mutation detect threshold range arr, first element is min, second element is max
    BOOL                            bInfantCryDetect;                               // Whether support infant cry detect
    BOOL                            bIntensityDetect;                               // Whether support intensity detect
    unsigned int                    nIntensityDecibelGateRange[2];                  // Intensity decibel gate range arr, dB; first element is min, second element is max
}NET_OUT_GET_AUDIO_DETECT_CAPS;

// CLIENT_GetDevCaps NET_SUPPORT_FACEDB_DOWNLOAD input param

// CLIENT_GetDevCaps NET_AIDEO_IN_DEFOG_CAPS input param
typedef struct tagNET_IN_VIDEO_IN_DEFOG_CAPS
{
    DWORD                      dwSize;          // Structural size
    int                        nChannel;        // Channel
}NET_IN_VIDEO_IN_DEFOG_CAPS;

// indefog type
typedef struct tagNET_LIGHT_INTENSITY_CAPS
{   
    BOOL            bSupportLightMode;          // Supporting atmospheric light model capability
    BYTE            byReserved[68];             // Reserved
}NET_LIGHT_INTENSITY_CAPS;

// In defog mode
typedef enum tagEM_IN_DEFOG_MODE
{
    EM_IN_DEFOG_MODE_UNKNOWN,          // Unknown
    EM_IN_DEFOG_MODE_OFF,              // off
    EM_IN_DEFOG_MODE_MANUAL,           // Manual
    EM_IN_DEFOG_MODE_AUTO,             // Auto
} EM_IN_DEFOG_MODE;

// CLIENT_GetDevCaps NET_AIDEO_IN_DEFOG_CAPS output param
typedef struct tagNET_OUT_VIDEO_IN_DEFOG_CAPS
{
    DWORD                       dwSize;             // Structural size
    BOOL                        bSupportInDefog;    // Does it support fog permeability settings?
    BOOL                        bSupportCamDefog;   // Supporting Optical Physical Fog Penetration
    UINT                        nModeCount;         // Number of fog penetration modes    
    EM_IN_DEFOG_MODE            emMode[8];          // Fog penetration mode
    NET_LIGHT_INTENSITY_CAPS    stuLightIntensity;  // Atmospheric light model capability
}NET_OUT_VIDEO_IN_DEFOG_CAPS;

// CLIENT_GetDevCaps NET_SUPPORT_FACE_LIB_DOWNLOAD input param
typedef struct tagNET_IN_SUPPORT_FACEDB_DOWNLOAD_CAPS
{
    DWORD                           dwSize;                                         //  Structural size
} NET_IN_SUPPORT_FACEDB_DOWNLOAD_CAPS;

// CLIENT_GetDevCaps NET_SUPPORT_FACEDB_DOWNLOAD output param
typedef struct tagNET_OUT_SUPPORT_FACEDB_DOWNLOAD_CAPS
{
    DWORD                           dwSize;                                         // Struct size
    BOOL                            bSupportFaceDbDownload;                         // Is support to download remote facelib
} NET_OUT_SUPPORT_FACEDB_DOWNLOAD_CAPS;


// Input param of CLIENT_GetDevCaps + NET_DIAGNOSIS_CAPS
typedef struct tagNET_IN_DIAGNOSIS_CAPS
{
	DWORD							dwSize;											// Struct size
}NET_IN_DIAGNOSIS_CAPS;


// Output param of CLIENT_GetDevCaps + NET_DIAGNOSIS_CAPS
typedef struct tagNET_OUT_DIAGNOSIS_CAPS
{
	DWORD							dwSize;											// Struct size
	BOOL							bSupportReport;									// whether support report
	BOOL							bSupportDelInfo;								// whether support delete selected fault code
	BOOL							bSupportDelAllInfo;								// whether support delete all fault code
}NET_OUT_DIAGNOSIS_CAPS;


// smart locker caps
typedef struct tagNET_SMARTLOCKER_CAPS
{
	UINT							nMaxFpAmount;									// max fingerprint supported
	UINT							nMaxPwdAmount;									// max password supported
	UINT							nMaxCardAmount;									// max card supported
	BYTE							byReserved[132];								// reserved
}NET_SMARTLOCKER_CAPS;

// LowRateWPAN type
typedef enum tagEM_LOWRATEWPAN_CAPS_TYPE
{
	EM_LOWRATEWPAN_CAPS_TYPE_UNKNOWN = -1,											// unknown
	EM_LOWRATEWPAN_CAPS_TYPE_SMARTLOCKER,											// smart locker
}EM_LOWRATEWPAN_CAPS_TYPE;

// input param of CLIENT_GetDevCaps + NET_LOWRATEWPAN_CAPS 
typedef struct tagNET_IN_LOWRATEWPAN_CAPS
{
	DWORD							dwSize;											// struct size
	int								nChannelID;										// channel id(currently not used)
	EM_LOWRATEWPAN_CAPS_TYPE		emType;											// type
	char							szModuleSNList[16][32];							// module sn list
}NET_IN_LOWRATEWPAN_CAPS;

// output param of CLIENT_GetDevCaps + NET_LOWRATEWPAN_CAPS 
typedef struct tagNET_OUT_LOWRATEWPAN_CAPS
{
	DWORD							dwSize;											// struct size
	NET_SMARTLOCKER_CAPS			stuSmartLockerCaps[16];							// smart locker caps
	UINT							nSmartLockerCapsRet;							// the num of stuSmartLockerCaps returned
}NET_OUT_LOWRATEWPAN_CAPS;



// CLIENT_StopAdjustingAngle input param
typedef struct tagNET_IN_STOP_ADJUSTING_ANGLE
{
    DWORD                           dwSize;                                         // Struct size
    int                             nChannel;                                       // Channel ID 
}NET_IN_STOP_ADJUSTING_ANGLE;

// CLIENT_StopAdjustingAngle output param
typedef struct tagNET_OUT_STOP_ADJUSTING_ANGLE
{
    DWORD                           dwSize;                                         // Struct size
}NET_OUT_STOP_ADJUSTING_ANGLE;

// Lens stop adjusting angle
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopAdjustingAngle(LLONG lLoginID, const NET_IN_STOP_ADJUSTING_ANGLE *pstInParam, NET_OUT_STOP_ADJUSTING_ANGLE *pstOutParam, int nWaitTime);

// Lens direction
typedef enum tagEM_ADJUST_ANGLE_DIRECTION
{
    EM_ADJUST_ANGLE_DIRECTION_UNKNOWN,                                  // UNKNOWN
    EM_ADJUST_ANGLE_DIRECTION_NEGATIVE_X,                               // -X
    EM_ADJUST_ANGLE_DIRECTION_POSITIVE_X,                               // +X
    EM_ADJUST_ANGLE_DIRECTION_NEGATIVE_Y,                               // -Y
    EM_ADJUST_ANGLE_DIRECTION_POSITIVE_Y,                               // +Y
} EM_ADJUST_ANGLE_DIRECTION;

// CLIENT_AdjustingAngleContinuously input param
typedef struct tagNET_IN_ADJUST_ANGLE_CONTINUOUSLY
{
    DWORD                           dwSize;                                         // Struct size
    int                             nChannel;                                       // Channel ID 
    EM_ADJUST_ANGLE_DIRECTION       emDirection;                                    // Direction
    UINT                            nVelocity;                                      // speed
}NET_IN_ADJUST_ANGLE_CONTINUOUSLY;

// CLIENT_AdjustingAngleContinuously output param
typedef struct tagNET_OUT_ADJUST_ANGLE_CONTINUOUSLY
{
    DWORD                           dwSize;                                         // Struct size
}NET_OUT_ADJUST_ANGLE_CONTINUOUSLY;

// Lens adjust angle continuously
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AdjustingAngleContinuously(LLONG lLoginID, const NET_IN_ADJUST_ANGLE_CONTINUOUSLY *pstInParam, NET_OUT_ADJUST_ANGLE_CONTINUOUSLY *pstOutParam, int nWaitTime);

// CLIENT_GetDevCaps NET_GET_LENS_FUNC_CAPS input param
typedef struct tagNET_IN_GET_LENS_FUNC_CAPS
{
    DWORD                           dwSize;                                         // Struct size
    int                             nChannel;                                       // Channel ID 
}NET_IN_GET_LENS_FUNC_CAPS;

// Angle adjust ability
typedef enum tagEM_SUPPORT_ANGLE_ADJUST
{
    EM_SUPPORT_ANGLE_ADJUST_UNKNOWN,                          // unknown
    EM_SUPPORT_ANGLE_ADJUST_NO,                               // don't support
    EM_SUPPORT_ANGLE_ADJUST_X,                                // support horizontal direction
    EM_SUPPORT_ANGLE_ADJUST_Y,                                // support vertical direction
    EM_SUPPORT_ANGLE_ADJUST_XY,                               // support horizontal and vertical direction
} EM_SUPPORT_ANGLE_ADJUST;

// CLIENT_GetDevCaps NET_GET_LENS_FUNC_CAPS output param
typedef struct tagNET_OUT_GET_LENS_FUNC_CAPS
{
    DWORD                           dwSize;                                         // Struct size
    UINT                            nDepthField;                                    // If support depth field; 0-not support, 1-support
    EM_SUPPORT_ANGLE_ADJUST         emSupportAngleAdjust;                           // Angle adjust ability
    UINT                            nMaxVelocity;                                   // Max velocity:1~8         
}NET_OUT_GET_LENS_FUNC_CAPS;

// CLIENT_GetDevCaps NET_ADJUST_DEPTH_FIELD input param
typedef struct tagNET_IN_ADJUST_DEPTH_FIELD
{
    DWORD                           dwSize;                                         // Struct size
    UINT                            nChannel;                                       // Channel num 
    float                           fDepthField;                                    // Depth filed position: 0-1
}NET_IN_ADJUST_DEPTH_FIELD;

// CLIENT_GetDevCaps NET_ADJUST_DEPTH_FIELD output param
typedef struct tagNET_OUT_ADJUST_DEPTH_FIELD
{
    DWORD                           dwSize;                                         // Struct size
}NET_OUT_ADJUST_DEPTH_FIELD;

// CLIENT_GetDevCaps NET_ADJUST_DEPTH_FIELD_CONTINUOUSLY input param
typedef struct tagNET_IN_ADJUST_DEPTH_FIELD_CONTINUOUSLY
{
    DWORD                           dwSize;                                         // Struct size
    UINT                            nChannel;                                       // Channel num 
    float                           fDepthFieldSpeed;                               // Depth field speed:-1~1
}NET_IN_ADJUST_DEPTH_FIELD_CONTINUOUSLY;

// CLIENT_GetDevCaps NET_ADJUST_DEPTH_FIELD_CONTINUOUSLY output param
typedef struct tagNET_OUT_ADJUST_DEPTH_FIELD_CONTINUOUSLY
{
    DWORD                           dwSize;                                         // Struct size
}NET_OUT_ADJUST_DEPTH_FIELD_CONTINUOUSLY;

// CLIENT_GetDevCaps NET_GET_DEPTH_FIELD_STATUS input param
typedef struct tagNET_IN_GET_DEPTH_FIELD_STATUS
{
    DWORD                            dwSize;                                         // Struct size
    UINT                             nChannel;                                       // Channel num 
}NET_IN_GET_DEPTH_FIELD_STATUS;

// depth field status
typedef enum tagEM_DEPTH_FIELD_STATUS
{
    EM_DEPTH_FIELD_STATUS_UNKNOWN,                                                  // Unknown
    EM_DEPTH_FIELD_STATUS_NORMAL,                                                   // Normal
    EM_DEPTH_FIELD_STATUS_AUTODEPTHFIELD,                                           // Auto depth field
}EM_DEPTH_FIELD_STATUS;

// CLIENT_GetDevCaps NET_GET_DEPTH_FIELD_STATUS output param
typedef struct tagNET_OUT_GET_DEPTH_FIELD_STATUS
{
    DWORD                            dwSize;                                        // Struct size
    float                            fDepthField;                                   // Depth field position:0-1
    UINT                             nTotalDepthFieldSteps;                         // Total depth field steps
    EM_DEPTH_FIELD_STATUS            emStatus;                                      // Depth field status
}NET_OUT_GET_DEPTH_FIELD_STATUS;

// CLIENT_GetDevCaps NET_AUTO_ADJUST_DEPTH_FIELD input param
typedef struct tagNET_IN_AUTO_ADJUST_DEPTH_FIELD
{
    DWORD                            dwSize;                                        // Struct size
    UINT                             nChannel;                                      // Channel num 
}NET_IN_AUTO_ADJUST_DEPTH_FIELD;

// CLIENT_GetDevCaps NET_AUTO_ADJUST_DEPTH_FIELD output param
typedef struct tagNET_OUT_AUTO_ADJUST_DEPTH_FIELD
{
    DWORD                            dwSize;                                        // Struct size
}NET_OUT_AUTO_ADJUST_DEPTH_FIELD;

// Adjust depth field
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AdjustDepthField(LLONG lLoginID, const NET_IN_ADJUST_DEPTH_FIELD *pstInParam, NET_OUT_ADJUST_DEPTH_FIELD *pstOutParam, int nWaitTime);

// Adjust depth field continuously
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AdjustDepthFieldContinuously(LLONG lLoginID, const NET_IN_ADJUST_DEPTH_FIELD_CONTINUOUSLY *pstInParam, NET_OUT_ADJUST_DEPTH_FIELD_CONTINUOUSLY *pstOutParam, int nWaitTime);

// Get depth field status
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDepthFieldStatus(LLONG lLoginID, const NET_IN_GET_DEPTH_FIELD_STATUS *pstInParam, NET_OUT_GET_DEPTH_FIELD_STATUS *pstOutParam, int nWaitTime);

// auto adjust depth field
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AutoAdjustDepthField(LLONG lLoginID, const NET_IN_AUTO_ADJUST_DEPTH_FIELD *pstInParam, NET_OUT_AUTO_ADJUST_DEPTH_FIELD *pstOutParam, int nWaitTime);

// CLIENT_GetDevCaps NET_GET_FILE_TRANSFER_CAPS input param
typedef struct tagNET_IN_GET_FILE_TRANSFER_CAPS
{
    DWORD                           dwSize;                                         // Struct size
}NET_IN_GET_FILE_TRANSFER_CAPS;

// CLIENT_GetDevCaps NET_GET_FILE_TRANSFER_CAPS output param
typedef struct tagNET_OUT_GET_FILE_TRANSFER_CAPS
{
    DWORD                           dwSize;                                         // Struct size
    BOOL                            bSupportFaceDbDownload;                         // is support face database download
    BOOL                            bSupportPlateNumberDbDownload;                  // is support plate number database download
    BYTE                            byReserved[4];                                  // byte alignment
}NET_OUT_GET_FILE_TRANSFER_CAPS;

typedef enum tagNET_DOORWORK_MODE
{
    NET_DOORWORK_MODE_UNKNOWN = 0,                                // unknown
    NET_DOORWORK_MODE_NORMAL = 1,                                 // normal
    NET_DOORWORK_MODE_SHUTLOCK = 2,                               // shutlock
    NET_DOORWORK_MODE_UNUSED = 3,                                 // unused
    NET_DOORWORK_MODE_OPENDOORCONTINUE = 4,                       // open door continue
} NET_DOORWORK_MODE;

// Get DoorWork mode, type DH_DEVSTATE_GET_ACCESSCONTROLMODE
typedef struct tagNET_GET_DOORWORK_MODE
{
    DWORD                    dwSize;
    int                      nChannel;              // ChannelID
    NET_DOORWORK_MODE   emControlMode;              // DoorWork mode      
}NET_GET_DOORWORK_MODE;

// VT Event Type
typedef enum tagEM_AUDIO_CB_FLAG
{
    EM_AUDIO_CB_FLAG_UNKNOWN,
    EM_AUDIO_CB_FLAG_NEWCALL,                   // new call
    EM_AUDIO_CB_FLAG_REMOTE_HANGUP,             // remote hangup
    EM_AUDIO_CB_FLAG_DISCONNECT,                // disconnect
    EM_AUDIO_CB_FLAG_RING,                      // ring
} EM_AUDIO_CB_FLAG;

// VT callback function
typedef int (CALLBACK *pfVtEventCallBack)(LLONG instId, LLONG ulRegisterId, LLONG ulSessionId, int nEvent, char *pDataBuf, DWORD dwBufSize, LDWORD dwUser);

// new call action EM_AUDIO_CB_FLAG_NEWCALL
typedef enum tagEM_NEWCALL_ACTION
{
    EM_NEWCALL_ACTION_UNKNOWN,                  // unknown
    EM_NEWCALL_ACTION_REFUSE,                   // refuse
    EM_NEWCALL_ACTION_ACCEPT,                   // accept
} EM_NEWCALL_ACTION;

typedef enum tagEM_VT_PARAM_VALID
{
    EM_VT_PARAM_VALID_EVENT_CB     = 0x0001,
    EM_VT_PARAM_VALID_USER_DATA    = 0x0002,
    EM_VT_PARAM_VALID_MID_NUM      = 0x0004,
    EM_VT_PARAM_VALID_ACTION       = 0x0008,
    EM_VT_PARAM_VALID_WAITTIME     = 0x0010,
    EM_VT_PARAM_VALID_VIDEOWND     = 0x0020,
    EM_VT_PARAM_VALID_CSMODE       = 0x0040,
    EM_VT_PARAM_VALID_AUDIO_ENCODE = 0x0080,
    EM_VT_PARAM_VALID_LOCAL_IP     = 0x0100,
} EM_VT_PARAM_VALID;

// VT Talk Parameter
typedef struct tagNET_VT_TALK_PARAM
{
    DWORD               dwSize;                  // struct size
    int                 nValidFlag;              // Flag Valid, combination of EM_VT_PARAM_VALID 
    pfVtEventCallBack   pfEventCb;               // Event callback function, EM_VT_PARAM_VALID_EVENT_CB
    LDWORD              dwUser;                  // user information, EM_VT_PARAM_VALID_USER_DATA
    char                szPeerMidNum[16];        // peer middle number, 8 byte, EM_VT_PARAM_VALID_MID_NUM
    EM_NEWCALL_ACTION   emAction;                // Action, 0:unknown, 1:refuse, 2:accept, EM_VT_PARAM_VALID_ACTION
    int                 nWaitTime;               // waittime, EM_VT_PARAM_VALID_WAITTIME
    HWND                hVideoWnd;               // Video Window, EM_VT_PARAM_VALID_VIDEOWND
    BOOL                bClient;                 // Client/Server, TRUE:Client, FALSE:Server, EM_VT_PARAM_VALID_CSMODE
    DHDEV_TALKDECODE_INFO stAudioEncode;         // Audio encode info, EM_VT_PARAM_VALID_AUDIO_ENCODE
} NET_VT_TALK_PARAM;

// VTC Register VTO
CLIENT_NET_API LLONG CALL_METHOD CLIENT_VT_RegisterVto(const char *pszIp, int nPort );

// VTC Unregister VTO
CLIENT_NET_API BOOL CALL_METHOD CLIENT_VT_UnRegisterVto(LLONG ulLongId);

/////////////////////////////////// UAV interfaces ///////////////////////////////////////

// UAV fly info
typedef struct tagNET_UAV_FLY_INFO 
{
    float               fAltitude;                          // Altitude, with respect to horizon, Unit: meter
    float               fDistance;                          // Distance, with respect to remote controller, Unit: meter
    float               fHorizontalSpeed;                   // Horizontal Speed, Unit: m/s
    float               fVerticalSpeed;                     // Vertical Speed, Unit: m/s
    int                 nRCLinkQuality;                     // remote controller link quality, range: 0~100
    char                reserved[512];
} NET_UAV_FLY_INFO;

// callback for UAV info, lAttachHandle is the return value of CLIENT_AttachUavFly
typedef void (CALLBACK *fUavFlyCallBack) (LLONG lAttachHandle, NET_UAV_FLY_INFO* pBuf, DWORD dwBufLen, LDWORD dwUser);

// CLIENT_AttachUavFly input
typedef struct tagNET_IN_ATTACH_UAV_FLY 
{
    DWORD               dwSize;
    fUavFlyCallBack     cbUavFly;                           // fly info callback
    DWORD               dwUser;                             // user data                   
} NET_IN_ATTACH_UAV_FLY;

// CLIENT_AttachUavFly output
typedef struct tagNET_OUT_ATTACH_UAV_FLY 
{
    DWORD                dwSize;
} NET_OUT_ATTACH_UAV_FLY;

// subscribe UAV fly info,user malloc memory of pInParam and pOutParam
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachUavFly(LLONG lLoginID, const NET_IN_ATTACH_UAV_FLY* pInParam, NET_OUT_ATTACH_UAV_FLY* pOutParam, int nWaitTime);

// unsubscribe UAV fly info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachUavFly(LLONG lAttachHandle);

////////////////////////////////////////////////////////////////////////////////

// Get device self check info,user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSelfCheckInfo(LLONG lLoginID, const NET_IN_GET_SELTCHECK_INFO* pInParam, NET_SELFCHECK_INFO* pOutParam, int nWaitTime );

/////////////////////////////////Laser and EIS interface/////////////////////////////////

// open or close laser input
typedef struct tagLASER_IN_INFO
{
	DWORD		dwSize;				
	UINT		nChannelID;			// channel ID
} LASER_IN_INFO;

// open or close laser output
typedef struct tagLaser_OUT_INFO 
{
	DWORD		dwSize;			
} LASER_OUT_INFO;

// open or close EIS input
typedef struct tagEIS_IN_INFO 
{
	DWORD		dwSize;				
	UINT		nChannelID;			// channel ID
} EIS_IN_INFO;

// open or close EIS output
typedef struct tagEIS_OUT_INFO 
{
	DWORD		dwSize;			
} EIS_OUT_INFO;


// open laser interface,user malloc and free memory of pLaserDataIn and pLaserDataOut 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartLaser(LLONG lLoginID,const LASER_IN_INFO* pLaserDataIn, LASER_OUT_INFO* pLaserDataOut,int nWaitTime );

// close laser interface,user malloc and free memory of pLaserDataIn and pLaserDataOut 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopLaser(LLONG lLoginID,const LASER_IN_INFO* pLaserDataIn, LASER_OUT_INFO* pLaserDataOut,int nWaitTime );

// open EIS interface,user malloc and free memory of pEISDataIn and pEISDataOut 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartEIS(LLONG lLoginID,const EIS_IN_INFO* pEISDataIn, EIS_OUT_INFO* pEISDataOut,int nWaitTime );

// close EIS interface,user malloc and free memory of pEISDataIn and pEISDataOut 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopEIS(LLONG lLoginID,const EIS_IN_INFO* pEISDataIn, EIS_OUT_INFO* pEISDataOut,int nWaitTime );

// PSTN manually checking,user malloc and free memory of pInBuf and pOutBuf 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ManualCheckPSTN(LLONG lLoginID, const NET_IN_PSTN_MANUALCHECK_STATE* pInBuf, NET_OUT_PSTN_MANUALCHECK_STATE* pOutBuf, int nWaitTime );
#define  MAX_NUM_EX_MODULE          16              // the max number of extend modules
#define  MAX_NUM_ADDR_IN_BUS        256             // the max number of address in the bus

// CLIENT_GetExModuleState input parameter
typedef struct tagNET_IN_EXMODULE_INFO 
{
    DWORD		dwSize;				                                        // size of the structure
} NET_IN_EXMODULE_INFO;

// the information of single extend module
typedef struct tagNET_OUT_EXMODULE_INFO
{
    NET_BUS_TYPE		emBusType;                                          // bus type
    int                 nChannelID;	                                        // bus number
    int                 nAddrCount;                                         // the number of address in actually
    int                 nAddr[MAX_NUM_ADDR_IN_BUS];                         // address in the bus
    char                reserved[1024];                                     // reserved
} NET_OUT_EXMODULE_INFO;

// CLIENT_GetExModuleState output parameter
typedef struct tagNET_OUT_EXMODULE_INFO_ALL
{
    DWORD		                dwSize;			                            // size of the structure
    int                         nExModuleCount;                             // the number of bus
    NET_OUT_EXMODULE_INFO       stuExModuleInfo[MAX_NUM_EX_MODULE];         // the array of extend modules's information
} NET_OUT_EXMODULE_INFO_ALL;

/**************************************************************************************
*   Funcname: CLIENT_GetExModuleState
*   Purpose:Get the information of extend modules
*   InputParam:   LLONG                        :lLoginID        //login handle
*   InputParam:   NET_IN_EXMODULE_INFO*        :pInParam        //input parameter,can't fill NULL,need set dwSize,user malloc and free pInParam's memory
*   InputParam:   NET_OUT_EXMODULE_INFO_ALL*   :pOutParam       //output parameter,can't fill NULL,need set dwSize,user malloc and free pOutParam's memory
*   InputParam:   int                          :nWaitTime       //wait time
*   Return: BOOL
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetExModuleState(LLONG lLoginID, const NET_IN_EXMODULE_INFO* pInParam, NET_OUT_EXMODULE_INFO_ALL* pOutParam, int nWaitTime );

///////////////////////////////Master slave Group operate interface //////////////////////////
#define MASTERSALVE_CLASS_LEN           16

typedef struct tagNET_IN_MSGROUP_OPEN_INFO
{
    DWORD                  dwSize;     
    int                    nGroupID;                            // device group id
    int                    nSlaveID;                            // slave device id
	int				       nMasterID;							// master device id in the group,(like tree IPC with one SD, nMasterID can be 0,1,2)
	int					   nChannel;							// Video channel ID, start from 0.(if not a multi-channel device, set 0)
}NET_IN_MSGROUP_OPEN_INFO;

typedef struct tagNET_OUT_MSGROUP_OPEN_INFO
{
    DWORD                  dwSize;         
    DWORD                  dwToken;                             // master slave group token
}NET_OUT_MSGROUP_OPEN_INFO;

typedef struct tagNET_IN_MSGROUP_LOCATE_INFO
{
    DWORD                   dwSize;          
    DWORD                   dwToken;                            // master slave group token
    DH_POINT                stuPoint;                           // master coordinate
    short                   snMasterInfo[3];                    // [abscissa, ordinate, radius]
}NET_IN_MSGROUP_LOCATE_INFO;

typedef struct tagNET_OUT_MSGROUP_LOCATE_INTO
{
    DWORD                   dwSize;        
    short                   snPTZ[3];                           // PTZ
}NET_OUT_MSGROUP_LOCATE_INTO;

typedef struct tagNET_IN_MSGROUP_TRACK_INFO
{
    DWORD                   dwSize;                        
    DWORD                   dwToken;                            // master slave group token
    char                    szClass[MASTERSALVE_CLASS_LEN];     // object type
    DWORD                   dwObjectID;                         // object id
}NET_IN_MSGROUP_TRACK_INFO;

typedef struct tagNET_OUT_MSGROUP_TRACK_INFO
{
    DWORD                   dwSize;        
}NET_OUT_MSGROUP_TRACK_INFO;

typedef struct tagNET_IN_MSGROUP_CLOSE_INFO
{
    DWORD                   dwSize;         
    DWORD                   dwToken;                            // master slave group token
}NET_IN_MSGROUP_CLOSE_INFO;

typedef struct tagNET_OUT_MSGROUP_CLOSE_INFO
{
    DWORD                   dwSize;        
}NET_OUT_MSGROUP_CLOSE_INFO;

// MasterSlaveGroup operation type EM_MSGROUP_OPERATE_RECTLOCATE input
typedef struct tagNET_IN_MSGROUP_RECTLOCATE_INFO
{
    DWORD                   dwSize;                            
    DWORD                   dwToken;                            // master slave group token, get from the EM_MSGROUP_OPERATE_OPEN operate type
    NET_RECT                stuRect;                            // the selected rectangle coordinates
    int                     nRectDirection;                     // the rectangle direction, 0-from top left to bottom right, zoom in; 1-from bottom right to top left, zoom out
}NET_IN_MSGROUP_RECTLOCATE_INFO;

// MasterSlaveGroup operation type EM_MSGROUP_OPERATE_RECTLOCATE output
typedef struct tagNET_OUT_MSGROUP_RECTLOCATE_INFO
{
    DWORD                   dwSize;                             
    int                     nPTZ[3];                            // PTZ
}NET_OUT_MSGROUP_RECTLOCATE_INFO;

// master slave group notify structure
typedef struct tagNET_MSGROUP_NOTIFY_INFO 
{
    DWORD                    dwSubscribeID;                     // subscribe id
    int                      nSlaveID;                          // slave device id
    char                     szClass[MASTERSALVE_CLASS_LEN];    // object type
    DWORD                    dwObjectID;                        // object id
    NET_RECT                 stuBoundingBox;                    // bounding box of tracking object
    BYTE                     byReserved[512];                   // reserved
}NET_MSGROUP_NOTIFY_INFO;

// notify callback function, lAttachHandle is the return value of CLIENT_AttachMasterSlaveGroup interface
typedef void (CALLBACK *fMasterSlaveCallBack)(LLONG lAttachHandle, NET_MSGROUP_NOTIFY_INFO* pBuf, DWORD dwBufLen, LDWORD dwUser);

// CLIENT_AttachMasterSlaveGroup input
typedef struct tagNET_IN_MSGROUP_ATTACH_INFO
{
    DWORD                    dwSize;                    
    fMasterSlaveCallBack     cbNotify;                          // callback function
    LDWORD                   dwUser;                            // user information
    int                      nGroupID;                          // device group id
	int					     nChannel;							// Video channel ID, start from 0.(if not a multi-channel device, set 0)
}NET_IN_MSGROUP_ATTACH_INFO;

// CLIENT_AttachMasterSlaveGroup output
typedef struct tagNET_OUT_MSGROUP_ATTACH_INFO
{
    DWORD                    dwSize;               
}NET_OUT_MSGROUP_ATTACH_INFO;

// CLIENT_OperateMasterSlaveGroup operation type
typedef enum tagEM_MSGROUP_OPERATE_TYPE
{
    EM_MSGROUP_OPERATE_OPEN,                                    // Open operating handle, corresponding to  NET_IN_MSGROUP_OPEN_INFO and NET_OUT_MSGROUP_OPEN_INFO
    EM_MSGROUP_OPERATE_LOCATE,                                  // Locate master device and link the slave device, corresponding to NET_IN_MSGROUP_LOCATE_INFO and NET_OUT_MSGROUP_LOCATE_INTO
    EM_MSGROUP_OPERATE_TRACK,                                   // Do tracking, corresponding to NET_IN_MSGROUP_TRACK_INFO and NET_OUT_MSGROUP_TRACK_INFO
    EM_MSGROUP_OPERATE_CLOSE,                                   // Close the operation, corresponding to NET_IN_MSGROUP_CLOSE_INFO and NET_OUT_MSGROUP_CLOSE_INFO
    EM_MSGROUP_OPERATE_RECTLOCATE,                              // Select the rectangular box from the main device linkage from the slave, corresponding to NET_IN_MSGROUP_RECTLOCATE_INFO and NET_OUT_MSGROUP_RECTLOCATE_INFO
}EM_MSGROUP_OPERATE_TYPE;

// Master slave group operation interface,user malloc memory of pInParam and pOutParam,please refer to corresponding structure of emOperateType
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateMasterSlaveGroup(LLONG lLoginID, EM_MSGROUP_OPERATE_TYPE emOperateType, void* pInParam, void* pOutParam, int nWaitTime );

// Attach Master slave group interface,user malloc memory of pInParam and pOutParam
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachMasterSlaveGroup(LLONG lLoginID, const NET_IN_MSGROUP_ATTACH_INFO *pInParam, NET_OUT_MSGROUP_ATTACH_INFO *pOutParam, int nWaitTime );

// Detach Master slave group interface
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachMasterSlaveGroup(LLONG lAttachHandle);
//////////////////////////////////////////////////////////////////////////

#define     MAX_TRAFFIC_LANE_NUM            16                  // max lane number
#define     MAX_CAMERA_PERIPHERAL_NUM       8                   // max peripherals of camera
#define     MAX_STORAGE_NUM                 8                   // max storage number
#define     MAX_PARTITION_NUM               8                   // max partition of storage

// partition information
typedef struct tagNET_PARTITION_INFO
{
    double                      dbTotalBytes;                   // total bytes of partition
    double                      dbUsedBytes;                    // used bytes of partition
    BOOL                        bError;                         // is partition error
    BYTE                        byReserved[64];                 // reserved
}NET_PARTITION_INFO;

// storage work state
typedef enum tagENUM_STORAGE_STATE
{
    ENUM_STORAGE_STATE_UNKONWN,                                 // unknown
    ENUM_STORGAE_STATE_READ_ERROR,                              // do read error
    ENUM_STORAGE_STATE_INITIALIZING,                            // initializing
    ENUM_STORAGE_STATE_READ_SUCCESS,                            // do read success
}ENUM_STORAGE_STATE;

// storage Device information
typedef struct tagNET_STORAGE_INFO
{
    ENUM_STORAGE_STATE       emState;                           // storage work state
    int                      nPartitonNum;                      // partition numbers
    NET_PARTITION_INFO       stuPartions[MAX_PARTITION_NUM];    // partition information
    BYTE                     byReserved[128];                   // reserved
}NET_STORAGE_INFO;

// network resource
typedef struct tagNET_RESOURCE_STATE
{
	int						nIPChanneIn;					// IP channel access speed, unit:kbps
	int						nNetRemain;						// network recevied residual capability, unit:kbps
	int						nNetCapability;					// total network recevied capability, unit:kbps
	int						nRemotePreview;					// remote preview capability, unit:kbps
	int						nRmtPlayDownload;				// remote playback and download capability, unit:kbps
	int						nRemoteSendRemain;				// remote send residual capability, unit:kbps
	int						nRemoteSendCapability;			// total remote send capability, unit:kbps
	BYTE                    byReserved[32];                 // reserved
} NET_RESOURCE_STATE;

// device work state
typedef struct tagNET_WORKSTATE
{
    BOOL                     bOnline;                           // is device online 
    char                     szFirmwareVersion[DH_COMMON_STRING_128];  // firmware version
    float                    fTemperature;                      // temperature, unit: centigrade
    float                    fPowerDissipation;                 // power dissipation, unit: W
    int                      nUtilizationOfCPU;                 // utilization of CPU
    
    int                      nStorageNum;                       // storage number of device
    NET_STORAGE_INFO         stuStorages[MAX_STORAGE_NUM];      // storage information
    int					 	 nUpTimeLast;						// last poewr up time, unit:second
    int					 	 nUpTimeTotal;						// total power up time, unit:second
    double					 dbMemInfoTotal;					// total memory size, unit:byte
    double					 dbMemInfoFree;						// free momery size, unit:byte
    BYTE					 byReserved1[4];					// keep align, not reserved
	char					 szDevType[32];						// device type
    NET_RESOURCE_STATE		 stuResourceStat;					// network resource state
    BYTE                     byReserved[8];                     // reserved
}NET_WORKSTATE;

// get device information, type DH_DEVSTATE_GET_WORK_STATE
typedef struct tagNET_QUERY_WORK_STATE
{
    DWORD                    dwSize;                            // size of structure
    NET_WORKSTATE            stuWorkState;                      // working state
}NET_QUERY_WORK_STATE;

// input parameter of get capsule lock state 
typedef struct tagNET_IN_QUERY_CAPSULE_LOCKSTATE
{
    DWORD                    dwSize;                            // size of structure
    int                      nChannel;                          // channel id
}NET_IN_QUERY_CAPSULE_LOCKSTATE;

// on line state
typedef enum tagNET_EM_ONLINESTATE
{
	NET_EM_ONLINESTATE_UNKNOWN,									 // unknown
    NET_EM_ONLINESTATE_ONLINE,                                   // online
    NET_EM_ONLINESTATE_OFFLINE,                                  // offfline
}NET_EM_ONLINESTATE;

// Lock state
typedef enum  tagNET_EM_LOCKSTATE
{
    NET_EM_LOCKSTATE_UNKNOWN,                                   // unknown
    NET_EM_LOCKSTATE_Open,                                      // open
    NET_EM_LOCKSTATE_CLOSE,                                     // close
    NET_EM_LOCKSTATE_ABNORMAL,                                  // abnormal
    NET_EM_LOCKSTATE_FAKELOCKED,                                // fakelocked
}NET_EM_LOCKSTATE;

// output parameter of get capsule lock state  
typedef struct tagNET_OUT_QUERY_CAPSULE_LOCKSTATE
{
    DWORD                       dwSize;                         // size of structure
    NET_EM_LOCKSTATE            emLockState;                    // lock state
    NET_EM_ONLINESTATE			emOnLineState;					// on line state
}NET_OUT_QUERY_CAPSULE_LOCKSTATE;

// input parameter(get human number in capsule)
typedef struct tagNET_IN_QUERY_CAPSULE_HUMANNUM
{
    DWORD                       dwSize;                         // size of structure
    int                         nChannel;                       // channel id
}NET_IN_QUERY_CAPSULE_HUMANNUM;

// output parameter(get human number in capsule)
typedef struct tagNET_OUT_QUERY_CAPSULE_HUMANNUM
{
    DWORD                       dwSize;                         // size of structure
    UINT                        nHumanNum;                      // human number
}NET_OUT_QUERY_CAPSULE_HUMANNUM;

// record mode
typedef enum tagNET_EM_RECORD_MODE
{
    NET_EM_RECORD_MODE_UNKNOWN,                                 // unknown
    NET_EM_RECORD_MODE_COURSE,                                  // course record
    NET_EM_RECORD_MODE_NORMAL,                                  // normal
}NET_EM_RECORD_MODE;

// In parameter, accrossoing interface CLIENT_SetCourseRecordMode
typedef struct tagNET_IN_SET_COURSE_RECORD_MODE
{
    DWORD                       dwSize;                         
    NET_EM_RECORD_MODE          emRecordMode;                   // record mode
    int                         nClassRoomID;                   // classroom id
}NET_IN_SET_COURSE_RECORD_MODE;

// out parameter,accrossoing interface CLIENT_SetCourseRecordMode
typedef struct tagNET_OUT_SET_COURSE_RECORD_MODE
{
    DWORD                       dwSize;                         
}NET_OUT_SET_COURSE_RECORD_MODE;

// In parameter, accrossoing interface CLIENT_GetCourseRecordMode
typedef struct tagNET_IN_GET_COURSE_RECORD_MODE
{
    DWORD                       dwSize;  
    int                         nClassRoomID;                   // classroom id
}NET_IN_GET_COURSE_RECORD_MODE;

// out parameter,accrossoing interface CLIENT_GetCourseRecordMode
typedef struct tagNET_OUT_GET_COURSE_RECORD_MODE
{
    DWORD                       dwSize; 
    NET_EM_RECORD_MODE          emRecordMode;                   // record mode
}NET_OUT_GET_COURSE_RECORD_MODE;

// device common information
typedef struct tagNET_DEVICE_COMMON_INFO
{
    char                     szVendor[DH_COMMON_STRING_32];     // vendor
    char                     szDviceType[DH_COMMON_STRING_32];  // device type
    char                     szVersion[DH_COMMON_STRING_128];   // device version
    char                     szSerialNo[DH_COMMON_STRING_128];  // serial No.
    BYTE                     byReserved[128];                   // reserved
}NET_DEVICE_COMMON_INFO;

// vehicle detector
typedef struct tagNET_VEHICLE_DETECTOR_INFO
{
    NET_DEVICE_COMMON_INFO   stuDevice;                         // device information
    int                      nWokingState;                      // working state: 0 - fault, 1 - normal, 2 - close 
    int                      nMatchState;                       // coil matching state: 0 - no match, 1 - match, 2 - no detect
    int                      nLaneNum;                          // lane number
    int                      nUsageOfLane[MAX_TRAFFIC_LANE_NUM];// usage of each lane, 0-100
    BYTE                     byReserved[128];                   // reserved
}NET_VEHICLE_DETECTOR_INFO;

// signal detector
typedef struct tagNET_SIGNAL_DETECTOR_INFO 
{
    NET_DEVICE_COMMON_INFO   stuDevice;                         // device information
    int                      nWokingState;                      // working state: 0 - fault, 1 - normal, 2 - close 
    int                      nMatchState;                       // coil matching state: 0 - no match, 1 - match, 2 - no detect
    BYTE                     byReserved[128];                   // reserved
}NET_SIGNAL_DETECTOR_INFO;

// stroboscopic lamp information
typedef struct tagNET_STROBOSCOPIC_LAMP_INFO
{
    NET_DEVICE_COMMON_INFO   stuDevice;                         // device information
    int                      nWokingState;                      // working state: 0 - fault, 1 - normal, 2 - close
    int                      nMatchState;                       // coil matching state: 0 - no match, 1 - match, 2 - no detect
    BYTE                     byReserved[128];                   // reserved
}NET_STROBOSCOPIC_LAMP_INFO;

// RS485 stroboscopic lamp information
typedef struct tagNET_RS485_STROBOSCOPIC_LAMP_INFO
{
    NET_DEVICE_COMMON_INFO   stuDevice;                         // device information
    int                      nWokingState;                      // working state: 0- fault, 1- normal, 2- close
    int                      nMatchState;                       // coil matching state: 0- no match, 1- match, 2- no detect

    int                      nPeripheralAddress;                // address of peripheral
    int                      nPeripheralStateCode;              // peripheral fault code: 1-no response, 2-lamp fault, 3-not connected to storbe signal     
    int                      nLuminance;                        // luminance, 1-20
    int                      nSensibility;                      // sensibility, 1-255
    float                    fPowerDissipation;                 // dissipation of power

    BYTE                     byReserved[128];                   // reserved
}NET_RS485_STROBOSCOPIC_LAMP_INFO;

// flash lamp information
typedef struct tagNET_FLASH_LAMP_INFO
{
    NET_DEVICE_COMMON_INFO   stuDevice;                         // device information
    int                      nWokingState;                      // working state: 0- fault, 1- normal, 2- close
    int                      nMatchState;                       // coil matching state: 0- no match, 1- match, 2- no detect
    BYTE                     byReserved[128];                   // reserved
}NET_FLASH_LAMP_INFO;

// RS485 flash lamp information
typedef struct tagNET_RS485_FLASH_LAMP_INFO
{
    NET_DEVICE_COMMON_INFO   stuDevice;                         // device information
    int                      nWokingState;                      // working state: 0- fault, 1- normal, 2- close
    int                      nMatchState;                       // coil matching state: 0- no match, 1- match, 2- no detect
    
    int                      nPeripheralAddress;                // address of peripheral
    int                      nPeripheralStateCode;              // peripheral fault code: 1-no response, 2-lamp fault, 3-not connected to storbe signal          
    int                      nLuminance;                        // luminance, 1-20
    int                      nSensibility;                      // sensibility, 1-255
    float                    fPowerDissipation;                 // dissipation of power
    
    BYTE                     byReserved[128];                   // reserved
}NET_RS485_FLASH_LAMP_INFO;

// RS485 steady lamp information
typedef struct tagNET_RS485_STEADY_LAMP_INFO
{
    NET_DEVICE_COMMON_INFO   stuDevice;                         // device information
    int                      nWokingState;                      // working state: 0- fault, 1- normal, 2- close
    int                      nMatchState;                       // coil matching state: 0- no match, 1- match, 2- no detect
    
    int                      nPeripheralAddress;                // address of peripheral
    int                      nPeripheralStateCode;              // peripheral fault code: 1-no response, 2-lamp fault, 3-not connected to storbe signal    
    int                      nLuminance;                        // luminance, 1-20
    int                      nSensibility;                      // sensibility, 1-255
    float                    fPowerDissipation;                 // dissipation of power
    
    BYTE                     byReserved[128];                   // reserved
}NET_RS485_STEADY_LAMP_INFO;

// camera peripheral information
typedef struct tagNET_CAMERA_PERIPHERAL_INFO
{
    int                         nVehicleDetectorNum;                                // amount of vehicle detector
    NET_VEHICLE_DETECTOR_INFO   stuVehicleDetectors[MAX_CAMERA_PERIPHERAL_NUM];     // vehicle detector information

    int                         nSignalDetectorNum;                                 // amount of signal detector
    NET_SIGNAL_DETECTOR_INFO    stuSignalDetectors[MAX_CAMERA_PERIPHERAL_NUM];      // signal detector information
    
    int                         nStroboscopicLampNum;                               // amount of stroboscopic lamp
    NET_STROBOSCOPIC_LAMP_INFO  stuStroboscopicLamps[MAX_CAMERA_PERIPHERAL_NUM];    // stroboscopic lamp information

    int                         nFlashLampNum;                                      // amount of flash lamp
    NET_FLASH_LAMP_INFO         stuFlashLamps[MAX_CAMERA_PERIPHERAL_NUM];           // flash lamp information

    int                         nRS485StroboscopicLampNum;                          // amount of RS485 flash lamp
    NET_RS485_STROBOSCOPIC_LAMP_INFO    stuRS485StroboscopicLamps[MAX_CAMERA_PERIPHERAL_NUM]; // RS485 flash lamp information
    
    int                         nRS485FlashLampNum;                                 // amount of RS485 flash lamp
    NET_RS485_FLASH_LAMP_INFO   stuRS485FlashLamps[MAX_CAMERA_PERIPHERAL_NUM];      // RS485 flash lamp

    int                         nRS485SteadyLampNum;                                // amount of RS485 steady lamp
    NET_RS485_STEADY_LAMP_INFO  stuRS485SteadyLamps[MAX_CAMERA_PERIPHERAL_NUM];     // RS485 Steady lamp

    BYTE                        byReserved[128];                                    // reserved
}NET_CAMERA_PERIPHERAL_INFO;

// camera work state 
typedef struct tagNET_REMOTECAMERA_NOTIFY_INFO
{
    int                         nChannelID;                     // channel id
    NET_WORKSTATE               stuNative;                      // camera work state
    NET_CAMERA_PERIPHERAL_INFO  stuPeripherals;                 // all peripherals's information
    BYTE                        byReserved[128];                // reserved
}NET_REMOTECAMERA_NOTIFY_INFO;

// camera work state callback function, lAttachHandle is the result of CLIENT_AttachRemoteCameraState 
typedef void (CALLBACK *fRemoteCameraStateCallBack)(LLONG lAttachHandle, NET_REMOTECAMERA_NOTIFY_INFO* pstuState, DWORD dwStateSize, LDWORD dwUser);

// CLIENT_AttachRemoteCameraState input
typedef struct tagNET_IN_REMOTECAMERA_ATTACH_INFO
{
    DWORD                       dwSize;                         // size of structure
    fRemoteCameraStateCallBack  cbNotify;                       // callback function
    LDWORD                      dwUser;                         // user information
}NET_IN_REMOTECAMERA_ATTACH_INFO;

// CLIENT_AttachRemoteCameraState output
typedef struct tagNET_OUT_REMOTECAMERA_ATTACH_INFO
{
    DWORD                    dwSize;                            // size of structure
}NET_OUT_REMOTECAMERA_ATTACH_INFO;

// attach remote camera state,user malloc memory of pInParam and pOutParam
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachRemoteCameraState(LLONG lLoginID, const NET_IN_REMOTECAMERA_ATTACH_INFO *pInParam, NET_OUT_REMOTECAMERA_ATTACH_INFO *pOutParam, int nWaitTime);

// detach remote camera state
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachRemoteCameraState(LLONG lAttachHandle);

// stream type
typedef enum tagEM_STREAM_TYPE
{
    EM_STREAM_TYPE_UNKNOWN,                               // unknown
    EM_STREAM_TYPE_MAIN,                                  // main
    EM_STREAM_TYPE_EXTRA1,                                // extra1
    EM_STREAM_TYPE_EXTRA2,                                // extra2
    EM_STREAM_TYPE_EXTRA3,                                // extra3
}EM_STREAM_TYPE;

// record manager work state
typedef struct tagNET_RECORDMANAGER_NOTIFY_INFO
{
    int                         nChannelID;                     // channel id
    EM_STREAM_TYPE              emStreamType;                   // stream type
    BOOL                        bState;                         // if record
    BYTE                        byReserved[128];                // reserved
}NET_RECORDMANAGER_NOTIFY_INFO;

// record manager state callback function, lAttachHandle is the result of CLIENT_AttachRecordManagerState
typedef void (CALLBACK *fRecordManagerStateCallBack)(LLONG lAttachHandle, NET_RECORDMANAGER_NOTIFY_INFO* pstuState, DWORD dwStateSize, LDWORD dwUser);

// CLIENT_AttachRecordManagerState input
typedef struct tagNET_IN_RECORDMANAGER_ATTACH_INFO
{
    DWORD                        dwSize;                         // size of structure
    fRecordManagerStateCallBack  cbNotify;                       // callback function
    LDWORD                       dwUser;                         // user info
}NET_IN_RECORDMANAGER_ATTACH_INFO;

// CLIENT_AttachRecordManagerState output
typedef struct tagNET_OUT_RECORDMANAGER_ATTACH_INFO
{
    DWORD                    dwSize;                            // size of structure
}NET_OUT_RECORDMANAGER_ATTACH_INFO;

// attach record manager state, user malloc memory of pInParam and pOutParam
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachRecordManagerState(LLONG lLoginID, const NET_IN_RECORDMANAGER_ATTACH_INFO *pInParam, NET_OUT_RECORDMANAGER_ATTACH_INFO *pOutParam, int nWaitTime);

// detach record manager state
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachRecordManagerState(LLONG lAttachHandle);

// Patrol status
typedef enum tagNET_EM_PATROL_STATUS
{
    NET_EM_PATROL_STATUS_UNKNOWN,                               // Unknown
    NET_EM_PATROL_STATUS_BEGIN,                                 // Patrol start
    NET_EM_PATROL_STATUS_END,                                   // Patrol end
    NET_EM_PATROL_STATUS_FAIL,                                  // Patrol fail
}NET_EM_PATROL_STATUS;

// CLIENT_SendNotifyToDev inparam (corresponding to NET_EM_NOTIFY_PATROL_STATUS)
typedef struct tagNET_IN_PATROL_STATUS_INFO
{
    DWORD                       dwSize;                         // size of the structure
    NET_EM_PATROL_STATUS        emPatrolStatus;                 // Patrol status
    
}NET_IN_PATROL_STATUS_INFO;

// CLIENT_SendNotifyToDev outparam (corresponding to NET_EM_NOTIFY_PATROL_STATUS)
typedef struct tagNET_OUT_PATROL_STATUS_INFO
{
    DWORD                    dwSize;                            // size of the structure
}NET_OUT_PATROL_STATUS_INFO;

// Type of notify, corresponding to CLIENT_SendNotifyToDev 
typedef enum tagNET_EM_NOTIFY_TYPE
{
    NET_EM_NOTIFY_PATROL_STATUS = 1,                            // Send patrol status (corresponding to NET_IN_PATROL_STATUS_INFO, NET_OUT_PATROL_STATUS_INFO)
}NET_EM_NOTIFY_TYPE;

// Send notify to device interface,  pInParam :user allocate memory,  pOutParam :user allocate memory ,please refer to corresponding structure of emNotifyType
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SendNotifyToDev(LLONG lLoginID, NET_EM_NOTIFY_TYPE emNotifyType, const void* pInParam, void* pOutParam, int nWaitTime );

// heat map raw stream information
typedef struct tagNET_RAWSTREAM_NOTIFY_INFO 
{
    int                      nWidth;                            // width of picture
    int                      nHeight;                           // height of picture
    NET_TIME                 stuStartTime;                      // start time
    NET_TIME                 stuEndTime;                        // end time
    char*                    pStream;                           // stream
    int                      nLength;                           // length of raw stream
    BYTE                     byReserved[512];                   // reserved
}NET_RAWSTREAM_NOTIFY_INFO;

// heat map raw stream callback function, lAttachHandle is the result of CLIENT_AttachHeatMapRawStream 
typedef void (CALLBACK *fRawStreamCallBack)(LLONG lAttachHandle, NET_RAWSTREAM_NOTIFY_INFO* pBuf, DWORD dwBufLen, LDWORD dwUser);

// CLIENT_AttachHeatMapRawStream input
typedef struct tagNET_IN_RAWSTREAM_ATTACH_INFO
{
    DWORD                    dwSize;                            // size of structure
    fRawStreamCallBack       cbNotify;                          // callback function
    LDWORD                   dwUser;                            // user information
    int                      nChannel;                          // channel id
}NET_IN_RAWSTREAM_ATTACH_INFO;

// CLIENT_AttachHeatMapRawStream output
typedef struct tagNET_OUT_RAWSTREAM_ATTACH_INFO
{
    DWORD                    dwSize;                            // size of structure
}NET_OUT_RAWSTREAM_ATTACH_INFO;

// attach heat map raw stream,user malloc memory of pInParam and pOutParam
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachHeatMapRawStream(LLONG lLoginID, const NET_IN_RAWSTREAM_ATTACH_INFO *pInParam, NET_OUT_RAWSTREAM_ATTACH_INFO *pOutParam, int nWaitTime);

// detach heat map raw stream 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachHeatMapRawStream(LLONG lAttachHandle);

//plate info
typedef struct tagNET_ANALYSERESULT
{
    char                      szPlateNumber[64];                // plate number
    NET_RECT                  stuRect;                          // plate boundingBox coordinate,absolute coordinate
    BYTE                      byReserved[128];                  // reserved 
}NET_ANALYSERESULT;

// CLIENT_SetIVSServerAnalyseResult input
typedef struct tagNET_IN_SET_ANALYSERESULT_INFO
{
    DWORD                     dwSize;                           // 
    int                       nChannel;                         // channel id,from 0
    int                       nAnalyseResultCount;              // count of plate analyse result
    NET_ANALYSERESULT         stuAnalyseResult[MAX_PLATE_NUM];  // plate info
	unsigned int			  nFrameSequence;					// frame sequence, Used to identify with the IVS,Required
	unsigned int			  nPhysicalLane;					// Physical parking space
}NET_IN_SET_ANALYSERESULT_INFO;

// CLIENT_SetIVSServerAnalyseResult output
typedef struct tagNET_OUT_SET_ANALYSERESULT_INFO
{
    DWORD                     dwSize;                           
}NET_OUT_SET_ANALYSERESULT_INFO;

// CLIENT_AttachEventRestore input
typedef struct tagNET_IN_ATTACH_EVENT_RESTORE
{
    DWORD                dwSize;															// size of structure
	char 				 szUuid[MAX_EVENT_RESTORE_UUID];									// client identifier
}NET_IN_ATTACH_EVENT_RESTORE;

// IVSServer set Analyseresult,use with event of EVENT_IVS_TRAFFIC_ANALYSE_PRESNAP,user malloc and free memory of pInBuf and pOutBuf
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetIVSServerAnalyseResult(LLONG lLoginID, const NET_IN_SET_ANALYSERESULT_INFO* pInBuf,NET_OUT_SET_ANALYSERESULT_INFO* pOutBuf,int nWaitTime);

// Get state of capsulelock,user malloc and free memory of pInBuf and pOutBuf
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetCapsuleLockState(LLONG lLoginID, const NET_IN_QUERY_CAPSULE_LOCKSTATE* pInBuf,NET_OUT_QUERY_CAPSULE_LOCKSTATE* pOutBuf, int nWaitTime);

// get human number in capsule,user malloc and free memory of pInBuf and pOutBuf
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetCapsuleHumanNum(LLONG lLoginID, const NET_IN_QUERY_CAPSULE_HUMANNUM* pInBuf, NET_OUT_QUERY_CAPSULE_HUMANNUM* pOutBuf, int nWaitTime);

// set course record mode,user malloc and free memory of pInBuf and pOutBuf
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetCourseRecordMode(LLONG lLoginID, const NET_IN_SET_COURSE_RECORD_MODE* pInBuf, NET_OUT_SET_COURSE_RECORD_MODE* pOutBuf, int nWaitTime);

// get course record mode,user malloc and free memory of pInBuf and pOutBuf
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetCourseRecordMode(LLONG lLoginID, const NET_IN_GET_COURSE_RECORD_MODE* pInBuf, NET_OUT_GET_COURSE_RECORD_MODE* pOutBuf, int nWaitTime);

// logic channel
typedef enum tagNET_EM_LOGIC_CHANNEL
{
    NET_EM_LOGIC_CHANNEL_INVALID = -1,                          // invalid
    NET_EM_LOGIC_CHANNEL_COMPOSITE,                             // composite channel id
    NET_EM_LOGIC_CHANNEL_PPT,                                   // PPT logic channel id
    NET_EM_LOGIC_CHANNEL_BLACKBOARD,                            // blackboard logic channel id
    NET_EM_LOGIC_CHANNEL_STUDENTFEATURE,                        // student feature logic channel id
    NET_EM_LOGIC_CHANNEL_STUDENTFULLVIEW,                       // student fullview logic channel id
    NET_EM_LOGIC_CHANNEL_TEACHERFEATURE,                        // teacher feature logic channel id
    NET_EM_LOGIC_CHANNEL_TEACHERFULLVIEW,                       // teacher fullview logic channel id
    NET_EM_LOGIC_CHANNEL_TEACHERDETECT,                         // teacher detect logic channel id
    NET_EM_LOGIC_CHANNEL_BLACKBOARDDETECT,                      // blackboard detect logic channel id
	NET_EM_LOGIC_CHANNEL_BLACKBOARD1,                           // blackboard 1 logic channel id
    NET_EM_LOGIC_CHANNEL_BLACKBOARDDETECT1,                     // blackboard detect 1 logic channel id
    NET_EM_LOGIC_CHANNEL_VISUALPRESENTER,                       // visual presenter logic channel id
    NET_EM_LOGIC_CHANNEL_VIDEOSURVEILLANCE,                     // video surveillange channel id
	NET_EM_LOGIC_CHANNEL_VIDEOCONFERENCE,					    // video conference logic channel id
	NET_EM_LOGIC_CHANNEL_VIDEO_PRESENTATION,					// video presentation logic channel id
}NET_EM_LOGIC_CHANNEL;

// channel info
typedef struct  tagNET_LOGIC_CHANNEL_INFO
{
    int                         nRoomID;                        // classroom id
    NET_EM_LOGIC_CHANNEL        emLogicChannel;                 // logic channel id
    BYTE                        byReserved[32];                 // reserved
}NET_LOGIC_CHANNEL_INFO;

// in parameter, accrossoing interface CLIENT_GetRealPreviewChannel
typedef struct tagNET_IN_GET_REAL_PREVIEW_CHANNEL
{
    DWORD                       dwSize;
    int                         nChannelCount;                  // channel count
    NET_LOGIC_CHANNEL_INFO      stuChannelInfo[MAX_PREVIEW_CHANNEL_NUM];          // logicchannel info
}NET_IN_GET_REAL_PREVIEW_CHANNEL;

// out parameter, accrossoing interface CLIENT_GetRealPreviewChannel
typedef struct tagNET_OUT_GET_REAL_PREVIEW_CHANNEL
{
    DWORD                    dwSize;
    int                      nChannelNum;                       // channel number
    int                      nChannel[MAX_PREVIEW_CHANNEL_NUM]; // channel id
}NET_OUT_GET_REAL_PREVIEW_CHANNEL;

// get course preview channel,user malloc and free memory of pInBuf and pOutBuf
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetRealPreviewChannel(LLONG lLoginID, const NET_IN_GET_REAL_PREVIEW_CHANNEL* pInBuf, NET_OUT_GET_REAL_PREVIEW_CHANNEL* pOutBuf, int nWaitTime);

// in parameter, accrossoing interface CLIENT_GetDefaultRealChannel
typedef struct tagNET_IN_GET_DEFAULT_REAL_CHANNEL
{
    DWORD                       dwSize; 
    int                         nChannelCount;                                       // channel count
    NET_LOGIC_CHANNEL_INFO      stuChannelInfo[MAX_PREVIEW_CHANNEL_NUM];             // logic channel info
}NET_IN_GET_DEFAULT_REAL_CHANNEL;

// out parameter, accrossoing interface CLIENT_GetDefaultRealChannel
typedef struct tagNET_OUT_GET_DEFAULT_REAL_CHANNEL
{
    DWORD                    dwSize;
    int                      nChannelNum;                                           // channel count
    int                      nChannel[MAX_PREVIEW_CHANNEL_NUM];                     // channel id
}NET_OUT_GET_DEFAULT_REAL_CHANNEL;

// get course media default real channel id,user malloc and free memory of pInBuf and pOutBuf
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDefaultRealChannel(LLONG lLoginID, const NET_IN_GET_DEFAULT_REAL_CHANNEL* pInBuf, NET_OUT_GET_DEFAULT_REAL_CHANNEL* pOutBuf, int nWaitTime);

// in parameter, accrossoing interface CLIENT_GetLogicChannel
typedef struct tagNET_IN_GET_COURSE_LOGIC_CHANNEL
{
    DWORD                       dwSize; 
    int                         nChannelNum;                       // channel count
    int                         nChannel[MAX_PREVIEW_CHANNEL_NUM]; // channel id
}NET_IN_GET_COURSE_LOGIC_CHANNEL;

// out parameter, accrossoing interface CLIENT_GetLogicChannel
typedef struct tagNET_OUT_GET_COURSE_LOGIC_CHANNEL
{
    DWORD                       dwSize;
    int                         nChannelCount;                                          // logic channel count 
    NET_LOGIC_CHANNEL_INFO      stuChannelInfo[MAX_PREVIEW_CHANNEL_NUM];                // logic channel info
}NET_OUT_GET_COURSE_LOGIC_CHANNEL;

// get course media logic channel id,user malloc and free memory of pInBuf and pOutBuf
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetLogicChannel(LLONG lLoginID, const NET_IN_GET_COURSE_LOGIC_CHANNEL* pInBuf,NET_OUT_GET_COURSE_LOGIC_CHANNEL* pOutBuf, int nWaitTime);

// out parameter, accrossoing interface CLIENT_SetBlindRealChannel
typedef struct tagNET_IN_SET_BLIND_REAL_CHANNEL
{
    DWORD                       dwSize; 
    int                         nChannelNum;                                            // channel count
    int                         nChannel[MAX_PREVIEW_CHANNEL_NUM];                      // channel id
    NET_LOGIC_CHANNEL_INFO      stuChannelInfo[MAX_PREVIEW_CHANNEL_NUM];                // logic channel info
}NET_IN_SET_BLIND_REAL_CHANNEL;

// out parameter, accrossoing interface CLIENT_SetBlindRealChannel
typedef struct tagNET_OUT_SET_BLIND_REAL_CHANNEL
{
    DWORD                       dwSize; 
}NET_OUT_SET_BLIND_REAL_CHANNEL;

// set blind of Real and logic channel ,user malloc and free memory of pInBuf and pOutBuf
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetBlindRealChannel(LLONG lLoginID, const NET_IN_SET_BLIND_REAL_CHANNEL* pInBuf,NET_OUT_SET_BLIND_REAL_CHANNEL* pOutBuf, int nWaitTime);

// out parameter, accrossoing interface CLIENT_GetInputChannelMedia
typedef struct tagNET_IN_GET_INPUT_CHANNEL_MEDIA
{
    DWORD                           dwSize; 
    int                             nChannelNum;                       // channel count
    int                             nChannel[MAX_PREVIEW_CHANNEL_NUM]; // channel id
}NET_IN_GET_INPUT_CHANNEL_MEDIA;

// input media
typedef enum tagNET_ENUM_INPUT_CHANNEL_MEDIA
{
    NET_ENUM_INPUT_MEDIA_UNKNOWN,                                       // unknown
    NET_ENUM_INPUT_MEDIA_VGA,                                           // VGA
    NET_ENUM_INPUT_MEDIA_HDMI,                                          // HDMI
}NET_ENUM_INPUT_CHANNEL_MEDIA;

// out parameter, accrossoing interface CLIENT_GetInputChannelMedia
typedef struct tagNET_OUT_GET_INPUT_CHANNEL_MEDIA
{
    DWORD                           dwSize;
    int                             nChannelNum;                              // channel count
    NET_ENUM_INPUT_CHANNEL_MEDIA    emInputMedia[MAX_PREVIEW_CHANNEL_NUM];    // input media 
}NET_OUT_GET_INPUT_CHANNEL_MEDIA;

// get course media input type,user malloc and free memory of pInBuf and pOutBuf
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetInputChannelMedia(LLONG lLoginID, const NET_IN_GET_INPUT_CHANNEL_MEDIA* pInBuf,NET_OUT_GET_INPUT_CHANNEL_MEDIA* pOutBuf, int nWaitTime);

//attach event restore,user malloc and free memory of pInParam 
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachEventRestore(LLONG lLoginID, const NET_IN_ATTACH_EVENT_RESTORE *pInParam, int nWaitTime);

// detach event restore ,user malloc and free memory of pInParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachEventRestore(LLONG lAttachHandle);

// CLIENT_GetLaserDistance input
typedef struct tagNET_IN_GET_LASER_DISTANCE
{
    DWORD                     dwSize;                           // size of structure
    int                       nChannel;                         // channel id,from 0
}NET_IN_GET_LASER_DISTANCE;

// CLIENT_GetLaserDistance output
typedef struct tagNET_OUT_GET_LASER_DISTANCE
{
    DWORD                     dwSize;                           // size of structure
    UINT                      unDistance;                       // Distance   unit:meter
}NET_OUT_GET_LASER_DISTANCE;

// get the distance which object in the center of picture,user malloc and free memory of pInBuf and pOutBuf
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetLaserDistance(LLONG lLoginID, const NET_IN_GET_LASER_DISTANCE* pInBuf, NET_OUT_GET_LASER_DISTANCE* pOutBuf, int nWaitTime );

// CLIENT_GetAtomsphData input
typedef struct tagNET_IN_GET_ATOMSPHDATA
{
    DWORD                     dwSize;                           
}NET_IN_GET_ATOMSPHDATA;

// CLIENT_GetAtomsphData output
typedef struct tagNET_OUT_GET_ATOMSPHDATA
{
    DWORD                     dwSize;
    float                     fWindSpeed;                       // WindSpeed, unit m/s
    float                     fWindDirection;                   // WindDirection, unit degree
    float                     fHumidity;                        // Humidity, unit %
    float                     fTemperture;                      // Temperture, unit degree Celsius
    float                     fAirPressure;                     // AirPressure, unit hPa
    float                     fSunBathe;                        // SunBathe, unit w/m2
}NET_OUT_GET_ATOMSPHDATA;

// get atomsphere data,user malloc and free memory of pInBuf and pOutBuf
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetAtomsphData(LLONG lLoginID, const NET_IN_GET_ATOMSPHDATA* pInBuf, NET_OUT_GET_ATOMSPHDATA* pOutBuf,int nWaitTime);

// enable/disable designated channel video input parameter
typedef struct tagNET_IN_SET_COURSE_RECORD_STATE
{
    DWORD                    dwSize;                 // the structure size
    int                      nChannel;               // channel id
    int                      nAction;                // 0:enable 1:disable
}NET_IN_SET_COURSE_RECORD_STATE;

// enable/disable designated channel video out parameter
typedef struct tagNET_OUT_SET_COURSE_RECORD_STATE
{
    DWORD                    dwSize;                 // the structure size
}NET_OUT_SET_COURSE_RECORD_STATE;

// start or stop record,user malloc and free memory of pInBuf and pOutBuf
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetCourseRecordState(LLONG lLoginID, const NET_IN_SET_COURSE_RECORD_STATE *pInBuf, NET_OUT_SET_COURSE_RECORD_STATE *pOutBuf, int nWaitTime);

// open find coursemedia record in parameter
typedef struct tagNET_IN_QUERY_COURSEMEDIA_FILEOPEN
{
    DWORD                    dwSize;                            // the structure size
    NET_TIME                 stuStartTime;                      // start time
    NET_TIME                 stuEndTime;                        // end time
    char                     szKeyWord[DH_COMMON_STRING_128];   // key word
}NET_IN_QUERY_COURSEMEDIA_FILEOPEN;

// open find coursemedia record out parameter
typedef struct tagNET_OUT_QUERY_COURSEMEDIA_FILEOPEN
{
    DWORD                    dwSize;                            // the structure size
    UINT                     ntotalNum;                         // total num of resule
    UINT                     nfindID;                           // find id
}NET_OUT_QUERY_COURSEMEDIA_FILEOPEN;

// open find coursemedia record, user malloc and free memory of pInBuf and pOutBuf
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OpenQueryCourseMediaFile(LLONG lLoginID, const NET_IN_QUERY_COURSEMEDIA_FILEOPEN *pInBuf, NET_OUT_QUERY_COURSEMEDIA_FILEOPEN *pOutBuf, int nWaitTime);

// find coursemedia record in parameter
typedef struct tagNET_IN_QUERY_COURSEMEDIA_FILE
{
    DWORD                    dwSize;                            // the structure size
    UINT                     nfindID;                           // find id
    int                      nOffset;                           // start find offset
    int                      nCount;                            // find count
}NET_IN_QUERY_COURSEMEDIA_FILE;

// record info
typedef struct tagNET_RECORD_INFO
{
    int                      nRealChannel;                                      // real channel id
    NET_TIME                 stuStartTime;                                      // start time
    NET_TIME                 stuEndTime;                                        // end time
    UINT                     nFileLen;                                          // record file lenth,low 32-bit,0:no record 
    UINT                     nFileLenEx;                                        // record file lenth,high 32-bit
    UINT                     nTime;                                             // record time unit:second
    UINT                     nFileType;                                         // file type 0,cut file 1, uncut file
    BYTE                     byReserved[64];                                    // reserved 
}NET_RECORD_INFO;

// course info
typedef struct tagNET_COURSE_INFO
{
    char                     szCourseName[DH_COMMON_STRING_64];                 // course name
    char                     szTeacherName[DH_COMMON_STRING_64];                // teacher name
    char                     szIntroduction[DH_COMMON_STRING_128];              // record introdution
    BYTE                     byReserved[64];                                    // reserved
}NET_COURSE_INFO;

// coursemedia info
typedef struct tagNET_COURSEMEDIA_FILE_INFO
{
    int                      nID;                                               // id,-1,no record
    NET_COURSE_INFO          stuCourseInfo;                                     // course info
    int                      nChannelNum;                                       // channel count
    int                      nRecordNum[64];                                    // record section num of logic channel 
    NET_RECORD_INFO          stuRecordInfo[64][16];                             // record info,first dimensional:logic channel id,second dimensional:record section num
    BYTE                     byReserved[128];                                   // reserve
}NET_COURSEMEDIA_FILE_INFO;

// find coursemedia record out parameter
typedef struct tagNET_OUT_QUERY_COURSEMEDIA_FILE
{
    DWORD                       dwSize;                                         // the structure size
    int                         nCountResult;                                   // resule num
    NET_COURSEMEDIA_FILE_INFO   stuCourseMediaFile[64];                         // record file info
}NET_OUT_QUERY_COURSEMEDIA_FILE;

// find coursemedia record,user malloc and free memory of pInBuf and pOutBuf
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoQueryCourseMediaFile(LLONG lLoginID, const NET_IN_QUERY_COURSEMEDIA_FILE *pInBuf, NET_OUT_QUERY_COURSEMEDIA_FILE *pOutBuf, int nWaitTime);

// close find coursemedia record in parameter
typedef struct tagNET_IN_QUERY_COURSEMEDIA_FILECLOSE
{
    DWORD                       dwSize;                                         // the structure size
    UINT                        nFindID;                                        // find id
}NET_IN_QUERY_COURSEMEDIA_FILECLOSE;

// close find coursemedia record out parameter
typedef struct tagNET_OUT_QUERY_COURSEMEDIA_FILECLOSE
{
    DWORD                       dwSize;                                         // the structure size
}NET_OUT_QUERY_COURSEMEDIA_FILECLOSE;

// close find coursemedia record,user malloc and free memory of pInBuf and pOutBuf
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CloseQueryCourseMediaFile(LLONG lLoginID, const NET_IN_QUERY_COURSEMEDIA_FILECLOSE *pInBuf, NET_OUT_QUERY_COURSEMEDIA_FILECLOSE *pOutBuf, int nWaitTime);


// file transmit status
typedef enum tagNET_EM_AIO_FILE_STATUS
{
	NET_EM_AIO_FILE_STATUS_UNKNOWN,
	NET_EM_AIO_FILE_STATUS_BEGIN,				// Begin, 
	NET_EM_AIO_FILE_STATUS_UPLOADING,			// Uploading
	NET_EM_AIO_FILE_STATUS_END,					// End, 
}NET_EM_AIO_FILE_STATUS;

// file type
typedef enum tagNET_EM_AIO_FILE_TYPE
{
	NET_EM_AIO_FILE_TYPE_UNKNOWN,
	NET_EM_AIO_FILE_TYPE_UPSYSTEM,				// "upSystem"
	NET_EM_AIO_FILE_TYPE_UPAPP,					// "upApp"
}NET_EM_AIO_FILE_TYPE;

// CLIENT_UploadAIOFile's interface input param(upload file to the device)
typedef struct tagNET_IN_UPLOAD_AIO_FILE
{
    DWORD               dwSize;
    char*				pszFileSrc;                     // path of source file
    char*				pszFileDst;                     // path of goal file
    char*				pszFolderDst;                   // target file path: may be NULL, NULL device use default path
    unsigned int        nPacketLen;                     // file pack size(byte): 0 means not pack
	NET_EM_AIO_FILE_TYPE	emType;						// file type
} NET_IN_UPLOAD_AIO_FILE;

// CLIENT_UploadAIOFile's interface output param(upload file to the device)
typedef struct tagNET_OUT_UPLOAD_AIO_FILE
{
    DWORD               dwSize;
} NET_OUT_UPLOAD_AIO_FILE;

// fAttachBurnStateCB parameter
typedef struct tagNET_CB_AIOFILEPROC
{
    DWORD						dwSize;
    NET_EM_AIO_FILE_STATUS      emStatus;				// file transmit status
    NET_EM_AIO_FILE_TYPE		emType;					// file type

    unsigned int				dwLength;				// file size : unit byte
	char*						pbFileBuf;				// file buf 
	DWORD						dwBufSize;				// file buf size
}NET_CB_AIOFILEPROC;

// CLIENT_attachAIOFileProc() callback function,lAttachHandle is the return value of CLIENT_attachAIOFileProc
typedef void (CALLBACK *fAttachAIOFileprocCB) (LLONG lAttachHandle, NET_CB_AIOFILEPROC* pBuf, int nBufLen, LDWORD dwUser);

// CLIENT_attachAIOFileProc() input param
typedef struct tagNET_IN_ATTACH_AIO
{
    DWORD                   dwSize;
    fAttachAIOFileprocCB    cbNotify;						// callback function
    LDWORD                  dwUser;                         // user data
}NET_IN_ATTACH_AIO;

// CLIENT_attachAIOFileProc output param
typedef struct tagNET_OUT_ATTACH_AIO
{
    DWORD                   dwSize;
}NET_OUT_ATTACH_AIO;

// advert action
typedef enum tagNET_EM_ADVERT_ACTION
{
	NET_EM_ADVERT_ACTION_UNKNOWN	= 0,
	NET_EM_ADVERT_ACTION_START,				// start
	NET_EM_ADVERT_ACTION_STOP,				// stop
}NET_EM_ADVERT_ACTION;

// advert position
typedef enum tagNET_EM_ADVERT_POSITION
{
	NET_EM_ADVERT_POSITION_UNKNOWN	= 0,
	NET_EM_ADVERT_POSITION_TOP,				// top    
	NET_EM_ADVERT_POSITION_MIDDLE,			// middle 
	NET_EM_ADVERT_POSITION_BOTTOM,			// bottom 
}NET_EM_ADVERT_POSITION;

// CLIENT_SetAdvert input param(set advert)
typedef struct tagNET_IN_SET_ADVERT 
{
    DWORD						dwSize;
    NET_EM_ADVERT_ACTION        emAction;             // advert action
    int							nSpeed;               // advert play speed
    NET_EM_ADVERT_POSITION		emPosition;           // advert position
} NET_IN_SET_ADVERT;

// CLIENT_SetAdvert output param(set advert)
typedef struct tagNET_OUT_SET_ADVERT
{
    DWORD               dwSize;
} NET_OUT_SET_ADVERT;

// CLIENT_AIOScreen input param(get NVR screen)
typedef struct tagNET_IN_AIO_SCREEN
{
    DWORD						dwSize;
} NET_IN_AIO_SCREEN;

// CLIENT_AIOScreen input param(get NVR screen)
typedef struct tagNET_OUT_AIO_SCREEN
{
    DWORD               dwSize;
	char				szName[DH_COMMON_STRING_256];	// picture path
} NET_OUT_AIO_SCREEN;

// CLIENT_AIOandroidAdb input param(control android Adb)
typedef struct tagNET_IN_CONTROL_ANDROID_ADB 
{
    DWORD						dwSize;
	BOOL						bEnable;				// enable open android adb
} NET_IN_CONTROL_ANDROID_ADB;

// CLIENT_AIOandroidAdb output param(control android Adb)
typedef struct tagNET_OUT_CONTROL_ANDROID_ADB
{
    DWORD               dwSize;
} NET_OUT_CONTROL_ANDROID_ADB;

// Alarm EventHandle
typedef struct tagNET_ALARM_MSG_HANDLE
{
	//Ability
	bool                				abChannelCount;                                 // Whether Support Channel Count
	bool                				abAlarmOutCount;                                // Whether Support AlarmOut Count

	bool								abRecordMask;                                   // Whether Support RecordMask
	bool								abRecordEnable;                                 // Whether Support RecordEnable
	bool								abRecordLatch;                                  // Whether Support RecordLatch

	bool								abAlarmOutMask;                                 // Whether Support AlarmOutMask
	
	bool								abAlarmOutEn;                                   // Whether Support AlarmOut Enable
	bool								abAlarmOutLatch;                                // Whether Support AlarmOut Latch
	bool								abExAlarmOutMask;                               // Whether Support ExAlarmOut Mask
	bool								abExAlarmOutEn;                                 // Whether Support ExAlarmOut Enable

	bool								abPtzLinkEn;                                    // Whether Support PTZ Link Enable
	bool								abTourMask;                                     // Whether Support Tour Mask
	bool								abTourEnable;                                   // Whether Support Tour Enable

	bool								abSnapshot;                                     // Whether Support Snapshot
	bool								abSnapshotEn;                                   // Whether Support Snapshot Enable
	bool								abSnapshotPeriod;                               // Whether Support Snapshot Period, Snap a picture every sceond
	bool								abSnapshotTimes;                                // Whether Support Snapshot Times
	bool								abTipEnable;                                    // Whether Support Local Message Box prompt

	bool								abMailEnable;                                   // Whether Support Send Mail Enable
	bool								abMessageEnable;                                // Whether Support Upload to the alarm center server
	bool								abBeepEnable;                                   // Whether Support Beep Enable
	bool								abVoiceEnable;                                  // Whether Support Voice Enable

	bool								abMatrixMask;                                   // Whether Support Matrix Mask
	bool								abMatrixEnable;                                 // Whether Support Matrix Enable
	bool								abEventLatch;                                   // Whether Support Event Latch
	bool								abLogEnable;                                    // Whether Support Log Enable

	bool								abDelay;                                        // Whether Support Delay
	bool								abVideoMessageEn;                               // Whether Support Add Message to video
	bool								abMMSEnable;                                    // Whether Support Send MMS Enable
	bool								abMessageToNetEn;                               // Whether Support Message to Net Enable
	bool								abTourSplit;                                    // Whether Support TourSplit

	bool								abSnapshotTitleEn;                              // Whether Support Snapshot Title Enable
	bool                				abPtzLinkEx;                                    // Whether Support PTZ Link Enable
	bool                				abSnapshotTitle;                                // Whether Support Add Snapshot Title
	bool                				abMailDetail;                                   // Whether Support Mail Detail
	bool                				abVideoTitleEn;                                 // Whether Support Add Video Title Enable, MainStream
	bool                				abVideoTitle;                                   // Whether Support Video Title

	bool                				abTour;                                         // Whether Support Tour
	bool                				abDBKeys;                                       // Whether Support Specifies the KeyWords that need to be Written to the DB in the event details
	bool                				abJpegSummary;                                  // Whether Support Add JPEG Summary
	bool                				abFlashEn;                                      // Whether Support Flash Enable
	bool                				abFlashLatch;                                   // Whether Support Flash Latch

	bool								abAudioFileName;                                // Whether Support Audio File Name
	bool								abAlarmBellEn;                                  // Whether Support AlarmBell Enable
	bool								abAccessControlEn;                              // Whether Support Access Control Enable
	bool								abAccessControl;                                // Whether Support Access Control

	bool								abTalkBack;	                                    // Whether Support TalkBack
	bool								abPSTNAlarmServer;                              // Whether Support PSTN Alarm Server
	bool								abAlarmBellLatch;                               // Whether Support AlarmBell Latch

	bool                                abPlayTimes;                                    // Whether Support PlayTimes
	bool                                abReboot;                                        // Whether Support Reboot enable
	bool                                abBeepTime;                                     // Whether Support BeepTime

	BYTE                                byReserved[68];                                 // reserved for ability

	//Information
	NET_CFG_TIME_SCHEDULE				stuTimeSection;									// Alarm Time Section

	int									nChannelCount;									// The video channel of the device
	int									nAlarmOutCount;									// The alarm output amount of the device

	DWORD								dwRecordMask[CFG_MAX_CHANNEL_COUNT];			// Subnet mask of the recording channel(use the bit to represent)
	BOOL								bRecordEnable;									// Record enable
	int									nRecordLatch;									// Record delay time(s)
	DWORD								dwAlarmOutMask[CFG_MAX_CHANNEL_COUNT];			// ubnet mask of alarm output channel

	BOOL								bAlarmOutEn;									// Alarm output enable
	int									nAlarmOutLatch;									// Alarm output delay time (s)
	DWORD								dwExAlarmOutMask[CFG_MAX_CHANNEL_COUNT];		// Subnet mask of extension alarm output channel 
	BOOL								bExAlarmOutEn;									// Extension alarm output enable

	NET_CFG_PTZ_LINK					stuPtzLink[CFG_MAX_VIDEO_CHANNEL_NUM];			// PTZ activation item
	BOOL								bPtzLinkEn;										// PTZ activation enable
	DWORD								dwTourMask[CFG_MAX_CHANNEL_COUNT];				// Subnet mask of tour channel
	BOOL								bTourEnable;									// Tour enable

	DWORD								dwSnapshot[CFG_MAX_CHANNEL_COUNT];				// Snapshot channel subnet mask
	BOOL								bSnapshotEn;									// Snapshot enable
	int									nSnapshotPeriod;								// Snapshot period(s)
	int									nSnapshotTimes;									// Snapshot times
	BOOL								bTipEnable;										// Local prompt dialogue box

	BOOL								bMailEnable;									// Send out emali. The image is sent out as the attachment.
	BOOL								bMessageEnable;									// Upload to the alarm server
	BOOL								bBeepEnable;							 		// Buzzer

	BOOL								bVoiceEnable;									// Audio prompt
	int                                 nPlayTimes;                                     // The Linkage Audio play times,bVoiceEnable=TRUE is effective

	DWORD								dwMatrixMask[CFG_MAX_CHANNEL_COUNT];			// Subnet mask of the activated video channel
	BOOL								bMatrixEnable;									// Activate the video matrix
	int									nEventLatch;									// Activation delay time (s),0-15
	BOOL								bLogEnable;										// Record log or not

	int									nDelay;											// Delay first and then becomes valid when set. Unit is second.
	BOOL								bVideoMessageEn;								// Overlay the prompt character to the video. The overlay character includes the event type, channel number. The unit is second.
	BOOL								bMMSEnable;										// Enable MMS
	BOOL								bMessageToNetEn;								// Send the message to the network enable
	int									nTourSplit;										// Tour split mod 0: 1tour; 1: 8tour

	BOOL								bSnapshotTitleEn;								// Enble osd
	int                 				nPtzLinkExNum;									// PTZ link configuration number
	NET_PTZ_LINK 						stuPtzLinkEx[CFG_MAX_VIDEO_CHANNEL_NUM];        // PTZ extend information
	int                 				nSnapTitleNum;									// Number of picture title
	NET_CFG_EVENT_TITLE 				stuSnapshotTitle[CFG_MAX_VIDEO_CHANNEL_NUM];	// Picture title content
	NET_CFG_MAIL_DETAIL 				stuMailDetail;									// Mail detial
	BOOL                				bVideoTitleEn;									// Whether overlay video title, mainly refers to the main stream
	int                 				nVideoTitleNum;									// Video title num
	NET_CFG_EVENT_TITLE 				stuVideoTitle[CFG_MAX_VIDEO_CHANNEL_NUM];		// Video title

	int                 				nTourNum;										// Tour num
	NET_CFG_TOURLINK    				stuTour[CFG_MAX_VIDEO_CHANNEL_NUM];				// Tour configuration
	int                 				nDBKeysNum;										// Specify the db keyword on the number of effective
	char                				szDBKeys[CFG_MAX_DBKEY_NUM][CFG_MAX_CHANNELNAME_LEN];	// The specify event detail information need write the BD keyword
	BYTE                				byJpegSummary[CFG_MAX_SUMMARY_LEN];						// The summary information of the jpeg image
	BOOL                				bFlashEnable;											// Whether enable flash
	int                 				nFlashLatch;											// Flash delay time (s),the time range:[10,300]

	char								szAudioFileName[MAX_PATH];						// The Absolute Path to the Linkage Audio Files
	BOOL								bAlarmBellEn;									// Warning Signal Enable
	BOOL								bAccessControlEn;								// Entrance Guard Enable
	DWORD								dwAccessControl;								// Class Number of Entrance Guard
	NET_EM_CFG_ACCESSCONTROLTYPE		emAccessControlType[CFG_MAX_ACCESSCONTROL_NUM];	// Entrance Guard Linkage Operation Information

	NET_CFG_TALKBACK_INFO				stuTalkback;									// Voice Call Linkage Information
	NET_CFG_PSTN_ALARM_SERVER			stuPSTNAlarmServer;								// Telephone Alarm Center Linkage Information
	int									nAlarmBellLatch;								// Police no. output delay time(10-300 s)

	BOOL                                bReboot;                                         // Rebot Enable,TRUE:enable FALSE:unenble
	int                                 nBeepTime;                                      // The Max Beep Time:36000 Stand for persistent buzz
	BOOL								abAudioLinkTime;								// enable of nAudioLinkTime
	int									nAudioLinkTime;									// time of linkage voice play, uint:s
	BOOL								abAudioPlayTimes;								// enable of nAudioPlayTimes
	int									nAudioPlayTimes;								// times of linkage voice play
	BYTE								byReserve[2032];								// reserved
} NET_ALARM_MSG_HANDLE;

// Alarm EventHandle
typedef struct tagNET_CFG_ALARM_MSG_HANDLE
{
    DWORD                               dwSize;

	//Ability
    bool                				abChannelCount;                                 // Whether Support Channel Count
	bool                				abAlarmOutCount;                                // Whether Support AlarmOut Count
	
	bool								abRecordMask;                                   // Whether Support RecordMask
	bool								abRecordEnable;                                 // Whether Support RecordEnable
	bool								abRecordLatch;                                  // Whether Support RecordLatch
	
	bool								abAlarmOutMask;                                 // Whether Support AlarmOutMask
	
	bool								abAlarmOutEn;                                   // Whether Support AlarmOut Enable
	bool								abAlarmOutLatch;                                // Whether Support AlarmOut Latch
	bool								abExAlarmOutMask;                               // Whether Support ExAlarmOut Mask
	bool								abExAlarmOutEn;                                 // Whether Support ExAlarmOut Enable
	
	bool								abPtzLinkEn;                                    // Whether Support PTZ Link Enable
	bool								abTourMask;                                     // Whether Support Tour Mask
	bool								abTourEnable;                                   // Whether Support Tour Enable
	
	bool								abSnapshot;                                     // Whether Support Snapshot
	bool								abSnapshotEn;                                   // Whether Support Snapshot Enable
	bool								abSnapshotPeriod;                               // Whether Support Snapshot Period, Snap a picture every sceond
	bool								abSnapshotTimes;                                // Whether Support Snapshot Times
	bool								abTipEnable;                                    // Whether Support Local Message Box prompt
	
	bool								abMailEnable;                                   // Whether Support Send Mail Enable
	bool								abMessageEnable;                                // Whether Support Upload to the alarm center server
	bool								abBeepEnable;                                   // Whether Support Beep Enable
	bool								abVoiceEnable;                                  // Whether Support Voice Enable
	
	bool								abMatrixMask;                                   // Whether Support Matrix Mask
	bool								abMatrixEnable;                                 // Whether Support Matrix Enable
	bool								abEventLatch;                                   // Whether Support Event Latch
	bool								abLogEnable;                                    // Whether Support Log Enable
	
	bool								abDelay;                                        // Whether Support Delay
	bool								abVideoMessageEn;                               // Whether Support Add Message to video
	bool								abMMSEnable;                                    // Whether Support Send MMS Enable
	bool								abMessageToNetEn;                               // Whether Support Message to Net Enable
	bool								abTourSplit;                                    // Whether Support TourSplit
	
	bool								abSnapshotTitleEn;                              // Whether Support Snapshot Title Enable
	bool                				abPtzLinkEx;                                    // Whether Support PTZ Link Enable
	bool                				abSnapshotTitle;                                // Whether Support Add Snapshot Title
	bool                				abMailDetail;                                   // Whether Support Mail Detail
	bool                				abVideoTitleEn;                                 // Whether Support Add Video Title Enable, MainStream
	bool                				abVideoTitle;                                   // Whether Support Video Title
	
	bool                				abTour;                                         // Whether Support Tour
	bool                				abDBKeys;                                       // Whether Support Specifies the KeyWords that need to be Written to the DB in the event details
	bool                				abJpegSummary;                                  // Whether Support Add JPEG Summary
	bool                				abFlashEn;                                      // Whether Support Flash Enable
	bool                				abFlashLatch;                                   // Whether Support Flash Latch
	
    bool								abAudioFileName;                                // Whether Support Audio File Name
    bool								abAlarmBellEn;                                  // Whether Support AlarmBell Enable
    bool								abAccessControlEn;                              // Whether Support Access Control Enable
    bool								abAccessControl;                                // Whether Support Access Control
	
    bool								abTalkBack;	                                    // Whether Support TalkBack
    bool								abPSTNAlarmServer;                              // Whether Support PSTN Alarm Server
    bool								abAlarmBellLatch;                               // Whether Support AlarmBell Latch

	bool                                abPlayTimes;                                    // Whether Support PlayTimes
	bool                                abReboot;                                        // Whether Support Reboot enable
	bool                                abBeepTime;                                     // Whether Support BeepTime
	
	BYTE                                byReserved[68];                                 // reserved for ability

	//Information
	NET_CFG_TIME_SCHEDULE				stuTimeSection;									// Alarm Time Section

	int									nChannelCount;									// The video channel of the device
	int									nAlarmOutCount;									// The alarm output amount of the device

	DWORD								dwRecordMask[CFG_MAX_CHANNEL_COUNT];			// Subnet mask of the recording channel(use the bit to represent)
	BOOL								bRecordEnable;									// Record enable
	int									nRecordLatch;									// Record delay time(s)
	DWORD								dwAlarmOutMask[CFG_MAX_CHANNEL_COUNT];			// ubnet mask of alarm output channel

	BOOL								bAlarmOutEn;									// Alarm output enable
	int									nAlarmOutLatch;									// Alarm output delay time (s)
	DWORD								dwExAlarmOutMask[CFG_MAX_CHANNEL_COUNT];		// Subnet mask of extension alarm output channel 
	BOOL								bExAlarmOutEn;									// Extension alarm output enable

	NET_CFG_PTZ_LINK					stuPtzLink[CFG_MAX_VIDEO_CHANNEL_NUM];			// PTZ activation item
	BOOL								bPtzLinkEn;										// PTZ activation enable
	DWORD								dwTourMask[CFG_MAX_CHANNEL_COUNT];				// Subnet mask of tour channel
	BOOL								bTourEnable;									// Tour enable

	DWORD								dwSnapshot[CFG_MAX_CHANNEL_COUNT];				// Snapshot channel subnet mask
	BOOL								bSnapshotEn;									// Snapshot enable
	int									nSnapshotPeriod;								// Snapshot period(s)
	int									nSnapshotTimes;									// Snapshot times
	BOOL								bTipEnable;										// Local prompt dialogue box

	BOOL								bMailEnable;									// Send out emali. The image is sent out as the attachment.
	BOOL								bMessageEnable;									// Upload to the alarm server
	BOOL								bBeepEnable;							 		// Buzzer
	
	BOOL								bVoiceEnable;									// Audio prompt
	int                                 nPlayTimes;                                     // The Linkage Audio play times,bVoiceEnable=TRUE is effective

	DWORD								dwMatrixMask[CFG_MAX_CHANNEL_COUNT];			// Subnet mask of the activated video channel
	BOOL								bMatrixEnable;									// Activate the video matrix
	int									nEventLatch;									// Activation delay time (s),0-15
	BOOL								bLogEnable;										// Record log or not

	int									nDelay;											// Delay first and then becomes valid when set. Unit is second.
	BOOL								bVideoMessageEn;								// Overlay the prompt character to the video. The overlay character includes the event type, channel number. The unit is second.
	BOOL								bMMSEnable;										// Enable MMS
	BOOL								bMessageToNetEn;								// Send the message to the network enable
	int									nTourSplit;										// Tour split mod 0: 1tour; 1: 8tour

	BOOL								bSnapshotTitleEn;								// Enble osd
	int                 				nPtzLinkExNum;									// PTZ link configuration number
	NET_PTZ_LINK 						stuPtzLinkEx[CFG_MAX_VIDEO_CHANNEL_NUM];        // PTZ extend information
	int                 				nSnapTitleNum;									// Number of picture title
	NET_CFG_EVENT_TITLE 				stuSnapshotTitle[CFG_MAX_VIDEO_CHANNEL_NUM];	// Picture title content
	NET_CFG_MAIL_DETAIL 				stuMailDetail;									// Mail detial
	BOOL                				bVideoTitleEn;									// Whether overlay video title, mainly refers to the main stream
	int                 				nVideoTitleNum;									// Video title num
	NET_CFG_EVENT_TITLE 				stuVideoTitle[CFG_MAX_VIDEO_CHANNEL_NUM];		// Video title

	int                 				nTourNum;										// Tour num
	NET_CFG_TOURLINK    				stuTour[CFG_MAX_VIDEO_CHANNEL_NUM];				// Tour configuration
	int                 				nDBKeysNum;										// Specify the db keyword on the number of effective
	char                				szDBKeys[CFG_MAX_DBKEY_NUM][CFG_MAX_CHANNELNAME_LEN];	// The specify event detail information need write the BD keyword
	BYTE                				byJpegSummary[CFG_MAX_SUMMARY_LEN];						// The summary information of the jpeg image
	BOOL                				bFlashEnable;											// Whether enable flash
	int                 				nFlashLatch;											// Flash delay time (s),the time range:[10,300]

	char								szAudioFileName[MAX_PATH];						// The Absolute Path to the Linkage Audio Files
	BOOL								bAlarmBellEn;									// Warning Signal Enable
	BOOL								bAccessControlEn;								// Entrance Guard Enable
	DWORD								dwAccessControl;								// Class Number of Entrance Guard
	NET_EM_CFG_ACCESSCONTROLTYPE		emAccessControlType[CFG_MAX_ACCESSCONTROL_NUM];	// Entrance Guard Linkage Operation Information

	NET_CFG_TALKBACK_INFO				stuTalkback;									// Voice Call Linkage Information
	NET_CFG_PSTN_ALARM_SERVER			stuPSTNAlarmServer;								// Telephone Alarm Center Linkage Information
	int									nAlarmBellLatch;								// Police no. output delay time(10-300 s)

	BOOL                                bReboot;                                         // Rebot Enable,TRUE:enable FALSE:unenble
	int                                 nBeepTime;                                      // The Max Beep Time:36000 Stand for persistent buzz
} NET_CFG_ALARM_MSG_HANDLE;

// Link group
typedef struct tagNET_CFG_LINKGROUP_INFO
{
	BOOL 						bEnable;							// Group enable
	char						szGroupID[64];						// Group ID
	BYTE                		bySimilarity;                       // Similarity
	BYTE						bReserved1[3];						// Byte alignment
	char						szColorName[32];						// Color name
	BOOL 						bShowTitle;							// Show title
	BOOL 						bShowPlate;							// Show plate		
	NET_ALARM_MSG_HANDLE 		stuEventHandler;					// Alarm event handler
	BYTE						bReserved[512];						// Reserved	
}NET_CFG_LINKGROUP_INFO;

// Stranger mode
typedef struct tagNET_CFG_STRANGERMODE_INFO
{
	BOOL 						bEnable;							// Mode enable
	char						szColorHex[8];						// Color HEX
	BOOL 						bShowTitle;							// Show title
	BOOL 						bShowPlate;							// Show plate
	NET_ALARM_MSG_HANDLE 		stuEventHandler;					// Alarm event handler
	BYTE						bReserved[512];						// Reserved
}NET_CFG_STRANGERMODE_INFO;

// Calibrate box info 
typedef struct tagNET_CFG_CALIBRATEBOX_INFO
{
	POINTCOORDINATE     stuCenterPoint;                       // Calibrate box center point(0,8191)
	float               fRatio;                               // The relative ratio of the calibrate box(such as 1 means the calibrate box,0.5 means the half size of the calibrate box)
}NET_CFG_CALIBRATEBOX_INFO;

// Size
typedef struct tagNET_CFG_SIZE
{
	union
	{
		float				nWidth;			// Width
		float				nArea;			// Area
	};
	float					nHeight;		// Height
	
} NET_CFG_SIZE;

// Size filter
typedef struct tagNET_CFG_SIZEFILTER_INFO
{
	int                   nCalibrateBoxNum;                       // Calibration pane number
	NET_CFG_CALIBRATEBOX_INFO stuCalibrateBoxs[10]; 				  // Calibration box (far and near-end calibration mode only)
	bool                bMeasureModeEnable;                       // Measurement mode enabled or not 
	BYTE                bMeasureMode;                             // Measurement mode, 0-pixel, far and near-end calibration not necessary, 1- real length, unit: meter, 2- pixel after far and near-end calibration
	bool                bFilterTypeEnable;                        // Filter type enabled or not 
	// ByArea,ByRatio as compatible only, with independent ByArea and ByRatio alternatives as substitute 2012/03/06
	BYTE				bFilterType;			 				  // Filter type:0:"ByLength",1:"ByArea", 2"ByWidthHeight"
	bool                bFilterMinSizeEnable;                     // Min object size parameter is valid or not  
	bool                bFilterMaxSizeEnable;                     // Max object size parameter is valid or not 
	bool                abByArea;
	bool                abMinArea;
	bool                abMaxArea;
	bool                abMinAreaSize;
	bool                abMaxAreaSize;
	bool                bByArea;                                  // Filter by area or not. You can use ComplexSizeFilter to see it works or not. 
	NET_CFG_SIZE		stuFilterMinSize;						  // Min object size      size of length ratio under "ByLength" Mode,size of area under "ByArea" mode, invalid height (size of standard box lengths under far and near-end calibration mode)
	NET_CFG_SIZE		stuFilterMaxSize;				          // Max object size size of length ratio under "ByLength" mode, size of area under "ByArea" mode", invalid height (size of standard box lengths under far and near-end calibration mode)
	float               nMinArea;                                 // Min area
	float               nMaxArea;                                 // Max area
	NET_CFG_SIZE        stuMinAreaSize;                           // Min area rectangle box.   When  "measurement method" is "pixel", it represents its sizes of lengths; when "measurement method" is "far and near-end calibration mode", it represents the min sizes of lengths of standard box
	NET_CFG_SIZE        stuMaxAreaSize;                           // Max area rectangle box, same as above
	bool                abByRatio;
	bool                abMinRatio;
	bool                abMaxRatio;
	bool                abMinRatioSize;
	bool                abMaxRatioSize;
	bool                bByRatio;                                 // Filter by length ratio or not   . You can use ComplexSizeFilter to see it works or not. 
	bool                bReserved1[2];
	double              dMinRatio;                                // Min W/H ratio
	double              dMaxRatio;                                // Max W/H ratio
	NET_CFG_SIZE        stuMinRatioSize;                          // Min W/H ratio rectangle box size, min W/H ratio corresponding to sizes of lengths of rectangle box
	NET_CFG_SIZE        stuMaxRatioSize;                          // Max W/H ratio rectangle box size. See above information.
	int                 nAreaCalibrateBoxNum;                     // Area calibration box number
	NET_CFG_CALIBRATEBOX_INFO stuAreaCalibrateBoxs[10];			  // Area calibration box
	int                 nRatioCalibrateBoxs;                      // W/H calibration box number
	NET_CFG_CALIBRATEBOX_INFO stuRatioCalibrateBoxs[10];			  // W/H calibration box number
	
	bool                abBySize;                                 // Valid filter by L/H ration parameter enabled or not 
	bool                bBySize;                                  // L/W filter enabled
	BYTE				bReserved[518];							  // Reserved
}NET_CFG_SIZEFILTER_INFO;

// Sensor type
typedef enum tagEM_SENSOR_TYPE
{
	EM_SENSOR_TYPE_UNKNOWN,		// Unknown
	EM_SENSOR_TYPE_NC,			// NC
	EM_SENSOR_TYPE_NO,			// NO
}EM_SENSOR_TYPE;

// Local ext alarm info
typedef struct tagNET_LOCAL_EXT_ALARM_INFO
{
	DWORD				dwSize;                        // Struct size
	BOOL				bEnable;					   // Enable
	char				szName[MAX_LOCAL_EXT_ALARM_NAME_LEN];	// Name
	EM_SENSOR_TYPE		emSensorType;				   // Sensor type
	NET_CFG_ALARM_MSG_HANDLE  stuEventHandler;		   // Event handler
}NET_LOCAL_EXT_ALARM_INFO;

// firewarning mode type
typedef enum tagNET_EM_FIREWARNING_MODE_TYPE
{
	NET_EM_FIREWARNING_TYPE_PTZPRESET,		// PTZ preset point modedefault	
	NET_EM_FIREWARNING_TYPE_SPACEEXCLUDE,	// Spatial exclusion mode
} NET_EM_FIREWARNING_MODE_TYPE;

// firewarning mode config NET_EM_CFG_FIRE_WARNINGMODE
typedef struct tagNET_FIREWARNING_MODE_INFO
{
	DWORD							dwSize;							// struct size
	NET_EM_FIREWARNING_MODE_TYPE	emFireWarningMode;				// firewarning mode
} NET_FIREWARNING_MODE_INFO;

// fire warning detect mode type
typedef enum tagNET_EM_FIREWARNING_DETECTMODE_TYPE
{
	NET_EM_FIREWARNING_DETECTMODE_TYPE_AUTO,			// Auto(default)
	NET_EM_FIREWARNING_DETECTMODE_TYPE_NORMAL,		    // Normal
} NET_EM_FIREWARNING_DETECTMODE_TYPE;

//fire warning detect target
typedef enum tagNET_EM_FIREWARNING_DETECTTARGET_TYPE
{
	NET_EM_FIREWARNING_DETECTTARGET_TYPE_FIRE,		// Fire point detection(default)
	NET_EM_FIREWARNING_DETECTTARGET_TYPE_SMOKE,		// Smoking detection
} NET_EM_FIREWARNING_DETECTTARGET_TYPE;

#define  MAX_FIREWARNING_DETECTRGN_NUM			32								// Max fire warning detectrgn num
#define  MAX_FIREWARNING_RULE_NUM				32								// Max fire warning rule num
#define  MAX_FIREWARNING_DETECTWND_NUM			8								// Max fire detect windows num

// Fire warning linkage item information
typedef struct tagNET_FIREWARN_EVENTHANDLE_INFO
{
	NET_CFG_TIME_SCHEDULE   stuTimeSection;									// Alarm time section
	BOOL					bRecordEnable;									// Video enables,and nust be RecordChannels at the same time.
																			// The enable is true and the event action is start.
																			// Start recording, stop stop recording. If it is false, it will not be videotaped
	int						nRecordChannelNum;								// Number of video channels
	int						nRecordChannels[32];							// Video channel number list
	int						nRecordLatch;									// video delay time range[10~300]
	BOOL					bAlarmOutEnable;								// Alarm output enable
	int						nAlarmOutChannelNum;							// Number of alarm output channels
	int						nAlarmOutChannels[32];							// List of alarm output channel numbers
	int						nAlarmOutLatch;									// Output delay time after alarm input stopsunitsecondrange[10, 300]
	int						nPtzLinkNum;									// Ptzlink num   
	DH_PTZ_LINK				struPtzLink[16];								// PTZ linkage 
	BOOL					bPtzLinkEnable;									// PTZ link enable
	BOOL					bSnapshotEnable;								// Snapshot enable
	int						nSnapshotChannelNum;							// Snapshot channel num
	int						nSnapshotChannels[32];							// List of snapshot channel numbers
	BOOL					bMailEnable;									// Mail enable
	BYTE					byReserved[1024];								// Reserved
} NET_FIREWARN_EVENTHANDLE_INFO;

// Fire detect window
typedef struct tagNET_FIREWARN_DETECTWND_INFO
{
	int				nRgnNum;												// Number of test areas
	BYTE            byReservedAlign[4];										// byReserved
	INT64			nRegions[MAX_FIREWARNING_DETECTRGN_NUM];				// Detection area
	NET_POSTIONF	stuPostion;												// Space exclusion information
	int				nTargetSize;											// Target size(Fire warning mode:Normal effective, unit:piexl)
	int				nSensitivity;											// detection sensitivity(Fire warning mode:Normal effective)
	int				nWindowsID;												// Windows ID
	char			szName[32];												// Windows name
	BYTE			byReserved[256];										// byReserved
} NET_FIREWARN_DETECTWND_INFO;

// Firewarn rule info
typedef struct tagNET_FIREWARN_RULE_INFO
{
	BOOL							bEnable;								// Fire warning enable 
	int								nPresetId;								// Preset id(PTZ preset mode effective)
	int								nRow;									// Fire detection area row number
	int								nCol;									// Fire detection area col number( Default 40 lines) 
	NET_EM_FIREWARNING_DETECTMODE_TYPE			emFireWarningDetectMode;	// Fire Warning Detection mode
	NET_EM_FIREWARNING_DETECTTARGET_TYPE		emFireWarningDetectTragetType;//Fire Warning Detection target
	BOOL							bTimeDurationEnable;					// Time duration enable
	int								nFireDuration;							// Fire duration(unit:seconds)
	NET_FIREWARN_EVENTHANDLE_INFO	stuEventHandler;						// Fire linkage information
	int								nDetectWindowNum;						// Detect window num
	NET_FIREWARN_DETECTWND_INFO		stuDetectWnd[MAX_FIREWARNING_DETECTWND_NUM]; // Fire detect Window
	BYTE							byReserved[256];						// Reserved
} NET_FIREWARN_RULE_INFO;

// Fire warning configLarge structure,it is recommended to allocate memory with new NET_EM_CFG_FIRE_WARNING
typedef struct tagNET_FIRE_WARNING_INFO
{
	DWORD							dwSize;									// struct size
	int								nFireWarnRuleNum;						// Fire warning num
	NET_FIREWARN_RULE_INFO			stuFireWarnRule[MAX_FIREWARNING_RULE_NUM];	// Fire warning config rule
} NET_FIRE_WARNING_INFO;

// hot alarm condition
typedef enum tagEM_HOT_ALARM_CONDITION
{
    EM_HOT_ALARM_CONDITION_UNKNOWN,						               // unknown
    EM_HOT_ALARM_CONDITION_ABOVE_MAX,								   // above max temperature threshold
    EM_HOT_ALARM_CONDITION_ABOVE_MAX_AND_BELOW_MIN,					   // above max temperature threshold and below min temperature threshold(cold alarm conditon takes this value into effect)
} EM_HOT_ALARM_CONDITION;

// cold alarm condition
typedef enum tagEM_COLD_ALARM_CONDITION
{
    EM_COLD_ALARM_CONDITION_UNKNOWN,						           // unknown
    EM_COLD_ALARM_CONDITION_BELOW_MIN,								   // below min temperature threshold
    EM_COLD_ALARM_CONDITION_ABOVE_MAX_AND_BELOW_MIN,				   // above max temperature threshold and below min temperature threshold(hot alarm conditon takes this value into effect)
} EM_COLD_ALARM_CONDITION;

// hot cold spot warning configLarge structure, it is recommended to allocate memory with new NET_EM_CFG_HOT_COLD_SPOT_WARNING
typedef struct tagNET_HOT_COLD_SPOT_WARNING_INFO
{
    DWORD							dwSize;								// struct size
    BOOL                            bHotAlarmEnable;                    // hot alarm enable
    BOOL                            bColdAlarmEnable;                   // cold alarm enable
    EM_HOT_ALARM_CONDITION			emHotAlarmCondition;				// hot alarm condition
    EM_COLD_ALARM_CONDITION			emColdAlarmCondition;				// cold alarm condition
    BYTE                            byReserved[4];                      // reserved
    double                          dHotThreshold;                      // hot alarm temperature threshold
    double                          dColdThreshold;                     // cold alarm temperature threshold
    BOOL                            bHotSpotLinkEnable;                 // hot spot link enable
    BOOL                            bColdSpotLinkEnable;                // cold spot link enable
    NET_CFG_ALARM_MSG_HANDLE        stuEventHandler;		            // alarm activation
} NET_HOT_COLD_SPOT_WARNING_INFO;

// Alarm Out Mode
typedef enum tagEM_ALARM_OUT_MODE
{
	EM_ALARM_OUT_MODE_UNKNOWN = -1,						// Unknown
	EM_ALARM_OUT_MODE_AUTO,								// Auto Alarm
	EM_ALARM_OUT_MODE_FORCED,							// Forced Alarm
	EM_ALARM_OUT_MODE_CLOSE,							// Close Alarm
} EM_ALARM_OUT_MODE;

// Remote Alarm Bell Config (corresponding to NET_EM_CFG_REMOTE_ALARM_BELL)
typedef struct tagNET_CFG_REMOTE_ALARM_BELL_INFO
{
	DWORD							dwSize;							// Struct Size
	EM_ALARM_OUT_MODE				emMode;							// Alarm Out Mode
} NET_CFG_REMOTE_ALARM_BELL_INFO;
 


// alarm of blacklist form accesscontrol    
typedef struct tagNET_CFG_ACCESSCTL_BLACKLIST
{
    DWORD                           dwSize;                             
    BOOL                            bEnable;								// config enable   
}NET_CFG_ACCESSCTL_BLACKLIST;

typedef struct tagNET_CFG_VSP_HONEYWELL_INFO
{
	DWORD                   dwSize;                 //Struct size
	BOOL                    bEnable;                //Enable
	char                    szIPAddress[64];        //Server IP
	int                     nPort;                  //Server port
	char                    szUserName[128];        //Username
	char                    szPassword[128];        //Password
	char					szUserCode[8];			//UserCode
}NET_CFG_VSP_HONEYWELL_INFO;

// Log Group
typedef struct tagNET_CFG_LOG_GROUP_INFO
{
	UINT				nSize;		// Size, Max Value: 1400
	UINT				nBatch;		// Batch, Max Value: 20 Default: 1
	UINT				nDelay;		// Delay, Max Value: 60000 Default: 60000 Unit: millseconds
	BYTE				byReserved[32];		// Reserved
}NET_CFG_LOG_GROUP_INFO;
// Service ingo
typedef struct tagNET_CFG_LOG_SERVER_INFO
{
	BOOL						bEnable;		// Enable
	char						szIP[40];		// IP
	UINT						nPort;			// Port
	UINT						nProtocol;		// Protocol. 0: TCP 1: UDP
	UINT						nSerial;		// Serial, Max Value: 0xFFFF. 0x0001:Comn 1, 0x0002:Comn 2, 0x0004:Comn 3, etc
	NET_CFG_LOG_GROUP_INFO		stuLogGroup;	// Log group
	BYTE						byReserved[256];	// Reserved
}NET_CFG_LOG_SERVER_INFO;
// Append info
typedef struct tagNET_CFG_LOG_APPEND_INFO
{
	BOOL		bSequence;		// Sequence
	BOOL		bDate;			// Date enable
	BOOL		bTime;			// Time enable
	char		szCustom[32];	// Custom
	BYTE		byReserved[32];	// Reserved
}NET_CFG_LOG_APPEND_INFO;
// Serial push log
typedef struct tagNET_CFG_SERIALPUSHLOG_INFO
{
	DWORD						dwSize;					// Struct size
	BOOL						bEnable;				// Enable
	NET_CFG_LOG_SERVER_INFO		stuServerInfo[16];		// Server info
	int							nServerCount;			// Server info count
	NET_CFG_LOG_APPEND_INFO		stuAppendInfo[16];		// Append info
	int							nAppendCount;			// Append info count
}NET_CFG_SERIALPUSHLOG_INFO;

// coaxial local alaram config
typedef struct tagNET_CFG_COAXIAL_ALARMLOCAL
{
	BOOL							bEnable;				// enable
	char							szName[64];				// channel name
	NET_SENSE_METHOD				emSenseMethod;			// sensor type
	NET_ALARM_MSG_HANDLE			stuEventHandler;		// event config info
	BYTE							byReserved[1024];		// reserved
}NET_CFG_COAXIAL_ALARMLOCAL;

// coaxial local alarm info
typedef struct tagNET_COAXIAL_ALARMLOCAL_INFO
{
	DWORD							dwSize;					// Struct size
	NET_CFG_COAXIAL_ALARMLOCAL*		pstuAlaramCfg;			// config info 
	int								nCount;					// pstuAlaramCfg count
	int								nCountRet;				// count return
}NET_COAXIAL_ALARMLOCAL_INFO;

// Register update file
CLIENT_NET_API LLONG CALL_METHOD CLIENT_attachAIOFileProc(LLONG lLoginID, const NET_IN_ATTACH_AIO* pstInParam, NET_OUT_ATTACH_AIO *pstOutParam, int nWaitTime);

// detach AIO fileproc,lAttachHandle is the return value of CLIENT_attachAIOFileProc
CLIENT_NET_API BOOL CALL_METHOD CLIENT_detachAIOFileproc(LLONG lAttachHandle);

// set NVR advert
CLIENT_NET_API LLONG CALL_METHOD CLIENT_SetAIOAdvert(LLONG lLoginID, const NET_IN_SET_ADVERT* pstInParam, NET_OUT_SET_ADVERT *pstOutParam, int nWaitTime );

// get NVR screen
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AIOScreen(LLONG lLoginID, const NET_IN_AIO_SCREEN* pstInParam, NET_OUT_AIO_SCREEN *pstOutParam, int nWaitTime );

// CLIENT_StartUploadAIOFile callback function, lUploadFileHandle is CLIENT_StartUploadAIOFile return value
typedef void (CALLBACK *fUploadAIOFileCallBack) (LLONG lUploadFileHandle, int nTotalSize, int nSendSize, LDWORD dwUser, int nError);

// start upload AIO file
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartUploadAIOFile(LLONG lLoginID, const NET_IN_UPLOAD_AIO_FILE* pInParam, NET_OUT_UPLOAD_AIO_FILE* pOutParam, fUploadAIOFileCallBack cbUploadFile, LDWORD dwUser);

// stop upload AIO file
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopUploadAIOFile(LLONG lUploadFileID);

// control androidAdb open or close
CLIENT_NET_API LLONG CALL_METHOD CLIENT_ControlAndroidAdb(LLONG lLoginID, const NET_IN_CONTROL_ANDROID_ADB* pstInParam, NET_OUT_CONTROL_ANDROID_ADB *pstOutParam, int nWaitTime);

// configuration interface, Get configuration information(szOutBuffer malloc/release by user, type corresponding to enum NET_EM_CFG_OPERATE_TYPE)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetConfig(LLONG lLoginID, NET_EM_CFG_OPERATE_TYPE emCfgOpType, int nChannelID,
                                                         void* szOutBuffer, DWORD dwOutBufferSize, int waittime, void *reserve);

// configuration interface, Set configuration information(szInBuffer malloc/release by user, type corresponding to enum NET_EM_CFG_OPERATE_TYPE)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetConfig(LLONG lLoginID, NET_EM_CFG_OPERATE_TYPE emCfgOpType, int nChannelID,
                                                         void* szInBuffer, DWORD dwInBufferSize, int waittime, int *restart, void *reserve);

// set net AutoAdapt Encode policy, in parameter
typedef struct tagNET_IN_BUFFER_POLICY
{
    DWORD                   dwSize;             
    DH_RealPlayType         emRealPlayType;          // stream type,only support DH_RType_Realplay_0,DH_RType_Realplay_1,DH_RType_Realplay_Test
    UINT                    nPolicy;                 // 0:default,1:fluency, 2:actual time
}NET_IN_BUFFER_POLICY; 

// set net AutoAdapt Encode policy,user malloc and free memory of pInBuf 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetRealplayBufferPolicy(LLONG lPlayHandle,NET_IN_BUFFER_POLICY* pInBuf,int nWaitTime);



//////////////////////////////////////////////////////////////////////////
// TestOSD operation type
typedef enum tagEM_TESTOSD_OPERATE_TYPE
{
    EM_TESTOSD_ADD_TEXT,          // add text info, corresponding to NET_IN_TESTOSD_ADD_TEXT and NET_OUT_TESTOSD_ADD_TEXT
    EM_TESTOSD_GET_TEXT,          // get text info, corresponding to NET_IN_TESTOSD_GET_TEXT and NET_OUT_TESTOSD_GET_TEXT
    EM_TESTOSD_MODIFY_TEXT,       // modify text info, corresponding to NET_IN_TESTOSD_MODIFY_TEXT and NET_OUT_TESTOSD_MODIFY_TEXT
    EM_TESTOSD_DELETE_TEXT,       // delete text info, corresponding to NET_IN_TESTOSD_DELETE_TEXT and NET_OUT_TESTOSD_DELETE_TEXT
    EM_TESTOSD_ADD_PICTURE,       // add picture info, corresponding to NET_IN_TESTOSD_ADD_PIC and NET_OUT_TESTOSD_ADD_PIC
    EM_TESTOSD_GET_PICTURE,       // get picture info, corresponding to NET_IN_TESTOSD_GET_PIC and NET_OUT_TESTOSD_GET_PIC
    EM_TESTOSD_DELETE_PICTURE,    // delete picture info, corresponding to NET_IN_TESTOSD_DELETE_PIC and NET_OUT_TESTOSD_DELETE_PIC
}EM_TESTOSD_OPERATE_TYPE;

// OSD text info
typedef struct tagNET_TEXT_OSD
{   
    char                    szText[DH_COMMON_STRING_256];   // text
    DH_POINT                stuPoint;                       // position
	NET_COLOR_RGBA			stuTextColor;					// text color
	int						nFontSize;						// the font size, 0-middle 1-small 2-big
    BYTE                    byReserved[44];                 // reserved
}NET_TEXT_OSD;

// OSD picture type
typedef enum tagEM_OSDPIC_TYPE
{
    EM_OSDPIC_UNKNOWN,                                      // unknown
    EM_OSDPIC_HEADONFACE,                                   // head face
    EM_OSDPIC_SIDEFACE,                                     // side face
    EM_OSDPIC_MAP,                                          // map 
}EM_OSDPIC_TYPE;

// OSD picture info
typedef struct tagNET_PICTURE_OSD
{
    EM_OSDPIC_TYPE          emPictureType;                  // OSD picture type
	NET_RECT				stuPictureLocation;				// Picture Location
    BYTE                    byReserved[48];                 // reserved
}NET_PICTURE_OSD;

// Operation type EM_TESTOSD_ADD_TEXT, input param
typedef struct tagNET_IN_TESTOSD_ADD_TEXT
{
    DWORD                   dwSize; 
    int                     nMaxCount;                     // max count of text info to allocate
    NET_TEXT_OSD            *pstuTextInfo;                 // text info, allocated by user
}NET_IN_TESTOSD_ADD_TEXT;

// Operation type EM_TESTOSD_ADD_TEXT, output param
typedef struct tagNET_OUT_TESTOSD_ADD_TEXT
{
    DWORD                   dwSize;
    int                     nReturnCount;                   // the valid return count
    int                     *pnTextID;                      // text info ID, allocated by user, the length is equal to nMaxCount
    int                     *pnReturnCode;                  // return code , 0-success 1-failure, allocated by user, the length is equal to nMaxCount
}NET_OUT_TESTOSD_ADD_TEXT;

// Operation type EM_TESTOSD_GET_TEXT, input param
typedef struct tagNET_IN_TESTOSD_GET_TEXT
{
    DWORD                   dwSize;
    int                     nMaxCount;                      // max count of text info to allocate
    int                     *pnTextID;                      // text info, allocated by user
}NET_IN_TESTOSD_GET_TEXT;

// Operation type EM_TESTOSD_GET_TEXT, output param
typedef struct tagNET_OUT_TESTOSD_GET_TEXT
{
    DWORD                   dwSize;
    int                     nReturnCount;                   // the valid return count
    NET_TEXT_OSD            *pstuTextInfo;                  // text info ID, allocated by user, the length is equal to nMaxCount
}NET_OUT_TESTOSD_GET_TEXT;

// Operation type EM_TESTOSD_MODIFY_TEXT, input param
typedef struct tagNET_IN_TESTOSD_MODIFY_TEXT
{
    DWORD                   dwSize;
    int                     nMaxCount;                      // max count of text info and text id to allocate
    int                     *pnTextID;                      // text info ID, allocated by user
    NET_TEXT_OSD            *pstuTextInfo;                  // text info, allocated by user
}NET_IN_TESTOSD_MODIFY_TEXT;

// Operation type EM_TESTOSD_MODIFY_TEXT, output param
typedef struct tagNET_OUT_TESTOSD_MODIFY_TEXT
{
    DWORD                   dwSize;
    int                     nReturnCount;                   // the valid return count
    int                     *pnReturnCode;                  // return code , 0-success 1-failure, allocated by user, the length is equal to nMaxCount
}NET_OUT_TESTOSD_MODIFY_TEXT;

// Operation type EM_TESTOSD_DELETE_TEXT, input param
typedef struct tagNET_IN_TESTOSD_DELETE_TEXT
{
    DWORD                   dwSize;
    int                     nMaxCount;                      // max count of text id to allocate
    int                     *pnTextID;                      // text info ID, allocated by user
}NET_IN_TESTOSD_DELETE_TEXT;

// Operation type EM_TESTOSD_DELETE_TEXT, output param
typedef struct tagNET_OUT_TESTOSD_DELETE_TEXT
{
    DWORD                   dwSize;
    int                     nReturnCount;                   // the valid return count
    int                     *pnReturnCode;                  // return code , 0-success 1-failure, allocated by user, the length is equal to nMaxCount
}NET_OUT_TESTOSD_DELETE_TEXT;

// Operation type EM_TESTOSD_ADD_PICTURE, input param
typedef struct tagNET_IN_TESTOSD_ADD_PIC
{
    DWORD                   dwSize;
    int                     nMaxCount;                      // max count of info to allocate
    char                    (*pszFilePath)[MAX_PATH];       // the file path
    NET_PICTURE_OSD         *pstuPicture;                   // picture info
}NET_IN_TESTOSD_ADD_PIC;

// Operation type EM_TESTOSD_ADD_PICTURE, output param
typedef struct tagNET_OUT_TESTOSD_ADD_PIC
{
    DWORD                   dwSize;
    int                     nReturnCount;                   // the valid return count
    int                     *pnReturnCode;                  // return code , 0-success 1-failure, allocated by user, the length is equal to nMaxCount
}NET_OUT_TESTOSD_ADD_PIC;

// Operation type EM_TESTOSD_GET_PICTURE, input param
typedef struct tagNET_IN_TESTOSD_GET_PIC
{
    DWORD                   dwSize;
    int                     nCount;                         // get mounts of picture 
}NET_IN_TESTOSD_GET_PIC;

// Operation type EM_TESTOSD_GET_PICTURE, output param
typedef struct tagNET_OUT_TESTOSD_GET_PIC
{
    DWORD                   dwSize;    
    int                     nReturnCount;                   // the valid return count
    char                    (*pszFilePath)[MAX_PATH];       // the file path
    NET_PICTURE_OSD         *pstuPicture;                   // the picture info
}NET_OUT_TESTOSD_GET_PIC;

// Operation type EM_TESTOSD_DELETE_PICTURE, input param
typedef struct tagNET_IN_TESTOSD_DELETE_PIC
{
    DWORD                   dwSize;
    int                     nMaxCount;                      // max count of info to allocate
    char                    (*pszFilePath)[MAX_PATH];       // the file path    
}NET_IN_TESTOSD_DELETE_PIC;

// Operation type EM_TESTOSD_DELETE_PICTURE, output param
typedef struct tagNET_OUT_TESTOSD_DELETE_PIC
{
    DWORD                   dwSize;
    int                     nReturnCount;                   // the valid return count
    int                     *pnReturnCode;                  // return code , 0-success 1-failure, allocated by user, the length is equal to nMaxCount
}NET_OUT_TESTOSD_DELETE_PIC;


// get alarm event log input param
typedef struct tagNET_IN_GET_ALARM_EVENT_LOG
{
	DWORD                   dwSize;
	UINT 	                nEventID;				        // event ID
}NET_IN_GET_ALARM_EVENT_LOG;

// get alarm event log output param
typedef struct tagNET_OUT_GET_ALARM_EVENT_LOG
{
	DWORD                   dwSize;
	DWORD			        dwAlarmType;			       // alarm event type
	BYTE 			       *byAlarmData;                   // alarm event data, allocated by user, at least 2* 1024 bytes
	int 			        nMaxDataLen;		           // max alarm data len
	int						nRetDataLen;                   // real retrun data len
}NET_OUT_GET_ALARM_EVENT_LOG;

// Get alarm event log
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetEventLog(LLONG lLoginID, const NET_IN_GET_ALARM_EVENT_LOG *pstuInParam, NET_OUT_GET_ALARM_EVENT_LOG *pstuOutParam, int nWaitTime);

// TestOSD operation interface

CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateTestOSD(LLONG lLoginID, EM_TESTOSD_OPERATE_TYPE emOperateType, void *pInParam, void *pOutParam, int nWaitTime);

// input of set lock or unlock
typedef struct tagNET_IN_COURSECOMPOSITE_LOCK_CONTROL
{
    DWORD                   dwSize;
    BOOL                    bLock;                         // TRUE lock,FALSE unlock
    int                     nClassRoomID;                  // Classroom id        
    int                     nLogicChannel;                 // logic channel
}NET_IN_COURSECOMPOSITE_LOCK_CONTROL;

// output of set lock or unlock
typedef struct tagNET_OUT_COURSECOMPOSITE_LOCK_CONTROL
{
    DWORD                   dwSize;
}NET_OUT_COURSECOMPOSITE_LOCK_CONTROL;

// input of get lock state
typedef struct tagNET_IN_COURSECOMPOSITE_GET_LOCKINFO
{
    DWORD                   dwSize;
    int                     nClassRoomID;                   // Classroom id 
    int                     nLogicChannel;                  // logic channel
}NET_IN_COURSECOMPOSITE_GET_LOCKINFO;

// output of get lock state
typedef struct tagNET_OUT_COURSECOMPOSITE_GET_LOCKINFO
{
    DWORD                   dwSize;             
    BOOL                    bState;                         // lock state TRUE locked FALSE unlock
}NET_OUT_COURSECOMPOSITE_GET_LOCKINFO;

// input of get composite channel info
typedef struct tagNET_IN_COURSECOMPOSITE_GET_INFO
{
    DWORD                   dwSize;                        
    int                     nClassRoomId;                  // classroom id
}NET_IN_COURSECOMPOSITE_GET_INFO;

// record mdoe
typedef enum tagEM_COMPOSITECHANNEL_MODE
{
    EM_COMPOSITECHANNEL_CUSTOMER = -1,                      // customer
    EM_COMPOSITECHANNEL_INVALID,                            // invalid
    EM_COMPOSITECHANNEL_MOVIE,                              // movie
    EM_COMPOSITECHANNEL_NORMALCY,                           // normal
    EM_COMPOSITECHANNEL_PICK,                               // pick
}EM_COMPOSITECHANNEL_MODE;

// composite channel info
typedef struct tagNET_COMPOSITECHANNEL_INFO
{
    char                        szCourseName[DH_COMMON_STRING_128];      // course name
    char                        szTeacherName[DH_COMMON_STRING_64];      // teacher name
    int  					    nCompositeChannelMode;                  // record mode 0:invalid;1:movie mode; 2:normal mode; 3:pick mode; <0:customer mode;
    int                         nChannelNum;                             // logic channel number
    BOOL                        bCanStream[MAX_COURSE_LOGIC_CHANNEL];    // disable to stream,number is logic channel id
    BYTE                        byReserved[256];                                                  
}NET_COMPOSITECHANNEL_INFO;

// output of get composite channel info
typedef struct tagNET_OUT_COURSECOMPOSITE_GET_INFO
{
    DWORD                       dwSize;  
    NET_COMPOSITECHANNEL_INFO   stuChannelInfo;                          // composite channel info
}NET_OUT_COURSECOMPOSITE_GET_INFO;

// input of set composite channel info
typedef struct tagNET_IN_COURSECOMPOSITE_SET_INFO
{
    DWORD                       dwSize;                        
    int                         nClassRoomId;                            // classroom id
    NET_COMPOSITECHANNEL_INFO   stuChannelInfo;                          // composite channel info
}NET_IN_COURSECOMPOSITE_SET_INFO;

// output of set composite channel info
typedef struct tagNET_OUT_COURSECOMPOSITE_SET_INFO
{
    DWORD                       dwSize;                        
}NET_OUT_COURSECOMPOSITE_SET_INFO;

// input of update composite channel info to time
typedef struct tagNET_IN_COURSECOMPOSITE_UPDATE_INFO
{
    DWORD                       dwSize; 
    int                         nClassRoomId;                        // classroom id
    NET_TIME                    stuTime;                             // query time                     
}NET_IN_COURSECOMPOSITE_UPDATE_INFO;

// output of update composite channel info to time
typedef struct tagNET_OUT_COURSECOMPOSITE_UPDATE_INFO
{
    DWORD                       dwSize;                     
}NET_OUT_COURSECOMPOSITE_UPDATE_INFO;

// enum of coursemedia operate 
typedef enum tagEM_COURSECOMPOSITE_OPERATE_TYPE
{
    EM_COURSECOMPOSITE_TYPE_LOCK_CONTROL,                   // control composite and logic channel lock or unlock, corresponding to pInParam = NET_IN_COURSECOMPOSITE_LOCK_CONTROL, pOutParam = NET_OUT_COURSECOMPOSITE_LOCK_CONTROL
    EM_COURSECOMPOSITE_TYPE_GET_LOCKINFO,                   // get composite and logic channel lock state, corresponding to pInParam = NET_IN_COURSECOMPOSITE_GET_LOCKINFO, pOutParam = NET_OUT_COURSECOMPOSITE_GET_LOCKINFO 
    EM_COURSECOMPOSITE_TYPE_GET_INFO,                       // get Compositechannel info,corresponding to pInParam = NET_IN_COURSECOMPOSITE_GET_INFO,pOutParam = NET_OUT_COURSECOMPOSITE_GET_INFO 
    EM_COURSECOMPOSITE_TYPE_SET_INFO,                       // set compositechannel info,corresponding to pInParam = NET_IN_COURSECOMPOSITE_SET_INFO,pOutParam = NET_OUT_COURSECOMPOSITE_SET_INFO 
    EM_COURSECOMPOSITE_TYPE_UPDATE_INFO,                    // update compositechannel info to time,corresponding to pInParam = NET_IN_COURSECOMPOSITE_UPDATE_INFO, pOutParam = NET_OUT_COURSECOMPOSITE_UPDATE_INFO
}EM_COURSECOMPOSITE_OPERATE_TYPE;

//interface of coursemedia Operate 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateCourseCompositeChannel(LLONG lLoginID, EM_COURSECOMPOSITE_OPERATE_TYPE emOperateType, void *pInParam, void *pOutParam, int nWaitTime);

// max number of windows
#define NET_MAX_WINDOWS_NUMBER	64

// max number of mode 
#define NET_MAX_MODE_NUMBER		64

// CourseCompositeChannelMode window info
typedef struct tagNET_COMPOSITECHANNELMODE_WINDOWS
{
	DH_RECT					stRect;					// window coordinate
	int						nLogicChannel;			// logic channel, -1 means this window not bind channel
	int						nZOrder;				// Z order
	BYTE                    byReserved[64];         // Reserved
}NET_COMPOSITECHANNELMODE_WINDOWS;

// CourseCompositeChannelMode info
typedef struct tagNET_COMPOSITECHANNELMODE_INFO
{
	char									szName[DH_COMMON_STRING_128];			// mode name
	int										nWindowNum;								// actual number of windows
	NET_COMPOSITECHANNELMODE_WINDOWS		stWindows[NET_MAX_WINDOWS_NUMBER];		// windows info
	BYTE									byReserved[64];							// Reserved
}NET_COMPOSITECHANNELMODE_INFO;

// input params of add CourseCompositeChannelMode
typedef struct tagNET_IN_COURSECOMPOSITE_CHANNEL_MODE_ADD
{
    DWORD							dwSize;								// struct size
    int								nCount;								// number of add mode
	NET_COMPOSITECHANNELMODE_INFO	stModeInfo[NET_MAX_MODE_NUMBER];	// mode info
}NET_IN_COURSECOMPOSITE_CHANNEL_MODE_ADD;

// result of add CourseCompositeChannelMode
typedef struct tagNET_COURSECOMPOSITE_CHANNEL_MODE_ADD_RESULT
{
	int						nMode;					// mode, 0 invalid, 1 movie mode, 2 normal mode, 3 boutique mode, <0 custom mode
	int						nReturnCode;			// return code: 1 success, 2 failure, 3 full, 4 resource lack
	BYTE                    byReserved[64];         // Reserved
}NET_COURSECOMPOSITE_CHANNEL_MODE_ADD_RESULT;

// output params of add CourseCompositeChannelMode
typedef struct tagNET_OUT_COURSECOMPOSITE_CHANNEL_MODE_ADD
{
    DWORD											dwSize;								// struct size
	int												nCount;								// actual number of result
	NET_COURSECOMPOSITE_CHANNEL_MODE_ADD_RESULT		stResult[NET_MAX_MODE_NUMBER];		// return results
}NET_OUT_COURSECOMPOSITE_CHANNEL_MODE_ADD;

// input params of delete CourseCompositeChannelMode
typedef struct tagNET_IN_COURSECOMPOSITE_CHANNEL_MODE_DELETE
{
	DWORD					dwSize;							// struct size
	int						nModeNum;						// number of delete mode
	int						nMode[NET_MAX_MODE_NUMBER];		// sequence number of mode
}NET_IN_COURSECOMPOSITE_CHANNEL_MODE_DELETE;

// output params of delete CourseCompositeChannelMode 
typedef struct tagNET_OUT_COURSECOMPOSITE_CHANNEL_MODE_DELETE
{
	DWORD					dwSize;									// struct size
	int						nReturnNum;								// number of delete mode
	int						nReturnCode[NET_MAX_MODE_NUMBER];		// return code: 1 success, 2 failure
}NET_OUT_COURSECOMPOSITE_CHANNEL_MODE_DELETE;

// input params of modify CourseCompositeChannelMode
typedef struct tagNET_IN_COURSECOMPOSITE_CHANNEL_MODE_MODIFY 
{
	DWORD							dwSize;								// struct size
	int								nModeNum;							// number of modify mode
	int								nMode[NET_MAX_MODE_NUMBER];			// sequence number of mode 
	NET_COMPOSITECHANNELMODE_INFO	stModeInfo[NET_MAX_MODE_NUMBER];	// mode info
}NET_IN_COURSECOMPOSITE_CHANNEL_MODE_MODIFY;

// output params of modify CourseCompositeChannelMode 
typedef struct tagNET_OUT_COURSECOMPOSITE_CHANNEL_MODE_MODIFY
{
	DWORD					dwSize;									// struct size
	int						nReturnNum;								// number of modify mode
	int						nReturnCode[NET_MAX_MODE_NUMBER];		// return code: 1 success, 2 failure, 3 full, 4 resource lack
}NET_OUT_COURSECOMPOSITE_CHANNEL_MODE_MODIFY;

// input params of get CourseCompositeChannelMode
typedef struct tagNET_IN_COURSECOMPOSITE_CHANNEL_MODE_GET 
{
	DWORD					dwSize;					// struct size
	int						nCount;					// number of get mode
}NET_IN_COURSECOMPOSITE_CHANNEL_MODE_GET;

// output params of get CourseCompositeChannelMode 
typedef struct tagNET_OUT_COURSECOMPOSITE_CHANNEL_MODE_GET
{
	DWORD							dwSize;								// struct size
	int								nReturnNum;							// actual number of get mode
	int								nMode[NET_MAX_MODE_NUMBER];			// sequence number of mode 
	NET_COMPOSITECHANNELMODE_INFO	stModeInfo[NET_MAX_MODE_NUMBER];	// mode information
}NET_OUT_COURSECOMPOSITE_CHANNEL_MODE_GET;

// CourseCompositeChannelMode operate type
typedef enum tagNET_COURSECOMPOSITE_MODE_OPERATE_TYPE
{
    NET_COURSECOMPOSITE_MODE_ADD,                   // add mode,	pInParam = NET_IN_COURSECOMPOSITE_CHANNEL_MODE_ADD,	   pOutParam = NET_OUT_COURSECOMPOSITE_CHANNEL_MODE_ADD
	NET_COURSECOMPOSITE_MODE_DELETE,                // delete mode, pInParam = NET_IN_COURSECOMPOSITE_CHANNEL_MODE_DELETE, pOutParam = NET_OUT_COURSECOMPOSITE_CHANNEL_MODE_DELETE
	NET_COURSECOMPOSITE_MODE_MODIFY,                // modify mode, pInParam = NET_IN_COURSECOMPOSITE_CHANNEL_MODE_MODIFY, pOutParam = NET_OUT_COURSECOMPOSITE_CHANNEL_MODE_MODIFY
	NET_COURSECOMPOSITE_MODE_GET,                   // get mode,	pInParam = NET_IN_COURSECOMPOSITE_CHANNEL_MODE_GET,	   pOutParam = NET_OUT_COURSECOMPOSITE_CHANNEL_MODE_GET
}NET_COURSECOMPOSITE_MODE_OPERATE_TYPE;

//interface of CourseCompositeChannelMode Operate 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateCourseCompositeChannelMode(LLONG lLoginID, NET_COURSECOMPOSITE_MODE_OPERATE_TYPE emOperateType, void *pInParam, void *pOutParam, int nWaitTime);

///////////////////////////////////////////////////////////////////////
#define NET_UPGRADE_COUNT_MAX    256  //max upgrade count number

// vendor type info
typedef enum tagENUM_VENDOR_TYPE
{
    ENUM_VENDOR_TYPE_UNKNOWN,              //unknown
	ENUM_VENDOR_TYPE_GENERAL,              //General 
	ENUM_VENDOR_TYPE_DH,                   //DH 
	ENUM_VENDOR_TYPE_OEM,                  //OEM
	ENUM_VENDOR_TYPE_LC,				   //LC
	ENUM_VENDOR_TYPE_EZIP,				   //EZIP
}ENUM_VENDOR_TYPE;

//standard type
typedef enum tagENUM_STANDARD_TYPE
{
    ENUM_STANDARD_TYPE_UNKNOWN,              //unknown
	ENUM_STANDARD_TYPE_PAL,                  //P-PAL
	ENUM_STANDARD_TYPE_NTSC,                 //N-NTSC
	ENUM_STANDARD_TYPE_PAL_NTSC,             //PN-PAL/NTSC(default:PAL)
	ENUM_STANDARD_TYPE_NTSC_PAL,             //NP-NTSC/PAL(default:NTSC)
	ENUM_STANDARD_TYPE_SECAM,                //S-SECAM
}ENUM_STANDARD_TYPE;


//get NVR/IPC serial input parameter, use connect mode:direct
typedef struct tagNET_IN_UPGRADER_GETSERIAL
{   
    DWORD               dwSize;					
}NET_IN_UPGRADER_GETSERIAL;

//upgrade serial info
typedef struct tagNET_UPGRADER_SERIAL_INO
{
    ENUM_VENDOR_TYPE    emVendor;               //vendor
    ENUM_STANDARD_TYPE  emStandard;             //video standard
    NET_TIME_EX  stuBuild;                      //build info
    char    szChip[DH_COMMON_STRING_16];        //chip
    char    szSerial[DH_COMMON_STRING_256];     //serial
    char    szLanguage[DH_COMMON_STRING_128];   //language
    char    szSn[DH_COMMON_STRING_64];          //sn
    char    szSWVersion[DH_COMMON_STRING_64];   //software version    
    char    szTag[DH_COMMON_STRING_256];        //tag
    char    szTag2[DH_COMMON_STRING_256];       //tag2
    char    reserved[1024];                         
}NET_UPGRADER_SERIAL_INO;

#define MAX_UPGRADER_SERIAL_INFO  8

//get NVR/IPC serial output parameter, use connect mode:direct
typedef struct tagNET_OUT_UPGRADER_GETSERIAL
{   
    DWORD                     dwSize;					              
    NET_UPGRADER_SERIAL_INO   stuSerialInfo[MAX_UPGRADER_SERIAL_INFO]; // serial info
    int                       nRetNum;                                 // return serial count
}NET_OUT_UPGRADER_GETSERIAL;

//get update serial
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetUpdateSerial(LLONG lLoginID, NET_IN_UPGRADER_GETSERIAL *pstuInGetSerial, NET_OUT_UPGRADER_GETSERIAL *pstuOutGetSerial, int nWaitTime);

// cloud upgrade check input parameter
typedef struct tagNET_IN_CLOUD_UPGRADER_CHECK
{
    DWORD                  dwSize;
    ENUM_VENDOR_TYPE       emVendor;                            //vendor
    ENUM_STANDARD_TYPE     emStandard;                          //video standard
    NET_TIME_EX            stuBuild;                            //compile time, for comparison versions
    char                   szUrl[DH_COMMON_STRING_1024];        // url
    char                   szClass[DH_COMMON_STRING_64];        // device class
    char                   szSerial[DH_COMMON_STRING_256];      // device hardware signal series
    char                   szLanguage[DH_COMMON_STRING_128];    // language
    char                   szSN[DH_COMMON_STRING_64];           // device serial
    char                   szSWVersion[DH_COMMON_STRING_64];    // software version
    char                   szTag1[DH_COMMON_STRING_256];        // reserved bytes1
    char                   szTag2[DH_COMMON_STRING_256];        // reserved bytes2
    char                   szAccessKeyId[DH_COMMON_STRING_128]; //Access Key ID
    char                   szSecretAccessKey[DH_COMMON_STRING_128];//Secret Access Key
}NET_IN_CLOUD_UPGRADER_CHECK;

// cloud upgrade check output parameter
typedef struct tagNET_OUT_CLOUD_UPGRADER_CHECK
{
    DWORD                  dwSize;
    BOOL                   bHasNewVersion;                       //has new version
    char                   szVersion[DH_COMMON_STRING_64];       // version info
    char                   szAttention[DH_COMMON_STRING_1024];   // prompt information
    char                   szPackageUrl[DH_COMMON_STRING_1024];  // package url
	char 			       szPackageId[DH_COMMON_STRING_64];     //package id
}NET_OUT_CLOUD_UPGRADER_CHECK;

// check if there is scalable software in the cloud
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CloudUpgraderCheck(NET_IN_CLOUD_UPGRADER_CHECK *pIn, NET_OUT_CLOUD_UPGRADER_CHECK *pOut, DWORD dwWaitTime);

//cloud download state
typedef enum tagemCloudDownloadState
{
    emCloudDownloadState_Unknown,            //unknown
    emCloudDownloadState_Success,            //download success(need to call CLIENT_CloudUpgraderStop)
    emCloudDownloadState_Failed,             //download failed(don't need to call CLIENT_CloudUpgraderStop,it will keep trying)
    emCloudDownloadState_Downloading,        //downloading  
    emCloudDownloadState_NoEnoughDiskSpace,  //no enough disk space
}emCloudDownloadState;

//cloud download process callback function pointer
typedef void (CALLBACK *fCloudDownload_Process_callback)(LLONG lDownHandle, emCloudDownloadState emState, double dwDownloadSpeed, DWORD dwProgressPercentage, LDWORD dwUser);

// cloud upgrade download input parameter
typedef struct tagNET_IN_CLOUD_UPGRADER_DOWN
{
    DWORD                               dwSize;                              //structure size
    char                                szPackageUrl[DH_COMMON_STRING_1024]; //device upgrade package url
    char                                szSaveFile[DH_COMMON_STRING_1024];   //saved file path
    fCloudDownload_Process_callback     pfProcessCallback;                   //process callback
    LDWORD                              dwUser;                              //callback user data 
}NET_IN_CLOUD_UPGRADER_DOWN;

//cloud upgrade download output parameter
typedef struct tagNET_OUT_CLOUD_UPGRADER_DOWN
{
    DWORD                  dwSize;     //structure size
}NET_OUT_CLOUD_UPGRADER_DOWN;

//cloud upgrade download 
CLIENT_NET_API LLONG CALL_METHOD CLIENT_CloudUpgraderDownLoad(NET_IN_CLOUD_UPGRADER_DOWN *pIn, NET_OUT_CLOUD_UPGRADER_DOWN *pOut);

//stop cloud upgrade download
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CloudUpgraderStop(LLONG lDownloadHandle);

//pause cloud upgrade download
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CloudUpgraderPause(LLONG lDownloadHandle, BOOL bPause);

//upgrade report result
typedef enum tagNET_UPGRADE_REPORT_RESULT
{
    NET_UPGRADE_REPORT_RESULT_UNKNWON,     //unknown
    NET_UPGRADE_REPORT_RESULT_SUCCESS,     //success
    NET_UPGRADE_REPORT_RESULT_FAILED,      //failed
}NET_UPGRADE_REPORT_RESULT;

//upgrade report info
typedef struct tagNET_UPGRADE_REPORT
{
    int     nDeviceNum;                                                 //device number
    char    szDevSerial[NET_UPGRADE_COUNT_MAX][MAX_COMMON_STRING_64];   // device serial
    char    szPacketID[MAX_COMMON_STRING_128];                          //package id
    NET_UPGRADE_REPORT_RESULT emResult;                                 //upgrade result
    char    szCode[MAX_COMMON_STRING_128];                              //error code      
    char    reserved[256];
}NET_UPGRADE_REPORT;

//upgrade result report input parameter
typedef struct tagNET_IN_UPGRADE_REPORT
{
    DWORD                   dwSize;                                    //structure size
    int                     nCount;                                    //upgrade package count
    NET_UPGRADE_REPORT      *pstuUpgradeReport;                        //upgrade result info    
    char                    szAccessKeyId[DH_COMMON_STRING_128];       //Access Key ID
    char                    szSecretAccessKey[DH_COMMON_STRING_128];   //Secret Access Key    
    char                    szUrl[DH_COMMON_STRING_1024];              //url
}NET_IN_UPGRADE_REPORT;

//upgrade result report output parameter
typedef struct tagNET_OUT_UPGRADE_REPORT
{
    DWORD                  dwSize;
}NET_OUT_UPGRADE_REPORT;

//cloud upgrade result report
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CloudUpgraderReport(NET_IN_UPGRADE_REPORT *pIn, NET_OUT_UPGRADE_REPORT *pOut, DWORD dwWaitTime);


// struct of upgrader state callback function
typedef struct tagNET_CLOUD_UPGRADER_STATE
{
	DWORD					dwSize;
	EM_UPGRADE_STATE		emState;							// upgrader state
	int						nProgress;							// upgrader progress
	char					szFileName[DH_COMMON_STRING_128];	// upgrader filename
} NET_CLOUD_UPGRADER_STATE;

// upgrader state callback function pointer
typedef void (CALLBACK *fUpgraderStateCallback) (LLONG lLoginId, LLONG lAttachHandle, NET_CLOUD_UPGRADER_STATE* pBuf, DWORD dwBufLen, void* pReserved, LDWORD dwUser);

// CLIENT_CloudUpgraderAttachState in parameter
typedef struct tagNET_IN_CLOUD_UPGRADER_ATTACH_STATE
{
	DWORD					dwSize;
	fUpgraderStateCallback	cbUpgraderState;
	LDWORD					dwUser;
} NET_IN_CLOUD_UPGRADER_ATTACH_STATE;

// CLIENT_CloudUpgraderAttachState out parameter
typedef struct tagNET_OUT_CLOUD_UPGRADER_ATTACH_STATE
{
	DWORD					dwSize;
} NET_OUT_CLOUD_UPGRADER_ATTACH_STATE;

// CLIENT_CloudUpgraderGetState in parameter
typedef struct tagNET_IN_CLOUD_UPGRADER_GET_STATE
{
	DWORD					dwSize;
} NET_IN_CLOUD_UPGRADER_GET_STATE;

// CLIENT_CloudUpgraderGetState out parameter
typedef struct tagNET_OUT_CLOUD_UPGRADER_GET_STATE
{
	DWORD					dwSize;
	EM_UPGRADE_STATE		emState;							// upgrader state
	int						nProgress;							// upgrader progress
	char					szFileName[DH_COMMON_STRING_128];	// upgrader filename
} NET_OUT_CLOUD_UPGRADER_GET_STATE;

// CLIENT_UpgraderGetCaps in parameter
typedef struct tagNET_IN_UPGRADER_GET_CAPS
{
    DWORD					dwSize;
} NET_IN_UPGRADER_GET_CAPS;

// caps info
typedef struct tagNET_UPGRADER_CAPS
{
    UINT            nOfflineTransfer;    // Download remote upgrade file and resume from break point. 0: not support(defualt valuye); 1: support
    UINT            nRemoteDownload;     // Download remote upgrade file and upgrade. 0: not support; 1: support(defualt valuye)
	BYTE            byReserved[128];      // Reserved
}NET_UPGRADER_CAPS;

// CLIENT_UpgraderGetCaps out parameter
typedef struct tagNET_OUT_UPGRADER_GET_CAPS
{
    DWORD					dwSize;
    NET_UPGRADER_CAPS       stuCaps; // caps   
} NET_OUT_UPGRADER_GET_CAPS;


// CLIENT_UpgraderCancel in parameter
typedef struct tagNET_IN_UPGRADER_CANCEL 
{
    DWORD					dwSize;
} NET_IN_UPGRADER_CANCEL;

// CLIENT_UpgraderCancel out parameter
typedef struct tagNET_OUT_UPGRADER_CANCEL
{
    DWORD					dwSize;
} NET_OUT_UPGRADER_CANCEL;

// Attach Cloud Upgrader state
CLIENT_NET_API LLONG CALL_METHOD CLIENT_CloudUpgraderAttachState(LLONG lLoginID, const NET_IN_CLOUD_UPGRADER_ATTACH_STATE *pInParam, NET_OUT_CLOUD_UPGRADER_ATTACH_STATE *pOutParam, int nWaitTime);

// Detach Cloud Upgrader state
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CloudUpgraderDetachState(LLONG lAttachHandle);

// Get Cloud Upgrader State
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CloudUpgraderGetState(LLONG lLoginID, const NET_IN_CLOUD_UPGRADER_GET_STATE *pInParam, NET_OUT_CLOUD_UPGRADER_GET_STATE *pOutParam, int nWaitTime);

// Get upgrade caps
CLIENT_NET_API BOOL CALL_METHOD CLIENT_UpgraderGetCaps(LLONG lLoginID, const NET_IN_UPGRADER_GET_CAPS *pInParam, NET_OUT_UPGRADER_GET_CAPS *pOutParam, int nWaitTime);

// Cancel upgrade
CLIENT_NET_API BOOL CALL_METHOD CLIENT_UpgraderCancel(LLONG lLoginID, const NET_IN_UPGRADER_CANCEL *pInParam, NET_OUT_UPGRADER_CANCEL *pOutParam, int nWaitTime);


// Input param of Cloud upload getcaps
typedef struct tagNET_IN_CLOUDUPLOAD_GETCAPS
{
	DWORD				dwSize;							// Struct size			
}NET_IN_CLOUDUPLOAD_GETCAPS;

// Output param of Cloud upload getcaps
typedef struct tagNET_OUT_CLOUDUPLOAD_GETCAPS
{
	DWORD				dwSize;							// Struct size	
	BOOL				bAsyncUpload;					// Whether support async upload,TRUE:support,FALSE:not support	
}NET_OUT_CLOUDUPLOAD_GETCAPS;

// CLIENT_CloudUploadPicture in parameter
typedef struct tagNET_IN_CLOUD_UPLOAD_PICTURE
{
    DWORD					dwSize;
    int                     nChannelID;                                     // channel id
    int                     nServerType;                                    // server type,0-cloud 1-FTP 
    int                     nPicType;                                       // picture type, 0-driver hands up 1-12 series photo 2-1 cun photo
    char                    szFileName[256];                // file name for ocx(only use in web client)   
    char                    szAccessKeyId[DH_COMMON_STRING_64];             // usename of server       
    char                    szAccessKeySecret[DH_COMMON_STRING_64];         // password of server
    char                    szBucketName[DH_COMMON_STRING_32];              // bucket name in server
    char                    szFileKey[256];                 // file name in server
    char                    szEndPoint[DH_COMMON_STRING_64];                // end point for file service    

    UINT                    nFileLength;                                    // file length,unit:byte
    char*                   pFileData;                                      // file data

} NET_IN_CLOUD_UPLOAD_PICTURE;

// CLIENT_CloudUploadPicture out parameter
typedef struct tagNET_OUT_CLOUD_UPLOAD_PICTURE
{
    DWORD					dwSize;
    char                    szFileName[256];                // file name of uplaoded successfully(use for ocx)
    char                    szFileURL[DH_COMMON_STRING_2048];               // URL of file on server
	BOOL					bAsyncUploadPic;				// Whether upload pic is async,TRUE:async,FALSE:sync
} NET_OUT_CLOUD_UPLOAD_PICTURE;

// upload picture to cloud server
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CloudUploadPicture(LLONG lLoginID, const NET_IN_CLOUD_UPLOAD_PICTURE *pInParam, NET_OUT_CLOUD_UPLOAD_PICTURE *pOutParam, int nWaitTime);

// CLIENT_CloudUploadVideo in parameter
typedef struct tagNET_IN_CLOUD_UPLOAD_VIDEO
{
    DWORD					dwSize;
    int                     nChannelID;                                     // channel id
    int                     nServerType;                                    // server type,0-cloud 1-FTP
    int                     nAction;                                        // manual record action,0-stop record 1-start record
    int                     nStrategy;                                      // strategy of upload,0-real time 1-configration
    char                    szAccessKeyId[DH_COMMON_STRING_64];             // usename of server    
    char                    szAccessKeySecret[DH_COMMON_STRING_64];         // password of server
    char                    szBucketName[DH_COMMON_STRING_32];              // bucket name in server
    char                    szFileKey[256];									// file name in server
    char                    szEndPoint[DH_COMMON_STRING_64];                // end point for file service
} NET_IN_CLOUD_UPLOAD_VIDEO;

// CLIENT_CloudUploadVideo out parameter
typedef struct tagNET_OUT_CLOUD_UPLOAD_VIDEO
{
    DWORD					dwSize;   
	BOOL					bAsyncUploadVideo;				// Whether upload video is async,TRUE:async,FALSE:sync
} NET_OUT_CLOUD_UPLOAD_VIDEO;

// upload video to cloud server
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CloudUploadVideo(LLONG lLoginID, const NET_IN_CLOUD_UPLOAD_VIDEO *pInParam, NET_OUT_CLOUD_UPLOAD_VIDEO *pOutParam, int nWaitTime);

// Snap pic info
typedef struct tagNET_SNAPPIC_INFO
{
	char				szFileName[256];  				   // Ocx file name
	BOOL				bState;							   // Whether the picture was uploaded successfully,FALSE:fail,TRUE:success
	char				szUrl[2048];	   				   // pic access URL After upload server
	BYTE				byReserved[1024];				   // Reserved	
}NET_SNAPPIC_INFO;

// Video info
typedef struct tagNET_VIDEO_INFO
{
	char				szFileName[256];						// File name of the video uploaded to the server
	unsigned int	    nChannel;								// Channel
	NET_TIME			stuStartTime;							// The start time of the video segment that needs to be uploaded	
	NET_TIME			stuEndTime;								// The end time of the video segment that needs to be uploaded
	BOOL				bState;									// Whether the video was uploaded successfully,FALSE:fail,TRUE:success
	BYTE				byReserved[1024];						// Reserved
}NET_VIDEO_INFO;

// Cloud upload state
typedef struct tagNET_CLOUDUPLOAD_STATE
{
	NET_SNAPPIC_INFO     stuSnapPicInfo;			// Snap picture uploaded info
	NET_VIDEO_INFO		 stuVideoInfo;				// Video uploaded info
	BYTE				 byReserved[2048];			// Reserved
}NET_CLOUDUPLOAD_STATE;

// Cloud upload state callback function
typedef void (CALLBACK *fCloudUploadStateCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_CLOUDUPLOAD_STATE* pBuf, int nBufLen, LDWORD dwUser);

// Input param of CLIENT_AttachCloudUploadState
typedef struct tagNET_IN_ATTACH_CLOUDUPLOAD_STATE
{
	DWORD						dwSize;				   // Struct size
	fCloudUploadStateCallBack	cbCloudUploadState;    // Callback Function
	LDWORD						dwUser;                // User data
}NET_IN_ATTACH_CLOUDUPLOAD_STATE;

// Output param of CLIENT_AttachCloudUploadState
typedef struct tagNET_OUT_ATTACH_CLOUDUPLOAD_STATE
{
	DWORD				dwSize;
}NET_OUT_ATTACH_CLOUDUPLOAD_STATE;

// Attach cloud upload state of picture or video
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachCloudUploadState(LLONG lLoginID, NET_IN_ATTACH_CLOUDUPLOAD_STATE *pInBuf,NET_OUT_ATTACH_CLOUDUPLOAD_STATE *pOutBuf, int nWaitTime);

// Detach cloud upload state of picture or video
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachCloudUploadState(LLONG lAttachHandle);

////////////////////////////////////////////////////////////

// CLIENT_GetRecordState in parameter
typedef struct tagNET_IN_GET_RECORD_STATE
{
	DWORD				dwSize;				// struct size
	int					nChannel;			// channel 
} NET_IN_GET_RECORD_STATE;

// CLIENT_GetRecordState out parameter
typedef struct tagNET_OUT_GET_RECORD_STATE
{
	DWORD				dwSize;				// struct size
	BOOL				bState;				// record state
} NET_OUT_GET_RECORD_STATE;

// interface of get record state
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetRecordState(LLONG lLoginID, const NET_IN_GET_RECORD_STATE *pInParam, NET_OUT_GET_RECORD_STATE *pOutParam, int nWaitTime);

// input of get course record info
typedef struct tagNET_IN_COURSERECORD_GETINFO
{
    DWORD                       dwSize;
    int                         nClassRoomID;                           // classroom id,defult:0
}NET_IN_COURSERECORD_GETINFO;

// output of get course record info
typedef struct tagNET_OUT_COURSERECORD_GETINFO
{
    DWORD                       dwSize;
    int                         nChannelNum;                            // logic channel number
    int                         nCanRecord[MAX_COURSE_LOGIC_CHANNEL];   // 0:invalid,1:record,2unrecord,number is logic channel id
}NET_OUT_COURSERECORD_GETINFO;

// input of set course record info
typedef struct tagNET_IN_COURSERECORD_SETINFO
{
    DWORD                       dwSize;
    int                         nClassRoomID;                           // classroom id, defult:0
    int                         nChannelNum;                            // logic channel number
    int                         nCanRecord[MAX_COURSE_LOGIC_CHANNEL];   // 0:invalid,1:record,2unrecord,number is logic channel id
}NET_IN_COURSERECORD_SETINFO;

// output of set course record info
typedef struct tagNET_OUT_COURSERECORD_SETINFO
{
    DWORD                       dwSize;
}NET_OUT_COURSERECORD_SETINFO;

// input of update record info to  time
typedef struct tagNET_IN_COURSERECORD_UPDATE_INFO
{
    DWORD                       dwSize;
    int                         nClassRoomID;                           // classroom id, defult:0
    NET_TIME                    stuTime;                                // query time
}NET_IN_COURSERECORD_UPDATE_INFO;

// output of update record info to time
typedef struct tagNET_OUT_COURSERECORD_UPDATE_INFO
{
    DWORD                       dwSize;
}NET_OUT_COURSERECORD_UPDATE_INFO;

// input of get course recorded time
typedef struct tagNET_IN_COURSERECORD_GET_TIME
{
    DWORD                       dwSize;
    int                         nClassRoomID;                        // classroom id, defult:0
}NET_IN_COURSERECORD_GET_TIME;

// output of get course recorded time
typedef struct tagNET_OUT_COURSERECORD_GET_TIME
{
    DWORD                       dwSize;
    UINT                        nTime;                               // recorded time, unit: second
}NET_OUT_COURSERECORD_GET_TIME;

// operate of coursemedia record info
typedef enum tagEM_COURSERECORD_OPERATE_TYPE
{
    EM_COURSERECORDE_TYPE_GET_INFO,                       // get classroom  record info ,corresponding to pInParam = NET_IN_COURSERECORD_GETINFO,pOutParam = NET_OUT_COURSERECORD_GETINFO 
    EM_COURSERECORDE_TYPE_SET_INFO,                       // set classroom  record info,corresponding to pInParam = NET_IN_COURSERECORD_SETINFO,pOutParam = NET_OUT_COURSERECORD_SETINFO 
    EM_COURSERECORDE_TYPE_UPDATE_INFO,                    // update record info to time,corresponding to pInParam = NET_IN_COURSERECORD_UPDATE_INFO, pOutParam = NET_OUT_COURSERECORD_UPDATE_INFO
    EM_COURSERECORDE_TYPE_GET_TIME,                       // get course recorded time,corresponding to pInParam = NET_IN_COURSERECORD_GET_TIME, pOutParam = NET_OUT_COURSERECORD_GET_TIME
}EM_COURSERECORD_OPERATE_TYPE;

// interface of operate coursemedia record info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateCourseRecordManager(LLONG lLoginID, EM_COURSERECORD_OPERATE_TYPE emOperateType, void *pInParam, void *pOutParam, int nWaitTime);

// call back for attach config change
typedef void(CALLBACK *fConfigChangeCallBack)(LLONG lAttachHandle, char* szCommand, char* szBuffer, LDWORD dwUser);

// attach config change input param
typedef struct tagNET_IN_ATTACH_CONFIGCHANNGE
{
    DWORD                           dwSize;
    char*                           szCfgName;                // config name,see dhconfigsdk.h CLIENT_GetNewDevConfig and CLIENT_SetNewDevConfig port command 
    fConfigChangeCallBack           cbNotify;                 // callback config of changed
    LDWORD                          dwUser;                   // userinfo
}NET_IN_ATTACH_CONFIGCHANNGE;

// attach config change output param
typedef struct tagNET_OUT_ATTACH_CONFIGCHANNGE
{
    DWORD                           dwSize;
}NET_OUT_ATTACH_CONFIGCHANNGE;

// attach config change 
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachConfigChange(LLONG lLoginID, NET_IN_ATTACH_CONFIGCHANNGE *pInBuf,NET_OUT_ATTACH_CONFIGCHANNGE *pOutBuf, int nWaitTime);

// detach config change  
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachConfigChange(LLONG lAttachHandle);

//CLIENT_GetRingFileList in parameter
typedef struct tagNET_IN_GET_RINGFILELIST
{
	DWORD 		dwSize;
}NET_IN_GET_RINGFILELIST;

//CLIENT_GetRingFileList out parameter
typedef struct tagNET_OUT_GET_RINGFILELIST
{
	DWORD       dwSize;	
	UINT        nRingFileNum;                                         //return ring file num
	char        szRingFileList[MAX_RINGFILE_NUM][DH_COMMON_STRING_64];//ring file list info
}NET_OUT_GET_RINGFILELIST;

//get ring file list 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetRingFileList(LLONG lLoginID, NET_IN_GET_RINGFILELIST *pstuInParam, NET_OUT_GET_RINGFILELIST *pstuOutParam, int nWaitTime);

// CLIENT_GetConnetionStatus in parameter
typedef struct tagNET_IN_GETCONNECTION_STATUS
{
    DWORD       dwSize;                                               
}NET_IN_GETCONNECTION_STATUS;

// CLIENT_GetConnetionStatus out parameter
typedef struct tagNET_OUT_GETCONNECTION_STATUS
{
    DWORD       dwSize;  
    int         nChannelNum;                                           // channel number
    int         nStatus[MAX_ALARMEXT_MODULE_NUM];                      // 0:not distributed 1:offfline 2:online
}NET_OUT_GETCONNECTION_STATUS;

// Get Alarm ext module status
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetConnectionStatus(LLONG lLoginID,const NET_IN_GETCONNECTION_STATUS* pstuInParam, NET_OUT_GETCONNECTION_STATUS *pstuOutParam, int nWaitTime);

#define MAX_ALARM_BOX_VIDEO_NUM		16

// CLIENT_GetAlarmBoxVideoConnectionStatus in parameter
typedef struct tagNET_IN_GETALARMBOXVIDEOCONNECTION_STATUS
{
    DWORD       dwSize;                                               
} NET_IN_GETALARMBOXVIDEOCONNECTION_STATUS;

// CLIENT_GetAlarmBoxVideoConnectionStatus out parameter
typedef struct tagNET_OUT_GETALARMBOXVIDEOCONNECTION_STATUS
{
    DWORD       dwSize;  
    int         nChannelNum;                                        // alarm box video channel number
    int         nStatus[MAX_ALARM_BOX_VIDEO_NUM];                   // alarm box video channel , 0:disconnect 1:offline 2:online
} NET_OUT_GETALARMBOXVIDEOCONNECTION_STATUS;

// Get Alarm Box Video connection status
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetAlarmBoxVideoConnectionStatus(LLONG lLoginID,const NET_IN_GETALARMBOXVIDEOCONNECTION_STATUS* pstuInParam, NET_OUT_GETALARMBOXVIDEOCONNECTION_STATUS *pstuOutParam, int nWaitTime);

//authority
typedef enum tagNET_ATTENDANCE_AUTHORITY
{
    NET_ATTENDANCE_AUTHORITY_UNKNOWN = -1,
    NET_ATTENDANCE_AUTHORITY_CUSTOMER,           //customer
    NET_ATTENDANCE_AUTHORITY_ADMINISTRATORS,     //administrators
}NET_ATTENDANCE_AUTHORITY;

#define MAX_ATTENDANCE_USERNAME_LEN 36

//attendance user info
typedef struct tagNET_ATTENDANCE_USERINFO
{
    char                     szUserID[MAX_COMMON_STRING_32];   				// user id   
    char                     szUserName[MAX_ATTENDANCE_USERNAME_LEN]; 		// username
    char                     szCardNo[MAX_COMMON_STRING_32];   				// cardno
    NET_ATTENDANCE_AUTHORITY emAuthority;                      				// authority
    char                     szPassword[MAX_COMMON_STRING_32]; 				// password
    int                      nPhotoLength;                     				// photo data len   
	char					 szClassNumber[MAX_CLASS_NUMBER_LEN];  			// Class number(Kenya custom) 
	char					 szPhoneNumber[MAX_PHONENUMBER_LEN];   			// Phone number(Kenya custom)
	NET_ACCESSCTLCARD_TYPE   emCardType;									// card type
	BYTE					 byReserved[204];								// reserved 
}NET_ATTENDANCE_USERINFO;

//CLIENT_Attendance_InsertFingerByUserID input Parameter
typedef struct tagNET_IN_FINGERPRINT_INSERT_BY_USERID
{
	DWORD						dwSize;
    char 						szUserID[DH_COMMON_STRING_32];			//  user ID
    int 						nSinglePacketLen;						// length of single packet
    int 						nPacketCount;							// count of packet
	char*						szFingerPrintInfo;						// count is nSinglePacketLen*nPacketCount)
}NET_IN_FINGERPRINT_INSERT_BY_USERID;


//CLIENT_Attendance_InsertFingerByUserID output Parameter
typedef struct tagNET_OUT_FINGERPRINT_INSERT_BY_USERID
{
	DWORD						dwSize;
    int							nFingerPrintID[DH_MAX_FINGER_PRINT];	// fingerprint' ID array
	int 						nReturnedCount;							// the count of actually useful in array.
	int							nFailedCode;							// failed code 0:success  1:other error  2:limits on the fingerprint capabilities of this user
}NET_OUT_FINGERPRINT_INSERT_BY_USERID;

//CLIENT_Attendance_RemoveFingerByUserID input param
typedef struct tagNET_CTRL_IN_FINGERPRINT_REMOVE_BY_USERID
{
	DWORD						dwSize;
	char 						szUserID[DH_COMMON_STRING_32];			// User ID
}NET_CTRL_IN_FINGERPRINT_REMOVE_BY_USERID;

//CLIENT_Attendance_RemoveFingerByUserID output param
typedef struct tagNET_CTRL_OUT_FINGERPRINT_REMOVE_BY_USERID
{
	DWORD						dwSize;
}NET_CTRL_OUT_FINGERPRINT_REMOVE_BY_USERID;

//CLIENT_Attendance_RemoveFingerRecord input param
typedef struct tagNET_CTRL_IN_FINGERPRINT_REMOVE
{
	DWORD						dwSize;
	int							nFingerPrintID;							//fingerprint ID
}NET_CTRL_IN_FINGERPRINT_REMOVE;

//CLIENT_Attendance_RemoveFingerRecord output param
typedef struct tagNET_CTRL_OUT_FINGERPRINT_REMOVE
{
	DWORD						dwSize;
}NET_CTRL_OUT_FINGERPRINT_REMOVE;

//CLIENT_Attendance_GetFingerRecord input param
typedef struct tagNET_CTRL_IN_FINGERPRINT_GET
{
	DWORD						dwSize;
	int							nFingerPrintID;							//fingerprint ID
}NET_CTRL_IN_FINGERPRINT_GET;

//CLIENT_Attendance_GetFingerRecord output param
typedef struct tagNET_CTRL_OUT_FINGERPRINT_GET
{
	DWORD						dwSize;
	char 						szUserID[DH_COMMON_STRING_32];			//	user ID
	char 						szFingerPrintName[DH_COMMON_STRING_32]; // name of fingerprint
	int							nFingerPrintID;							// fingerprint ID
	int							nRetLength;								// the returned length of fingerprint's binary data.
	int							nMaxFingerDataLength;					// the max length of fingerprint's binary data.
	char*						szFingerPrintInfo;						// binary data of fingerprint.
}NET_CTRL_OUT_FINGERPRINT_GET;

//CLIENT_Attendance_FindUser input parameter
typedef struct tagNET_IN_ATTENDANCE_FINDUSER
{
	DWORD			dwSize;
	int				nOffset;										// query offset
	int				nPagedQueryCount;								// query countpaged queryNo more than 100
}NET_IN_ATTENDANCE_FINDUSER;

//CLIENT_Attendance_FindUser output parameter
typedef struct tagNET_OUT_ATTENDANCE_FINDUSER
{
	DWORD 							dwSize;
	int								nTotalUser;						// the total of users.
	int								nMaxUserCount;					// max number of user infors
	NET_ATTENDANCE_USERINFO*       	stuUserInfo;            		// user information; alloc memory by user, size is (sizeof(NET_ATTENDANCE_USERINFO)*nMaxUserCount) 
	int								nRetUserCount;					// returned user infor counts.
	int                           	nMaxPhotoDataLength;        	// max photo data len
	int								nRetPhoteLength;				// returned length of photo data
	BYTE *                        	pbyPhotoData;           		// photo data
}NET_OUT_ATTENDANCE_FINDUSER;

//CLIENT_Attendance_GetFingerByUserID input parameter
typedef struct tagNET_IN_FINGERPRINT_GETBYUSER
{
	DWORD						 dwSize;
	char                         szUserID[MAX_COMMON_STRING_32];      //user ID 
}NET_IN_FINGERPRINT_GETBYUSER;

//CLIENT_Attendance_GetFingerByUserID output parameter
typedef struct tagNET_OUT_FINGERPRINT_GETBYUSER
{
	DWORD						dwSize;
	int							nFingerPrintIDs[DH_MAX_FINGER_PRINT];	// array of fingerprint'ID
	int							nRetFingerPrintCount;					// returned count of fingerprint
	int							nSinglePacketLength;					// the length of single fingerprint packet data
	int							nMaxFingerDataLength;					// the max length of photo data
	int							nRetFingerDataLength;					// returned length of photo data
	BYTE*                       pbyFingerData;                       	// photo data	
}NET_OUT_FINGERPRINT_GETBYUSER;


// CLIENT_Attendance_AddUser  input parameter
typedef struct tagNET_IN_ATTENDANCE_ADDUSER
{
    DWORD                      dwSize;  
    NET_ATTENDANCE_USERINFO    stuUserInfo;           //user info
    BYTE                       *pbyPhotoData;         // photo data
}NET_IN_ATTENDANCE_ADDUSER;

// CLIENT_Attendance_AddUser output parameter
typedef struct tagNET_OUT_ATTENDANCE_ADDUSER
{
    DWORD         dwSize; 
}NET_OUT_ATTENDANCE_ADDUSER;

// attendance add user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Attendance_AddUser(LLONG lLoginID, NET_IN_ATTENDANCE_ADDUSER *pstuInAddUser, NET_OUT_ATTENDANCE_ADDUSER *pstuOutAddUser, int nWaitTime);

// CLIENT_Attendance_DelUser input parameter
typedef struct tagNET_IN_ATTENDANCE_DELUSER
{
    DWORD                      dwSize;  
    char                       szUserID[MAX_COMMON_STRING_32];      //userid
}NET_IN_ATTENDANCE_DELUSER;

// CLIENT_Attendance_DelUser output parameter
typedef struct tagNET_OUT_ATTENDANCE_DELUSER
{
    DWORD         dwSize;   
}NET_OUT_ATTENDANCE_DELUSER;

//attendance delete user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Attendance_DelUser(LLONG lLoginID, NET_IN_ATTENDANCE_DELUSER *pstuInDelUser, NET_OUT_ATTENDANCE_DELUSER *pstuOutDelUser, int nWaitTime);

// CLIENT_Attendance_ModifyUser  input parameter
typedef struct tagNET_IN_ATTENDANCE_ModifyUSER
{
    DWORD                      dwSize;  
    NET_ATTENDANCE_USERINFO    stuUserInfo;                         //user info
    BYTE                       *pbyPhotoData;                       // photo data
}NET_IN_ATTENDANCE_ModifyUSER;

// CLIENT_Attendance_ModifyUser output parameter
typedef struct tagNET_OUT_ATTENDANCE_ModifyUSER
{
    DWORD         dwSize;   
}NET_OUT_ATTENDANCE_ModifyUSER;

//attendance modify user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Attendance_ModifyUser(LLONG lLoginID, NET_IN_ATTENDANCE_ModifyUSER *pstuInModifyUser, NET_OUT_ATTENDANCE_ModifyUSER *pstuOutModifyUser, int nWaitTime);

// CLIENT_Attendance_GetUser  input parameter
typedef struct tagNET_IN_ATTENDANCE_GetUSER
{
    DWORD                        dwSize;  
    char                         szUserID[MAX_COMMON_STRING_32];      //userid
}NET_IN_ATTENDANCE_GetUSER;

// CLIENT_Attendance_GetUser output parameter
typedef struct tagNET_OUT_ATTENDANCE_GetUSER
{
    DWORD                         dwSize;   
    NET_ATTENDANCE_USERINFO       stuUserInfo;            //user info    
    int                           nMaxLength;             // max photo data len
    BYTE *                        pbyPhotoData;           // photo data
}NET_OUT_ATTENDANCE_GetUSER;

//attendance get user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Attendance_GetUser(LLONG lLoginID, NET_IN_ATTENDANCE_GetUSER *pstuInGetUser, NET_OUT_ATTENDANCE_GetUSER *pstuOutGetUser, int nWaitTime);

//attendance insert fingerprint by userID
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Attendance_InsertFingerByUserID(LLONG lLoginID, NET_IN_FINGERPRINT_INSERT_BY_USERID* pstuInInsert, NET_OUT_FINGERPRINT_INSERT_BY_USERID* pstuOutInsert, int nWaitTime);

//attendance remove all fingerprint of one user
CLIENT_NET_API BOOL CALL_METHOD	CLIENT_Attendance_RemoveFingerByUserID(LLONG lLoginID, NET_CTRL_IN_FINGERPRINT_REMOVE_BY_USERID* pstuInRemove, NET_CTRL_OUT_FINGERPRINT_REMOVE_BY_USERID* pstuOutRemove, int nWaitTime);

//attendance get fingerprint record
CLIENT_NET_API BOOL CALL_METHOD	CLIENT_Attendance_GetFingerRecord(LLONG lLoginID, NET_CTRL_IN_FINGERPRINT_GET* pstuInGet, NET_CTRL_OUT_FINGERPRINT_GET* pstuOutGet, int nWaitTime);

//attendance remove fingerprint record.
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Attendance_RemoveFingerRecord(LLONG lLoginID, NET_CTRL_IN_FINGERPRINT_REMOVE* pstuInRemove, NET_CTRL_OUT_FINGERPRINT_REMOVE* pstuOutRemove, int nWaitTime);

//attendance find user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Attendance_FindUser(LLONG lLoginID, NET_IN_ATTENDANCE_FINDUSER *pstuInFindUser, NET_OUT_ATTENDANCE_FINDUSER *pstuOutFindUser, int nWaitTime);

//attendance get fingerprint record by userID
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Attendance_GetFingerByUserID(LLONG lLoginID, NET_IN_FINGERPRINT_GETBYUSER *pstuIn, NET_OUT_FINGERPRINT_GETBYUSER *pstuOut, int nWaitTime);


// Device Discovery subclassID type
typedef enum tagEM_NET_DEVICE_DISCOVERY_SUBCLASSID_TYPE
{
	EM_NET_DEVICE_DISCOVERY_SUBCLASSID_TYPE_UNKNOWN = -1,					// unknown
    EM_NET_DEVICE_DISCOVERY_SUBCLASSID_TYPE_NONE = 0,						// private
	EM_NET_DEVICE_DISCOVERY_SUBCLASSID_TYPE_ONVIF,                          // Onvif 
	EM_NET_DEVICE_DISCOVERY_SUBCLASSID_TYPE_UPNP,                           // UPnP 
}EM_NET_DEVICE_DISCOVERY_SUBCLASSID_TYPE;

// fAttachDeviceDiscoveryCB parameter
typedef struct tagNET_DEVICE_DISCOVERY_INFO
{
	DWORD				dwSize;
	char				szMachineName[DH_COMMON_STRING_32];					// MachineName
	char				szDeviceClass[DH_COMMON_STRING_32];					// DeviceClass
	char				szDeviceType[DH_COMMON_STRING_32];					// DeviceType
	char				szSerialNo[DH_COMMON_STRING_32];					// SerialNo
	char				szVersion[DH_COMMON_STRING_32];						// Version
	char				szMac[DH_COMMON_STRING_32];							// Mac Address
	int					nVideoInputChannels;								// VideoInputChannels
	int					nRemoteVideoInputChannels;							// RemoteVideoInputChannels
	int					nVideoOutputChannels;								// VideoOutputChannels
	int					nAlarmInputChannels;								// AlarmInputChannels
	int					nAlarmOutputChannels;								// AlarmOutputChannels
	int					nAudioInputChannels;								// AudioInputChannels
	int					nPort;												// Port
	char				szVendor[DH_COMMON_STRING_32];						// Vendor
	int					nInit;												// Init:0 donot have an initialization feature, 1 uninitialized, 2 initialized
	char				szIPv4Address[DH_COMMON_STRING_32];					// IPv4 Address
	char				szIPv4SubnetMask[DH_COMMON_STRING_32];				// IPv4 SubnetMask
	char				szIPv4DefaultGateway[DH_COMMON_STRING_32];			// IPv4 DefaultGateway
	BOOL				bIPv4DhcpEnable;									// IPv4 DhcpEnable
	char				szIPv6Address[DH_COMMON_STRING_32];					// IPv6 Address
	char				szIPv6DefaultGateway[DH_COMMON_STRING_32];			// IPv6 DefaultGateway
	char				szIPv6LinkLocalAddress[DH_COMMON_STRING_32];		// IPv6 LinkLocalAddress
	BOOL				bIPv6DhcpEnable;									// IPv6 DhcpEnable
	char				szProtocol[DH_COMMON_STRING_32];					// Protocol
}NET_DEVICE_DISCOVERY_INFO;


// Attach Device Discovery callback function,lAttachHandle is the returned value of CLIENT_AttachDeviceDiscovery, pDeviceInfo is the returned value of deviceInfo, nDeivceNum is the number of  pDeviceInfo
typedef void (CALLBACK *fAttachDeviceDiscoveryCB) (LLONG lAttachHandle, NET_DEVICE_DISCOVERY_INFO* pDeviceInfo, int nDeviceNum, LDWORD dwUser);


// CLIENT_AttachDeviceDiscovery input parameter
typedef struct tagNET_IN_ATTACH_DEVICE_DISCOVERY
{
    DWORD											dwSize;					
    EM_NET_DEVICE_DISCOVERY_SUBCLASSID_TYPE 		emSubClassID;			// subclassID
	fAttachDeviceDiscoveryCB						cbNotify;				// callback function 
	LDWORD											dwUser;					// User Data
} NET_IN_ATTACH_DEVICE_DISCOVERY;

// CLIENT_AttachDeviceDiscovery output parameter
typedef struct tagNET_OUT_ATTACH_DEVICE_DISCOVERY
{
    DWORD											dwSize;
} NET_OUT_ATTACH_DEVICE_DISCOVERY;

// CLIENT_StartDeviceDiscovery input parameter
typedef struct tagNET_IN_START_DEVICE_DISCOVERY 
{
    DWORD											dwSize;
	EM_NET_DEVICE_DISCOVERY_SUBCLASSID_TYPE 		emSubClassID;			// subclassID
    int												nTimeOut;				// timeout, unit:s
} NET_IN_START_DEVICE_DISCOVERY;

// CLIENT_StartDeviceDiscovery output parameter
typedef struct tagNET_OUT_START_DEVICE_DISCOVERY 
{
    DWORD											dwSize;
} NET_OUT_START_DEVICE_DISCOVERY;

// CLIENT_StopDeviceDiscovery input parameter
typedef struct tagNET_IN_STOP_DEVICE_DISCOVERY 
{
    DWORD											dwSize;
	EM_NET_DEVICE_DISCOVERY_SUBCLASSID_TYPE 		emSubClassID;			// SubClassID
} NET_IN_STOP_DEVICE_DISCOVERY;

// CLIENT_StopDeviceDiscovery output parameter
typedef struct tagNET_OUT_STOP_DEVICE_DISCOVERY 
{
    DWORD											dwSize;
} NET_OUT_STOP_DEVICE_DISCOVERY;

// Attach Device Discovery
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachDeviceDiscovery(LLONG lLoginID, const NET_IN_ATTACH_DEVICE_DISCOVERY *pInParam, NET_OUT_ATTACH_DEVICE_DISCOVERY *pOutParam, int nWaitTime);

// Detach Device Discovery, lAttachHandle is the returned handle of CLIENT_AttachDeviceDiscovery
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachDeviceDiscovery(LLONG lAttachHandle);

// Start Device Discovery
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartDeviceDiscovery(LLONG lLoginID, const NET_IN_START_DEVICE_DISCOVERY *pInParam, NET_OUT_START_DEVICE_DISCOVERY *pOutParam, int nWaitTime);

// Stop Device Discovery
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopDeviceDiscovery(LLONG lLoginID, const NET_IN_STOP_DEVICE_DISCOVERY *pInParam, NET_OUT_STOP_DEVICE_DISCOVERY *pOutParam, int nWaitTime);

// Set Defence Arm Mode,user malloc and free memory of pInBuf and pOutBuf
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDefenceArmMode(LLONG lLoginID, NET_IN_SET_DEFENCEMODE* pInBuf, NET_OUT_SET_DEFENCEMODE* pOutBuf );

// Get Defence Arm Mode,user malloc and free memory of pInBuf and pOutBuf
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDefenceArmMode(LLONG lLoginID, NET_IN_GET_DEFENCEMODE* pInBuf, NET_OUT_GET_DEFENCEMODE* pOutBuf, int nWaitTime );

// Set SubSystem Arm Mode,user malloc and free memory of pInBuf and pOutBuf
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetSubSystemArmMode(LLONG lLoginID, NET_IN_SET_SUBSYSTEMMODE* pInBuf, NET_OUT_SET_SUBSYSTEMMODE* pOutBuf );

// Get SubSystem Arm Mode,user malloc and free memory of pInBuf and pOutBuf
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSubSystemArmMode(LLONG lLoginID, NET_IN_GET_SUBSYSTEMMODE* pInBuf, NET_OUT_GET_SUBSYSTEMMODE* pOutBuf, int nWaitTime );

// Get Arm Mode,user malloc and free memory of pInBuf and pOutBuf
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetArmMode(LLONG lLoginID, NET_IN_GET_ARM_MODE* pInBuf, NET_OUT_GET_ARM_MODE* pOutBuf, int nWaitTime);

// set mobile push notification, use RegisterID to identify the config info,user malloc and free pstuCfg's memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetMobilePushNotify(LLONG lLoginID, const NET_MOBILE_PUSH_NOTIFY *pstuCfg, int *nError, int *nRestart, int nWaitTime );

// delete mobile push notification, use RegisterID to identify the config info,user malloc and free memory of pstuIn and pstuOut
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DelMobilePushNotify(LLONG lLoginID, const NET_MOBILE_PUSH_NOTIFY_DEL *pstuIn, NET_OUT_DELETECFG* pstuOut, int nWaitTime );

// get mobile push notification config, use RegisterID+AppID to identify the info, AppID cannot include ".", use "_" instead of ".",user malloc and free pstuCfg's memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetMobilePushNotifyCfg(LLONG lLoginID, NET_MOBILE_PUSH_NOTIFY_CFG *pstuCfg, int *nError, int nWaitTime );

// set mobile push notification config, use RegisterID+AppID to identify the info, AppID cannot include ".", use "_" instead of ".",user malloc and free pstuCfg's memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetMobilePushNotifyCfg(LLONG lLoginID, const NET_MOBILE_PUSH_NOTIFY_CFG *pstuCfg, int *nError, int *nRestart, int nWaitTime );

// delete mobile push notification config, use RegisterID+AppID to identify the info, AppID cannot include ".", use "_" instead of ".",user malloc and free memory of pstuIn and pstuOut
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DelMobilePushNotifyCfg(LLONG lLoginID, const NET_MOBILE_PUSH_NOTIFY_CFG_DEL *pstuIn, NET_OUT_DELETECFG* pstuOut, int nWaitTime );


// batch insert access control cards
// nInsertCount: number of cards to insert, no more than 20
// pInsertCards: cards to insert, NET_RECORDSET_ACCESS_CTL_CARD buffer allocated and filled by user, amount to nInsertCount
// nRecNo: record number after inserted (-1 for failed), int buffer allocated by user, coresponding to pInsertCards one by one, amount to nInsertCount
CLIENT_NET_API BOOL CALL_METHOD CLIENT_InsertAccessControlCards(LLONG lLoginID, int nInsertCount, const NET_RECORDSET_ACCESS_CTL_CARD* pInsertCards, int* pRecNo, void* reserved );

//face image compare info
typedef struct tagNET_IMAGE_COMPARE_INFO
{
	DWORD 			   	    dwoffset;			// offset in binary data,unit:byte
	DWORD					dwLength;			// Image length,unit:byte
	DWORD					dwWidth;			// image width
	DWORD					dwHeight;			// image height
	BYTE                    byReserved[128];    // Reserved
} NET_IMAGE_COMPARE_INFO;

//CLIENT_MatchTwoFace input param
typedef struct tagNET_MATCH_TWO_FACE_IN
{
	DWORD					dwSize;
	NET_IMAGE_COMPARE_INFO  stuOriginalImage;	// original image
	NET_IMAGE_COMPARE_INFO  stuCompareImage;	// compare image
	char 			   	   *pSendBuf;			// two face image data
	DWORD 					dwSendBufLen;		// data length
} NET_MATCH_TWO_FACE_IN;

//CLIENT_MatchTwoFace output param
typedef struct tagNET_MATCH_TWO_FACE_OUT
{
	DWORD					dwSize;
	int						nSimilarity;		//Similarity ( expressed as a percentage, from 1 to 100)
} NET_MATCH_TWO_FACE_OUT;

// calculate the similarity of two face images,user malloc and free memory of pstInParam and pstOutParam
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_MatchTwoFaceImage(LLONG lLoginID, const NET_MATCH_TWO_FACE_IN *pstInParam, NET_MATCH_TWO_FACE_OUT *pstOutParam, int nWaitTime );

// the decode frame type
typedef enum tagEM_DECODE_FRAME_TYPE
{
    EM_FRAME_TYPE_UNKNOWN   = -1,               // unknown
    EM_FRAME_TYPE_VIDEO     = 0,				// video
    EM_FRAME_TYPE_AUDIO     = 1,				// audio
}EM_DECODE_FRAME_TYPE;

// the ex frame info
typedef struct tagNET_FRAME_INFO_EX
{
    DWORD                   dwSize;
    EM_DECODE_FRAME_TYPE    emFrameType;			//frame type
    int				        nFrameSeq;				//frame index
    int				        nStamp;					//stamp info,in ms
    int				        nWidth;					//frame width,it is zero when frame type is audio
    int 			        nHeight;				//frame height,it is zero when frame type is audio
    int				        nFrameRate;				//frame rate
    int				        nChannels;				//channel num
    int				        nBitPerSample;			//bit per sample
    int				        nSamplesPerSec;			//sample per second
    int				        nRemainData;			//length of buffer data
    NET_TIME_EX		        nDataTime;				//frame time info

}NET_FRAME_INFO_EX;

// the decode frame info
typedef struct tagNET_FRAME_DECODE_INFO 
{
    DWORD                   dwSize;
    EM_DECODE_FRAME_TYPE    emFrameType;			//frame type

    void*			        pAudioData;				//audio data
    int				        nAudioDataLen;			//audio data length

    void*			        pVideoData[3];			//YUV data
    int				        nStride[3];				//stride of YUV
    int				        nWidth[3];				//width of YUV
    int				        nHeight[3];				//height of YUV  
}NET_FRAME_DECODE_INFO;

// the call back function type for decode of frame
typedef void (CALLBACK *fDecCallBack)(LLONG lLoginID, LLONG lPlayHandle, NET_FRAME_DECODE_INFO* pFrameDecodeInfo, NET_FRAME_INFO_EX* pFrameInfo, LDWORD dwUserData, LLONG nReserved);

// set the call back function for decode of frame
CLIENT_NET_API void CALL_METHOD CLIENT_SetDecCallBack(fDecCallBack cbDecCallBack, LDWORD dwUserData, LLONG nReserved );

//  set the call back function for decode of frame ---- extend
CLIENT_NET_API void CALL_METHOD CLIENT_SetDecCallBackEx(fDecCallBack cbDecCallBack, LDWORD dwUserData, NET_VIDEOSTREAM_TYPE emVideoStreamType, LLONG nReserved);

// get default config of device(only support EncodePlane config now, emCfgOpType == NET_EM_CFG_ENCODE_PLAN)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDevDefaultConfig(LLONG lLoginID, NET_EM_CFG_OPERATE_TYPE emCfgOpType, int nChannelID,
                                          LPVOID lpOutBuffer, DWORD dwOutBufferSize, int nWaittime/*=NET_INTERFACE_DEFAULT_TIMEOUT*/);

#define NET_CUSTOM_PARKING_SPACE_NUMBER_MAX_LEN 32                        // the max length of car custom  lane

// the light color of parking space
typedef enum tagEM_PARKINGSPACE_LIGHT_COLOR
{
    EM_PARKINGSPACE_LIGHT_COLOR_UNKNOWN,                                    // Unknown
    EM_PARKINGSPACE_LIGHT_COLOR_RED,                                        // red
    EM_PARKINGSPACE_LIGHT_COLOR_YELLOW,                                     // yellow    
	EM_PARKINGSPACE_LIGHT_COLOR_GREEN,                                      // green  
	EM_PARKINGSPACE_LIGHT_COLOR_BLUE,										// blue    
	EM_PARKINGSPACE_LIGHT_COLOR_PURPLE,                                     // purple   
	EM_PARKINGSPACE_LIGHT_COLOR_WHITE,										// white  
	EM_PARKINGSPACE_LIGHT_COLOR_PINK,										// pink 
}EM_PARKINGSPACE_LIGHT_COLOR;

// the light state of parking space
typedef enum tagEM_PARKINGSPACE_LIGHT_STATE
{
    EM_PARKINGSPACE_LIGHT_STATE_UNKNOWN = -1,                               // Unknown  
    EM_PARKINGSPACE_LIGHT_STATE_OFF,                                        // off
    EM_PARKINGSPACE_LIGHT_STATE_ON,                                         // on
    EM_PARKINGSPACE_LIGHT_STATE_GLINT,                                      // glint
    EM_PARKINGSPACE_LIGHT_STATE_LAST_STATE,                                 // last state
}EM_PARKINGSPACE_LIGHT_STATE;

// the light plan info of parking space
typedef struct tagNET_PARKING_SPACE_LIGHT_PLAN_INFO
{
    EM_PARKINGSPACE_LIGHT_COLOR emColor;                                    // light color
    EM_PARKINGSPACE_LIGHT_STATE emState;                                    // light state
    int nKeepTime;                                                          // state keep time,in second,-1 means light on all the time
    BYTE byReserved[128];                                                   // reserved
}NET_PARKING_SPACE_LIGHT_PLAN_INFO;

// the in param for set the light plan
typedef struct tagNET_IN_SET_PARKING_SPACE_LIGHT_PLAN
{
    DWORD dwSize;                                                           // struct size                                                           
    int nPhysicalLane;                                                      // physical lane,user should use this memeber prior.negative means this member is invalid
    char szCustomParkNo[NET_CUSTOM_PARKING_SPACE_NUMBER_MAX_LEN];           // custom lane number
    int nLightPlanNum;                                                      // the num of light plan
    NET_PARKING_SPACE_LIGHT_PLAN_INFO* pstuLightPlan;                       // the light plan data pointer
}NET_IN_SET_PARKING_SPACE_LIGHT_PLAN;

// the out param for set the light plan
typedef struct tagNET_OUT_SET_PARKING_SPACE_LIGHT_PLAN
{
    DWORD dwSize;                                                           // struct size
}NET_OUT_SET_PARKING_SPACE_LIGHT_PLAN;


// set the parking space light plan
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetParkingSpaceLightPlan(LLONG lLoginID,const NET_IN_SET_PARKING_SPACE_LIGHT_PLAN* pNetDataIn,NET_OUT_SET_PARKING_SPACE_LIGHT_PLAN* pNetDataOut,int nWaitTime);


// in param of CLIENT_SyncParkingInfo, geomagnetism sensor sync report parking info
typedef struct tagNET_IN_SYNC_PARKING_INFO
{
	DWORD			dwSize;													// struct size
	int				nChannel;												// channel
	char			szParkingNum[32];										// parking num
	DWORD			dwPresetNum;											// preset num
	BOOL			bHaveCar;												// is parking space have car
	BOOL			bParkingFault;											// is parking space have fault
	int				nSnapTimes;												// Snap timesRange0-5
	int				nSnapIntervel;											// Snap IntervelRange3-10
}NET_IN_SYNC_PARKING_INFO;

// out param of CLIENT_SyncParkingInfo, geomagnetism sensor sync report parking info
typedef struct tagNET_OUT_SYNC_PARKING_INFO
{
	DWORD			dwSize;													// struct size
}NET_OUT_SYNC_PARKING_INFO;

// SD customize project, geomagnetism sensor sync report parking info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SyncParkingInfo(LLONG lLoginID, const NET_IN_SYNC_PARKING_INFO* pNetIn, NET_OUT_SYNC_PARKING_INFO* pNetOut, int nWaitTime);



/************************************************************************
 ** ObjectStructlize protocol interface
 ***********************************************************************/
//structlize event image info
typedef struct tagDEV_ALARM_OBJECTSTRUCTLIZE_PIC_INFO
{
    char                     szCutPicPath[MAX_PATH];          // the path of cut pictrue
    DWORD                    dwWidth;                         // picture width, pixel
    DWORD                    dwHeight;                        // picture height, pixel
    BYTE                     byReserved[256];                 // Reserved
} DEV_ALARM_OBJECTSTRUCTLIZE_PIC_INFO;

//objectstructlize person condition info or result info
typedef struct tagDEV_PERSON_CONDITION_RESULT_FEATURE_INFO 
{
    EM_DEV_EVENT_FACEDETECT_SEX_TYPE        emSex;                      // sex
    BYTE                                    byAge;                      // age
    BYTE                                    byCall;                     // calling        ,0:unknow 1:NO  2:YES
    BYTE                                    byHat;                      // with hat       ,0:unknow 1:NO  2:YES
    BYTE                                    byBag;                      // with bag       ,0:unknow 1:NO  2:YES
    BYTE                                    byUmbrella;                 // with Umbrella  ,0:unknow 1:NO  2:YES
    BYTE                                    byGlasses;                  // with Glasses   ,0:unknow 1:NO  2:YES
    BYTE                                    byReserved1[2];             
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE    emEmotion;                  // human emotion:smile,anger, sadness, disgust, fear, surprise, neutral, laugh
    NET_COLOR_RGBA                          stuUpperBodyColor;          // upper body color
    NET_COLOR_RGBA                          stuLowerBodyColor;          // lower body color
    BYTE                                    byReserved[256];            // Reserved
} DEV_PERSON_CONDITION_FEATURE_INFO,DEV_PERSON_RESULT_FEATURE_INFO;

//person feature detect event(command:EVENT_IVS_OBJECTSTRUCTLIZE_PERSON)
typedef struct tagDEV_EVENT_OBJECTSTRUCTLIZE_PERSON_INFO
{
    int                                    nChannelID;                           // channel ID
    char                                   szName[DH_EVENT_NAME_LEN];            // event name
	BYTE                                   bReserved1[4];                        //
    double                                 dbPTS;                                // PTS(ms)
    NET_TIME_EX                            stuUTC;                               // time of occurrence
    int                                    nEventID;                             // event ID
    DH_EVENT_FILE_INFO                     stuFileInfo;                          // event file info
    int                                    nEventAction;                         // event action,0 pulse,1 durable events begin, 2 durable 

	char                                   szFilePath[MAX_PATH];                 // file path
    DEV_PERSON_RESULT_FEATURE_INFO         stuPersonFeatrue;                     // person feature
    NET_RECT                               stuBoundingBoxRect;                   // BoundingBox Rect, 0~8192
    DEV_ALARM_OBJECTSTRUCTLIZE_PIC_INFO    stuImageInfo;                         // cut image info

    int                                    nImageIndex;                          // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD                                  dwSnapFlagMask;                       // flag(by bit),see NET_RESERVED_COMMON      
    BYTE                                   bReserved[1024];                      // Reserved 
} DEV_EVENT_OBJECTSTRUCTLIZE_PERSON_INFO;

//nonmotor feature detect event(command:EVENT_IVS_OBJECTSTRUCTLIZE_NONMOTOR)
typedef struct tagDEV_EVENT_OBJECTSTRUCTLIZE_NONMOTOR_INFO
{
    int                                    nChannelID;                           // channel ID
    char                                   szName[DH_EVENT_NAME_LEN];            // event name
	BYTE                                   bReserved1[4];
    double                                 dbPTS;                                // PTS(ms)
    NET_TIME_EX                            stuUTC;                               // time of occurrence
    int                                    nEventID;                             // event ID
    DH_EVENT_FILE_INFO                     stuFileInfo;                          // event file info
    int                                    nEventAction;                         // event action,0 pulse,1 durable events begin, 2 durable 
    
	char                                   szFilePath[MAX_PATH];                 // file path
    char                                   szPlateNumber[DH_MAX_PLATE_NUMBER_LEN];// plate number 
    DEV_PERSON_RESULT_FEATURE_INFO         stuPersonFeatrue;                     // person feature
    NET_RECT                               stuBoundingBoxRect;                   // BoundingBox Rect, 0~8192
    DEV_ALARM_OBJECTSTRUCTLIZE_PIC_INFO    stuImageInfo;                         // cut image info

    int                                    nImageIndex;                          // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD                                  dwSnapFlagMask;                       // flag(by bit),see NET_RESERVED_COMMON      
    BYTE                                   bReserved[1024];                      // Reserved 
} DEV_EVENT_OBJECTSTRUCTLIZE_NONMOTOR_INFO;

//tumble detection info , Corresponding to DH_ALARM_TUMBLE_DETECTION alarm
typedef struct tagALARM_TUMBLE_DETECTION_INFO       
{     
	int									nAction;							// Event operation. 1: Start, 2: Stop
	int									nChannelID;							// Channel No.
    double								PTS;								// Time stamp (Unit is ms)
    NET_TIME_EX							UTC;								// Event occurrence time 
    int									nEventID;							// Event ID
	int									UTCMS;								// Millisecond	
	
	EM_CLASS_TYPE						emClassType;						// class type
	int									nObjectID;							// object ID
	char								szObjectType[DH_COMMON_STRING_16];	// Object Type, support for the following:
																			// "Unknown", "Human", "Vehicle","Fire", "Smoke", "Plate", "HumanFace", 
																			// "Container", "Animal", "TrafficLight", "PastePaper", "HumanHead", "BulletHole",  "Entity"
	NET_RECT							stuBoundingBox;						// Bounding Box
	BYTE                				byReserved[1024];   				// reserved  
}ALARM_TUMBLE_DETECTION_INFO; 

// tumble detection event (command:EVENT_IVS_TUMBLE_DETECTION)
typedef struct tagDEV_EVENT_TUMBLE_DETECTION_INFO
{
    int                     nChannelID;                             // channel ID
    char                    szName[DH_EVENT_NAME_LEN];              // event name
    int						nAction;								// Event operation. 1: Start, 2: Stop
    double                  PTS;                                    // PTS(ms)
    NET_TIME_EX             UTC;                                    // time of occurrence
    int                     nEventID;                               // event ID
	int						UTCMS;									// millseconds

	EM_CLASS_TYPE			emClassType;							// class type
	int						nObjectID;								// Object ID
	char					szObjectType[DH_COMMON_STRING_16];		// Object Type, support for the following:
																	// "Unknown", "Human", "Vehicle","Fire", "Smoke", "Plate", "HumanFace", 
																	// "Container", "Animal", "TrafficLight", "PastePaper", "HumanHead", "BulletHole",  "Entity"
	NET_RECT				stuBoundingBox;							// Bounding Box
	
	BYTE                    bReserved[1024];                        // reserved
} DEV_EVENT_TUMBLE_DETECTION_INFO;

//EVENT_IVS_SPILLEDMATERIAL_DETECTION Event info data
typedef struct tagDEV_EVENT_SPILLEDMATERIAL_DETECTION_INFO
{
	int						nChannelID;								// ChannelId
	char					szName[128];							// event name
	char					bReserved[4];							// byte alignment
	double					PTS;									// PTS(ms)
	NET_TIME_EX				UTC;									// the event happen time
	int						nEventID;								// event ID

	DH_MSG_OBJECT_EX		stuObjects[MAX_OBJECT_NUM_EX];			// Objects
	int						nObjectNum;								// The number of objects
	DH_EVENT_FILE_INFO		stuFileInfo;							// event file info
	DH_POINT				stuDetectLine[DH_MAX_DETECT_LINE_NUM];	// rule detect line
	int						nDetectLineNum;							// rule detect line's point number
	DH_POINT				stuTrackLine[DH_MAX_TRACK_LINE_NUM];	// object moveing track
	int						nTrackLineNum;							// object moveing track's point number
	BYTE					bEventAction;							// event action,0 pulse,1 durable events begin, 2 durable events end
	BYTE					bReserved1[3];							// reserved
	NET_CROSSLINE_DIRECTION_INFO	emDirection;					// Direction,( if nObjectNum > 0 please use emPersonDirection which in stuObjects )
	int						nImageIndex;							// Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	DWORD					dwSnapFlagMask;							// flag(by bit),see NET_RESERVED_COMMON
	int						nSourceIndex;							// the source device's index,-1 means data in invalid
	char					szSourceDevice[MAX_PATH];				// the source device's sign(exclusive),field said local device does not exist or is empty
	unsigned int			nOccurrenceCount;						// event trigger accumulated times
	EVENT_INTELLI_COMM_INFO stuIntelliCommInfo;						// intelli comm info
	NET_EXTENSION_INFO		stuExtensionInfo;						// Extension info
	BYTE					byReserved[1028];						// reserved
}DEV_EVENT_SPILLEDMATERIAL_DETECTION_INFO;

// citizen picture compare image info
typedef struct tagCITIZEN_PICTURE_COMPARE_IMAGE_INFO
{
    DWORD           dwOffSet;                       // data offset, unit:byte
    DWORD           dwFileLenth;                    // file lenght, unit:byte
    WORD            wWidth;                         // width, unit:pixel
    WORD            wHeight;                        // height, unit:pixel
    BYTE            byReserved[256];                // reserved
}CITIZEN_PICTURE_COMPARE_IMAGE_INFO;

// picture type
typedef enum tagCITIZEN_PICTURE_COMPARE_TYPE
{
	CITIZEN_PICTURE_COMPARE_TYPE_UNKNOWN = -1,
	CITIZEN_PICTURE_COMPARE_TYPE_LOCAL,				// Local face database
	CITIZEN_PICTURE_COMPARE_TYPE_FACEMAP,			// shooting scene map
}CITIZEN_PICTURE_COMPARE_TYPE;

// citizen picture compare image extended info
typedef struct tagCITIZEN_PICTURE_COMPARE_IMAGE_INFO_EX
{
	CITIZEN_PICTURE_COMPARE_TYPE		emType;					// type
	DWORD								dwOffSet;               // data offset, unit:byte
	DWORD								dwFileLenth;            // file lenght, unit:byte
	WORD								wWidth;                 // width, unit:pixel
	WORD								wHeight;                // height, unit:pixel
	BYTE								byReserved[64];        // Reserved
}CITIZEN_PICTURE_COMPARE_IMAGE_INFO_EX;

// citizen picture compare event,command:EVENT_IVS_CITIZEN_PICTURE_COMPARE
typedef struct tagDEV_EVENT_CITIZEN_PICTURE_COMPARE_INFO
{
    //common info
    int                 nChannelID;                         // channel number,start with 0
    int                 nEventAction;					    // event action, 0-pulse, -1-unknown
    double              dbPTS;                              // time stamp(unit:ms)
    char                szName[DH_EVENT_NAME_LEN];          // event name   
    NET_TIME_EX         stuUTC;                             // evnet time(UTC)
    int                 nEventID;                           // evnet id

    //evnet data
    bool                bCompareResult;                     // compare result,true:success,false:failed
    BYTE                nSimilarity;                        // Similarity,unit:%,rang:[1,100]
    BYTE                nThreshold;                         // Threshold,rang:[1,100]
    EM_CITIZENIDCARD_SEX_TYPE emSex;                        // sex
    int                 nEthnicity;                         // Ethnicity(see DEV_EVENT_ALARM_CITIZENIDCARD_INFO::nEthnicity)
    char                szCitizen[DH_COMMON_STRING_64];     // citizen name    
    char                szAddress[DH_COMMON_STRING_256];    // address
    char                szNumber[DH_COMMON_STRING_64];      // citizen number
    char                szAuthority[DH_COMMON_STRING_256];  // Authority
    NET_TIME            stuBirth;                           // Birth(y-m-d)
    NET_TIME            stuValidityStart;                   // Validity start time(y-m-d)
    BOOL                bLongTimeValidFlag;                 // When the value is TRUE, the stop date menas always valid, at this time, the stuValidityEnd is null. 
                                                            // When the value is FALSE, refer to stuValidityEnd value for stop date.
    NET_TIME            stuValidityEnd;                     // Validity end time(y-m-d)
    CITIZEN_PICTURE_COMPARE_IMAGE_INFO stuImageInfo[2];     // image info,elememnt 0 indicate snap pic,elememnt 1 indicate citizen pic
	char                szCardNo[DH_COMMON_STRING_32];      // IC cardNo
	char                szCellPhone[DH_COMMON_STRING_20];   // cellphone
	NET_EXTENSION_INFO  stuExtensionInfo;                   // Extension info
    CITIZEN_PICTURE_COMPARE_IMAGE_INFO_EX	stuImageInfoEx[6];	// Extended image info
	char				szCallNumber[20];					// Call Number
	NET_ACCESS_DOOROPEN_METHOD	emDoorOpenMethod;			// Door open methodPicture or fingerprint
	UINT				nEventGroupID;						// Event ID,relate other event
	UINT				nEventType;							// event type: 0: citizen picture compare result	1:citizen picture collection
	char				szUserID[32];						// user id of citizen picture collection (customized)
    BYTE                byReserved[296];                    // Reserved
}DEV_EVENT_CITIZEN_PICTURE_COMPARE_INFO;

// object find scope
typedef struct tagDEV_OBJECT_FIND_SCOPE_INFO
{
    BOOL                bEnable;                    // enable
	int                 nMinValue;                  // min value
	int                 nMaxValue;                  // max value
} DEV_OBJECT_FIND_SCOPE_INFO;

// sunshiled find scope
typedef struct tagDEV_OBJECT_SUNSHIELD_FIND_SCOPE_INFO
{
    BYTE                                   byFindType;                 // find type:1 find by number 2 find by seat(required,other value is invalid)
	int                                    nMinSunShieldNum;           // sun  shiled min numbers value(option)byFindType  is required 1
    int                                    nMaxSunShieldNum;           // sun  shiled max numbers value(option)byFindType  is required 1
	NET_SUNSHADE_STATE                     emMasterShield;             // master driver seat shield status(option)byFindType  is required 2
    NET_SUNSHADE_STATE                     emSlaveShield;              // slave driver seat shield status(option)byFindType  is required 2
} DEV_OBJECT_SUNSHIELD_FIND_SCOPE_INFO;

//vehicle structlize find condition 
typedef struct tagDEV_VEHICLE_CONDITION_FEATURE_INFO 
{
    char                                   szPlateNumber[DH_MAX_PLATE_NUMBER_LEN];        // plate number 
    EM_NET_PLATE_TYPE                      emPlateType;                                   // plate type
	NET_COLOR_RGBA                         stuPlateColor;                                 // plate color
    EM_NET_VEHICLE_TYPE                    emVehicleType;                                 // vehicle type
	NET_COLOR_RGBA                         stuVehicleColor;                               // vehicle color
    char                                   szVehicleLogo[32];                             // vehicle logo
    WORD                                   wVehicleSubBrand;                              // specifies the sub-brand of vehicle,the real value can be found in a mapping table from the development manual
    WORD                                   wVehicleYearModel;                             // specifies the model years of vehicle. the real value can be found in a mapping table from the development manual
    EM_VEHICLE_DIRECTION                   emVehicleDirection;                            // vehicle snapped direction

    NET_SAFEBELT_STATE                     emMainSeat;                                    // main driver seat belt status(option)
    NET_SAFEBELT_STATE                     emSlaveSeat;                                   // slave driver seat belt status(option)
	DEV_OBJECT_SUNSHIELD_FIND_SCOPE_INFO   stuSunShieldInfo;                              // sun shiled find scope info(option)
    DEV_OBJECT_FIND_SCOPE_INFO             stuDropInfo;                                   // drop find scope info(option)
    DEV_OBJECT_FIND_SCOPE_INFO             stuPaperBoxInfo;                               // paperBox find scope info(option)
    DEV_OBJECT_FIND_SCOPE_INFO             stuAnnualInspectionInfo;                       // Annual Inspection find scope info(option)   
    BYTE                                   byReserved[256];                               // reserved
} DEV_VEHICLE_CONDITION_FEATURE_INFO;

//vehicle structlize find result
typedef struct tagDEV_VEHICLE_RESULT_FEATURE_INFO 
{
    char                                   szPlateNumber[DH_MAX_PLATE_NUMBER_LEN];        // plate number 
    EM_NET_PLATE_TYPE                      emPlateType;                                   // plate type
	NET_COLOR_RGBA                         stuPlateColor;                                 // plate color
    NET_COLOR_RGBA                         stuVehicleColor;                               // vehicle color
    char                                   szVehicleLogo[32];                             // vehicle logo
    WORD                                   wVehicleSubBrand;                              // specifies the sub-brand of vehicle,the real value can be found in a mapping table from the development manual
    WORD                                   wVehicleYearModel;                             // specifies the model years of vehicle. the real value can be found in a mapping table from the development manual
    int                                    nVehicleWindowNum;                             // valid vehicle window numbers                                        
    NET_RECT                               stuVehicleWindow[4];                           // vehicle window positon,mark 0 corresponding to front vehicle window,
	                                                                                      // mark 1 corresponding to back vehicle window,others marks corresponding to side vehicle window
    EM_VEHICLE_DIRECTION                   emVehicleDirection;                            // vehicle snapped direction
    
    NET_SAFEBELT_STATE                     emMainSeat;                                    // main driver seat belt status
    NET_SAFEBELT_STATE                     emSlaveSeat;                                   // slave driver seat belt status
    NET_RECT                               stuMasterShield;                               // main driver seat shiled position
    NET_RECT                               stuSlaveShield;                                // slave driver seat shiled position
    int                                    nAnnualInspectionNum;                          // annual Inspection number                                        
    NET_RECT                               stuAnnualInspection[8];                        // annual Inspection position
    int                                    nDropNum;                                      // drop number                                       
    NET_RECT                               stuDrop[4];                                    // drop position
    int                                    nPaperBoxNum;                                  // paper box number                                        
    NET_RECT                               stuPaperBox[4];                                // paper box position
    BYTE                                   byReserved[256];                               // Reserved
} DEV_VEHICLE_RESULT_FEATURE_INFO;

// feature picture type
typedef enum tagEM_PIC_FEATURE_TYPE
{
    EM_PIC_FEATURE_TYPE_UNKOWN,            // unknow
    EM_PIC_FEATURE_TYPE_GLOBAL_SENCE,      // global scene
    EM_PIC_FEATURE_TYPE_SMALL,             // small
}EM_PIC_FEATURE_TYPE;

// image reuqest info
typedef struct tagDEV_IMAGE_REQUEST_FEATURE_INFO
{
    EM_PIC_FEATURE_TYPE      emPicType;            // picture type(required)
    DWORD                    dwoffset;             // offset in binary data,unit:byte
    DWORD                    dwLength;             // Image length,unit:byte
    DWORD                    dwWidth;              // image width
    DWORD                    dwHeight;             // image height
	BOOL                     bEnableRect;          // enable rect find
    NET_RECT                 stuRect;              // (option)mark object rect when picture type is Global Scene.(absolute coordinate)
    BYTE                     byReserved[256];      // Reserved
} DEV_IMAGE_REQUEST_FEATURE_INFO;

// image result info
typedef struct tagDEV_IMAGE_RESULT_FEATURE_INFO
{
    DWORD                   dwSimilarity;                   // Similarity ( expressed as a percentage, from 1 to 100)
    NET_TIME                stuTime;                        // time

	DWORD                   dwObjectOffset;                 // object image offset in binary data,unit:byte( depend on NeedData value in request)
	DWORD                   dwObjectLength;                 // object Image length,unit:byte(depend on NeedData value in request)
    char                    szObjectFilePath[MAX_PATH];     // object Image file path(depend on NeedData value in request)

	DWORD                   dwSceneOffset;                  // global scene image offset in binary data,unit:byte(depend on NeedData value in request)
	DWORD                   dwSceneLength;                  // global scene Image length,unit:byte(depend on NeedData value in request)
    char                    szSceneFilePath[MAX_PATH];      // global scene Image file path(depend on NeedData value in request)

    NET_RECT                stuObjectRect;                  // object rect(absolute coordinate)
    BYTE                    byReserved[256];                // Reserved
} DEV_IMAGE_RESULT_FEATURE_INFO;


// CLIENT_DetectObjectStructlize input parameter
typedef struct tagNET_IN_OBJECTSTRUCTLIZE_DETECT_PIC
{
    DWORD                                    dwSize; 
    int					                     nWidth;              // image width
    int                                      nHeight;             // image height
    char                                     *pBuffer;            // image binary buffer address
    int                                      nBufferLen;          // image binary buffer length
}NET_IN_OBJECTSTRUCTLIZE_DETECT_PIC;

// detected object info
typedef struct tagNET_OBJECT_DETECTED_INFO
{
    DH_POINT                         stuPoint;                       // object position,(absolute coordinate)
    DWORD                            dwWidth;                        // image width
    DWORD                            dwHeight;                       // image height
    char                             szObjectType[16];               // object type, refer to the same field of NET_OBJFILTER_INFO 
    char                             szObjectSubType[32];            // object sub type, refer to the same field of NET_OBJFILTER_INFO
    DEV_PERSON_RESULT_FEATURE_INFO   stuPersonResult;                // detected person result
    DEV_VEHICLE_RESULT_FEATURE_INFO  stuVehicleResult;               // detected vehicle result
    BYTE                             byReserved[512];                // Reserved
} NET_OBJECT_DETECTED_INFO;

// CLIENT_DetectObjectStructlize output parameter
typedef struct tagNET_OUT_OBJECTSTRUCTLIZE_DETECT_PIC
{
    DWORD                          dwSize; 
    int                            nObjectNum;                                // detected objects numbers
    NET_OBJECT_DETECTED_INFO       stuObjectinfos[DH_MAX_OBJECT_LIST];        // detected objects
}NET_OUT_OBJECTSTRUCTLIZE_DETECT_PIC;

// objectstructlize finding status callback function, 
typedef struct tagNET_CB_OBJECTSTRUCTLIZE_FIND_STATE
{
    DWORD               dwSize;     
    int                 nToken;         //The search token received 
    int                 nProgress;      //Normal value: 0-100. 1=Searched token does not exist (When subscribe a search that does not exist or already finished)
    int                 nCurrentCount;  //The amount that match current criteria
}NET_OBJECTSTRUCTLIZE_FIND_STATE;

//ObjectStructlize Find State callback
typedef void (CALLBACK *fObjectStructlizeFindState)(LLONG lLoginID, LLONG lAttachHandle, NET_OBJECTSTRUCTLIZE_FIND_STATE* pstStates, int nStateNum, LDWORD dwUser);

//CLIENT_ObjectStructlizeAttachFindState 
typedef struct tagNET_IN_OBJECTSTRUCTLIZE_FIND_STATE
{
    DWORD                              dwSize;             // Structure size. Must fill in. 
    
    int                                nTokenNum;          // Search token. 0=subscribe all searched tasks.
    int                                nTokens[8];         // Search tokens
    fObjectStructlizeFindState         cbObjectSFindState; // Callback function 
    LDWORD                             dwUser;             // User data 
}NET_IN_OBJECTSTRUCTLIZE_FIND_STATE;

//CLIENT_ObjectStructlizeAttachFindState
typedef struct  tagNET_OUT_OBJECTSTRUCTLIZE_FIND_STATE
{
    DWORD           dwSize;
 }NET_OUT_OBJECTSTRUCTLIZE_FIND_STATE;

// CLIENT_StartFindObjectStructlize 
typedef struct tagNET_IN_STARTFIND_OBJECTSTRUCTLIZE
{
    DWORD                                      dwSize;
    int                                        nChannelNum;                    // channel number
    int                                        stuChannelID[16];               // channel ID
	BOOL                                       bTimeEnable;                    // enable time find
    NET_TIME                                   stStartTime;                    // (option)start time
    NET_TIME                                   stEndTime;                      // (option)end time
    //find condition
    char                                       szObjectType[16];               // (required)object type, refer to the same field of NET_OBJFILTER_INFO
    char                                       szObjectSubType[32];            // (option)object sub type, refer to the same field of NET_OBJFILTER_INFO
    int                                        nSimilarity;                    // Similarity ( expressed as a percentage, from 1 to 100)

    DEV_PERSON_CONDITION_FEATURE_INFO          stuPersonCondition;             // person find condition,multiple conditions linked by AND
    DEV_VEHICLE_CONDITION_FEATURE_INFO         stuVehicleCondition;            // vehicle find condition,multiple conditions linked by AND
    DEV_IMAGE_REQUEST_FEATURE_INFO             stuImageRequestInfo;            // image find condition
    int                                        nRectNum;                       // valid feature box
    NET_RECT                                   stuRect[4];                     // feature box rect
    
    // image binary data
    char                                       *pBuffer;                       // Buffer address
    int                                        nBufferLen;                     // Buffer data length        
}NET_IN_STARTFIND_OBJECTSTRUCTLIZE;

// CLIENT_StartFindObjectStructlize 
typedef struct tagNET_OUT_STARTFIND_OBJECTSTRUCTLIZE
{
    DWORD               dwSize;
    int                 nTotalCount;                   // Record number of returns that match the query criteria 
    
    LLONG               lFindHandle;                   // Query handle
    int                 nToken;                        // The search token received
}NET_OUT_STARTFIND_OBJECTSTRUCTLIZE;



// CLIENT_DoFindObjectStructlize input parameter
typedef struct tagNET_IN_DOFIND_OBJECTSTRUCTLIZE
{
    DWORD                          dwSize;
    LLONG                          lFindHandle;                // Query handle
    int                            nBeginNum;                  // Queries starting serial number,0<=beginNumber<= totalCount-1
    int                            nCount;                     // The current number of records you want to search for
    EM_NEEDED_PIC_RETURN_TYPE      emNeededData;               // needed data type    
}NET_IN_DOFIND_OBJECTSTRUCTLIZE;

// doFind detected object info
typedef struct tagNET_DODBFIND_OBJECT_DETECTED_INFO
{
    int                               nChannelID;                        // channel id
    char                              szObjectType[16];                  // object type, refer to the same field of NET_OBJFILTER_INFO
    char                              szObjectSubType[32];               // object sub type, refer to the same field of NET_OBJFILTER_INFO
    
    DEV_PERSON_RESULT_FEATURE_INFO    stuPersonResult;                   // detected person result
    DEV_VEHICLE_RESULT_FEATURE_INFO   stuVehicleResult;                  // detected vehicle result
    int                               nImageNum;                         // detected image numbers
    DEV_IMAGE_RESULT_FEATURE_INFO     stuImageResults[4];                // detected image result
    BYTE                              byReserved[512];                   // Reserved
} NET_DODBFIND_OBJECT_DETECTED_INFO;

// CLIENT_DoFindObjectStructlize output parameter
typedef struct tagNET_OUT_DOFIND_OBJECTSTRUCTLIZE
{
    DWORD                                  dwSize;
    int                                    nfoundNum;                               // detected found numbers
    int                                    nObjectNum;                              // detected object return numbers
    NET_DODBFIND_OBJECT_DETECTED_INFO      stuObjectinfos[DH_MAX_OBJECT_LIST];      // detected object infos
    
    // image binary data
    char                                   *pBuffer;                                // Buffer address
    int                                    nBufferLen;                              // Buffer data length 
	int                                    nBufRet;                                 // actually returned len
}NET_OUT_DOFIND_OBJECTSTRUCTLIZE;

// query image by image,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetectObjectStructlize(LLONG lLoginID, const NET_IN_OBJECTSTRUCTLIZE_DETECT_PIC* pstInParam, NET_OUT_OBJECTSTRUCTLIZE_DETECT_PIC *pstOutParam, int nWaitTime );

//subscribe structlize find state,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachObjectStructlizeFindState(LLONG lLoginID, const NET_IN_OBJECTSTRUCTLIZE_FIND_STATE* pstInParam, NET_OUT_OBJECTSTRUCTLIZE_FIND_STATE *pstOutParam, int nWaitTime );

//detach structlize find state,lAttachHandle is the return value of CLIENT_ObjectStructlizeAttachFindState
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachObjectStructlizeFindState(LLONG lAttachHandle);

//start structlize find by condition,user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartFindObjectStructlize(LLONG lLoginID, const NET_IN_STARTFIND_OBJECTSTRUCTLIZE* pstInParam, NET_OUT_STARTFIND_OBJECTSTRUCTLIZE *pstOutParam, int nWaitTime );

// search object structlize result:nFilecount: need search item,  return value is media file item  return value<nFilecount then corresponding period file search complete(search max of 20 records each time)
// user malloc and free (pstInParam's and pstOutParam's) memory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoFindObjectStructlize(const NET_IN_DOFIND_OBJECTSTRUCTLIZE* pstInParam, NET_OUT_DOFIND_OBJECTSTRUCTLIZE *pstOutParam, int nWaitTime );

// stop structlize find by findhanle
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindObjectStructlize(LLONG lFindHandle);

// CLIENT_GetSubModuleInfo interface input parameter
typedef struct tagNET_IN_GET_SUBMODULES_INFO
{
    DWORD                       dwSize;    
}NET_IN_GET_SUBMODULES_INFO;

// SubModule state
typedef enum tagEM_STATE_SUBMODULE
{
    EM_STATE_SUBMODULES_UNKNOWN,
    EM_STATE_SUBMODULES_NORMAL,                  // normal
    EM_STATE_SUBMODULES_EXCEPTION,               // abnormal
}EM_STATE_SUBMODULE;

// SubModule info 
typedef struct tagNET_SUBMODULES_INFO 
{
    char                        szModuleName[DH_COMMON_STRING_32];      // submule name
    char                        szHardwareVersion[DH_COMMON_STRING_64]; // hardware version
    char                        szSoftwareVersion[DH_COMMON_STRING_64]; // software version
    EM_STATE_SUBMODULE          emState;                                // module state    
    BYTE                        byReserve[512];             
}NET_SUBMODULES_INFO;

// CLIENT_GetSubModuleInfo interface input parameter
typedef struct tagNET_OUT_GET_SUBMODULES_INFO
{
    DWORD                       dwSize;
    int                         nRetNum;                                // return number
    NET_SUBMODULES_INFO         stuSubModuleInfo[MAX_SUBMODULE_NUM];    // submodule info                 
}NET_OUT_GET_SUBMODULES_INFO;

// Get Submodule info
CLIENT_NET_API  BOOL  CALL_METHOD  CLIENT_GetSubModuleInfo(LLONG lLoginID, const NET_IN_GET_SUBMODULES_INFO* pstInParam, NET_OUT_GET_SUBMODULES_INFO* pstOutParam, int nWaitTime);

// CLIENT_GetSoftwareVersion input parameter
typedef struct tagNET_IN_GET_SOFTWAREVERSION_INFO
{
	DWORD                       dwSize;                                 // struct size
}NET_IN_GET_SOFTWAREVERSION_INFO;

// CLIENT_GetSoftwareVersion output parameter
typedef struct tagNET_OUT_GET_SOFTWAREVERSION_INFO
{
	DWORD                       dwSize;                                 // struct size
	char                        szVersion[DH_COMMON_STRING_64];         // software version
	NET_TIME                    stuBuildDate;                           // version build date,exact to the second
	char                        szWebVersion[DH_COMMON_STRING_16];      // web version info
	char                        szSecurityVersion[DH_COMMON_STRING_64]; // security baseline version
}NET_OUT_GET_SOFTWAREVERSION_INFO;

// Get Software Version
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSoftwareVersion(LLONG lLoginID, const NET_IN_GET_SOFTWAREVERSION_INFO* pstInParam, NET_OUT_GET_SOFTWAREVERSION_INFO* pstOutParam, int nWaitTime);

// CLIENT_GetDeviceType input parameter
typedef struct tagNET_IN_GET_DEVICETYPE_INFO
{
	DWORD                       dwSize;                                 // struct size
}NET_IN_GET_DEVICETYPE_INFO;

// CLIENT_GetDeviceType output parameter
typedef struct tagNET_OUT_GET_DEVICETYPE_INFO
{
	DWORD                       dwSize;                                 // struct size
	char                        szType[DH_COMMON_STRING_32];            // Device Type, the field is discarded
    char                        szTypeEx[DH_COMMON_STRING_256];            // Device Type, extending device type suggests using the field
}NET_OUT_GET_DEVICETYPE_INFO;

// Get Device Type(not the true type of the device)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDeviceType(LLONG lLoginID, const NET_IN_GET_DEVICETYPE_INFO* pstInParam, NET_OUT_GET_DEVICETYPE_INFO* pstOutParam, int nWaitTime);

//requires the granularity of the statistics returned
typedef enum tagEM_STATIS_GRANULARITY
{
	EM_STATIS_GRANULARITY_UNKNOWN,					// unknown mode
	EM_STATIS_GRANULARITY_BY_HOUR,					// by hour
	EM_STATIS_GRANULARITY_BY_DAY,					// by day
	EM_STATIS_GRANULARITY_BY_MONTH,					// by month
}EM_STATIS_GRANULARITY;
//CLIENT_StartFindExternalSensor interface input parameter
typedef struct tagNET_IN_STARTFIND_EXTERNALSENSOR
{
	DWORD						dwSize;
	NET_TIME					stStartTime;				// start time
	NET_TIME					stEndTime;					// end time
	EM_STATIS_GRANULARITY		emGranularity;				// requires the granularity of the statistics returned"Hour"/"Day"/"Month"
	UINT						nVideoChannel;				// video channel numberDVR/NVR docking required, monocular IPC can not fill or fill 0
	UINT						nIndex;						// external sensor channel number
	UINT						nRecordHour;				// sample time point, Unit:Hour, range:[0,23],"szGranularity" is "Day" or "Month"

}NET_IN_STARTFIND_EXTERNALSENSOR;

// CLIENT_StartFindExternalSensor interface output parameter
typedef struct tagNET_OUT_STARTFIND_EXTERNALSENSOR
{
	DWORD				dwSize;
	UINT				nToken;											// query token
	UINT				nTotalCount;									// the total number of items that meet the query
}NET_OUT_STARTFIND_EXTERNALSENSOR;

// start querying exteranl sensor data
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartFindExternalSensor(LLONG lLoginID, const NET_IN_STARTFIND_EXTERNALSENSOR* pstInParam, NET_OUT_STARTFIND_EXTERNALSENSOR* pstOutParam, int nWaitTime);

// CLIENT_DoFindExternalSensor interface input paramter
typedef struct tagNET_IN_DOFIND_EXTERNALSENSOR
{
	DWORD				dwSize;
	UINT				nToken;											// query token
	UINT				nBegin;											// query the start sequence numbersaid from begintake nCount to return
	UINT				nCount;											// the number of queries per query
}NET_IN_DOFIND_EXTERNALSENSOR;

typedef struct tagNET_FIND_EXTERNALSENSOR_INFO
{
	UINT				nVideoChannel;									// video channle 
	UINT				nIndex;											// external sensor channel
	NET_TIME			stRecordTime;									// external sensor data storage time
	double				dbData;											// external sensot data 
	BYTE				byReserve[1024];								// Reserved
}NET_FIND_EXTERNALSENSOR_INFO;

// CLIENT_DoFindExternalSensor interface input parameter
typedef struct tagNET_OUT_DOFIND_EXTERNALSENSOR
{
	DWORD								dwSize;
	UINT								nFound;							// the number of inquiries
	UINT								nMazNum;						// number of queries
	NET_FIND_EXTERNALSENSOR_INFO*		pstuInfo;						// external sensor data query time,
}NET_OUT_DOFIND_EXTERNALSENSOR;

// obtain external sensor data that matches the query criteria
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoFindExternalSensor(LLONG lFindHandle, const NET_IN_DOFIND_EXTERNALSENSOR* pstInParam, NET_OUT_DOFIND_EXTERNALSENSOR* pstOutParam, int nWaitTime);

// stop querying external sensor data
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindExternalSensor(LLONG lFindHandle);

typedef struct tagNET_CFG_TRACKBOX
{
	int				nVideoChannel;				// video channel
	BOOL			bTargetBox;					// show target box
	BOOL			bTrackBox;					// show track box
	BOOL			bTargetNumber;				// show target number
	BYTE			byReserved[1024];			// Reserved
}NET_CFG_TRACKBOX;

typedef struct tagNET_IN_GET_TRACKBOX
{
	DWORD			dwSize;
	int				nVideoChannel;				// video channel
}NET_IN_GET_TRACKBOX;

// Get the tracking box display configuration

typedef struct tagNET_OUT_GET_TRACKBOX
{
	DWORD				dwSize;
	NET_CFG_TRACKBOX	stuGetTrackBox;
}NET_OUT_GET_TRACKBOX;

// Get the tracking box display configuration
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetTrackBox(LLONG lLoginID, const NET_IN_GET_TRACKBOX* pstInParam, NET_OUT_GET_TRACKBOX *pstOutParam, int nWaitTime);

typedef struct tagNET_IN_SET_TRACKBOX
{
	DWORD				dwSize;
	NET_CFG_TRACKBOX	stuSetTrackBox;
}NET_IN_SET_TRACKBOX;

typedef struct tagNET_OUT_SET_TRACKBOX
{
	DWORD			dwSize;
}NET_OUT_SET_TRACKBOX;

// Set the tracking box display configuration
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetTrackBox(LLONG lLoginID, const NET_IN_SET_TRACKBOX* pstInParam, NET_OUT_SET_TRACKBOX *pstOutParam, int nWaitTime);

// Track Mode
typedef enum tagEM_TRACK_MODE
{
	EM_TRACK_MODE_UNKNOWN = -1,						// Unknown mode
	EM_TRACK_MODE_AUTO,								// Automatic tracking
	EM_TRACK_MODE_SINGLE,							// Single target tracking
	EM_TRACK_MODE_MANUAL,							// Manual control
	EM_TRACK_MODE_ALARM								// Alarm tracking
}EM_TRACK_MODE;

typedef struct tagNET_CFG_TRACKMODE
{
	int					nVideoChannel;				// video channel
	EM_TRACK_MODE		emTrackMode;				// Track mode
	BYTE				byReserved[1024];			// Reserved
}NET_CFG_TRACKMODE;

typedef struct tagNET_IN_GET_TRACKMODE
{
	DWORD				dwSize;
	int					nVideoChannel;				// video channel
}NET_IN_GET_TRACKMODE;

typedef struct tagNET_OUT_GET_TRACKMODE
{
	DWORD				dwSize;
	NET_CFG_TRACKMODE	stuGetTrackMode;
}NET_OUT_GET_TRACKMODE;

// Get the tracking mode
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetTrackMode(LLONG lLoginID, const NET_IN_GET_TRACKMODE* pstInParam, NET_OUT_GET_TRACKMODE *pstOutParam, int nWaitTime);

typedef struct tagNET_IN_SET_TRACKMODE
{
	DWORD				dwSize;
	NET_CFG_TRACKMODE	stuSetTrackMode;
}NET_IN_SET_TRACKMODE;

typedef struct tagNET_OUT_SET_TRACKMODE
{
	DWORD			dwSize;
}NET_OUT_SET_TRACKMODE;

// Set the tracking mode
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetTrackMode(LLONG lLoginID, const NET_IN_SET_TRACKMODE* pstInParam, NET_OUT_SET_TRACKMODE *pstOutParam, int nWaitTime);

typedef struct tagNET_CFG_LINKPOS
{
	int				nVideoChannel;					// video channel
	char			szBallip[DH_COMMON_STRING_64];	// Linkage ball machine IP address, can be ignored
	unsigned short	nX;								// mouse click tracker video nx coordinate normalized value or mouse frame select rectangel center, ranges: [0, 8192)
	unsigned short	nY;								// mouse click tracker video ny coordinate normalized value or mouse frame select rectangel center, ranges: [0, 8192)
	float			fZoom;							// fZoom is negative for click linkage, only linkage unchanged times. Greater than or equal to 0 means that box selection linkages
	BYTE			byReserved[1024];				// Reserved
}NET_CFG_LINKPOS;

typedef struct tagNET_IN_SET_LINKPOS
{
	DWORD				dwSize;
	NET_CFG_LINKPOS		stuSetLinkPos; 
}NET_IN_SET_LINKPOS;

typedef struct tagNET_OUT_SET_LINKPOS
{
	DWORD			dwSize;
}NET_OUT_SET_LINKPOS;

// Click the linkage and box selection linkage
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetLinkPos(LLONG lLoginID, const NET_IN_SET_LINKPOS* pstInParam, NET_OUT_SET_LINKPOS *pstOutParam, int nWaitTime);
// +++++++++++++++++++++++++++++++++++++++++++++++++++++Clound storage service related interface+++++++++++++++++++++++++++++++++++++++++++

// bucket name info
typedef struct tagNET_BUCKET_NAME_INFO
{
    char szName[DH_COMMON_STRING_64];                       // name
    BYTE byReserved[256];                                   // reserved
}NET_BUCKET_NAME_INFO;

// the input pararm of find bucket name info
typedef struct tagNET_IN_FIND_BUCKET_NAME
{
    DWORD dwSize;                                           // struct size
    UINT nOffset;                                           // offset
    UINT nCount;                                            // count of bucket name to find    
}NET_IN_FIND_BUCKET_NAME;

// the output pararm of find bucket name info
typedef struct tagNET_OUT_FIND_BUCKET_NAME
{
    DWORD dwSize;                                           // struct size
    UINT nTotalCount;                                       // the total bucket name count
    UINT nFindCount;                                        // the result count of find
    NET_BUCKET_NAME_INFO* pBucketName;                      // the buffer for bucket name
    UINT nNameCount;                                        // the buffer count  
}NET_OUT_FIND_BUCKET_NAME;

// the file name info in someone bucket
typedef struct tagNET_BUCKET_FILE_NAME_INFO
{
    char szName[DH_COMMON_STRING_1024];                     // file name
    BYTE byReserved[256];                                   // reserved
}NET_BUCKET_FILE_NAME_INFO;

// the input param of find the file name info in someone bucket
typedef struct tagNET_IN_FIND_BUCKET_FILE_NAME
{
    DWORD dwSize;                                           // struct size    
    UINT nOffset;                                           // offset
    UINT nCount;                                            // count of file to find
    char szBucketName[DH_COMMON_STRING_64];                 // the name of bucket    
}NET_IN_FIND_BUCKET_FILE_NAME;

// the output param of find the file name info in someone bucket
typedef struct tagNET_OUT_FIND_BUCKET_FILE_NAME
{
    DWORD dwSize;                                           // struct size
    UINT nTotalCount;                                       // the total file count
    UINT nFindCount;                                        // the result num of find
    NET_BUCKET_FILE_NAME_INFO* pFileName;                   // the buffer fo file name info
    UINT nFileCount;                                        // the buffer count
}NET_OUT_FIND_BUCKET_FILE_NAME;

// find the bucket name info in the efs
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FindBucketName(LLONG lLoginID, const NET_IN_FIND_BUCKET_NAME* pstInParam, NET_OUT_FIND_BUCKET_NAME *pstOutParam, int nWaitTime );

// find the file name info by bucket name
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FindBucketFileName(LLONG lLoginID, const NET_IN_FIND_BUCKET_FILE_NAME* pstInParam, NET_OUT_FIND_BUCKET_FILE_NAME *pstOutParam, int nWaitTime );

// +++++++++++++++++++++++++++++++++++++++++++++++++++++EFS Interface+++++++++++++++++++++++++++++++++++++++++++

// +++++++++++++++++++++++++++++++++++++++++++++++++++++voice broadcast interface+++++++++++++++++++++++++++++++++++++++++++
// voice broadcast callback function original shape
typedef void (CALLBACK *pfAudioBroadcastDataCallBack)(LLONG lSpeakHandle, char *pDataBuf, DWORD dwBufSize, int nToken, LDWORD dwUser);

// voice broadcast input parameters for the specified channels
typedef struct tagNET_IN_START_CHANNEL_INFO
{
	DWORD							dwSize;
	int 							nChannelCount;			// count of the specified channels
	int								nChannel[32];			// the list of the specified channels
	pfAudioBroadcastDataCallBack 	pfcb;					// voice broadcast callback function
	LDWORD 							dwUser;					// user data
} NET_IN_START_CHANNEL_INFO;

// voice broad cast output parameters for the specified channels
typedef struct tagNET_OUT_START_CHANNEL_INFO
{
	DWORD					dwSize;
	int						nToken;					// broadcast token
	int						nFrequency;				// audio sampling frequency
	int						nDepth;					// audio sampling depth
	DH_TALK_CODING_TYPE		emCompressionType;		// audio compression type
} NET_OUT_START_CHANNEL_INFO;

// the input parameters of CLIENT_TalkChannelSendData
typedef struct tagNET_TALK_CHANNEL_SENDDATA_IN
{
	DWORD					dwSize;
	char 			   	   *pSendBuf;		// audio data to be sent
	int 					nSendBufLen;	// the length of the audio data to be sent
} NET_TALK_CHANNEL_SENDDATA_IN;

// the output parameters of CLIENT_TalkChannelSendData
typedef struct tagNET_TALK_CHANNEL_SENDDATA_OUT
{
	DWORD					dwSize;
} NET_TALK_CHANNEL_SENDDATA_OUT;

// void broadcast on the specified channels
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartTalkChannel(LLONG lLoginID, const NET_IN_START_CHANNEL_INFO *pstInParam, NET_OUT_START_CHANNEL_INFO *pstOutParam, int nWaitTime);

// send voice data to the specified channels
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_TalkChannelSendData(LLONG lSpeakHandle, const NET_TALK_CHANNEL_SENDDATA_IN *pstInParam, NET_TALK_CHANNEL_SENDDATA_OUT *pstOutParam, int nWaitTime);

// stop voice broadcast
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_StopTalkChannel(LLONG lSpeakHandle);
// +++++++++++++++++++++++++++++++++++++++++++++++++++++voice broadcast interfaces+++++++++++++++++++++++++++++++++++++++++++

// the input parameters of CLIENT_InitDevAccount
typedef struct tagNET_IN_INIT_DEVICE_ACCOUNT
{
	DWORD					dwSize;										// struct size:assignment when init the struct
	char					szMac[DH_MACADDR_LEN];						// mac addr	
	char					szUserName[MAX_USER_NAME_LEN];				// user name
	char					szPwd[MAX_PWD_LEN];							// password
	char					szCellPhone[MAX_CELL_PHONE_NUMBER_LEN];		// cellphone
	char					szMail[MAX_MAIL_LEN];						// mail addr
	BYTE					byInitStatus;								// this field already abandoned
	BYTE					byPwdResetWay;								// the way supported for reset password:byPwdResetWay value of CLIENT_StartSearchDevices's , CLIENT_SearchDevicesByIPs's callback function and CLIENT_SearchDevices
																		// the meaning of this parameter refers to DEVICE_NET_INFO_EX, the value must be same as byPwdResetWay returned by CLIENT_StartSearchDevices,CLIENT_SearchDevicesByIPs and CLIENT_SearchDevices
																		// bit0 : 1-support reset password by cellphone, you should set cellphone in szCellPhone if you need to set cellphone
																		// bit1 : 1-support reset password by mail, you should set mail address in szMail if you need to set mail address
	BYTE					byReserved[2];								// reserved
}NET_IN_INIT_DEVICE_ACCOUNT;

// the output parameters of CLIENT_InitDevAccount
typedef struct tagNET_OUT_INIT_DEVICE_ACCOUNT
{
	DWORD					dwSize;// struct size:assignment when init the struct
}NET_OUT_INIT_DEVICE_ACCOUNT;

// init account
CLIENT_NET_API BOOL CALL_METHOD CLIENT_InitDevAccount(const NET_IN_INIT_DEVICE_ACCOUNT* pInitAccountIn, NET_OUT_INIT_DEVICE_ACCOUNT* pInitAccountOut, DWORD dwWaitTime, char* szLocalIp);

// init account by ip
CLIENT_NET_API BOOL CALL_METHOD CLIENT_InitDevAccountByIP(const NET_IN_INIT_DEVICE_ACCOUNT* pInitAccountIn, NET_OUT_INIT_DEVICE_ACCOUNT* pInitAccountOut, DWORD dwWaitTime, const char* szLocalIp,const char* szDeviceIP);

//boot wizard flow input parameters
typedef struct tagNET_IN_INIT_DEVICE_ACCESS
{
	DWORD             dwSize;                       //struct size:assignment when init the struct
	char			  szMac[DH_MACADDR_LEN];	    // mac addr	
	char			  szUserName[MAX_USER_NAME_LEN];// user name
	char			  szPwd[MAX_PWD_LEN];		    // password
	BYTE              byNetAccess;                  // whether enable netaccess:0-not involved, not handled 1-disable 2-enable
	BYTE              byUpgradeCheck;               // whether enable upgradecheck 0-not invloved, not handled 1-disable 2-enable
	BYTE              byReserved[2];                // reserved bytes
	EM_VIDEO_STANDARD emVideoStandard;				// Video Standard
}NET_IN_INIT_DEVICE_ACCESS;

//boot wizard flow ouput parameters
typedef struct tagNET_OUT_INIT_DEVICE_ACCESS
{
	DWORD             dwSize;                   // struct size:assignment when init the struct
}NET_OUT_INIT_DEVICE_ACCESS;

//boot wizard flow, include function netaccess, upgradecheck 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_InitDevAccess(const NET_IN_INIT_DEVICE_ACCESS* pInitAccessIn, NET_OUT_INIT_DEVICE_ACCESS* pInitAccessOut, DWORD dwWaitTime, char* szLocalIp);

// the input parameters of CLIENT_GetDescriptionForResetPwd
typedef struct tagNET_IN_DESCRIPTION_FOR_RESET_PWD
{
	DWORD					dwSize;								// struct size:assignment when init the struct
	char					szMac[DH_MACADDR_LEN];				// mac addr
	char					szUserName[MAX_USER_NAME_LEN];		// user name	
	BYTE					byInitStatus;						// init status:byInitStatus value of CLIENT_StartSearchDevices's callback functionCLIENT_SearchDevicesCLIENT_SearchDevicesByIPs
	BYTE					byReserved[3];						// reserved
}NET_IN_DESCRIPTION_FOR_RESET_PWD;

// the output parameters of CLIENT_GetDescriptionForResetPwd
typedef struct tagNET_OUT_DESCRIPTION_FOR_RESET_PWD
{
	DWORD			dwSize;										// struct size:assignment when init the struct
	char			szCellPhone[MAX_CELL_PHONE_NUMBER_LEN];		// cellphone
	char			szMailAddr[MAX_MAIL_LEN];					// mac addr
	char*			pQrCode;									// QR code:user malloc and free
	unsigned int	nQrCodeLen;									// QR code len user set(360 is enough for current)
	unsigned int    nQrCodeLenRet;								// QR code len device returns
}NET_OUT_DESCRIPTION_FOR_RESET_PWD;

// get description info for reset password
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDescriptionForResetPwd(const NET_IN_DESCRIPTION_FOR_RESET_PWD* pDescriptionIn, NET_OUT_DESCRIPTION_FOR_RESET_PWD* pDescriptionOut, DWORD dwWaitTime, char* szLocalIp);

// the input parameters of CLIENT_ResetPwd
typedef struct tagNET_IN_RESET_PWD
{
	DWORD					dwSize;								// struct size:assignment when init the struct
	char					szMac[DH_MACADDR_LEN];				// mac addr	
	char					szUserName[MAX_USER_NAME_LEN];		// user name
	char					szPwd[MAX_PWD_LEN];					// pass word
	char					szSecurity[MAX_SECURITY_CODE_LEN];	// security code
	BYTE					byInitStaus;						// init status:byInitStatus value of CLIENT_StartSearchDevices's callback functionCLIENT_SearchDevicesCLIENT_SearchDevicesByIPs
	BYTE					byPwdResetWay;						// the way supported for reset password:byPwdResetWay value of CLIENT_StartSearchDevices's callback functionCLIENT_SearchDevicesCLIENT_SearchDevicesByIPs
    BYTE					byReserved[2];						// reserved					
    char                    szContact[MAX_CONTACT_LEN];         // phone number of receiving security code, if bSetContact is TRUE, it as reserve cellphone
    BOOL                    bSetContact;                        // set as reserve cellphone, TRUE: agree; FALSE:disagree
}NET_IN_RESET_PWD;

// the output parameters of CLIENT_ResetPwd
typedef struct tagNET_OUT_RESET_PWD
{
	DWORD					dwSize;// struct size:assignment when init the struct
}NET_OUT_RESET_PWD;

// reset password 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ResetPwd(const NET_IN_RESET_PWD* pResetPwdIn, NET_OUT_RESET_PWD* pResetPwdOut, DWORD dwWaitTime, char* szLocalIp);

// account type
typedef enum tagEM_ACCOUNT_TYPE
{
    EM_ACCOUNT_TYPE_UNKNOWN,                                    // unknown
    EM_ACCOUNT_TYPE_SDK,                                        // sdk account
    EM_ACCOUNT_TYPE_WEB,                                        // web account
}EM_ACCOUNT_TYPE;

// input param of init account
typedef struct tagNET_IN_INIT_ACCOUNT
{
    DWORD					dwSize;								// struct size    
    char					szUser[MAX_USER_NAME_LEN];		    // user
    char					szPwd[MAX_PWD_LEN];					// password
    char                    szMac[DH_MACADDR_LEN];              // mac addr
    EM_ACCOUNT_TYPE         emAccountType;                      // account type
}NET_IN_INIT_ACCOUNT;

// output param of init account
typedef struct tagNET_OUT_INIT_ACCOUNT
{
    DWORD               dwSize;								    // struct size  		
}NET_OUT_INIT_ACCOUNT;

// input param of reset web account
typedef struct tagNET_IN_REST_WEB_PWD
{
    DWORD					dwSize;								// struct size  
    char					szWebUser[MAX_USER_NAME_LEN];		// web user
    char					szWebPwd[MAX_PWD_LEN];			    // web password
}NET_IN_REST_WEB_PWD;

// output param of reset web account
typedef struct tagNET_OUT_REST_WEB_PWD
{
    DWORD               dwSize;								    // struct size	
}NET_OUT_REST_WEB_PWD;

// init account
CLIENT_NET_API BOOL CALL_METHOD CLIENT_InitAccount(const NET_IN_INIT_ACCOUNT* pInitAccountIn, NET_OUT_INIT_ACCOUNT* pInitAccountOut, int nWaitTime, char* szLocalIp);

// interface of init account by ip
CLIENT_NET_API BOOL CALL_METHOD CLIENT_InitAccountByIP( const NET_IN_INIT_ACCOUNT* pInitAccountIn, NET_OUT_INIT_ACCOUNT* pInitAccountOut, int nWaitTime, char* szLocalIp, const char* szDeviceIP);

// reset web account
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ResetWebPwd(LLONG lLoginID,const NET_IN_REST_WEB_PWD* pstInParam, NET_OUT_REST_WEB_PWD* pstOutParam, int nWaitTime);

// the input parameters of CLIENT_CheckAuthCode
typedef struct tagNET_IN_CHECK_AUTHCODE
{
	DWORD					dwSize;									// struct size:assignment when init the struct
	char					szMac[DH_MACADDR_LEN];					// mac addr
	char					szSecurity[MAX_SECURITY_CODE_LEN];		// security code
    char                    szContact[MAX_CONTACT_LEN];             // phone number of receiving security code
}NET_IN_CHECK_AUTHCODE;

// the output parameters of CLIENT_CheckAuthCode
typedef struct tagNET_OUT_CHECK_AUTHCODE
{
	DWORD					dwSize;// struct size:assignment when init the struct
}NET_OUT_CHECK_AUTHCODE;

// check security code
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CheckAuthCode(const NET_IN_CHECK_AUTHCODE* pCheckAuthCodeIn, NET_OUT_CHECK_AUTHCODE* pCheckAuthCodeOut, DWORD dwWaitTime, char* szLocalIp);
// input parameters of CLIENT_SetEverest360MediaMode
typedef struct tagNET_IN_SET_EVEREST360_MEDIAMODE
{
    DWORD					dwSize;				
    UINT                    nMediaMode;                             // Media Mode,0:Snap,1:Record,2:Live
}NET_IN_SET_EVEREST360_MEDIAMODE;

// Output parameters of CLIENT_SetEverest360MediaMode
typedef struct tagNET_OUT_SET_EVEREST360_MEDIAMODE
{
    DWORD					dwSize;				
}NET_OUT_SET_EVEREST360_MEDIAMODE;

// Set MediaMode of Everest360 Sports Camera
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetEverest360MediaMode(LLONG lLoginID, const NET_IN_SET_EVEREST360_MEDIAMODE *pstInParam, NET_OUT_SET_EVEREST360_MEDIAMODE *pstOutParam, int nWaitTime);

// the input parameters of CLIENT_GetPwdSpecification
typedef struct tagNET_IN_PWD_SPECI
{
	DWORD		dwSize;					// struct size
	char		szMac[DH_MACADDR_LEN];	// mac address
}NET_IN_PWD_SPECI;

// the output parameters of CLIENT_GetPwdSpecification
typedef struct tagNET_OUT_PWD_SPECI
{
	DWORD	dwSize;										// struct size
	unsigned int	nMaxPwdLen;							// max passwd len
	unsigned int	nMinPwdLen;							// min passwd len	
	char	szType[MAX_PWD_BASIC_CHARS_ARRAY_LEN];		// basic chars supportedNumber,Lower case,Capital. such as :"Number,Lower,Upper"
	char	szCharList[MAX_PWD_SPEC_CHARS_ARRAY_LEN];	// special chars supported, as"~!@#$%^" 
	int		nCombine;									// chars combine style: 0-no special request, 1-special char must be included, 2-at least two style included (number, capital, lower case, special char)
}NET_OUT_PWD_SPECI;

// get passwd specification
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetPwdSpecification(const NET_IN_PWD_SPECI* pPwdSpeciIn, NET_OUT_PWD_SPECI* pPwdSpeciOut, DWORD dwWaitTime, char* szLocalIp);

// the input parameters of CLIENT_SetLowRateWPANPower
typedef struct tagNET_IN_SET_LOWRATEWPAN_POWER
{
    DWORD			dwSize;										// struct size
    int             nPower;                                     // power
    char            szSmartLockNum[MAX_COMMON_STRING_32];       // serial Number
}NET_IN_SET_LOWRATEWPAN_POWER;

// the output parameters of CLIENT_SetLowRateWPANPower
typedef struct tagNET_OUT_SET_LOWRATEWPAN_POWER
{
    DWORD			dwSize;										// struct size   
}NET_OUT_SET_LOWRATEWPAN_POWER;

// set power of LowRateWPAN
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetLowRateWPANPower(LLONG lLoginID, const NET_IN_SET_LOWRATEWPAN_POWER *pstInParam, NET_OUT_SET_LOWRATEWPAN_POWER *pstOutParam, int nWaitTime);

// operate type of accesscontroller
typedef enum tagNET_EM_ACCESS_CTL_MANAGER
{
    NET_EM_ACCESS_CTL_MANAGER_ADDDEVICE,                        // add accesssubcontroller, Corresponding to pstInParam = NET_IN_ACCESS_CTL_MANAGER_ADDDEVICE, pstOutParam = NET_OUT_ACCESS_CTL_MANAGER_ADDDEVICE
    NET_EM_ACCESS_CTL_MANAGER_MODIFYDEVICE,                     // modify accesssubcontroller, Corresponding to pstInParam = NET_IN_ACCESS_CTL_MANAGER_MODIFYDEVICE, pstOutParam = NET_OUT_ACCESS_CTL_MANAGER_MODIFYDEVICE
    NET_EM_ACCESS_CTL_MANAGER_REMOVEDEVICE,                     // remove accesssubcontroller, Corresponding to pstInParam = NET_IN_ACCESS_CTL_MANAGER_REMOVEDEVICE, pstOutParam = NET_OUT_ACCESS_CTL_MANAGER_REMOVEDEVICE
    NET_EM_ACCESS_CTL_GETSUBCONTROLLER_INFO,                    // get accesssubcontroller info, Corresponding to pstInParam = NET_IN_GET_SUB_CONTROLLER_INFO, pstOutParam = NET_OUT_GET_SUB_CONTROLLER_INFO
    NET_EM_ACCESS_CTL_GETSUBCONTROLLER_STATE,                   // get accesssubcontroller state, Corresponding to pstInParam = NET_IN_GET_SUB_CONTROLLER_STATE, pstOutParam = NET_OUT_GET_SUB_CONTROLLER_STATE
    NET_EM_ACCESS_CTL_SET_REPEAT_ENTERROUTE,                    // set repeat engterroute, Corresponding to pstInparam = NET_IN_SET_REPEAT_ENTERROUTE, pstOutParam = NET_OUT_SET_REPEAT_ENTERROUTE
    NET_EM_ACCESS_CTL_GET_REPEAT_ENTERROUTE,                    // get repeat enterroute, Corresponding to pstInparam = NET_IN_GET_REPEAT_ENTERROUTE, pstOutParam = NET_OUT_GET_REPEAT_ENTERROUTE
    NET_EM_ACCESS_CTL_SET_ABLOCK_ROUTE,                         // set ABLock route, Corresponding to pstInparam = NET_IN_SET_ABLOCK_ROUTE, pstOutParam = NET_OUT_SET_ABLOCK_ROUTE
    NET_EM_ACCESS_CTL_GET_ABLOCK_ROUTE,                         // get ABLock route, Corresponding to pstInparam = NET_IN_GET_ABLOCK_ROUTE, pstOutParam = NET_OUT_GET_ABLOCK_ROUTE     
    NET_EM_ACCESS_CTL_GET_LOGSTATUS,                            // get log synchronize status, Corresponding to pstInparam = NET_IN_GET_LOGSTATUS, pstOutParam = NET_OUT_GET_LOGSTATUS     
    NET_EM_ACCESS_CTL_SYNCHRO_OFFLINE_LOG,                      // synchro offline log, Corresponding to pstInparam = NET_IN_SYNCHRO_OFFLINE_LOG, pstOutParam = NET_OUT_SYNCHRO_OFFLINE_LOG 
    NET_EM_ACCESS_CTL_SYNCHRO_TIME,                             // synchro subController time,Corresponding to pstInparam = NET_IN_SYNCHRO_CONTROLLER_TIME, pstOutParam = NET_OUT_SYNCHRO_CONTROLLER_TIME 
    NET_EM_ACCESS_CTL_SET_QRCODEDECODE_INFO,                    // set QRcode decode info, Corresponding to pstInparam = NET_IN_SET_QRCODE_DECODE_INFO, pstOutParam = NET_OUT_SET_QRCODE_DECODE_INFO 
}NET_EM_ACCESS_CTL_MANAGER;

// in parameter of add device
typedef struct tagNET_IN_ACCESS_CTL_MANAGER_ADDDEVICE
{
    DWORD           dwSize;
    int             nSubControllerID;                           // accesssubcontroller ID, range: 1~255
    char            szSubControllerName[MAX_COMMON_STRING_128]; // accesssubcontroller name
}NET_IN_ACCESS_CTL_MANAGER_ADDDEVICE;

// out parameter of add device
typedef struct tagNET_OUT_ACCESS_CTL_MANAGER_ADDDEVICE
{
    DWORD           dwSize;   
    int             nErrorCode;                                 // errorcode 0-success, 1-add repeat,2-add fullest,3-other fail
}NET_OUT_ACCESS_CTL_MANAGER_ADDDEVICE;

// in parameter of modify device
typedef struct tagNET_IN_ACCESS_CTL_MANAGER_MODIFYDEVICE
{
    DWORD           dwSize;
    int             nSubControllerID;                           // accesssubcontroller ID, range: 1~255, 0:local
    char            szSubControllerName[MAX_COMMON_STRING_128]; // accesssubcontroller name
}NET_IN_ACCESS_CTL_MANAGER_MODIFYDEVICE;

// out parameter of modify device
typedef struct tagNET_OUT_ACCESS_CTL_MANAGER_MODIFYDEVICE
{
    DWORD           dwSize;
}NET_OUT_ACCESS_CTL_MANAGER_MODIFYDEVICE;

// in parameter of remove device
typedef struct tagNET_IN_ACCESS_CTL_MANAGER_REMOVEDEVICE
{
    DWORD           dwSize;
    int             nSubControllerID[MAX_ACCESSSUBCONTROLLER_NUM]; // accesssubcontroller ID, range: 1~255
    int             nSubControllerNum;                          // accesssubcontroller count
}NET_IN_ACCESS_CTL_MANAGER_REMOVEDEVICE;

// result of remove device
typedef struct tagNET_REMOVEDEVICE_RESULT
{
    int             nSubControllerID;                           // accesssubcontroller ID
    int             nErrorCode;                                 // result, 0-success,1-fail 2-unallocation
    BYTE            byReserved[128];                            
}NET_REMOVEDEVICE_RESULT;

//  out parameter of remove device
typedef struct tagNET_OUT_ACCESS_CTL_MANAGER_REMOVEDEVICE
{
    DWORD                       dwSize;
    int                         nResultNum;
    NET_REMOVEDEVICE_RESULT     stuResult[MAX_ACCESSSUBCONTROLLER_NUM];     
}NET_OUT_ACCESS_CTL_MANAGER_REMOVEDEVICE;

// in parameter of Get subcontroller info
typedef struct tagNET_IN_GET_SUB_CONTROLLER_INFO
{
    DWORD                       dwSize;
    int                         nSubControllerID[MAX_ACCESSSUBCONTROLLER_NUM];  // accesssubcontroller ID, range:-1~255, -1:Get All,0:Local,1~255:other
    int                         nSubControllerNum;                              // accesssubcontroller number
}NET_IN_GET_SUB_CONTROLLER_INFO;


// property
typedef enum  tagNET_EM_ACCESS_PROPERTY
{
    NET_EM_ACCESS_PROPERTY_UNKNOWN,                                             // unknown
    NET_EM_ACCESS_PROPERTY_BIDIRECT,                                            // bidirect
    NET_EM_ACCESS_PROPERTY_UNIDIRECT,                                           // unidirect
}NET_ACCESS_PROPERTY;

// card reader info
typedef struct tagNET_CARDREAD_INFO 
{
    int                         nDoor;                                          // door num
    int                         nReadNum;                                       // reader count
    char                        szReadID[MAX_ACCESS_READER_NUM][DH_COMMON_STRING_32];                 // reader num
    BYTE                        byReserved[64];  
}NET_CARDREAD_INFO;

// subcontroller info
typedef struct tagNET_SUB_CONTROLLER_INFO 
{
    int                         nSubControllerID;                               // ControllerID, range:0~255,0:local
    char                        szSubControllerName[MAX_COMMON_STRING_128];     // Controller name
    NET_ACCESS_PROPERTY         emProperty;                                     // property
    char                        szDeviceType[MAX_COMMON_STRING_128];            // device type
    char                        szVesion[MAX_COMMON_STRING_128];                // device vesion
    int                         nDoorNum;                                       // door count
    NET_CARDREAD_INFO           stuReaderInfo[MAX_ACCESSDOOR_NUM];              // the card reader of door
    BYTE                        byReserved[128];
}NET_SUB_CONTROLLER_INFO;

// out parameter of Get subcontroller info
typedef struct tagNET_OUT_GET_SUB_CONTROLLER_INFO
{
    DWORD                       dwSize;
    NET_SUB_CONTROLLER_INFO     stuSubControllerInfo[MAX_ACCESSSUBCONTROLLER_NUM];  // controller info
    int                         nRetNum;                                            // controller count
}NET_OUT_GET_SUB_CONTROLLER_INFO;

// in parameter of Get subcontroller state
typedef struct tagNET_IN_GET_SUB_CONTROLLER_STATE
{
    DWORD                       dwSize;
    int                         nSubControllerID[MAX_ACCESSSUBCONTROLLER_NUM];      // accesssubcontroller ID, range:-1~255, -1:Get All,0:Local,1~255:other
    int                         nSubControllerNum;                                  // accesssubcontroller number
}NET_IN_GET_SUB_CONTROLLER_STATE;

// controller state info
typedef struct tagNET_SUB_CONTROLLER_STATE
{
    int                         nSubControllerID;                                   // accesssubcontroller ID
    int                         nState;                                             // 0:off-line 1:online 2:unallocation
	BYTE                        byReserved[128];
}NET_SUB_CONTROLLER_STATE;

// out parameter of Get subcontroller state
typedef struct tagNET_OUT_GET_SUB_CONTROLLER_STATE
{
    DWORD                       dwSize;
    NET_SUB_CONTROLLER_STATE    stuSubControllerState[MAX_ACCESSSUBCONTROLLER_NUM];  // accesssubcontroller state
    int                         nRetNum;                                             // accesssubcontroller count
}NET_OUT_GET_SUB_CONTROLLER_STATE;

// repeat enterroute point info
typedef struct tagNET_POINT_READER_INFO
{
    int                         nReaderNum;                                         // repeat enterroute point num
    char                        szReaderID[MAX_ACCESS_READER_NUM][DH_COMMON_STRING_32]; // reader of repeat enterroute point
    BYTE                        byReserved[128];
}NET_POINT_READER_INFO;

// in parameter of set repaet enter route
typedef struct tagNET_IN_SET_REPEAT_ENTERROUTE
{
    DWORD                       dwSize;
    UINT                        nIndex;                                              // index of route
    int                         nPointNum;                                           // point number of route
    NET_POINT_READER_INFO       stuPointInfo[MAX_ACCESS_POINT_NUM];                  // point info
    int                         nTimeSection;                                        // config of AccessTimeSchedule number, please query dhconfigsdk.h
    BOOL                        bFlag;                                               // enable
    char                        szRouteName[MAX_COMMON_STRING_128];                  // route name
}NET_IN_SET_REPEAT_ENTERROUTE;

// out parameter of set repaet enter route
typedef struct tagNET_OUT_SET_REPEAT_ENTERROUTE
{
    DWORD                       dwSize;
}NET_OUT_SET_REPEAT_ENTERROUTE;

// in parameter of get repaet enter route
typedef struct tagNET_IN_GET_REPEAT_ENTERROUTE
{
    DWORD                       dwSize;
    UINT                        nIndex;                                              // repeat enter route index
}NET_IN_GET_REPEAT_ENTERROUTE;

// out parameter of set repaet enter route
typedef struct tagNET_OUT_GET_REPEAT_ENTERROUTE
{
    DWORD                       dwSize;
    int                         nPointNum;                                           // point count of route
    NET_POINT_READER_INFO       stuPointInfo[MAX_ACCESS_POINT_NUM];                  // point info
    int                         nTimeSection;                                        // config of AccessTimeSchedule number, please query dhconfigsdk.h
    BOOL                        bFlag;                                               // enable
    char                        szRouteName[MAX_COMMON_STRING_128];                  // route name
}NET_OUT_GET_REPEAT_ENTERROUTE;

// AB lock route info
typedef struct tagNET_POINT_DOOR_INFO
{
    int                         nDoorNum;                                           // ABlock door number
    int                         nDoorID[MAX_ACCESSDOOR_NUM];                        // ABlock door id
    BYTE                        byReserved[128];
}NET_POINT_DOOR_INFO;

// in parameter of set ABlock  route
typedef struct tagNET_IN_SET_ABLOCK_ROUTE
{
    DWORD                       dwSize;
    UINT                        nIndex;                                              // ABlock route index
    int                         nPointNum;                                           // point number of ABlock
    NET_POINT_DOOR_INFO         stuPointInfo[MAX_ACCESS_POINT_NUM];                  // point info
    int                         nTimeSection;                                        // config of AccessTimeSchedule number, please query dhconfigsdk.h
    BOOL                        bFlag;                                               // enable
    char                        szRouteName[MAX_COMMON_STRING_128];                  // route name
}NET_IN_SET_ABLOCK_ROUTE;

//  out parameter of get ABlock  route
typedef struct tagNET_OUT_SET_ABLOCK_ROUTE
{
    DWORD                       dwSize;
}NET_OUT_SET_ABLOCK_ROUTE;

// in parameter of get ABlock  route
typedef struct tagNET_IN_GET_ABLOCK_ROUTE
{
    DWORD                       dwSize;
    UINT                        nIndex;                                              // ABlock route index
}NET_IN_GET_ABLOCK_ROUTE;

// out parameter of get ABlock  route
typedef struct tagNET_OUT_GET_ABLOCK_ROUTE
{
    DWORD                       dwSize;
    int                         nPointNum;                                           // point number of ABlock
    NET_POINT_DOOR_INFO         stuPointInfo[MAX_ACCESS_POINT_NUM];                  // point info
    int                         nTimeSection;                                        // config of AccessTimeSchedule number,please query dhconfigsdk.h
    BOOL                        bFlag;                                               // enable
    char                        szRouteName[MAX_COMMON_STRING_128];                  // route name
}NET_OUT_GET_ABLOCK_ROUTE;

// in parameter of get log status
typedef struct tagNET_IN_GET_LOGSTATUS
{
    DWORD                       dwSize;
    int                         nControllerID;                                        // accesssubcontroller ID,range:1 ~255
}NET_IN_GET_LOGSTATUS;

// out parameter of get log status
typedef struct tagNET_OUT_GET_LOGSTATUS
{
    DWORD                       dwSize;
    BOOL                        bsynchronize;                                         // true:synchronizing
}NET_OUT_GET_LOGSTATUS;

// in parameter of synchro offline log
typedef struct tagNET_IN_SYNCHRO_OFFLINE_LOG
{
    DWORD                       dwSize;
    int                         nControllerID;                                        // ControllerID range:0 ~255
}NET_IN_SYNCHRO_OFFLINE_LOG;

// out parameter of synchro offline log
typedef struct tagNET_OUT_SYNCHRO_OFFLINE_LOG
{
    DWORD                       dwSize;
}NET_OUT_SYNCHRO_OFFLINE_LOG;

// in parameter of synchro time
typedef struct tagNET_IN_SYNCHRO_CONTROLLER_TIME
{
    DWORD                       dwSize;
    int                         nSubControllerID[MAX_ACCESSSUBCONTROLLER_NUM];  // accesssubcontroller ID, range:-1~255, -1:all,0:Local,1~255:other
    int                         nSubControllerNum;                              // accesssubcontroller number    
}NET_IN_SYNCHRO_CONTROLLER_TIME;

// out parameter of synchro time
typedef struct tagNET_OUT_SYNCHRO_CONTROLLER_TIME
{
    DWORD                       dwSize;
    int                         nSubControllerID[MAX_ACCESSSUBCONTROLLER_NUM];  // accesssubcontroller info
    int                         nRetNum;                                        // return number of failed, 0: all success    
}NET_OUT_SYNCHRO_CONTROLLER_TIME;

// QRCode cipher
typedef enum tagNET_ENUM_QRCODE_CIPHER
{
	NET_ENUM_QRCODE_CIPHER_UNKNOWN, 
    NET_ENUM_QRCODE_CIPHER_AES256,                                              // AES-256
}NET_ENUM_QRCODE_CIPHER;

// input of Set QRCode decode info
typedef struct tagNET_IN_SET_QRCODE_DECODE_INFO
{
    DWORD                       dwSize;
    NET_ENUM_QRCODE_CIPHER      emCipher;                                       // cipher    
    char                        szKey[33];                                      // key
    BYTE                        byReserved[3];                                  // reserved bytes
}NET_IN_SET_QRCODE_DECODE_INFO;

// output of Set QRCode decode info
typedef struct tagNET_OUT_SET_QRCODE_DECODE_INFO
{
    DWORD                       dwSize;
}NET_OUT_SET_QRCODE_DECODE_INFO;

// Input of set safe level
typedef struct tagNET_IN_SET_SAFE_LEVEL
{
	DWORD 						dwSize;							//struct size
	BYTE						byLevel;						//safe level: 1.safe  2.fire  3.emergency
	BYTE						byReserved[3];					//reserved bytes
}NET_IN_SET_SAFE_LEVEL;

// Output of set safe level
typedef struct tagNET_OUT_SET_SAFE_LEVEL
{
	DWORD						dwSize;
}NET_OUT_SET_SAFE_LEVEL;



// interface of operate AccessControlManager
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateAccessControlManager(LLONG lLoginID, NET_EM_ACCESS_CTL_MANAGER emtype, const void *pstInParam, void *pstOutParam, int nWaitTime);

// the input parameters of CLIENT_SetSmartLockUserName
typedef struct tagNET_IN_SET_SMART_LOCK_USERNAME
{
    DWORD						dwSize;										// struct size
	NET_ACCESS_METHOD			emType;										// open smart lock type
    char						szSerialNumber[MAX_COMMON_STRING_32];       // smart lock serial number									
	char						szUserID[MAX_COMMON_STRING_16];				// user ID
	char						szName[MAX_COMMON_STRING_32];				// modified name
} NET_IN_SET_SMART_LOCK_USERNAME;

// the output parameters of CLIENT_SetSmartLockUserName
typedef struct tagNET_OUT_SET_SMART_LOCK_USERNAME
{
    DWORD						dwSize;										// struct size   
} NET_OUT_SET_SMART_LOCK_USERNAME;

// Modify the user information for smart locks
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetSmartLockUsername(LLONG lLoginID, const NET_IN_SET_SMART_LOCK_USERNAME *pstInParam, NET_OUT_SET_SMART_LOCK_USERNAME *pstOutParam, int nWaitTime);

#define MAX_NUMBER_REGISTER_INFO	32

// // the input parameters of CLIENT_GetSmartLockRegisterInfo (you can get at most32 user info for one time)
typedef struct tagNET_IN_GET_SMART_LOCK_REGISTER_INFO
{
    DWORD			dwSize;										// struct size
    char            szSerialNumber[MAX_COMMON_STRING_32];       // device serial number
	int				nOffset;									// the offset of user list
} NET_IN_GET_SMART_LOCK_REGISTER_INFO;

// user register info
typedef struct tagNET_SMART_LOCK_REGISTER_INFO
{
	NET_ACCESS_METHOD			emType;										// open smart lock type
	char						szUserID[MAX_COMMON_STRING_16];				// user id
	char						szName[MAX_COMMON_STRING_32];				// user name
	BYTE						byReserved[512];							// Reserve
} NET_SMART_LOCK_REGISTER_INFO;

// the output parameters of CLIENT_GetSmartLockRegisterInfo
typedef struct tagNET_OUT_GET_SMART_LOCK_REGISTER_INFO
{
    DWORD							dwSize;						// struct size   
	int								nTotalCount;				// total user number
	int								nReturnCount;				// return user number
	NET_SMART_LOCK_REGISTER_INFO	stuRegisterInfo[MAX_NUMBER_REGISTER_INFO];	// user register info
} NET_OUT_GET_SMART_LOCK_REGISTER_INFO;

// get register info of the user of smart lock  
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSmartLockRegisterInfo(LLONG lLoginID, const NET_IN_GET_SMART_LOCK_REGISTER_INFO *pstInParam, NET_OUT_GET_SMART_LOCK_REGISTER_INFO *pstOutParam, int nWaitTime);

// card info
typedef struct tagNET_SMARTLOCK_CARDINFO
{
    NET_ACCESS_METHOD			    emType;                                     // open type
    int                             nIndex;                                     // user index
    char                            szCardNo[32];                               // card number
    NET_ACCESSCTLCARD_TYPE          emCardType;                                 // card type
    char						    szReserve[512];					            // reserved
}NET_SMARTLOCK_CARDINFO;

// password info
typedef struct tagNET_SMARTLOCK_PWDINFO
{
    NET_ACCESS_METHOD			    emType;                                     // open type
    int                             nIndex;                                     // user index
    char                            szPassword[32];                             // password
    UINT                            dwUseTime;                                  // use time
    char						    szReserve[512];					            // reserved
}NET_SMARTLOCK_PWDINFO;

// fingerprint info
typedef struct tagNET_SMARTLOCK_FPINFO
{
    NET_ACCESS_METHOD			    emType;                                     // open type
    int                             nIndex;                                     // user index
    int                             nFingerprintLen;                            // fingerprint lenth,max len 1.5K
    char*                           pFingerprintData;                           // fingerprint date
    char						    szReserve[512];					            // reserved
}NET_SMARTLOCK_FPINFO;

// input parameters of CLIENT_UpdateSmartLockUser 
typedef struct tagNET_IN_SMARTLOCK_UPDATE_USER_INFO 
{
    DWORD							dwSize;						                // struct size
    char                            szSerialNumber[32];                         // smart lock serial number
    char                            szCredentialHolder[16];                     // Credential Holder(same with the UserID from NET_RECORDSET_ACCESS_CTL_CARD)
    char                            szUserName[32];                             // user name
    NET_TIME                        stuStartTime;                               // start time
    NET_TIME                        stuEndTime;                                 // end time
     char						    szReserve[512];					            // reserved
    int                             nCardInfoNum;                               // cardinfo count
    NET_SMARTLOCK_CARDINFO          stuCardInfo[4];                             // card info
    int                             nPwdInfoNum;                                // password info count
    NET_SMARTLOCK_PWDINFO           stuPwdInfo[4];                              // password info
    int                             nFingerPrintInfoNum;                        // fingerprint info count
    NET_SMARTLOCK_FPINFO            stuFingerPrintInfo[4];                      // fingerprint info
	int								nTaskID;									// Task ID
}NET_IN_SMARTLOCK_UPDATE_USER_INFO;

// output parameters of CLIENT_UpdateSmartLockUser 
typedef struct tagNET_OUT_SMARTLOCK_UPDATE_USER_INFO 
{
    DWORD							dwSize;						                // struct size      
}NET_OUT_SMARTLOCK_UPDATE_USER_INFO;

// interface of add or update user to smartlock 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_UpdateSmartLockUser(LLONG lLoginID, const NET_IN_SMARTLOCK_UPDATE_USER_INFO *pstInParam,NET_OUT_SMARTLOCK_UPDATE_USER_INFO *pstOutParam, int nWaitTime);

// input parameters CLIENT_RemoveSmartLockUser 
typedef struct tagNET_IN_SMARTLOCK_REMOVE_USER_INFO
{
    DWORD							dwSize;						                // struct size      
    char                            szSerialNumber[32];       					// smart lock serial number
    char                            szCredentialHolder[16];   					// Credential Holder(same with the UserID from NET_RECORDSET_ACCESS_CTL_CARD)
    NET_ACCESS_METHOD			    emType;                                     // open type, unknow:all
    int                             nIndex;                                     // index of opendoor method-1:all
	int								nTaskID;									// Task ID
}NET_IN_SMARTLOCK_REMOVE_USER_INFO;

// output parameters of CLIENT_RemoveSmartLockUser 
typedef struct tagNET_OUT_SMARTLOCK_REMOVE_USER_INFO
{
    DWORD							dwSize;						                // struct size
}NET_OUT_SMARTLOCK_REMOVE_USER_INFO;

// interface of remove user to smartlock 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RemoveSmartLockUser(LLONG lLoginID, const NET_IN_SMARTLOCK_REMOVE_USER_INFO *pstInParam, NET_OUT_SMARTLOCK_REMOVE_USER_INFO *pstOutParam, int nWaitTime);

// user info
typedef struct tagMATRIX_CAMERA_USERS_INFO 
{	
	unsigned int				nChannel;					// channel
	char						szUser[MAX_USER_NAME_LEN];	// user name
    char						szPwd[MAX_PWD_LEN];			// passwd
	char						szReserve[512];				// reserved
}MATRIX_CAMERA_USERS_INFO;

// the intput parameter of CLIENT_MatrixGetCameraUsers
typedef struct tagNET_IN_MATRIX_GET_CAMERA_USERS
{
	DWORD						dwSize;						// struct size	
	unsigned int				nStartChannel;				// start channel
	unsigned int				nChannelCount;				// channel num
}NET_IN_MATRIX_GET_CAMERA_USERS;

// the output parameter of CLIENT_MatrixGetCameraUsers
typedef struct tagNET_OUT_MATRIX_GET_CAMERA_USERS
{
	DWORD						dwSize;						// struct size
	MATRIX_CAMERA_USERS_INFO*	pstuUserInfo;				// user info structuser alloc and free memoryequal to sizeof(MATRIX_CAMERA_USERS_INFO)*nChannelCount,nChannelCount is in NET_IN_MATRIX_GET_CAMERA_USERS																
	unsigned int				nChannelCountRet;			// channel num return 
}NET_OUT_MATRIX_GET_CAMERA_USERS;

// get user info of valid display source
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MatrixGetCameraUsers(LLONG lLoginID, const NET_IN_MATRIX_GET_CAMERA_USERS* pInParam, NET_OUT_MATRIX_GET_CAMERA_USERS* pOutParam, DWORD dwWaitTime);

// +++++++++++++++++++++++++++++++++++++++++++++++++++++API for MPT exchange data with NVR+++++++++++++++++++++++++++++++++++++++++++

// MPT state info
typedef struct tagNET_MPT_STATUS
{
    EM_MPT_STATE eState;                                            // MPT state
    char szSerialNumber[DH_COMMON_STRING_32];                       // SN of MPT,it is valid when state is 2 or 3
    BYTE byReserved[256];                                           // reserved
}NET_MPT_STATUS;

// the input param for get the MPT status
typedef struct tagNET_IN_GET_MPT_STATUS
{
    DWORD					dwSize;									// struct size
    UINT                    nOffset;                                // offset of usb slot
    UINT                    nCount;                                 // usb slot num
}NET_IN_GET_MPT_STATUS;

#define MAX_MPT_STATUS_NUM (64)                                     // max num of mpt status info

// the output param for get the MPT status
typedef struct tagNET_OUT_GET_MPT_STATUS
{
    DWORD					dwSize;									// struct size
    UINT                    nTotalUsbNum;                           // total usb slot num
    UINT                    nStatusNum;                             // MPT state num
    NET_MPT_STATUS          stuStatus[MAX_MPT_STATUS_NUM];          // MPT state data
}NET_OUT_GET_MPT_STATUS;

// Get the MPT status
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetMPTStatus(LLONG lLoginID,const NET_IN_GET_MPT_STATUS* pstInParam, NET_OUT_GET_MPT_STATUS* pstOutParam, DWORD dwWaitTime);

//  the type of MPT status
typedef enum tagEM_MPTSTATUS_TYPE
{
	EM_MPTSTATUS_UNKNOWN,			// unknown
	EM_MPTSTATUS_MPTBASE,			// the status of MPT base,  pOutParam = NET_MPTBASE_STATUS_INFO
	EM_MPTSTATUS_EXTCAMERA,			// the status of external camera, pOutParam = NET_EXTCAMERA_STATUS_INFO
	EM_MPTSTATUS_NETCONNECT,		// the type of network connection, pOutParam = NET_NETCONNECT_STATUS_INFO
} EM_MPTSTATUS_TYPE;

// the type of MPT base status
typedef enum tagNEM_MPTBASE_TYPE
{
	NEM_MPTBASE_UNKNOWN,				// unknown
	NEM_MPTBASE_ON,						// ON
	NEM_MPTBASE_OFF,					// OFF
} NEM_MPTBASE_TYPE;

// the type of external camera status
typedef enum tagEM_EXTCAMERA_TYPE
{
	EM_EXTCAMERA_UNKNOWN,				// unkonwn
	EM_EXTCAMERA_NORMAL,				//Normal
	EM_EXTCAMERA_ABNORMAL,				//Abnormal
} EM_EXTCAMERA_TYPE;

// the type of network connection
typedef enum tagEM_NETCONNECT_TYPE
{
	EM_NETCONNECT_UNKNOWN,				// unknown
	EM_NETCONNECT_WIFI,					// WIFI
	EM_NETCONNECT_MOBILE,				// Mobile
	EM_NETCONNECT_CABLE,				// Cable
	EM_NETCONNECT_MPTBASE,				// MptBase
} EM_NETCONNECT_TYPE;

// the info of MPT base
typedef struct tagNET_MPTBASE_STATUS_INFO
{
	DWORD					dwSize;									// the size of this struct(set the value when init)
	NEM_MPTBASE_TYPE		emMptBase;								//  the type of MPT base status
} NET_MPTBASE_STATUS_INFO;

// the info of external camera
typedef struct tagNET_EXTCAMERA_STATUS_INFO
{
	DWORD					dwSize;									// the size of this struct(set the value when init)
	EM_EXTCAMERA_TYPE		emExtCamera;							// the type of external camera status
} NET_EXTCAMERA_STATUS_INFO;

// the info of network connection
typedef struct tagNET_NETCONNECT_STATUS_INFO
{
	DWORD					dwSize;									// the size of this struct(set the value when init)
	EM_NETCONNECT_TYPE		emNetConnect;							// the type of network connection
} NET_NETCONNECT_STATUS_INFO;


// query the MPT status info
CLIENT_NET_API BOOL CALL_METHOD	CLIENT_QueryMPTStatus(LLONG lLoginID, const EM_MPTSTATUS_TYPE emStatusType, void* pstOutParam, DWORD dwWaitTime);


#define MAX_POLICE_ID_NUM 32                                        // max police id num

// the police id info to be written to MPT
typedef struct tagNET_WRITE_POLICE_ID_INFO
{
    int                     nUsbSlot;                                               // usb slot index
    int                     nPoliceIDCount;                                         // police id num                         
    char                    szPoliceID[MAX_POLICE_ID_NUM][DH_COMMON_STRING_32];     // police id data
    BYTE                    byReserved[512];                                        // reserved
}NET_WRITE_POLICE_ID_INFO;

#define MAX_POLICE_ID_INFO_NUM 64                                                   // max police info num

// the input param for write police id info to MPT
typedef struct tagNET_IN_WRITE_POLICE_ID
{
    DWORD					    dwSize;						                        // struct size
    int                         nIDInfoNum;                                         // police id num
    NET_WRITE_POLICE_ID_INFO    stuIDInfo[MAX_POLICE_ID_INFO_NUM];                  // police id data
}NET_IN_WRITE_POLICE_ID;

// the output param for write police id info to MPT
typedef struct tagNET_OUT_WRITE_POLICE_ID
{
    DWORD					dwSize;									                // struct size
    int                     nResultCount;                                           // result num
    BOOL                    bResult[MAX_POLICE_ID_INFO_NUM];                        // result data, 0-success,1-fail
}NET_OUT_WRITE_POLICE_ID;

// write police id info to MPT
CLIENT_NET_API BOOL CALL_METHOD CLIENT_WritePoliceID(LLONG lLoginID,const NET_IN_WRITE_POLICE_ID* pstInParam, NET_OUT_WRITE_POLICE_ID* pstOutParam, DWORD dwWaitTime);

#define MAX_MPT_MEDIA_TYPE_NUM 64                                                   // max num of mpt record file type

// limit mode
typedef enum tagNET_EM_HORIZONTAL_ROTATION_GROUP_LIMITMODE_TYPE
{
	NET_EM_HORIZONTAL_ROTATION_GROUP_LIMITMODE_TYPE_UNKNOWN,			// unknown
	NET_EM_HORIZONTAL_ROTATION_GROUP_LIMITMODE_TYPE_LEFT,				// left
	NET_EM_HORIZONTAL_ROTATION_GROUP_LIMITMODE_TYPE_RIGHT,				// right
	NET_EM_HORIZONTAL_ROTATION_GROUP_LIMITMODE_TYPE_UP,					// up
	NET_EM_HORIZONTAL_ROTATION_GROUP_LIMITMODE_TYPE_DOWN,				// down
} NET_EM_HORIZONTAL_ROTATION_GROUP_LIMITMODE_TYPE; 

// the input param for mark the MPT record file
typedef struct tagNET_IN_MARK_MPT_RECORD_FILE
{
    DWORD					dwSize;									// struct size
    int                     nChannelID;                             // channel id
    NET_TIME                stuStartTime;                           // start time
    NET_TIME                stuEndTime;                             // end time
    int                     nMediaTypeCount;                        // file type num                        
    int                     nMediaType[MAX_MPT_MEDIA_TYPE_NUM];     // file type data,0:all type, 1:jpg, 2:dav
    int                     nCrimeType;                             // crime type
    int                     nCrimeTag;                              // crime tag
    char                    szComment[DH_COMMON_STRING_256];        // comment for mark
}NET_IN_MARK_MPT_RECORD_FILE;

// the output param for mark the MPT record file
typedef struct tagNET_OUT_MARK_MPT_RECORD_FILE
{
    DWORD					dwSize;									// struct size   
}NET_OUT_MARK_MPT_RECORD_FILE;

// Mark the MPT record file
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MarkMPTRecordFile(LLONG lLoginID,const NET_IN_MARK_MPT_RECORD_FILE* pstInParam, NET_OUT_MARK_MPT_RECORD_FILE* pstOutParam, DWORD dwWaitTime);

// +++++++++++++++++++++++++++++++++++++++++++++++++++++API for MPT exchange data with NVR+++++++++++++++++++++++++++++++++++++++++++

// +++++++++++++++++++++++++++++++++++++++++++++++++++++Device Diagnosis+++++++++++++++++++++++++++++++++++++++++++

// the input param for query diagnosis info
typedef struct tagNET_IN_QUERY_DIAGNOSIS_INFO
{
    DWORD dwSize;                                   // strcut size
    UINT nOffset;                                   // offset to query
    UINT nCount;                                    // count of query
}NET_IN_QUERY_DIAGNOSIS_INFO;

// diagnosis info item
typedef struct tagNET_DIAGNOSIS_ITEM_INFO
{
    NET_TIME stuOccurTime;                          // event occur time 
    UINT nFaultCode;                                // fault code 
    BYTE byReserved[256];                           // reserved
}NET_DIAGNOSIS_ITEM_INFO;

// the output param for query diagnosis info
typedef struct tagNET_OUT_QUERY_DIAGNOSIS_INFO
{
    DWORD dwSize;                                   // struct size
    UINT nTotalCount;                               // total item num    
    NET_DIAGNOSIS_ITEM_INFO* pstuItemInfo;          // diagnosis info data pointer
    UINT nMaxCount;                                 // the max count of item
    UINT nRetCount;                                 // return count form device
}NET_OUT_QUERY_DIAGNOSIS_INFO;

// query diagnosis info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDiagnosisInfo(LLONG lLoginID,const NET_IN_QUERY_DIAGNOSIS_INFO* pstInParam, NET_OUT_QUERY_DIAGNOSIS_INFO* pstOutParam, int nWaitTime);


// the input param for reset system
typedef struct tagNET_IN_RESET_SYSTEM
{
    DWORD dwSize;
}NET_IN_RESET_SYSTEM;

// the output param for reset system
typedef struct tagNET_OUT_RESET_SYSTEM
{
    DWORD dwSize;
}NET_OUT_RESET_SYSTEM;

// reset the system(clear user data and reboot to device init state)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ResetSystem(LLONG lLoginID,const NET_IN_RESET_SYSTEM* pstInParam, NET_OUT_RESET_SYSTEM* pstOutParam, int nWaitTime);

// +++++++++++++++++++++++++++++++++++++++++++++++++++++Device Diagnosis+++++++++++++++++++++++++++++++++++++++++++

#define MAX_IMSI_LEN		32		// max len of IMSI
#define MAX_ICCID_LEN		32		// max len of ICCID

// the mode of wireless
typedef enum tagEM_WIRELESS_MODE
{
	EM_WIRELESS_UNKNOWN,
		EM_WIRELESS_3G,
		EM_WIRELESS_3G1,
		EM_WIRELESS_3G2,
		EM_WIRELESS_3G3,
} EM_WIRELESS_MODE;

// the input param for CLIENT_MobileGetIMSI
typedef struct tagNET_IN_GET_IMSI
{
	DWORD 				dwSize;
	EM_WIRELESS_MODE	emMode;		// the mode of wireless
} NET_IN_GET_IMSI;

// the output param for CLIENT_MobileGetIMSI
typedef struct tagNET_OUT_GET_IMSI
{
	DWORD 		dwSize;
	char 		szIMSI[MAX_IMSI_LEN];			// IMSI
	char		szICCID[MAX_ICCID_LEN];			// ICCID
} NET_OUT_GET_IMSI;

// Get the IMSI of the SIM card
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MobileGetIMSI(LLONG lLoginID, const NET_IN_GET_IMSI* pstInParam, NET_OUT_GET_IMSI* pstOutParam, int nWaitTime);        //gradually abandoned,function see CLIENT_GetMobileSIMInfo

// the input param of CLIENT_GetMobileSIMInfo related to EM_SIMINFO_TYPE_GET_IMSI
typedef struct tagNET_IN_SIMINFO_GET_IMSI
{
	DWORD 				dwSize;						// assignment to the size of structure
	EM_WIRELESS_MODE	emMode;						// the mode of wireless
} NET_IN_SIMINFO_GET_IMSI;

// the output param of CLIENT_GetMobileSIMInfo related to EM_SIMINFO_TYPE_GET_IMSI
typedef struct tagNET_OUT_SIMINFO_GET_IMSI
{
	DWORD 		dwSize;								// assignment to the size of structure
	char 		szIMSI[MAX_IMSI_LEN];				// IMSI
	char		szICCID[MAX_ICCID_LEN];				// ICCID
} NET_OUT_SIMINFO_GET_IMSI;

// the mode of SIMState
typedef enum tagEM_SIMSTATE_MODE
{
		EM_SIMSTATE_UNKNOWN,						// state unknown
		EM_SIMSTATE_UNEXIST,						// unexist
		EM_SIMSTATE_EXIST,							// exist
		EM_SIMSTATE_UNMATCH,						// mobile network number unmatch
		EM_SIMSTATE_PINLOCK,						// Pinlock
		EM_SIMSTATE_PUKLOCK,						// Puklock
} EM_SIMSTATE_MODE;

// the input param of CLIENT_GetMobileSIMInfo related to EM_SIMINFO_TYPE_GET_SIMState
typedef struct tagNET_IN_SIMINFO_GET_SIM_STATE
{
	DWORD 				dwSize;						// assignment to the size of structure
	EM_WIRELESS_MODE	emMode;						// the mode of wireless
} NET_IN_SIMINFO_GET_SIMSTATE;

// the output param of CLIENT_GetMobileSIMInfo related to EM_SIMINFO_TYPE_GET_SIMState
typedef struct tagNET_OUT_SIMINFO_GET_SIM_STATE
{
	DWORD 				dwSize;						// assignment to the size of structure
	EM_SIMSTATE_MODE	emMode;						// the mode of SIMState
} NET_OUT_SIMINFO_GET_SIMSTATE;

// SIMINFO
typedef enum tagEM_SIMINFO_TYPE
{
	EM_SIMINFO_TYPE_GET_IMSI,					//SIMInfoGetIMSI,pInParam = NET_IN_SIMINFO_GET_IMSI,pOutParam = NET_OUT_SIMINFO_GET_IMSI,replace function of CLIENT_MobileGetIMSI 
	EM_SIMINFO_TYPE_GET_SIMState,				//SIMInfoGetSIMState,pInParam = NET_IN_SIMINFO_GET_SIMSTATE,pOutParam = NET_OUT_SIMINFO_GET_SIMSTATE 
}EM_SIMINFO_TYPE;

// Get the SIMINFO of SIM card
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetMobileSIMInfo(LLONG lLoginID, EM_SIMINFO_TYPE emType, void *pInParam, void *pOutParam, int nWaitTime);       

#define MAX_ROOMNUM_COUNT		32		// max count of rooms
#define MAX_FACE_COUTN			20		// max count of face data

// the info of fae
typedef struct tagNET_FACE_RECORD_INFO
{
	char		szUserName[MAX_USER_NAME_LEN];						// user name
	int			nRoom;												// count of rooms
	char		szRoomNo[MAX_ROOMNUM_COUNT][DH_COMMON_STRING_16]; 	// list of rooms
	int 		nFaceData;											// count of face data
	char		szFaceData[MAX_FACE_COUTN][MAX_FACE_DATA_LEN];		// face data
    int         nFaceDataLen[MAX_FACE_COUTN];                       // face data len
    int         nFacePhoto;                                         // count of face photo
    int         nFacePhotoLen[MAX_PHOTO_COUNT];                     // face photo data len
    char*       pszFacePhoto[MAX_PHOTO_COUNT];                      // face photo data,max size: 120K
	BOOL    bValidDate;                                         //face photo date of validity
	NET_TIME      stuValidDateStart;                               // face photo start date of validity
	NET_TIME      stuValidDateEnd;                                 //face photo end date of validity
	int			nValidCounts;										// Valid count(nValidCounts < 0 : unlimited count, nValidCounts == 0 : can't open door)
	BOOL		bValidCountsEnable;									//	Valid Count Enable   
    BOOL        bFaceDataExEnable;                                  // face data extension enable
    char*       pszFaceDataEx[MAX_FACE_COUTN];                      // face data extension, it is applied and released by user, each photo max size: 8K
    BYTE        byReserved[240];                                    // reserved bytes
} NET_FACE_RECORD_INFO;

// the input param of adding face data
typedef struct tagNET_IN_ADD_FACE_INFO
{
	DWORD 					dwSize;
	char					szUserID[DH_MAX_USERID_LEN];	// user ID
	NET_FACE_RECORD_INFO	stuFaceInfo;					// face data
} NET_IN_ADD_FACE_INFO;

// the output param of adding face data
typedef struct tagNET_OUT_ADD_FACE_INFO
{
	DWORD 			dwSize;
} NET_OUT_ADD_FACE_INFO;


// the input param of getting face data
typedef struct tagNET_IN_GET_FACE_INFO
{
	DWORD 			dwSize;
	char			szUserID[DH_MAX_USERID_LEN];	// user ID
} NET_IN_GET_FACE_INFO;

// the out param of getting face data
typedef struct tagNET_OUT_GET_FACE_INFO
{
	DWORD 			dwSize;
	int 			nFaceData;											// count of face data
	char			szFaceData[MAX_FACE_COUTN][MAX_FACE_DATA_LEN];		// face data
    int             nPhotoData;                                         // the number of photo data, max number: 5
    int             nInPhotoDataLen[MAX_PHOTO_COUNT];                   // the length of each photo data applied by user
    int             nOutPhotoDataLen[MAX_PHOTO_COUNT];                  // the actual length of each photo data
    char*           pPhotoData[MAX_PHOTO_COUNT];                        // photo data, it is applied and released by user, each photo max size: 200K
} NET_OUT_GET_FACE_INFO;

// the input param to updata face data
typedef struct tagNET_IN_UPDATE_FACE_INFO
{
	DWORD 					dwSize;
	char					szUserID[DH_MAX_USERID_LEN];	// user ID
	NET_FACE_RECORD_INFO	stuFaceInfo;					// the info of face
} NET_IN_UPDATE_FACE_INFO;

// the output param to updata face data
typedef struct tagNET_OUT_UPDATE_FACE_INFO
{
	DWORD 			dwSize;
} NET_OUT_UPDATE_FACE_INFO;


// the input param of removing face data
typedef struct tagNET_IN_REMOVE_FACE_INFO
{
	DWORD 			dwSize;
	char			szUserID[DH_MAX_USERID_LEN];	// user ID
} NET_IN_REMOVE_FACE_INFO;

// the output param of removing face data
typedef struct tagNET_OUT_REMOVE_FACE_INFO
{
	DWORD 			dwSize;
} NET_OUT_REMOVE_FACE_INFO;

// the input param of clear face data
typedef struct tagNET_IN_CLEAR_FACE_INFO
{
	DWORD 			dwSize;
} NET_IN_CLEAR_FACE_INFO;

// the output param of clear face data
typedef struct tagNET_OUT_CLEAR_FACE_INFO
{
	DWORD 			dwSize;
} NET_OUT_CLEAR_FACE_INFO;

// the input param of get face eigen
typedef struct tagNET_IN_GETFACEEIGEN_INFO
{
    DWORD 			dwSize;
    int            nPhotoDataLen;          // photo data len
    char*          pszPhotoData;           // photo data, it is applied and released by user, each photo max size: 200K
} NET_IN_GETFACEEIGEN_INFO;

// the output param of get face eigen
typedef struct tagNET_OUT_GETFACEEIGEN_INFO
{
    DWORD 			dwSize;
    int             nInFaceEigenLen;          // the length of face eigen applied by user
    int             nOutFaceEigenLen;         // the actual length of face eigen
    char*           pszFaceEigen;             // face eigen data, it is applied and released by user, each photo max size: 8K
} NET_OUT_GETFACEEIGEN_INFO;

// the opreate type of face info
typedef enum tagEM_FACEINFO_OPREATE_TYPE
{
	EM_FACEINFO_OPREATE_ADD,				// add, pInbuf = NET_IN_ADD_FACE_INFO , pOutBuf = NET_OUT_ADD_FACE_INFO
	EM_FACEINFO_OPREATE_GET,				// get, pInBuf = NET_IN_GET_FACE_INFO , pOutBuf = NET_OUT_GET_FACE_INFO
	EM_FACEINFO_OPREATE_UPDATE,				// update, pInbuf = NET_IN_UPDATE_FACE_INFO , pOutBuf = NET_OUT_UPDATE_FACE_INFO
	EM_FACEINFO_OPREATE_REMOVE,				// remove, pInbuf = NET_IN_REMOVE_FACE_INFO , pOutBuf = NET_OUT_REMOVE_FACE_INFO
	EM_FACEINFO_OPREATE_CLEAR,				// clear, pInbuf = NET_IN_CLEAR_FACE_INFO, pOutBuf = NET_OUT_CLEAR_FACE_INFO
    EM_FACEINFO_OPREATE_GETFACEEIGEN,	    // get face eigen, pInbuf = NET_IN_GETFACEEIGEN_INFO, pOutBuf = NET_OUT_GETFACEEIGEN_INFO
} EM_FACEINFO_OPREATE_TYPE;

/**************************************************************************************
*   Funcname: CLIENT_FaceInfoOpreate
*   Purpose:the opreation function of face info
*   InputParam:	LLONG		:lLoginID		// login handle
*   InputParam:     EM_FACEINFO_OPREATE_TYPE: emType //opreate type
*   InputParam:	void*		:pInParam	// the input param, the resource is maintained by user
*   OutputParam:	void*		:pOutParam	// the outtime param, the resource is maintained by user
*   InputParam:	int			:nWaitTime	// timeout
*   Return:		BOOL
*   Created:		%2017%:%08%:%30%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FaceInfoOpreate(LLONG lLoginID, EM_FACEINFO_OPREATE_TYPE emType, void* pInParam, void* pOutParam, int nWaitTime );

// input of CLIENT_StartFindFaceInfo
typedef struct tagNET_IN_FACEINFO_START_FIND
{
    DWORD 			dwSize;
   	char			szUserID[DH_MAX_USERID_LEN];	// user ID
}NET_IN_FACEINFO_START_FIND;

// output of CLIENT_StartFindFaceInfo
typedef struct tagNET_OUT_FACEINFO_START_FIND
{
    DWORD 			dwSize;
    UINT            nTotalCount;                   // total count matching the finding condition
}NET_OUT_FACEINFO_START_FIND;

// input of CLIENT_DoFindFaceInfo
typedef struct tagNET_IN_FACEINFO_DO_FIND
{
    DWORD 			dwSize;
    int             nStartNo;                       // start number
    int             nCount;                         // number to query
}NET_IN_FACEINFO_DO_FIND;

// face photo info
typedef struct tagNET_FACEINFO
{
    char			szUserID[DH_MAX_USERID_LEN];	// user ID
    int             nMD5;                           // number of MD5 
    char            szMD5[5][DH_COMMON_STRING_64];  // MD5 of face photo
    BYTE            byReserved[512];         
}NET_FACEINFO;

// output of CLIENT_DoFindFaceInfo
typedef struct tagNET_OUT_FACEINFO_DO_FIND
{
    DWORD 			dwSize;
   	int             nRetNum;                        // return number
    NET_FACEINFO*   pstuInfo;                       // result, user malloc the memroy, apply to sizeof(NET_FACEINFO)*nMaxNum
    int	            nMaxNum;                        // number of user malloced
    BYTE            byReserved[4];
}NET_OUT_FACEINFO_DO_FIND;

// start find faceinfo
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartFindFaceInfo(LLONG lLoginID, NET_IN_FACEINFO_START_FIND* pstIn, NET_OUT_FACEINFO_START_FIND* pstOut, int nWaitTime);

// do find faceinfo
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoFindFaceInfo(LLONG lFindHandle, NET_IN_FACEINFO_DO_FIND* pstIn, NET_OUT_FACEINFO_DO_FIND* pstOut, int nWaitTime);

// stop find faceinfo
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindFaceInfo(LLONG lFindHandle);

// user type
typedef enum tagNET_ENUM_USER_TYPE
{
    NET_ENUM_USER_TYPE_UNKNOWN = -1,            	// unknown
    NET_ENUM_USER_TYPE_NORMAL,                      // normal
    NET_ENUM_USER_TYPE_BLACKLIST,                   // blacklist
    NET_ENUM_USER_TYPE_GUEST,                       // guset
    NET_ENUM_USER_TYPE_PATROL,                      // patrol
    NET_ENUM_USER_TYPE_VIP,                         // vip
    NET_ENUM_USER_TYPE_HANDICAP,                    // handicap
}NET_ENUM_USER_TYPE;

// user info
typedef struct tagNET_ACCESS_USER_INFO
{
    char						szUserID[DH_MAX_USERID_LEN];				// user ID
	char						szName[MAX_COMMON_STRING_32];				// user name
    NET_ENUM_USER_TYPE          emUserType;                                 // user type
    UINT                        nUserStatus;                                // user status, 0 normal, 1 freeze
    int                         nUserTime;                                  // user times of guest 
    char			            szCitizenIDNo[MAX_COMMON_STRING_32];		// CitizenID no
    char                        szPsw[DH_MAX_CARDPWD_LEN];                  // UserID+password
    int                         nDoorNum;                                   // door number;
    int                         nDoors[DH_MAX_DOOR_NUM];                    // Privileged Door Number,That is CFG_CMD_ACCESS_EVENT Configure Array Subscript
    int                         nTimeSectionNum;                            // the Number of Effective Open Time
    int                         nTimeSectionNo[DH_MAX_TIMESECTION_NUM];     // Open Time Segment Index,That is CFG_ACCESS_TIMESCHEDULE_INFO Array subscript
    int				            nSpecialDaysScheduleNum;					// the number of specialday
	int				            nSpecialDaysSchedule[MAX_ACCESSDOOR_NUM];	// Open specialday index, That is NET_EM_CFG_ACCESSCTL_SPECIALDAYS_SCHEDULE Array subscript
    NET_TIME                    stuValidBeginTime;                          // Valid Begin Time
    NET_TIME                    stuValidEndTime;                            // Valid End Time
    BOOL                        bFirstEnter;                                // has first card or not
    int                         nFirstEnterDoorsNum;                        // has first card door number
    int                         nFirstEnterDoors[DH_MAX_DOOR_NUM];          // has first card door No,FirstEnter-1 means all channels
    NET_ATTENDANCE_AUTHORITY    emAuthority;                                // user authority
    int                         nRepeatEnterRouteTimeout;                   // repeatenter timeout time 
    int                         nFloorNum;                                              // floor number
    char                        szFloorNo[MAX_ACCESS_FLOOR_NUM][DH_COMMON_STRING_16];   // floor
    int			                nRoom;												    // room number
	char		                szRoomNo[MAX_ROOMNUM_COUNT][DH_COMMON_STRING_16]; 	    // room
	BOOL						bFloorNoExValid;										// if szFloorNoEx is valid, TRUE:valid, else invalid
	int                         nFloorNumEx;											// floor number extended
	char                        szFloorNoEx[256][4];									// floor info
    BYTE                        byReserved[3064];										// reserved
}NET_ACCESS_USER_INFO;

// input of insert or update user
typedef struct tagNET_IN_ACCESS_USER_SERVICE_INSERT
{
    DWORD                       dwSize;	                                    // struct size
    int                         nInfoNum;                                   // user number
    NET_ACCESS_USER_INFO*       pUserInfo;                                  // user info
}NET_IN_ACCESS_USER_SERVICE_INSERT;

// error code
typedef enum tagNET_EM_FAILCODE
{
    NET_EM_FAILCODE_NOERROR,                                                // no error
    NET_EM_FAILCODE_UNKNOWN,                                                // unknown
    NET_EM_FAILCODE_INVALID_PARAM,                                          // invalid param
    NET_EM_FAILCODE_INVALID_PASSWORD,                                       // invalid password
    NET_EM_FAILCODE_INVALID_FP,                                             // invalid fingprint
    NET_EM_FAILCODE_INVALID_FACE,                                           // invalid face date
    NET_EM_FAILCODE_INVALID_CARD,                                           // invalid card date
    NET_EM_FAILCODE_INVALID_USER,                                           // invalid user date
    NET_EM_FAILCODE_FAILED_GET_SUBSERVICE,                                  // get sub services failed
    NET_EM_FAILCODE_FAILED_GET_METHOD,                                      // get method failed
    NET_EM_FAILCODE_FAILED_GET_SUBCAPS,                                     // get subcaps failed
	NET_EM_FAILCODE_ERROR_INSERT_LIMIT,                                     // insert limit 
    NET_EM_FAILCODE_ERROR_MAX_INSERT_RATE,                                  // max insert rate
	NET_EM_FAILCODE_FAILED_ERASE_FP,										// erase fingprint date failed
	NET_EM_FAILCODE_FAILED_ERASE_FACE,										// erase face  datefailed
	NET_EM_FAILCODE_FAILED_ERASE_CARD,										// erase card date failed
	NET_EM_FAILCODE_NO_RECORD,												// no record 
	NET_EM_FAILCODE_NOMORE_RECORD,											// no more record
	NET_EM_FAILCODE_RECORD_ALREADY_EXISTS,									// record already
	NET_EM_FAILCODE_MAX_FP_PERUSER,											// max fingprint per user
	NET_EM_FAILCODE_MAX_CARD_PERUSER,										// max card per user
	NET_EM_FAILCODE_EXCEED_MAX_PHOTOSIZE,									// exceed max picture size
	NET_EM_FAILCODE_INVALID_USERID,											// invalid user id(not found user)
	NET_EM_FAILCODE_EXTRACTFEATURE_FAIL,									// extract face feature fail
	NET_EM_FAILCODE_PHOTO_EXIST,											// photo already exist
	NET_EM_FAILCODE_PHOTO_OVERFLOW,											// exceed max photos
	NET_EM_FAILCODE_INVALID_PHOTO_FORMAT,									// invalid photo format
	NET_EM_FAILCODE_EXCEED_ADMINISTRATOR_LIMIT,								// exceed administrator limit
}NET_EM_FAILCODE;

// output param of insert or update user
typedef struct tagNET_OUT_ACCESS_USER_SERVICE_INSERT
{
    DWORD                       dwSize;	                                    // struct size
    int                         nMaxRetNum;                                 // max return number, nInfoNum of NET_IN_ACCESS_USER_SERVICE_INSERT plus
    NET_EM_FAILCODE*            pFailCode;                                  // errorcode when insert failed,return number is nInfoNum of NET_IN_ACCESS_USER_SERVICE_INSERT
}NET_OUT_ACCESS_USER_SERVICE_INSERT;

// input param of Get user
typedef struct tagNET_IN_ACCESS_USER_SERVICE_GET
{
    DWORD                       dwSize;	                                    // struct size
    int                         nUserNum;                                   // Get number
    char						szUserID[100][32];				            // user id
}NET_IN_ACCESS_USER_SERVICE_GET;

// output param of Get user
typedef struct tagNET_OUT_ACCESS_USER_SERVICE_GET
{
    DWORD                       dwSize;	                                    // struct size
    int                         nMaxRetNum;                                 // max number of return
    NET_ACCESS_USER_INFO*       pUserInfo;                                  // user info,larger than nUserNum*sizeof(NET_ACCESS_USER_INFO)
    NET_EM_FAILCODE*            pFailCode;                                  // errorcode when failed,return number is nUserNum in NET_IN_ACCESS_USER_SERVICE_GET
}NET_OUT_ACCESS_USER_SERVICE_GET;

// input of  remove user
typedef struct tagNET_IN_ACCESS_USER_SERVICE_REMOVE
{
    DWORD                       dwSize;	                                    // struct size
    int                         nUserNum;                                   // remove number
    char						szUserID[100][32];				            // user ID
}NET_IN_ACCESS_USER_SERVICE_REMOVE;

// output of remove user
typedef struct tagNET_OUT_ACCESS_USER_SERVICE_REMOVE
{
    DWORD                       dwSize;	                                    // struct size
    int                         nMaxRetNum;                                 // max return number,nUserNum in NET_IN_ACCESS_USER_SERVICE_REMOVE
    NET_EM_FAILCODE*            pFailCode;                                  // errorcode when failed,return number is nUserNum in NET_IN_ACCESS_USER_SERVICE_REMOVE
}NET_OUT_ACCESS_USER_SERVICE_REMOVE;			

// input of clear user 
typedef struct tagNET_IN_ACCESS_USER_SERVICE_CLEAR
{
    DWORD                       dwSize;	                                    // struct size
}NET_IN_ACCESS_USER_SERVICE_CLEAR;

// output of clear user
typedef struct tagNET_OUT_ACCESS_USER_SERVICE_CLEAR
{
    DWORD                       dwSize;	                                    // struct size
}NET_OUT_ACCESS_USER_SERVICE_CLEAR;

// operate type of userinfo
typedef enum tagNET_EM_ACCESS_CTL_USER_SERVICE
{
    NET_EM_ACCESS_CTL_USER_SERVICE_INSERT = 0,                              // insert user info, pstInParam = NET_IN_ACCESS_USER_SERVICE_INSERT , pstOutParam = NET_OUT_ACCESS_USER_SERVICE_INSERT
    NET_EM_ACCESS_CTL_USER_SERVICE_GET,                                     // get user info, pstInParam = NET_IN_ACCESS_USER_SERVICE_GET , pstOutParam = NET_OUT_ACCESS_USER_SERVICE_GET
    NET_EM_ACCESS_CTL_USER_SERVICE_REMOVE,                                  // delete user info, pstInParam = NET_IN_ACCESS_USER_SERVICE_REMOVE , pstOutParam = NET_OUT_ACCESS_USER_SERVICE_REMOVE
    NET_EM_ACCESS_CTL_USER_SERVICE_CLEAR,                                   // clear user info, pstInParam = NET_IN_ACCESS_USER_SERVICE_CLEAR , pstOutParam = NET_OUT_ACCESS_USER_SERVICE_CLEAR    
}NET_EM_ACCESS_CTL_USER_SERVICE;

// interface of operate user info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateAccessUserService(LLONG lLoginID, NET_EM_ACCESS_CTL_USER_SERVICE emtype, void *pstInParam, void *pstOutParam, int nWaitTime);

// input of CLIENT_StartFindUserInfo 
typedef struct tagNET_IN_USERINFO_START_FIND
{
    DWORD 			            dwSize;                                     // struct size
   	char			            szUserID[MAX_COMMON_STRING_32];	            // user ID
}NET_IN_USERINFO_START_FIND;

// output of CLIENT_StartFindUserInfo 
typedef struct tagNET_OUT_USERINFO_START_FIND
{
    DWORD 			           dwSize;                                     // struct size
    int                        nTotalCount;                                // total count
    int                        nCapNum;                                    // maxnumber of doFind
}NET_OUT_USERINFO_START_FIND;

// input of CLIENT_DoFindUserInfo
typedef struct tagNET_IN_USERINFO_DO_FIND
{
    DWORD 			            dwSize;                                     // struct size
    int                         nStartNo;                                   // start no
    int                         nCount;                                     // query count
}NET_IN_USERINFO_DO_FIND;

// output of CLIENT_DoFindUserInfo
typedef struct tagNET_OUT_USERINFO_DO_FIND
{
    DWORD 			            dwSize;                                     // struct size
   	int                         nRetNum;                                    // return number
    NET_ACCESS_USER_INFO*       pstuInfo;                                   // user info 
    int	                        nMaxNum;                                    // max return number
    BYTE                        byReserved[4];                              // reserve
}NET_OUT_USERINFO_DO_FIND;

// startfind user info
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartFindUserInfo(LLONG lLoginID, NET_IN_USERINFO_START_FIND* pstIn, NET_OUT_USERINFO_START_FIND* pstOut, int nWaitTime);

// dofind user info, lFindHandle is CLIENT_StartFindUserInfo return value
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoFindUserInfo(LLONG lFindHandle, NET_IN_USERINFO_DO_FIND* pstIn, NET_OUT_USERINFO_DO_FIND* pstOut, int nWaitTime);

// stopfind user info, lFindHandle is CLIENT_StartFindUserInfo return value
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindUserInfo(LLONG lFindHandle);

// card info
typedef struct tagNET_ACCESS_CARD_INFO
{
    char                        szCardNo[DH_MAX_CARDNO_LEN];                // card number 
    char						szUserID[DH_MAX_USERID_LEN];				// user id 
    NET_ACCESSCTLCARD_TYPE      emType;                                     // card type,only support GeneralCorceMother card
    char			            szDynamicCheckCode[MAX_COMMON_STRING_16];	// dynamic check code
    BYTE                        byReserved[4096];                           // reserve              
}NET_ACCESS_CARD_INFO;

// input of insert card
typedef struct tagNET_IN_ACCESS_CARD_SERVICE_INSERT
{
    DWORD                       dwSize;	                                    // struct size
    int                         nInfoNum;                                   // card number
    NET_ACCESS_CARD_INFO*       pCardInfo;                                  // card info 
}NET_IN_ACCESS_CARD_SERVICE_INSERT;

// output of insert card
typedef struct tagNET_OUT_ACCESS_CARD_SERVICE_INSERT
{
    DWORD                       dwSize;	                                    // struct size
    int                         nMaxRetNum;                                 // return number ,greater than nInfoNum in NET_IN_ACCESS_CARD_SERVICE_INSERT
    NET_EM_FAILCODE*            pFailCode;                                  // error code,return number is nInfoNum in NET_IN_ACCESS_CARD_SERVICE_INSERT
    BYTE                        byReserved[4];
}NET_OUT_ACCESS_CARD_SERVICE_INSERT;

// input of get card info 
typedef struct tagNET_IN_ACCESS_CARD_SERVICE_GET
{
    DWORD                       dwSize;	                                    // struct size
    int                         nCardNum;                                   // get number 
    char                        szCardNo[100][32];                          // card No
}NET_IN_ACCESS_CARD_SERVICE_GET;

// output of get card info
typedef struct tagNET_OUT_ACCESS_CARD_SERVICE_GET
{
    DWORD                       dwSize;                                     // struct size
    int                         nMaxRetNum;                                 // max return number
    NET_ACCESS_CARD_INFO*       pCardInfo;                                  // card info
    NET_EM_FAILCODE*            pFailCode;                                  // error code,return number is nCardNum in NET_IN_ACCESS_CARD_SERVICE_GET
}NET_OUT_ACCESS_CARD_SERVICE_GET;

// input of update card info
typedef struct tagNET_IN_ACCESS_CARD_SERVICE_UPDATE
{
    DWORD                       dwSize;	                                    // struct size
    int                         nInfoNum;                                   // card number
    NET_ACCESS_CARD_INFO*       pCardInfo;                                  // card info
}NET_IN_ACCESS_CARD_SERVICE_UPDATE;

// output of update card info
typedef struct tagNET_OUT_ACCESS_CARD_SERVICE_UPDATE
{
    DWORD                       dwSize;	                                    // struct size
    int                         nMaxRetNum;                                 // max return number,greater than nInfoNum in NET_IN_ACCESS_CARD_SERVICE_UPDATE
    NET_EM_FAILCODE*            pFailCode;                                  // error code,return number is nInfoNum in NET_IN_ACCESS_CARD_SERVICE_UPDATE
    BYTE                        byReserved[4];                              // reserved
}NET_OUT_ACCESS_CARD_SERVICE_UPDATE;

// input of remove card info
typedef struct tagNET_IN_ACCESS_CARD_SERVICE_REMOVE
{
    DWORD                       dwSize;	                                    // struct size
    int                         nCardNum;                                   // remove number 
    char                        szCardNo[100][32];                          // card no 
}NET_IN_ACCESS_CARD_SERVICE_REMOVE;

// output of remove card
typedef struct tagNET_OUT_ACCESS_CARD_SERVICE_REMOVE
{
    DWORD                       dwSize;	                                    // struct size
    int                         nMaxRetNum;                                 // max retrun number,great than nCardNum in NET_IN_ACCESS_CARD_SERVICE_REMOVE
    NET_EM_FAILCODE*            pFailCode;                                  // error code,return number is nCardNum in NET_IN_ACCESS_CARD_SERVICE_REMOVE
    BYTE                        byReserved[4];                              // reserved
}NET_OUT_ACCESS_CARD_SERVICE_REMOVE;

// inout of clear card
typedef struct tagNET_IN_ACCESS_CARD_SERVICE_CLEAR
{
    DWORD                       dwSize;	                                    // struct size
}NET_IN_ACCESS_CARD_SERVICE_CLEAR;

// output of clear card
typedef struct tagNET_OUT_ACCESS_CARD_SERVICE_CLEAR
{
    DWORD                       dwSize;	                                    // struct size
}NET_OUT_ACCESS_CARD_SERVICE_CLEAR;

// type of operate card 
typedef enum tagNET_EM_ACCESS_CTL_CARD_SERVICE
{
    NET_EM_ACCESS_CTL_CARD_SERVICE_INSERT = 0,                              // insert, pstInParam = NET_IN_ACCESS_CARD_SERVICE_INSERT , pstOutParam = NET_OUT_ACCESS_CARD_SERVICE_INSERT
    NET_EM_ACCESS_CTL_CARD_SERVICE_GET,                                     // get, pstInParam = NET_IN_ACCESS_CARD_SERVICE_GET , pstOutParam = NET_OUT_ACCESS_CARD_SERVICE_GET
    NET_EM_ACCESS_CTL_CARD_SERVICE_UPDATE,                                  // update, pstInParam = NET_IN_ACCESS_CARD_SERVICE_UPDATE , pstOutParam = NET_OUT_ACCESS_CARD_SERVICE_UPDATE
    NET_EM_ACCESS_CTL_CARD_SERVICE_REMOVE,                                  // remove, pstInParam = NET_IN_ACCESS_CARD_SERVICE_REMOVE , pstOutParam = NET_OUT_ACCESS_CARD_SERVICE_REMOVE
    NET_EM_ACCESS_CTL_CARD_SERVICE_CLEAR,                                   // clear, pstInParam = NET_IN_ACCESS_CARD_SERVICE_CLEAR , pstOutParam = NET_OUT_ACCESS_CARD_SERVICE_CLEAR
}NET_EM_ACCESS_CTL_CARD_SERVICE;

// interface of operate card info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateAccessCardService(LLONG lLoginID, NET_EM_ACCESS_CTL_CARD_SERVICE emtype, void *pstInParam, void *pstOutParam, int nWaitTime);

// input of CLIENT_StartFindCardInfo
typedef struct tagNET_IN_CARDINFO_START_FIND
{
    DWORD 			            dwSize;                                     // struct size
   	char			            szUserID[32];	                            // user ID
    char                        szCardNo[32];                               // card ID
    NET_ACCESSCTLCARD_TYPE      emType;                                     // card type,only support GeneralCorceMother card                        
}NET_IN_CARDINFO_START_FIND;

// output of CLIENT_StartFindCardInfo
typedef struct tagNET_OUT_CARDINFO_START_FIND
{
    DWORD 			           dwSize;                                     // struct size
    int                        nTotalCount;                                // total numbre
    int                        nCapNum;                                    // max number of doFind
}NET_OUT_CARDINFO_START_FIND;

// input of CLIENT_DoFindCardInfo
typedef struct tagNET_IN_CARDINFO_DO_FIND
{
    DWORD 			            dwSize;                                     // struct size
    int                         nStartNo;                                   // start No
    int                         nCount;                                     // dofind count
}NET_IN_CARDINFO_DO_FIND;

// output of CLIENT_DoFindCardInfo
typedef struct tagNET_OUT_CARDINFO_DO_FIND
{
    DWORD 			            dwSize;                                     // struct size
   	int                         nRetNum;                                    // return number 
    NET_ACCESS_CARD_INFO*       pstuInfo;                                   // card info
    int	                        nMaxNum;                                    // max return number
    BYTE                        byReserved[4];
}NET_OUT_CARDINFO_DO_FIND;

// start find card info
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartFindCardInfo(LLONG lLoginID, NET_IN_CARDINFO_START_FIND* pstIn, NET_OUT_CARDINFO_START_FIND* pstOut, int nWaitTime);

// do find card info,lFindHandle is CLIENT_StartFindCardInfo return value
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoFindCardInfo(LLONG lFindHandle, NET_IN_CARDINFO_DO_FIND* pstIn, NET_OUT_CARDINFO_DO_FIND* pstOut, int nWaitTime);

// stop find card info,lFindHandle is CLIENT_StartFindCardInfo return value
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindCardInfo(LLONG lFindHandle);

// fingerprint info
typedef struct tagNET_ACCESS_FINGERPRINT_INFO
{
    char			            szUserID[DH_MAX_USERID_LEN];	                // user ID
    int                         nPacketLen;                                     // singal fingerprint packet lenth
    int                         nPacketNum;                                     // fingerprint packet number
    char*                       szFingerPrintInfo;                              // fingerprint date(total lenthnPacketLen*nPacketNum)
    int                         nDuressIndex;                                   // duress fingerprint index
    BYTE                        byReserved[4096];                               // reserved
}NET_ACCESS_FINGERPRINT_INFO;

// input of insert fingerprint info
typedef struct tagNET_IN_ACCESS_FINGERPRINT_SERVICE_INSERT
{
    DWORD 			                dwSize;                                     // struct size
    int                             nFpNum;                                     // fingerprint number
    NET_ACCESS_FINGERPRINT_INFO*    pFingerPrintInfo;                           // fingerprint info 
}NET_IN_ACCESS_FINGERPRINT_SERVICE_INSERT;

// output of insert fingerprint info
typedef struct tagNET_OUT_ACCESS_FINGERPRINT_SERVICE_INSERT
{
    DWORD 			                dwSize;                                     // struct size
    int                             nMaxRetNum;                                 // return number ,greater than nFpNum
    NET_EM_FAILCODE*                pFailCode;                                  // error code,retrun number is nFpNum NET_IN_ACCESS_FINGERPRINT_SERVICE_INSERT
}NET_OUT_ACCESS_FINGERPRINT_SERVICE_INSERT;

// input of update fingerprint info
typedef struct tagNET_IN_ACCESS_FINGERPRINT_SERVICE_UPDATE
{
    DWORD 			                dwSize;                                     // struct size
    int                             nFpNum;                                     // fingerprint number
    NET_ACCESS_FINGERPRINT_INFO*    pFingerPrintInfo;                           // fingerprint info
}NET_IN_ACCESS_FINGERPRINT_SERVICE_UPDATE;

// output of update fingerprint info
typedef struct tagNET_OUT_ACCESS_FINGERPRINT_SERVICE_UPDATE
{
    DWORD 			                dwSize;                                     // struct size
    int                             nMaxRetNum;                                 // max return number,greater than nFpNum in NET_IN_ACCESS_FINGERPRINT_SERVICE_UPDATE
    NET_EM_FAILCODE*                pFailCode;                                  // error code,return number is nFpNum NET_IN_ACCESS_FINGERPRINT_SERVICE_UPDATE
}NET_OUT_ACCESS_FINGERPRINT_SERVICE_UPDATE;

// input of Get fingerprint info
typedef struct tagNET_IN_ACCESS_FINGERPRINT_SERVICE_GET
{
    DWORD 			                dwSize;                                     // struct size
    char			                szUserID[DH_MAX_USERID_LEN];	            // user ID
}NET_IN_ACCESS_FINGERPRINT_SERVICE_GET;

// output of get fingerprint info
typedef struct tagNET_OUT_ACCESS_FINGERPRINT_SERVICE_GET
{
    DWORD 			                dwSize;                                     // struct size
    int							    nRetFingerPrintCount;					    // return number of fingerprint 
    int							    nSinglePacketLength;					    // single packet length
    int                             nDuressIndex;                               // duress index
    int							    nMaxFingerDataLength;					    // max length of fingerprint date
    int							    nRetFingerDataLength;					    // return length of figerprint date
	BYTE*                           pbyFingerData;                       	    // fingerprint date
}NET_OUT_ACCESS_FINGERPRINT_SERVICE_GET;

// input of remove fingerprint info
typedef struct tagNET_IN_ACCESS_FINGERPRINT_SERVICE_REMOVE
{
    DWORD 			                dwSize;                                     // struct size
    int                             nUserNum;                                   // remove number
    char                            szUserID[100][32];                          // user ID
}NET_IN_ACCESS_FINGERPRINT_SERVICE_REMOVE;

//output of remove fingerprint info
typedef struct tagNET_OUT_ACCESS_FINGERPRINT_SERVICE_REMOVE
{
    DWORD 			                dwSize;                                     // struct size
    int                             nMaxRetNum;                                 // max return number,greater than nUserNum in NET_IN_ACCESS_FINGERPRINT_SERVICE_REMOVE
    NET_EM_FAILCODE*                pFailCode;                                  // error code,return number is nUserNum in NET_IN_ACCESS_FINGERPRINT_SERVICE_REMOVE
}NET_OUT_ACCESS_FINGERPRINT_SERVICE_REMOVE;

// input of clear fingerprint info
typedef struct tagNET_IN_ACCESS_FINGERPRINT_SERVICE_CLEAR
{
    DWORD 			            dwSize;                                         // struct size
}NET_IN_ACCESS_FINGERPRINT_SERVICE_CLEAR;

// output of clear fingerprint info
typedef struct tagNET_OUT_ACCESS_FINGERPRINT_SERVICE_CLEAR
{
    DWORD 			            dwSize;                                         // struct size
}NET_OUT_ACCESS_FINGERPRINT_SERVICE_CLEAR;

// operate fingerprint type
typedef enum tagNET_EM_ACCESS_CTL_FINGERPRINT_SERVICE
{
    NET_EM_ACCESS_CTL_FINGERPRINT_SERVICE_INSERT = 0,                               // insert, pstInParam = NET_IN_ACCESS_FINGERPRINT_SERVICE_INSERT , pstOutParam = NET_OUT_ACCESS_FINGERPRINT_SERVICE_INSERT
    NET_EM_ACCESS_CTL_FINGERPRINT_SERVICE_GET,                                      // get, pstInParam = NET_IN_ACCESS_FINGERPRINT_SERVICE_GET , pstOutParam = NET_OUT_ACCESS_FINGERPRINT_SERVICE_GET
    NET_EM_ACCESS_CTL_FINGERPRINT_SERVICE_UPDATE,                                   // update, pstInParam = NET_IN_ACCESS_FINGERPRINT_SERVICE_UPDATE , pstOutParam = NET_OUT_ACCESS_FINGERPRINT_SERVICE_UPDATE
    NET_EM_ACCESS_CTL_FINGERPRINT_SERVICE_REMOVE,                                   // remove, pstInParam = NET_IN_ACCESS_FINGERPRINT_SERVICE_REMOVE , pstOutParam = NET_OUT_ACCESS_FINGERPRINT_SERVICE_REMOVE
    NET_EM_ACCESS_CTL_FINGERPRINT_SERVICE_CLEAR,                                    // clear, pstInParam = NET_IN_ACCESS_FINGERPRINT_SERVICE_CLEAR , pstOutParam = NET_OUT_ACCESS_FINGERPRINT_SERVICE_CLEAR
}NET_EM_ACCESS_CTL_FINGERPRINT_SERVICE;

// interface of operate fingerprint info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateAccessFingerprintService(LLONG lLoginID, NET_EM_ACCESS_CTL_FINGERPRINT_SERVICE emtype, void *pstInParam, void *pstOutParam, int nWaitTime);

// face info
typedef struct tagNET_ACCESS_FACE_INFO
{
	char					    szUserID[32];	                                    // user ID
	int 		                nFaceData;											// count of face data,the max number is 20
	char		                szFaceData[20][2048];		                        // face data
	int                         nFaceDataLen[20];                                   // face data length
	int                         nFacePhoto;                                         // count of face photo,max size: 5
	int                         nInFacePhotoLen[5];                                 // the size of each photo used by the user
	int                         nOutFacePhotoLen[5];                                // the actual size of each photo
	char*                       pFacePhoto[5];                                      // face photo data,max size: 120K
	BYTE                        byReserved[2048];                                   // reserved
} NET_ACCESS_FACE_INFO;

// the input param of adding face data(NET_EM_ACCESS_CTL_FACE_SERVICE_INSERT)
typedef struct tagNET_IN_ACCESS_FACE_SERVICE_INSERT
{
	DWORD 					    dwSize;                                             // structure size
	int                         nFaceInfoNum;                                       // face info number
	NET_ACCESS_FACE_INFO*	    pFaceInfo;					                        // face info,user allocates memory
}NET_IN_ACCESS_FACE_SERVICE_INSERT;

// the output param of adding face data(NET_EM_ACCESS_CTL_FACE_SERVICE_INSERT)
typedef struct tagNET_OUT_ACCESS_FACE_SERVICE_INSERT
{
	DWORD 			            dwSize;                                             // structure size
	int                         nMaxRetNum;                                         // the max return number,not less than nFaceInfoNum in NET_IN_ACCESS_FACE_SERVICE_INSERT
	NET_EM_FAILCODE*            pFailCode;                                          // user allocates memory.when insert failed,the result of each item inserted,count is nFaceInfoNum in NET_IN_ACCESS_FACE_SERVICE_INSERT
}NET_OUT_ACCESS_FACE_SERVICE_INSERT;

// the input param of getting face data(NET_EM_ACCESS_CTL_FACE_SERVICE_GET)
typedef struct tagNET_IN_ACCESS_FACE_SERVICE_GET
{
	DWORD 			            dwSize;                                             // structure size
	int                         nUserNum;                                           // user ID number,the max number is 100
	char			            szUserID[100][32];	                                // user ID
}NET_IN_ACCESS_FACE_SERVICE_GET;

// the out param of getting face data(NET_EM_ACCESS_CTL_FACE_SERVICE_GET)
typedef struct tagNET_OUT_ACCESS_FACE_SERVICE_GET
{
	DWORD 			            dwSize;                                             // structure size
	int                         nMaxRetNum;                                         // the max return number,not less than nUserNum in NET_IN_ACCESS_FACE_SERVICE_GET
	NET_ACCESS_FACE_INFO*	    pFaceInfo;					                        // face data,user allocates memory.count is nUserNum in NET_IN_ACCESS_FACE_SERVICE_GET,only return face data
	NET_EM_FAILCODE*            pFailCode;                                          // user allocates memory.when get failed,the result of each item get,count is nUserNum in NET_IN_ACCESS_FACE_SERVICE_GET
}NET_OUT_ACCESS_FACE_SERVICE_GET;

// the input param to update face data(NET_EM_ACCESS_CTL_FACE_SERVICE_UPDATE)
typedef struct tagNET_IN_ACCESS_FACE_SERVICE_UPDATE
{
	DWORD 					    dwSize;                                             // structure size
	int                         nFaceInfoNum;                                       // face info number
	NET_ACCESS_FACE_INFO*	    pFaceInfo;					                        // face data,user allocates memory
}NET_IN_ACCESS_FACE_SERVICE_UPDATE;

// the output param to update face data(NET_EM_ACCESS_CTL_FACE_SERVICE_UPDATE)
typedef struct tagNET_OUT_ACCESS_FACE_SERVICE_UPDATE
{
	DWORD 			            dwSize;                                             // structure size
	int                         nMaxRetNum;                                         // the max return number,not less than nFaceInfoNum in NET_IN_ACCESS_FACE_SERVICE_UPDATE
	NET_EM_FAILCODE*            pFailCode;                                          // user allocates memory.when update failed,the result of each item updated,count is nFaceInfoNum in NET_IN_ACCESS_FACE_SERVICE_UPDATE
}NET_OUT_ACCESS_FACE_SERVICE_UPDATE;

// the input param of removing face data(NET_EM_ACCESS_CTL_FACE_SERVICE_REMOVE)
typedef struct tagNET_IN_ACCESS_FACE_SERVICE_REMOVE
{
	DWORD 			            dwSize;                                             // structure size
	int                         nUserNum;                                           // user ID number,the max number is 100
	char			            szUserID[100][32];	                                // user ID
}NET_IN_ACCESS_FACE_SERVICE_REMOVE;

// the output param of removing face data(NET_EM_ACCESS_CTL_FACE_SERVICE_REMOVE)
typedef struct tagNET_OUT_ACCESS_FACE_SERVICE_REMOVE
{
	DWORD 			            dwSize;                                             // structure size
	int                         nMaxRetNum;                                         // the max return number,not less than nUserNum in NET_IN_ACCESS_FACE_SERVICE_REMOVE
	NET_EM_FAILCODE*            pFailCode;                                          // user allocates memory.when remove failed,the result of each item removed,count is nUserNum in NET_IN_ACCESS_FACE_SERVICE_REMOVE
}NET_OUT_ACCESS_FACE_SERVICE_REMOVE;

// the input param of clear face data(NET_EM_ACCESS_CTL_FACE_SERVICE_CLEAR)
typedef struct tagNET_IN_ACCESS_FACE_SERVICE_CLEAR
{
	DWORD 			            dwSize;                                             // structure size
}NET_IN_ACCESS_FACE_SERVICE_CLEAR;

// the output param of clear face data(NET_EM_ACCESS_CTL_FACE_SERVICE_CLEAR)
typedef struct tagNET_OUT_ACCESS_FACE_SERVICE_CLEAR
{
	DWORD 			            dwSize;                                             // structure size
}NET_OUT_ACCESS_FACE_SERVICE_CLEAR;

// the operate type of face info
typedef enum tagNET_EM_ACCESS_CTL_FACE_SERVICE
{
	NET_EM_ACCESS_CTL_FACE_SERVICE_INSERT = 0,                      // insert, pInbuf = NET_IN_ACCESS_FACE_SERVICE_INSERT , pOutBuf = NET_OUT_ACCESS_FACE_SERVICE_INSERT
	NET_EM_ACCESS_CTL_FACE_SERVICE_GET,                             // get, pInbuf = NET_IN_ACCESS_FACE_SERVICE_GET , pOutBuf = NET_OUT_ACCESS_FACE_SERVICE_GET
	NET_EM_ACCESS_CTL_FACE_SERVICE_UPDATE,                          // update, pInbuf = NET_IN_ACCESS_FACE_SERVICE_UPDATE , pOutBuf = NET_OUT_ACCESS_FACE_SERVICE_UPDATE
	NET_EM_ACCESS_CTL_FACE_SERVICE_REMOVE,                          // remove, pInbuf = NET_IN_ACCESS_FACE_SERVICE_REMOVE , pOutBuf = NET_OUT_ACCESS_FACE_SERVICE_REMOVE
	NET_EM_ACCESS_CTL_FACE_SERVICE_CLEAR,                           // clear, pInbuf = NET_IN_ACCESS_FACE_SERVICE_CLEAR , pOutBuf = NET_OUT_ACCESS_FACE_SERVICE_CLEAR
}NET_EM_ACCESS_CTL_FACE_SERVICE;

// the operation function of face info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateAccessFaceService(LLONG lLoginID, NET_EM_ACCESS_CTL_FACE_SERVICE emtype, void *pstInParam, void *pstOutParam, int nWaitTime);

// CLIENT_AccessStartFindFaceInfo input parameter
typedef struct tagNET_IN_ACCESS_FACEINFO_START_FIND
{
	DWORD 			dwSize;                         // structure size
	char			szUserID[32];	                // User ID
}NET_IN_ACCESS_FACEINFO_START_FIND;

// CLIENT_AccessStartFindFaceInfo output parameter
typedef struct tagNET_OUT_ACCESS_FACEINFO_START_FIND
{
	DWORD 		   dwSize;                        // structure size
	int            nCapNum;                       // find max number once
	int            nTotalCount;                   // the total number of conforms to the query conditions
}NET_OUT_ACCESS_FACEINFO_START_FIND;

// CLIENT_AccessDoFindFaceInfo input parameter
typedef struct tagNET_IN_ACCESS_FACEINFO_DO_FIND
{
	DWORD 			dwSize;                         // structure size
	int             nStartNo;                       // start number
	int             nCount;                         // find count,not greater than nCapNum in NET_OUT_ACCESS_FACEINFO_START_FIND
}NET_IN_ACCESS_FACEINFO_DO_FIND;

// CLIENT_AccessDoFindFaceInfo output parameter
typedef struct tagNET_OUT_ACCESS_FACEINFO_DO_FIND
{
	DWORD 			dwSize;                         // structure size
	int             nRetNum;                        // find number
	NET_FACEINFO*   pstuInfo;                       // find result, user new memory,size:sizeof(NET_FACEINFO)*nMaxNum
	int	            nMaxNum;                        // the number of memory allocated by the user
	BYTE            byReserved[4];                  // reserved byte
}NET_OUT_ACCESS_FACEINFO_DO_FIND;

// Start Find Face Info,return value is CLIENT_AccessDoFindFaceInfoCLIENT_AccessStopFindFaceInfo input param lFindHandle
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AccessStartFindFaceInfo(LLONG lLoginID, NET_IN_ACCESS_FACEINFO_START_FIND* pstIn, NET_OUT_ACCESS_FACEINFO_START_FIND* pstOut, int nWaitTime);

// Do Find Face Info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AccessDoFindFaceInfo(LLONG lFindHandle, NET_IN_ACCESS_FACEINFO_DO_FIND* pstIn, NET_OUT_ACCESS_FACEINFO_DO_FIND* pstOut, int nWaitTime);

// Stop Find Face Info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AccessStopFindFaceInfo(LLONG lFindHandle);

/**************************************************************************************
*   Funcname: CLIENT_RenderPrivateData
*   Purpose:display private data
*   InputParam:     LLONG		:lPlayHandle        	// play handle
*   InputParam:     BOOL		:bTrue        		// TRUE:display  FALSE:not display
*   Return:		BOOL:TRUE--sucess   FALSE--failed
*   Created:	       %2017%:%09%:%25%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RenderPrivateData(LLONG lPlayHandle, BOOL bTrue);

// get attendance device state input parameters
typedef struct tagNET_IN_ATTENDANCE_GETDEVSTATE
{
	DWORD 			dwSize;
} NET_IN_ATTENDANCE_GETDEVSTATE;

// get attendance device state output parameters
typedef struct tagNET_OUT_ATTENDANCE_GETDEVSTATE
{
	DWORD 			           dwSize;
	int                        nState;     // 0:offiline;1:online;other:unknown;attendance device state
} NET_OUT_ATTENDANCE_GETDEVSTATE;

//get attendance device state
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Attendance_GetDevState(LLONG lLoginID, const NET_IN_ATTENDANCE_GETDEVSTATE *pstuInParam, NET_OUT_ATTENDANCE_GETDEVSTATE *pstuOutParam, int nWaitTime);

//setting upgrade pakcages url input parameters
typedef struct tagNET_IN_UPGRADER_SETURL
{
	DWORD       dwSize;                                // structure size
	char        szUrl[DH_COMMON_STRING_256];           // upgrade pakcages url
	UINT        nCheckType;                            // upgrade pakcages verification mode 0:MD5
	char        szCheckSum[DH_COMMON_STRING_128];      // upgrade pakcages verification value
    int         nSpareUrl;                             // The number of supare upgrade pakcages url
    char        szSpareUrl[4][256];                    // supare upgrade pakcages url
}NET_IN_UPGRADER_SETURL;

//setting upgrade pakcages url output parameters
typedef struct tagNET_OUT_UPGRADER_SETURL
{
	DWORD        dwSize;                               // structure size
}NET_OUT_UPGRADER_SETURL;

//setting upgrade pakcages url, than download upgrade pakcages from the url
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Upgrader_SetUrl(LLONG lLoginID, NET_IN_UPGRADER_SETURL *pInParam, NET_OUT_UPGRADER_SETURL *pOutParam, int nWaitTime);

// Pack condition
typedef struct tagNET_XRAY_PACK_CONDITION
{
	NET_TIME_EX			stuStartTime;				// StartTime(include timezone)
	NET_TIME_EX			stuEndTime;					// EndTime(include timezone)
	BYTE				byReserved[1024];			// Reserved
}NET_XRAY_PACK_CONDITION;

// input param of CLIENT_Xray_GetPackTotalInfo
typedef struct tagNET_IN_XRAY_GETPACKTOTALINFO
{
	DWORD							dwSize;											// Structure size
	int								nChannelNum;									// valid Channel num
	int								nChannelsID[MAX_XRAY_CHANNEL_NUM]; 				// Channels ID 
	NET_XRAY_PACK_CONDITION			stuCondition;									// pack condition
}NET_IN_XRAY_GETPACKTOTALINFO;

// Pack num info according to Grade
typedef struct tagNET_GRADE_PACK_NUM_INFO
{
	unsigned int	nNormalPackNum;			// Normal pack num
	unsigned int	nWarnPackNum;			// Warn pack num
	unsigned int	nDangerPackNum;			// Danger pack num
	BYTE			byReserved[20];			// Reserved
}NET_GRADE_PACK_NUM_INFO;

// Pack num info according to object type 
typedef struct tagNET_PACK_TYPE_NUM_INFO
{
	unsigned int     nUnknownNum;				// Unknown num
	unsigned int	 nKnifeNum;					// Knife pack num
	unsigned int	 nBottleLiquidNum;			// Bottle liquid pack num
	unsigned int	 nGunNum;					// Gun pack num
	unsigned int	 nUmbrellaNum;				// Umbrella pack num
	unsigned int	 nPhoneNum;					// Phone pack num
	unsigned int     nNotebookNum;				// Note book pack num
	unsigned int	 nPowerbankNum;				// Power bank pack num
	unsigned int	 nShoesNum;					// Shoes pack num
	unsigned int	 nRodNum;					// Rod pack num
	unsigned int	 nMetalNum;					// Metal pack num
	unsigned int	 nExplosiveNum;				// Explosive pack num
	unsigned int	 nContainerSprayNum;		// ContainerSpray pack num
	unsigned int	 nExplosiveFireworksNum;    // ExplosiveFireworks pack num
	unsigned int	 nLighterNum;               // Lighter pack num
	unsigned int	 nStickNum;                 // Stick pack num
	unsigned int	 nBrassknuckleNum;          // Brassknuckle pack num
	unsigned int	 nHandcuffsNum;             // Handcuffs pack num
	unsigned int	 nIvoryNum;                 // Ivory pack num
	BYTE			 byReserved[996];			// Reserved
}NET_PACK_TYPE_NUM_INFO;

// Xray pack info
typedef struct tagNET_XRAY_PACKINFO
{
	unsigned int				nTotalNum;						// Total pack num
	NET_GRADE_PACK_NUM_INFO		stuGradePackNumInfo;			// Pack num info according to grade
	NET_PACK_TYPE_NUM_INFO		stuPackTypeNumInfo;				// Pack num info according to object type
	int							nChannel;						// Pack info channel
	BYTE						byReserved[1024];				// Reserved
}NET_XRAY_PACKINFO;

// output param of CLIENT_Xray_GetPackTotalInfo
typedef struct tagNET_OUT_XRAY_GETPACKTOTALINFO
{
	DWORD							dwSize;											// Structure size
	NET_XRAY_PACKINFO				stuXrayPackInfo[MAX_XRAY_CHANNEL_NUM];			// Xray pack info
	int								nRetXrayPackInfoNum;							// return num of Xray pack info
}NET_OUT_XRAY_GETPACKTOTALINFO;

// Get pack statistics info through Xray detection
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Xray_GetPackTotalInfo(LLONG lLoginID, const NET_IN_XRAY_GETPACKTOTALINFO* pInParam, NET_OUT_XRAY_GETPACKTOTALINFO* pOutParam,int nWaitTime);

// Package statistics info by grade of X Ray machine
typedef struct tagNET_IN_PACKAGE_STATISTICS_BYGRADE
{
	EM_DANGER_GRADE_TYPE		emGrade;								// danger grade of package
	UINT						nCount;									// package count
	BYTE						byReserved[64];							// reserved
}NET_IN_PACKAGE_STATISTICS_BYGRADE;

// Package statistics info by type of X Ray machine
typedef struct tagNET_IN_PACKAGE_STATISTICS_BYTYPE
{
	EM_INSIDE_OBJECT_TYPE		emType;									// object type
	UINT						nCount;									// package count
	BYTE						byReserved[64];							// reserved
}NET_IN_PACKAGE_STATISTICS_BYTYPE;

// Package statistics info of X Ray machine
typedef struct tagNET_IN_XRAY_STATISTICS_INFO
{
	char								szUUID[36];						// UUID
	UINT								nStatisticsInfoID;				// statistics info ID
	NET_TIME_EX							stuBeginTime;					// begin time
	NET_TIME_EX							stuEndTime;						// end time
	UINT								nTotalCount;					// total package count
	UINT								nStatisticsInfoByGradeNum;		// num of statistics info by danger grade
	NET_IN_PACKAGE_STATISTICS_BYGRADE	stuStatisticsInfoByGrade[16];	// statistics info by danger grade
	UINT								nStatisticsInfoByTypeNum;		// num of statistics info by danger type
	NET_IN_PACKAGE_STATISTICS_BYTYPE	stuStatisticsInfoByType[64];	// statistics info by danger type
	BYTE								byReserved[1024];				// reserved
}NET_IN_XRAY_PACKAGE_STATISTICS_INFO;

// Callback function of package statistics
typedef void (CALLBACK *fXRayAttachPackageStatistics)(LLONG lAttachHandle, NET_IN_XRAY_PACKAGE_STATISTICS_INFO* pInfo, LDWORD dwUser);

// Input param of CLIENT_XRayAttachPackageStatistics
typedef struct tagNET_IN_XRAY_ATTACH_PACKAGE_STATISTICS
{
	DWORD							dwSize;								// struct size
	char							szUUID[36];							// UUID
	fXRayAttachPackageStatistics	cbNotify;							// call back function
	LDWORD							dwUser;								// user info
}NET_IN_XRAY_ATTACH_PACKAGE_STATISTICS;

// Output param  of CLIENT_XRayAttachPackageStatistics
typedef struct tagNET_OUT_XRAY_ATTACH_PACKAGE_STATISTICS
{
	DWORD							dwSize;								// struct size
}NET_OUT_XRAY_ATTACH_PACKAGE_STATISTICS;

// Attach package statistics info of X Ray machine
CLIENT_NET_API LLONG CALL_METHOD CLIENT_XRayAttachPackageStatistics(LLONG lLoginID, const NET_IN_XRAY_ATTACH_PACKAGE_STATISTICS* pInParam, NET_OUT_XRAY_ATTACH_PACKAGE_STATISTICS* pOutParam, int nWaitTime);


// Cancel attach package statistics info of X Ray machine
// lAttachHandle is the value returned by CLIENT_XRayAttachPackageStatistics
CLIENT_NET_API BOOL CALL_METHOD CLIENT_XRayDetachPackageStatistics(LLONG lAttachHandle);


// Temperature type
typedef enum tagNET_TEMPERATURE_TYPE
{
	NET_TEMPERATURE_TYPE_CPU,			    // CPU
}NET_TEMPERATURE_TYPE;

// Input param of CLIENT_FaceBoard_GetHistoryTemperature
typedef struct tagNET_IN_GET_HISTORY_TEMPERATURE
{
	DWORD					dwSize;							// Structure size
	NET_TEMPERATURE_TYPE	emTemperatureType;				// Temperature type
}NET_IN_GET_HISTORY_TEMPERATURE;

// History temperature of every monitor point
typedef struct tagNET_TEMPERATURE_VALUE
{
	double				dbHistoryTemperature[MAX_HISTORY_TEMPERATURE_NUM];	// History temperature value,Unit:centigrade
	int					nRetHistoryTemperatureNum;							// Return valid history temperature num
	BYTE				byReserved[4];										// Reserved
}NET_TEMPERATURE_VALUE;

// History temperature info
typedef struct tagNET_HISTORY_TEMPERATURE_INFO
{
	int						nRetMonitorPointNum;										// Return valid temperature monitor point num
	BYTE					byReserved[4];												// Reserved
	NET_TEMPERATURE_VALUE   stuMonitorPointTemperature[MAX_TEMPERATURE_POINT_NUM];		// monitor point history temperature
	BYTE					byReserved1[1024];											// Reserved
}NET_HISTORY_TEMPERATURE_INFO;

// Output param of CLIENT_FaceBoard_GetHistoryTemperature
typedef struct tagNET_OUT_GET_HISTORY_TEMPERATURE
{
	DWORD							dwSize;							// Structure size
	BYTE							byReserved[4];					// Reserved
	NET_HISTORY_TEMPERATURE_INFO	stuHistoryTemperatureInfo;		// History temperature info
}NET_OUT_GET_HISTORY_TEMPERATURE;

// Get history temperature
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FaceBoard_GetHistoryTemperature(LLONG lLoginID, const NET_IN_GET_HISTORY_TEMPERATURE *pInParam, NET_OUT_GET_HISTORY_TEMPERATURE *pOutParam, int nWaitTime);

// temperature type
typedef enum tagEM_TEMPERATUREEX_TYPE
{
	EM_TEMPERATUREEX_TYPE_UNKNOWN,          // Unknown
	EM_TEMPERATUREEX_TYPE_ALL,			    // ALL
	EM_TEMPERATUREEX_TYPE_POWER,			// Power
	EM_TEMPERATUREEX_TYPE_CABINET,			// Cabinet
	EM_TEMPERATUREEX_TYPE_GLOBAL,			// Global
	EM_TEMPERATUREEX_TYPE_MAINBOARD,	    // Mainboard
	EM_TEMPERATUREEX_TYPE_CARD,			    // Sub card
	EM_TEMPERATUREEX_TYPE_BACKBOARD,	    // Backboard
	EM_TEMPERATUREEX_TYPE_CPU,			    // CPU
}EM_TEMPERATUREEX_TYPE;

// CLIENT_FaceBoard_GetTemperatureEx input param
typedef struct tagNET_IN_GET_TEMPERATUREEX
{
	DWORD                           dwSize;   						// Structure size
	EM_TEMPERATUREEX_TYPE	        emTemperatureType;				// Temperature Type
}NET_IN_GET_TEMPERATUREEX;

// Each monitor point temperature
typedef struct tagNET_TEMPERATUREEX_VALUE
{
	EM_TEMPERATUREEX_TYPE	        emTemperatureType;				// Temperature Type
	int					nRetTemperatureNum;							// The number of return valid temperature value
	float				fTemperature[MAX_HISTORY_TEMPERATURE_NUM];	// Temperature value,unit:centigrade
	BYTE				byReserved[128];						    // Reserved byte
}NET_TEMPERATUREEX_VALUE;

// CLIENT_FaceBoard_GetTemperatureEx output param
typedef struct tagNET_OUT_GET_TEMPERATUREEX
{
	DWORD                           dwSize;   						// Structure size
	int								nRetMonitorPointNum;			// The number of return valid monitor point temperature, when num>1,emTemperatureType is ALL
	NET_TEMPERATUREEX_VALUE			stuTemperatureEx[MAX_TEMPERATUREEX_POINT_NUM];	// monitor point temperature
}NET_OUT_GET_TEMPERATUREEX;

// Get Face Board Temperature
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FaceBoard_GetTemperatureEx(LLONG lLoginID, const NET_IN_GET_TEMPERATUREEX *pInParam, NET_OUT_GET_TEMPERATUREEX *pOutParam, int nWaitTime);

// CLIENT_GetAlarmOutState input param
typedef struct tagNET_IN_GET_ALARM_OUT_STATE 
{
	DWORD							dwSize; 						// Structure size
} NET_IN_GET_ALARM_OUT_STATE;

#define	MAX_OUT_STATE_COUNT	32

//CLIENT_GetAlarmOutState output param
typedef struct tagNET_OUT_GET_ALARM_OUT_STATE 
{
	DWORD							dwSize;							// Structure size
	int								nState[MAX_OUT_STATE_COUNT];	// output port state, 0: no, 1: yes
} NET_OUT_GET_ALARM_OUT_STATE;

// Get Alarm out state
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetAlarmOutState(LLONG lLoginID, const NET_IN_GET_ALARM_OUT_STATE *pInParam, NET_OUT_GET_ALARM_OUT_STATE *pOutParam, int nWaitTime);

// 2DCode Type 
typedef enum tagNET_EM_2DCODE_TYPE
{
    NET_EM_2DCODE_TYPE_OZVISION,                                        // P2P of TYCO
    NET_EM_2DCODE_TYPE_LCWEBSITE,                                       // lecheng
    NET_EM_2DCODE_TYPE_EASY4IP,                                         // easy4ip
    NET_EM_2DCODE_TYPE_DMSS,                                            // i/gDMSS
    NET_EM_2DCODE_TYPE_VIDEOTALK,                                       // videotalk
    NET_EM_2DCODE_TYPE_APPREGISTER,                                     // app register
	NET_EM_2DCODE_TYPE_DEVAUTH,											// H500 get authorisation from Midea
}NET_EM_2DCODE_TYPE;

// Work Directory Get Group Name In Param
typedef struct tagNET_IN_WORKDIRECTORY_GETGROUP_INFO
{
	DWORD				dwSize;
	char				szDirectoryName[DH_COMMON_STRING_256];		// Disk Directory name
}NET_IN_WORKDIRECTORY_GETGROUP_INFO;

// Work Directory Get Group Name Out Param
typedef struct tagNET_OUT_WORKDIRECTORY_GETGROUP_INFO
{
	DWORD				dwSize;			
	char				szGroupName[DH_COMMON_STRING_256];			// work directory group name
}NET_OUT_WORKDIRECTORY_GETGROUP_INFO;

// Work Directory Get Group name
CLIENT_NET_API BOOL CALL_METHOD CLIENT_WorkDirectoryGetGroup(LLONG lLoginID, const NET_IN_WORKDIRECTORY_GETGROUP_INFO *pInParam,  NET_OUT_WORKDIRECTORY_GETGROUP_INFO *pOutParam, int nWaitTime);

// Work Directory Set Group Name In Param
typedef struct tagNET_IN_WORKDIRECTORY_SETGROUP_INFO
{
	DWORD				dwSize;
	char				szGroupName[DH_COMMON_STRING_256];			// Work Directory Group name
	char				szDirectoryName[DH_COMMON_STRING_256];		// Disk Directory name
}NET_IN_WORKDIRECTORY_SETGROUP_INFO;

// Work Directory Set Group Name Out Param
typedef struct tagNET_OUT_WORKDIRECTORY_SETGROUP_INFO
{
	DWORD				dwSize;
}NET_OUT_WORKDIRECTORY_SETGROUP_INFO;

// Work Directory Set Group Name
CLIENT_NET_API BOOL CALL_METHOD CLIENT_WorkDirectorySetGroup(LLONG lLoginID, const NET_IN_WORKDIRECTORY_SETGROUP_INFO *pInParam, NET_OUT_WORKDIRECTORY_SETGROUP_INFO *pOutParam, int nWaitTime);

// input of CLIENT_Get2DCode
typedef struct tagNET_IN_GET_2DCODE
{
    DWORD							dwSize;							    // Structure size
    NET_EM_2DCODE_TYPE              em2DCodeType;                       // 2DCode Type 
}NET_IN_GET_2DCODE;

// output of CLIENT_Get2DCode
typedef struct tagNET_OUT_GET_2DCODE
{
    DWORD							dwSize;							    // Structure size
    char                            sz2DCode[DH_COMMON_STRING_512];     // 2DCode info
}NET_OUT_GET_2DCODE;

// Get 2DCode from deivce
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Get2DCode(LLONG lLoginID, const NET_IN_GET_2DCODE *pInParam, NET_OUT_GET_2DCODE *pOutParam, int nWaitTime);

// input of CLIENT_Set2DCode
typedef struct tagNET_IN_SET_2DCODE
{
    DWORD							dwSize;							    // Structure size
    NET_EM_2DCODE_TYPE              em2DCodeType;                       // 2DCode Type
    char                            sz2DCode[DH_COMMON_STRING_512];     // 2DCode info
}NET_IN_SET_2DCODE;

// output of CLIENT_Set2DCode
typedef struct tagNET_OUT_SET_2DCODE
{
    DWORD							dwSize;							    // Structure size
}NET_OUT_SET_2DCODE;

// Set 2DCode to deivce
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Set2DCode(LLONG lLoginID, const NET_IN_SET_2DCODE *pInParam, NET_OUT_SET_2DCODE *pOutParam, int nWaitTime);

// the state of import face database
typedef enum tagEM_IMPORT_FACEDB_STATE
{
	EM_IMPORT_FACEDB_UNKNOWN,			// unknown
	EM_IMPORT_FACEDB_ONGING,			// importing
	EM_IMPORT_FACEDB_END,				// import end, start production database
	EM_IMPORT_FACEDB_BUSY,				// the system is busy
	EM_IMPORT_FACEDB_DATAERROR,			// packet checkout faile
	EM_IMPORT_FACEDB_INVALID,			// packet illegal
	EM_IMPORT_FACEDB_SYNC_SUCCESS,		// synchronization success
	EM_IMPORT_FACEDB_SYNC_FALIED,		// synchronization failed
	EM_IMPORT_FACEDB_DBFULL,			// database cannot be imported
	EM_IMPORT_FACEDB_SDFULL,			// storage space is full, cannot to import face database
	EM_IMPORT_FACEDB_CIPHER_ERROR,		// compression package cipher is incorrect
} EM_IMPORT_FACEDB_STATE;

// the type of face database progress
typedef enum tagEM_FACEDB_PROGRESS_TYPE
{
	EM_FACEDB_PROGRESS_IMPORT,			// import progress
	EM_FACEDB_PROGRESS_DEPLOY,			// deploy progress
} EM_FACEDB_PROGRESS_TYPE;

// The status information of import face DB
typedef struct tagNET_IMPORT_FACEDB_STATE
{
	unsigned int	        	nProgress;			// progress, percentage
	EM_FACEDB_PROGRESS_TYPE		emType;				// the type of progress
	EM_IMPORT_FACEDB_STATE		emState;			// state type
	BYTE			        	byReserved[512];	// reserved
} NET_IMPORT_FACEDB_STATE;

// the callback function of import face DB
typedef void (CALLBACK *fImportFaceDbCallBack) (LLONG lImportFaceDbHandle, NET_IMPORT_FACEDB_STATE *pstFaceDbState, LDWORD dwUser);

// input parameter of interface CLIENT_ImportFaceDB
typedef struct tagNET_IN_IMPORT_FACE_DB
{
	DWORD							dwSize;							// the size of this struct
	char                			szGroupId[DH_COMMON_STRING_64];	// group ID
	char							szPassWord[DH_COMMON_STRING_64];// pass word
	char							*pszFaceDBPath;					// the path of face DB file, specified by user
	fImportFaceDbCallBack			cbImportState;					// the callback function of upload face DB
	LDWORD 							dwUser;							// user data
	int                             nWaitTime;                      // wait time
} NET_IN_IMPORT_FACE_DB;

// output parameter of interface CLIENT_ImportFaceDB
typedef struct tagNET_OUT_IMPORT_FACE_DB
{
	DWORD							dwSize;							// the size of this struct
} NET_OUT_IMPORT_FACE_DB;

// interface of import face DB
CLIENT_NET_API LLONG CALL_METHOD CLIENT_ImportFaceDB(LLONG lLoginID, const NET_IN_IMPORT_FACE_DB *pInParam, NET_OUT_IMPORT_FACE_DB *pOutParam);

// interface of stopping import face DB
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopImportFaceDB(LLONG lImportFaceDbHandle);

// the error code of export face DB
typedef enum tagEM_EXPORT_FACEDB_ERRORCODE
{
	EM_EXPORT_FACEDB_REQUEST_SUCCESS	= 1,		// request success
	EM_EXPORT_FACEDB_NO_AUTHORITY		= 2,		// no authority
	EM_EXPORT_FACEDB_NO_THIS_FILE		= 3,		// no such file
	EM_EXPORT_FACEDB_EXPORT_END			= 4,		// export end
	EM_EXPORT_FACEDB_EXPORTING			= 5,		// exporting
	EM_EXPORT_FACEDB_FILE_READY			= 8,		// prepare file success
	EM_EXPORT_FACEDB_FILE_FAILED		= 9,		// prepare file faild
	EM_EXPORT_FACEDB_WAIT_FILE			= 10,		// request success, and need to wait for the device preparation file
	EM_EXPORT_FACEDB_SYSTEM_BUSY		= 11,		// the system is busy, can not to export face BD
	EM_EXPORT_FACEDB_NO_PASSWORD		= 12,		// no password, can not to export face DB
} EM_EXPORT_FACEDB_ERRORCODE;

// The status information of export face DB
typedef struct tagNET_EXPORT_FACEDB_STATE
{
	unsigned int					nProgress;			// progress, percentage
	EM_EXPORT_FACEDB_ERRORCODE		emErrorCode;		// error code
	char							*pDataBuf;			// the data of face DB
	DWORD							dwDataLen;			// data len
	BYTE							byReserved[512];	// reserved
} NET_EXPORT_FACEDB_STATE;

// the callback function of export face DB
typedef void (CALLBACK *fExportStateCallBack)(LLONG lExportFaceDbHandle, NET_EXPORT_FACEDB_STATE *pstFaceDbState, LDWORD dwUser);

// input parameter of interface CLIENT_ExportFaceDB
typedef struct tagNET_IN_EXPORT_FACE_DB
{
	DWORD							dwSize;								// the size of this struct
	char                			szGroupId[DH_COMMON_STRING_64];		// Group ID
	char							szPassWord[DH_COMMON_STRING_64];	// password
	fExportStateCallBack			cbExportFaceDbCallBack;				// the callback function of export face DB
	LDWORD 							dwUser;								// user data
	int                             nWaitTime;                          // wait time
} NET_IN_EXPORT_FACE_DB;

// output parameter of interface CLIENT_ExportFaceDB
typedef struct tagNET_OUT_EXPORT_FACE_DB
{
	DWORD							dwSize;							// the size of this struct
} NET_OUT_EXPORT_FACE_DB;

// interface of export face DB
CLIENT_NET_API LLONG CALL_METHOD CLIENT_ExportFaceDB(LLONG lLoginID, const NET_IN_EXPORT_FACE_DB *pInParam, NET_OUT_EXPORT_FACE_DB *pOutParam);

// interface of stop export upload face DB
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopExportFaceDB(LLONG lExportFaceDbHandle);


// PIR Dectct window info
typedef struct tagNET_DETECT_WINDOW_IFNO
{
	int				    nRegionID;									// Region ID
    char                szRegionName[DH_COMMON_STRING_128];			// Region Name
    int                 nThreshold;                                 // Threshold, value:[0, 100]
	int					nSensitive;									// Sensitive, value:[0, 100]
	int					nRegionRow;									// Region Row count
	int					nRegionCol;									// Region Col count
	BYTE				byRegion[DH_MOTION_ROW][DH_MOTION_COL];		// Detect Region
	int					nLevel;										// Sensitive level,value:[1,6]
	BYTE				byReserved[508];							// reserved
} NET_DETECT_WINDOW_IFNO;

// 
typedef enum tagEM_PIR_LIGHT_LINK_TYPE
{
	EM_PIR_LIGHT_LINK_TYPE_UNKNOWN,									// unknown
	EM_PIR_LIGHT_LINK_TYPE_FILCKER,									// filcker
	EM_PIR_LIGHT_LINK_TYPE_KEEPLIGHTING,							// keep lighting
} EM_PIR_LIGHT_LINK_TYPE;

// Linked white light deterrence
typedef struct tagNET_LIGHTINGLINK_INFO 
{
	BOOL					bEnable;								// whether to link
	EM_PIR_LIGHT_LINK_TYPE	emLightLinkType;						// lighting linkage
	int						nFilckerIntevalTime;					// Blinking interval
	int						nLightDuration;							// Flashing or steady light duration
	DH_TSECT				stuWhiteLightTimeSection[DH_TSCHE_DAY_NUM][DH_TSCHE_SEC_NUM];	// Linked white light deterrence time
	BYTE					byReserved[512];						// reserved
} NET_LIGHTINGLINK_INFO ;

// alarm linkage information
typedef struct tagNET_PIR_LINK_INFO
{
	BOOL						bRecordEnable;							// Record enable
	BOOL						bAlarmOutEnable;						// alarm out enable
	BOOL						bSnapshotEnable;						// snapshot enable
	BOOL						bMailEnable;							// send mail
	BOOL						bAlarmBellEnable;						// alarmbell enable
	BOOL						bLogEnable;								// whether to record the alarm log
	int							nRecordChannelNum;						// record channel number
	int							nRecordChannels[DH_COMMON_STRING_64];	// record channels
	int							nRecordLatch;							// record latch time,range:[10,300]
	int							nAlarmOutChannelNum;					// alarm out channel number
	int							AlarmOutChannels[DH_COMMON_STRING_32];	// alarm out channel number
	int							nAlarmOutLatch;							// alarm out channels, range:[1,300]
	int							nSnapshotChannelNum;					// snapshot channel number
	int							SnapshotChannels[DH_COMMON_STRING_32];	// snap shot channels
	int							nAlarmBellLatch;						// alarmbell latch,10~300
	int							nDejitter;								// debounce time
	NET_LIGHTINGLINK_INFO		stLightingLink;							// Linked white light deterrence
	NET_CFG_TIME_SCHEDULE		stTimeShecule;							// alarm time period
	BYTE						byReserved1[512];						// reserved
}NET_PIR_LINK_INFO;

// Max count of detect window
#define MAX_DETECT_WINDOW	4

// PIR config info
typedef struct tagNET_PIR_ALARM_INFO
{
	BOOL					bEnable;									
	int						nDetectWindowCount;						// PIR Detect Window count
	NET_DETECT_WINDOW_IFNO	stDetectWindow[MAX_DETECT_WINDOW];		// PIR Detect window
	NET_PIR_LINK_INFO		stPirLink;								// PIR alarm link
} NET_PIR_ALARM_INFO;

// input parameter of interface CLIENT_GetPirAlarmParam
typedef struct tagNET_IN_GET_PIR_ALARM_PARAM
{
	DWORD				dwSize;
	int					nChannel;									// channel
} NET_IN_GET_PIR_ALARM_PARAM;

// output parameter of interface CLIENT_GetPirAlarmParam 
typedef struct tagNET_OUT_GET_PIR_ALARM_PARAM
{
	DWORD				dwSize;
	NET_PIR_ALARM_INFO	stPirAlarmInfo;								// PIR config info
	int					nPirAlarmNum;								// actual number of acquisitions
	NET_PIR_ALARM_INFO	stPirAlarmInfoEx[MAX_PIRPARAM_NUM];						// For device with multiple pirs, up to 10
} NET_OUT_GET_PIR_ALARM_PARAM;

// input parameter of interface CLIENT_SetPirAlarmParam 
typedef struct tagNET_IN_SET_PIR_ALARM_PARAM
{
	DWORD				dwSize;
	int					nChannel;									// channel
	NET_PIR_ALARM_INFO	stPirAlarmInfo;								// PIR config info
	int					nPirAlarmNum;								// number of settings
	NET_PIR_ALARM_INFO	stPirAlarmInfoEx[MAX_PIRPARAM_NUM];						// For device with multiple pirs, up to 10
} NET_IN_SET_PIR_ALARM_PARAM;

// output parameter of interface CLIENT_SetPirAlarmParam
typedef struct tagNET_OUT_SET_PIR_ALARM_PARAM
{
	DWORD				dwSize;
} NET_OUT_SET_PIR_ALARM_PARAM;

// interface of get PIR Alarm param
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetPirAlarmParam(LLONG lLoginID, const NET_IN_GET_PIR_ALARM_PARAM *pstInParam, NET_OUT_GET_PIR_ALARM_PARAM *pstOutParam, int nWaitTime);

// interface of set PIR Alarm param
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetPirAlarmParam(LLONG lLoginID, const NET_IN_SET_PIR_ALARM_PARAM *pstInParam, NET_OUT_SET_PIR_ALARM_PARAM *pstOutParam, int nWaitTime);

//Onvif User Group
typedef enum tagEM_GROUP_TYPE
{				  
	EM_GROUP_TYPE_UNKNOWN,		// UnKnown
	EM_GROUP_TYPE_ADMIN,		// admin
	EM_GROUP_TYPE_OPERATOR,		// operator
	EM_GROUP_TYPE_USER,			// user
	EM_GROUP_TYPE_ANONYMOUS,	// anonymous
} EM_GROUP_TYPE;

// motion data
typedef struct tagNET_MOTION_DATA
{
	int				    nRegionID;									// Region ID
	int                 nThreshold;                                 // Threshold, range [0, 100]
	BYTE				byReserved[512];							// reserved
} NET_MOTION_DATA;

//Onvif New user information
typedef struct tagNET_ONVIF_USER_INFO
{
	char			szName[DH_COMMON_STRING_128];						// User name
	char			szPassword[DH_COMMON_STRING_128];					// password
	NET_TIME		stuPasswordModifiedTime;							// Recently modified password time
	EM_GROUP_TYPE	emGroupType;										// User Group
	BOOL			bReserved;											// if the user keeps the user, the user must not be deleted
	BYTE			byReserved[512];									// reserved
} NET_ONVIF_USER_INFO;

// Modify onvif user, CLIENT_ModifyOnvifUser Entry parameter
typedef struct tagNET_IN_MODIFYONVIF_USER_INFO
{
	DWORD					dwSize;											// struct size
	char					szName[DH_COMMON_STRING_128];					// User name that needs to be modified
	NET_ONVIF_USER_INFO		stUserInfo;										// New user information
} NET_IN_MODIFYONVIF_USER_INFO;

// Modify onvif user, CLIENT_ModifyOnvifUser Output parameter
typedef struct tagNET_OUT_MODIFYONVIF_USER_INFO
{
	DWORD				dwSize;					// struct size
} NET_OUT_MODIFYONVIF_USER_INFO;

// Get all onvif user information, CLIENT_GetOnvifUserInfoAll Enter parameter
typedef struct tagNET_IN_GETONVIF_USERINFO_ALL_INFO
{
	DWORD				dwSize;			// struct size
} NET_IN_GETONVIF_USERINFO_ALL_INFO;

// Get all onvif user information, CLIENT_GetOnvifUserInfoAll Output parameter
typedef struct tagNET_OUT_GETONVIF_USERINFO_ALL_INFO
{
	DWORD					dwSize;										// struct size
	int						nRetUserInfoNumber;							// The number of this query
	NET_ONVIF_USER_INFO		stuUserInfo[MAX_ONVIF_USER_NUM];			// User information list(unable to get password information)
} NET_OUT_GETONVIF_USERINFO_ALL_INFO;

// Modify the Onvif user password CLIENT_ModifyOnvifUserPassword Enter parameter
typedef struct tagNET_IN_MODIFYONVIF_PASSWORD_INFO
{
	DWORD				dwSize;							// struct size
	char				szName[DH_COMMON_STRING_128];	// User name
	char				szPwd[DH_COMMON_STRING_128];	// User password
	char				szPwdOld[DH_COMMON_STRING_128];	// old password
} NET_IN_MODIFYONVIF_PASSWORD_INFO;

// Modify the Onvif user password, CLIENT_ModifyOnvifUserPassword Output parameter
typedef	struct tagNET_OUT_MODIFYONVIF_PASSWORD_INFO
{
	DWORD				dwSize;							// struct size
} NET_OUT_MODIFYONVIF_PASSWORD_INFO;

// Modify onvif user(Only non-admin users can be modified), pstInParampstOutParam  The memory is applied and released by the user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ModifyOnvifUser(LLONG lLoginID, const NET_IN_MODIFYONVIF_USER_INFO *pstInParam, NET_OUT_MODIFYONVIF_USER_INFO *pstOutParam, int nWaitTime);

// Get all onvif user information, pstInParampstOutParam  The memory is applied and released by the user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetOnvifUserInfoAll(LLONG lLoginID, const NET_IN_GETONVIF_USERINFO_ALL_INFO *pstInParam, NET_OUT_GETONVIF_USERINFO_ALL_INFO *pstOutParam, int nWaitTime);

// Modify the Onvif user password, pstInParampstOutParam  The memory is applied and released by the user
CLIENT_NET_API	BOOL CALL_METHOD CLIENT_ModifyOnvifUserPassword(LLONG lLoginID, const NET_IN_MODIFYONVIF_PASSWORD_INFO *pstInParam, NET_OUT_MODIFYONVIF_PASSWORD_INFO *pstOutParam, int nWaitTime);

// Max count of motion data
#define	MAX_MOTION_DATA_COUNT	4

// callback data of Attach Motion Data
typedef struct tagNET_CB_MOTION_DATA
{
	DWORD				dwSize;
	int				    nMotionDataCount;							// Motion data count
	NET_MOTION_DATA		stMotionData[MAX_MOTION_DATA_COUNT];		// Motion data
	int					nRegionRow;									// Region Row number
	int					nRegionCol;									// Region Col number
	BYTE				byRegion[DH_MOTION_ROW][DH_MOTION_COL];		// Region area
} NET_CB_MOTION_DATA;

// the callback function of Attach Motion Data, lAttachHandle is the returned value of CLIENT_attachMotionData
typedef void (CALLBACK *fAttachMotionDataCB) (LLONG lAttachHandle, NET_CB_MOTION_DATA* pBuf, LDWORD dwUser);

// CLIENT_AttachMotionData input param
typedef struct tagNET_IN_ATTACH_MOTION_DATA
{
    DWORD                   dwSize;
	int						nChannel;						// channel number
    fAttachMotionDataCB	    cbNotify;						// callback function
    LDWORD                  dwUser;                         // userdata
} NET_IN_ATTACH_MOTION_DATA;

// CLIENT_AttachMotionData output param
typedef struct tagNET_OUT_ATTACH_MOTION_DATA
{
    DWORD                   dwSize;
} NET_OUT_ATTACH_MOTION_DATA;

// Attach Motion Data
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachMotionData(LLONG lLoginID, const NET_IN_ATTACH_MOTION_DATA* pstInParam, NET_OUT_ATTACH_MOTION_DATA *pstOutParam, int nWaitTime);

// Detach Motion Data, lAttachHandle is the returned value of CLIENT_attachMotionData
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachMotionData(LLONG lAttachHandle);

// Insruction source
typedef enum tagEM_SRC_INSRUCTION
{
    EM_SRC_INSRUCTION_VTO_CALL,                      // VTO Call
    EM_SRC_INSRUCTION_VTO_CARD,                      // VTO Card
    EM_SRC_INSRUCTION_LIFT_CARD,                     // Lift Card
    EM_SRC_INSRUCTION_VTH_CALL,                      // VTH Call Lift
    EM_SRC_INSRUCTION_VTO_FINGERPRINT,               // VTO FingerPrint
    EM_SRC_INSRUCTION_VTO_PSW,                       // VTO Password
}EM_SRC_INSRUCTION;
// input of CLIENT_CallLift
typedef struct tagNET_IN_LIFTCONTROL_CALLLIFT_INFO
{
    DWORD				    dwSize;
    char                    szFloorNo[4];                   // Floor number
    char                    szRoomNo[12];                   // Room ID
    char                    szUserID[8];                    // User ID
    char                    szCardNo[32];                   // Card No
    EM_SRC_INSRUCTION       emSrcInstruction;               // Instruction source
}NET_IN_LIFTCONTROL_CALLLIFT_INFO;
// output of CLIENT_CallLift 
typedef struct tagNET_OUT_LIFTCONTROL_CALLLIFT_INFO
{
    DWORD				    dwSize;
}NET_OUT_LIFTCONTROL_CALLLIFT_INFO;
// Call lift 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CallLift(LLONG lLoginID, const NET_IN_LIFTCONTROL_CALLLIFT_INFO *pstInParam, NET_OUT_LIFTCONTROL_CALLLIFT_INFO *pstOutParam, int nWaitTime);
// input of CLIENT_ControlLift 
typedef struct tagNET_IN_LIFTCONTROL_CONTROLLIFT_INFO
{
    DWORD				    dwSize;
    int                     nFloorNum;                      // Floor number           
    char                    szFloorNo[32][4];               // Floor
    char                    szRoomNo[12];                   // Room ID
    char                    szUserID[8];                    // User ID
    char                    szCardNo[32];                   // Card No
    EM_SRC_INSRUCTION       emSrcInstruction;               // Instruction source
}NET_IN_LIFTCONTROL_CONTROLLIFT_INFO;
// output of CLIENT_ControlLift 
typedef struct tagNET_OUT_LIFTCONTROL_CONTROLLIFT_INFO
{
    DWORD				    dwSize;
}NET_OUT_LIFTCONTROL_CONTROLLIFT_INFO;
// control lift
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ControlLift(LLONG lLoginID, const NET_IN_LIFTCONTROL_CONTROLLIFT_INFO *pstInParam, NET_OUT_LIFTCONTROL_CONTROLLIFT_INFO *pstOutParam, int nWaitTime);

// wireless config
typedef enum tagNET_ENUM_LOWRATEWPAN_CONFIG
{
    NET_ENUM_LOWRATEWPAN_ACCESS_WORKMODE,               // Workmode, corresponding to NET_LOWRATEWPAN_WORKMODE
}NET_ENUM_LOWRATEWPAN_CONFIG;

// workmode
typedef enum tagNET_ENUM_LOWRATEWPAN_WORKMODE
{
    NET_ENUM_LOWRATEWPAN_WORKMODE_UNKNOWN,              // unknown
    NET_ENUM_LOWRATEWPAN_WORKMODE_NORMAL,               // normal
    NET_ENUM_LOWRATEWPAN_WORKMODE_CLEAN,				// clean
    NET_ENUM_LOWRATEWPAN_WORKMODE_DECORATION,			// decoration
    NET_ENUM_LOWRATEWPAN_WORKMODE_UNUSED,				// unused
    NET_ENUM_LOWRATEWPAN_WORKMODE_OUTSTANDING,			// out standing
}NET_ENUM_LOWRATEWPAN_WORKMODE;

// workmode config
typedef struct tagNET_LOWRATEWPAN_WORKMODE
{
    DWORD				                dwSize;
    NET_ENUM_LOWRATEWPAN_WORKMODE       emWorkMode;                 // work Mode
}NET_LOWRATEWPAN_WORKMODE;

// get wireless config
CLIENT_NET_API  BOOL CALL_METHOD CLIENT_GetLowRateWPANConfig(LLONG lLoginID,NET_ENUM_LOWRATEWPAN_CONFIG emType,char* SN,void* szOutBuffer, DWORD dwOutBufferSize, int nWaitTime, void *reserve);

// set wireless config
CLIENT_NET_API  BOOL CALL_METHOD CLIENT_SetLowRateWPANConfig(LLONG lLoginID,NET_ENUM_LOWRATEWPAN_CONFIG emType,char* SN,void* szInBuffer, DWORD dwInBufferSize, int nWaitTime, int *restart, void *reserve);

// input of CLIENT_GetVideoDiagnosisState
typedef struct tagNET_IN_GET_VIDEODIAGNOSIS_STATE
{
     DWORD				            dwSize;                                     // the size of this struct
     char                           szProject[128];                             // project name, null means all Project
}NET_IN_GET_VIDEODIAGNOSIS_STATE;

// VideoDiagnosis State
typedef struct tagVIDEODIAGNOSIS_STATE
{
    BOOL                            bEnable;                                     // enable
    BOOL                            bRunning;                                    // Running or not. Enabled.There is task in process and there is no error.
    char                            szCurrentProject[MAX_PATH];                  // Current project name
    char                            szCurrentTask[MAX_PATH];                     // Current task name
    char                            szCurrentProfile[MAX_PATH];                  // Current task parameter list name
    int                             nCurrentSourceCount;                         // Current task tour video sources amount
    int                             nCurrentSourceIndex;                         // Current task video source number. Starts from 0
    DH_TSECT                        stCurrentTimeSection;                        // Current project period
    int                             nTaskCountOfProject;                         // Current task amount of project
    int                             nIndexOfCurrentTask;                         // Current project number, Starts from 0
    BYTE				            byReserved[512];							 // reserved
}VIDEODIAGNOSIS_STATE;

// output of CLIENT_GetVideoDiagnosisState
typedef struct tagNET_OUT_GET_VIDEODIAGNOSIS_STATE
{
    DWORD				            dwSize;                                      // the size of this struct   
    VIDEODIAGNOSIS_STATE            stuState[2];                                 // index 0:Tour 1:RealTime                         
}NET_OUT_GET_VIDEODIAGNOSIS_STATE;
// GetVideoDiagnosisState
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetVideoDiagnosisState(LLONG lLoginID, const NET_IN_GET_VIDEODIAGNOSIS_STATE *pstInParam, NET_OUT_GET_VIDEODIAGNOSIS_STATE *pstOutParam, int nWaitTime);

#define LOGIN_TYPE_DEVICE_NOT_SUPPORT 100			// device not support the Login Type
// Callback of CLIENT_PostLoginTask 
typedef struct tagNET_POST_LOGIN_TASK
{
	LLONG						lLoginID;			//device login ID
	char*						pchDVRIP;			//device ip
	LONG						nDVRPort;			//device port
	BOOL						bOnline;			//device state. bOnline:TRUE,login success; FALSE,login fail.
	NET_DEVICEINFO_Ex			stuDeviceInfo;		//Device extension info 
	int							nError;				//bOnline:TRUE,login success; FALSE,login fail. When login failed, the meaning of nError relate to the error code in CLIENT_Login
													//meanwhile nError is LOGIN_TYPE_DEVICE_NOT_SUPPORT meaning the device not support the login type
	char						szReserve[1024];	//reserved
}NET_POST_LOGIN_TASK;

typedef void (CALLBACK *fPostLoginTask)(DWORD dwTaskID, NET_POST_LOGIN_TASK* pOutParam, LDWORD dwUser);

typedef enum tagEM_TCP_LOGIN_CONFIG_TYPE
{
	EM_TCP_LOGIN_CONFIG_TYPE_UNKNOWN = 0,			// unknown configure type
	EM_TCP_LOGIN_CONFIG_TYPE_MULTICAST,				// multicast configure
}EM_TCP_LOGIN_CONFIG_TYPE;

// input of CLIENT_PostLoginTask
typedef struct tagNET_IN_POST_LOGIN_TASK
{
	DWORD						dwSize;				// struct size:assignment when init the struct
	char						szReserve1[4];		// reserved
	char*						szIp;				// device ip
	unsigned int				nPort;				// port
	char						szReserve2[4];		// reserved
	char*						szName;				// user name
	char*						szPwd;				// password
	EM_LOGIN_SPAC_CAP_TYPE		emSpecCap;			// login type,currently only support EM_LOGIN_SPEC_CAP_TCP 
													// EM_LOGIN_SPEC_CAP_MAIN_CONN_ONLY and EM_LOGIN_SPEC_CAP_P2P
	EM_TCP_LOGIN_CONFIG_TYPE	emConfigType;		// configure to get when emSpecCap is EM_LOGIN_SPEC_CAP_TCP, configure relate to stream
													// EM_TCP_LOGIN_CONFIG_TYPE_UNKNOWN:stream transmits by TCP; EM_TCP_LOGIN_CONFIG_TYPE_MULTICAST:stream transmits by multicast
	fPostLoginTask				cbLogin;			// callback
	void*						pUser;				// user data
	BOOL						bHighLevelSecurity;	// high level security
	BYTE						byReserved[132];	// reserved
}NET_IN_POST_LOGIN_TASK;

// output of CLIENT_PostLoginTask 
typedef struct tagNET_OUT_POST_LOGIN_TASK 
{
	DWORD       dwSize;								// struct size:assignment when init the struct
}NET_OUT_POST_LOGIN_TASK;

// post async login task
CLIENT_NET_API DWORD CALL_METHOD CLIENT_PostLoginTask(const NET_IN_POST_LOGIN_TASK* pInParam, NET_OUT_POST_LOGIN_TASK* pOutParam);

// cancel async login taskdwTaskID is returned by CLIENT_PostLoginTask
CLIENT_NET_API BOOL CALL_METHOD  CLIENT_CancelLoginTask(DWORD dwTaskID);

/****************************** start western Europe alarm interface don't compatible with old interface***************************************/
// CLIENT_GetAlarmRegionInfo NET_EM_GET_ALARMREGION_INFO_ALARMCAPS input param
typedef struct tagNET_IN_GET_ALARMCAPS
{
	DWORD			dwSize;				// struct 
}NET_IN_GET_ALARMCAPS;



// CLIENT_GetAlarmRegionInfo NET_EM_GET_ALARMREGION_INFO_ALARMCAPS output param
typedef struct tagNET_OUT_GET_ALARMCAPS
{
	DWORD			dwSize;				// struct size
	int             nSiren;             // supported siren number

	int             nAlarmIn;           // supported input alarm number
	int             nAlarmOut;          // supported output alarm number
	int             nRemoteControl;     // supported remotecontrol number
}NET_OUT_GET_ALARMCAPS;

// CLIENT_GetAlarmRegionInfo NET_EM_GET_ALARMREGION_INFO_ARMMODE input param
typedef struct tagNET_IN_GET_ALARMMODE
{
	DWORD			dwSize;				// struct size
}NET_IN_GET_ALARMMODE;

// armmode information
typedef struct tagNET_ARMMODE_INFO
{
	EM_ARM_STATE   emArmState;   	     // arm state
	BYTE           byReserved[1024];     // reserved
}NET_ARMMODE_INFO;

// CLIENT_GetAlarmRegionInfo NET_EM_GET_ALARMREGION_INFO_ARMMODE output param
typedef struct tagNET_OUT_GET_ALARMMODE
{
	DWORD			      dwSize;				                 // struct size
	int                   nArmModeRet;                           // arm state number
	NET_ARMMODE_INFO      stuArmMode[MAX_AREA_NUMBER];           // arm mode information
}NET_OUT_GET_ALARMMODE;

// arm type
typedef enum tagEM_ARM_TYPE
{
	EM_ARM_TYPE_UNKNOWN,           	   // unknown
	EM_ARM_TYPE_TOTAL_ARMING,          // Total arming
	EM_ARM_TYPE_PARTIAL1_ARMING,       // partial1 arming
	EM_ARM_TYPE_PARTIAL2_ARMING,       // partial2 arming
	EM_ARM_TYPE_DISARMING,             // disarming
}EM_ARM_TYPE;

// CLIENT_SetAlarmRegionInfo NET_EM_SET_ALARMREGION_INFO_ARMMODE input param
typedef struct tagNET_IN_SET_ALARMMODE
{
	DWORD			dwSize;				                // struct size
	EM_ARM_TYPE     emArmType;                          // arm type
	char            szPwd[256];                         // password
	int             nAreaNum;                           // area number
	int             arrAreas[MAX_AREA_NUMBER];          // area id
}NET_IN_SET_ALARMMODE;

// failed detail
typedef struct tagARM_FAILED_DETAIL
{
	int       nArea;                                      // failed area id
	int       nAlarmSourceRet;                            // alarm source return number
	int       arrAlarmSource[MAX_ZONE_NUMBER];            // alarm source number
	BYTE      byReserved[1024];                           // reserved
}ARM_FAILED_DETAIL;

// CLIENT_SetAlarmRegionInfo NET_EM_SET_ALARMREGION_INFO_ARMMODE output param
typedef struct tagNET_OUT_SET_ALARMMODE
{
	DWORD			      dwSize;			                  // struct size
	int                   nArmResult;                         // result 0:succeed 1:failed
	int                   nFailedAreaRet;                     // failed area number
	ARM_FAILED_DETAIL     stuFailedDetail[MAX_AREA_NUMBER];   // failed detail
}NET_OUT_SET_ALARMMODE;

// bypass mode type
typedef enum tagEM_BYPASSMODE_TYPE
{
	EM_BYPASSMODE_TYPE_UNKNOWN,          // unknown
	EM_BYPASSMODE_TYPE_OFF,              // off
	EM_BYPASSMODE_TYPE_ACTIVE,           // active
	EM_BYPASSMODE_TYPE_BYPASSED,         // bypassed
	EM_BYPASSMODE_TYPE_ISOLATED,         // isolated
	EM_BYPASSMODE_TYPE_TEST,             // test
}EM_BYPASSMODE_TYPE;

// CLIENT_SetAlarmRegionInfo NET_EM_SET_ALARMREGION_INFO_BYPASSMODE input param
typedef struct tagNET_IN_SET_BYPASSMODE
{
	DWORD			          dwSize;				      // struct size
	char                      szPwd[256];                 // password
	EM_BYPASSMODE_TYPE        emType;                     // bypass mode
	int                       nZoneNum;                   // zone number
	int                       arrZones[MAX_ZONE_NUMBER];  // zone id
}NET_IN_SET_BYPASSMODE;

// CLIENT_SetAlarmRegionInfo NET_EM_SET_ALARMREGION_INFO_BYPASSMODE output param
typedef struct tagNET_OUT_SET_BYPASSMODE
{
	DWORD			      dwSize;			                  // struct size
}NET_OUT_SET_BYPASSMODE;

// CLIENT_GetAlarmRegionInfo NET_EM_GET_ALARMREGION_INFO_BYPASSMODE input param
typedef struct tagNET_IN_GET_BYPASSMODE
{
	DWORD			          dwSize;				      // struct size
	int                       nZoneNum;                   // zone number
	int                       arrZones[MAX_ZONE_NUMBER];  // zone id
}NET_IN_GET_BYPASSMODE;

// CLIENT_GetAlarmRegionInfo NET_EM_GET_ALARMREGION_INFO_BYPASSMODE output param
typedef struct tagNET_OUT_GET_BYPASSMODE
{
	DWORD			      			dwSize;			                 // struct size
	int                   			nZoneRet;                        // zone number	
	EM_BYPASSMODE_TYPE        		arrModes[MAX_ZONE_NUMBER];       // bypass mode
}NET_OUT_GET_BYPASSMODE;

// CLIENT_GetAlarmRegionInfo NET_EM_GET_ALARMREGION_INFO_AREAZONES input param
typedef struct tagNET_IN_GET_AREAZONES
{
	DWORD			          dwSize;				      // struct size
	int                       nAreaNum;                   // area number
	int                       arrArea[MAX_AREA_NUMBER];   // area id
}NET_IN_GET_AREAZONES;

// area information
typedef struct tagNET_AREA_INFO
{
	int      		nArea;       // arae id
	int             nZoneRet;    // zone number
	int             arrZones[MAX_ZONE_NUMBER]; // zone id
	BYTE            byReserved[1024];		   // reserved
}NET_AREA_INFO;

// CLIENT_GetAlarmRegionInfo NET_EM_GET_ALARMREGION_INFO_AREAZONES output param
typedef struct tagNET_OUT_GET_AREAZONES
{
	DWORD			      			dwSize;			               // struct size
	int                             nAreaRet;                      // area number
	NET_AREA_INFO                   stuAreaInfo[MAX_AREA_NUMBER];  // area information
}NET_OUT_GET_AREAZONES;

// CLIENT_GetAlarmRegionInfo NET_EM_GET_ALARMREGION_INFO_ALLINSLOTS input param
typedef struct tagNET_IN_GET_ALLINSLOTS
{
	DWORD			          dwSize;				      // struct size
}NET_IN_GET_ALLINSLOTS;

// CLIENT_GetAlarmRegionInfo NET_EM_GET_ALARMREGION_INFO_ALLINSLOTS output param
typedef struct tagNET_OUT_GET_ALLINSLOTS
{
	DWORD			      			dwSize;			               // struct size
	int                             nLocol;                        // local zone number
	int                             nWired;                        // wired zone number
	int                             nWireless;                     // wireless zone number 
}NET_OUT_GET_ALLINSLOTS;

// CLIENT_GetAlarmRegionInfo NET_EM_GET_ALARMREGION_INFO_ALLOUTSLOTS input param
typedef struct tagNET_IN_GET_ALLOUTSLOTS
{
	DWORD			          dwSize;				      // struct size
}NET_IN_GET_ALLOUTSLOTS;

// CLIENT_GetAlarmRegionInfo NET_EM_GET_ALARMREGION_INFO_ALLOUTSLOTS output param
typedef struct tagNET_OUT_GET_ALLOUTSLOTS
{
	DWORD			      			dwSize;			               // struct size
	int                             nLocol;                        // local alarm output number
	int                             nWired;                        // wired alarm output number
}NET_OUT_GET_ALLOUTSLOTS;


// CLIENT_GetAlarmRegionInfo NET_EM_GET_ALARMREGION_INFO_ZONECONNECTIONSSTATUS input param
typedef struct tagNET_IN_GET_CONNECTIONSTATUS
{
	DWORD			          dwSize;				      // struct size
}NET_IN_GET_CONNECTIONSTATUS;

// CLIENT_GetAlarmRegionInfo NET_EM_GET_ALARMREGION_INFO_ZONECONNECTIONSSTATUS output param
typedef struct tagNET_OUT_GET_CONNECTIONSTATUS
{
	DWORD			      			dwSize;			               // struct size
	int                             nZoneRet;                      // zone number
	bool                            arrZoneStates[MAX_ZONE_NUMBER];// zone state false:offline true:online
}NET_OUT_GET_CONNECTIONSTATUS;

// get area status
typedef enum tagEM_GET_AREASSTATUS_TYPE
{
	EM_GET_AREASSTATUS_TYPE_UNKNOWN,     // unknown
	EM_GET_AREASSTATUS_TYPE_ACTIVE,      // active
	EM_GET_AREASSTATUS_TYPE_OPEN,        // open
}EM_GET_AREASSTATUS_TYPE;

// CLIENT_GetAlarmRegionInfo NET_EM_GET_ALARMREGION_INFO_AREASTATUS input param
typedef struct tagNET_IN_GET_AREAS_STATUS
{
	DWORD			            dwSize;				      // struct size
	EM_GET_AREASSTATUS_TYPE     emType;                   // get area status type
}NET_IN_GET_AREAS_STATUS;

//zone status
typedef enum tagEM_ZONE_STATUS
{
	EM_ZONE_STATUS_UNKNOWN, 	// unknown
	EM_ZONE_STATUS_ALARM,       // open
	EM_ZONE_STATUS_TAMPER,      // tamper
	EM_ZONE_STATUS_MASK,        // mask
	EM_ZONE_STATUS_SHORT, 		// short
}EM_ZONE_STATUS; 

//zone status
typedef struct tagNET_ZONE_STATUS
{
	int              nIndex;               // zone id
	EM_ZONE_STATUS	 emStatus;             // zone statu
	BYTE             byReserved[1024];     // reserved
}NET_ZONE_STATUS;

//area status
typedef struct tagNET_AREA_STATUS
{
	int               nArea;                                  // area id
	int               nZoneRet;                               // zone number
	NET_ZONE_STATUS   stuZoneStatus[MAX_ZONE_NUMBER];         // zone status
	BYTE              byReserved[1024];                       // reserved
}NET_AREA_STATUS;

// CLIENT_GetAlarmRegionInfo NET_EM_GET_ALARMREGION_INFO_AREASTATUS output param
typedef struct tagNET_OUT_GET_AREAS_STATUS
{
	DWORD			      dwSize;			   // struct size
	int                   nAreaRet;            // area size
	NET_AREA_STATUS       stuAreaStatus[MAX_AREA_NUMBER]; //area status   
}NET_OUT_GET_AREAS_STATUS;

// output channel type
typedef enum tagEM_OUTPUT_TYPE
{
	EM_OUTPUT_TYPE_UNKNOWN,      // unknown
	EM_OUTPUT_TYPE_SIREN,        // siren
	EM_OUTPUT_TYPE_ALARMOUT,     // out
}EM_OUTPUT_TYPE;

// CLIENT_GetAlarmRegionInfo NET_EM_GET_ALARMREGION_INFO_OUTPUTSTATE input param
typedef struct tagNET_IN_GET_OUTPUT_STATE
{
	DWORD			          dwSize;				      // struct size
	EM_OUTPUT_TYPE            emType;                     // channel type
}NET_IN_GET_OUTPUT_STATE;

//CLIENT_GetAlarmRegionInfo NET_EM_GET_ALARMREGION_INFO_OUTPUTSTATE output param
typedef struct tagNET_OUT_GET_OUTPUT_STATE
{
	DWORD			      			dwSize;			               // struct size
	int                             nStateRet;                     // state number
	bool                            arrStates[MAX_ZONE_NUMBER];    // state false:close  true:open
}NET_OUT_GET_OUTPUT_STATE;

// CLIENT_SetAlarmRegionInfo NET_EM_SET_ALARMREGION_INFO_OUTPUTSTATE input param
typedef struct tagNET_IN_SET_OUTPUT_STATE
{
	DWORD			          		dwSize;				           // struct size
	EM_OUTPUT_TYPE					emType; 					   // output type
	int 							nChannel;					   /* emType= EM_OUTPUT_TYPE_SIREN: siren
	emType= EM_OUTPUT_TYPE_ALARMOUT: channel id*/
	bool							action; 					   // output action false:close true:open
	BYTE							byReserved[3];				   // reserved
}NET_IN_SET_OUTPUT_STATE;

// CLIENT_SetAlarmRegionInfo NET_EM_SET_ALARMREGION_INFO_OUTPUTSTATE output param
typedef struct tagNET_OUT_SET_OUTPUT_STATE
{
	DWORD			      			dwSize;			               // struct size
}NET_OUT_SET_OUTPUT_STATE;

// CLIENT_GetAlarmRegionInfo NET_EM_GET_ALARMREGION_INFO_ZONESTROUBLE input param
typedef struct tagNET_IN_GET_ZONES_TROUBLE
{
	DWORD			          		dwSize;				      // struct size
}NET_IN_GET_ZONES_TROUBLE;

//zone trouble type
typedef enum tagEM_ZONE_TROUBLE_TYPE
{
	EM_ZONE_TROUBLE_TYPE_UNKNOWN,  // unknown
	EM_ZONE_TROUBLE_TYPE_TAMPER,   // tamper
	EM_ZONE_TROUBLE_TYPE_MASK,     // Mask
	EM_ZONE_TROUBLE_TYPE_SHORT,    // short
}EM_ZONE_TROUBLE_TYPE;

//trouble information
typedef struct tagNET_ZONE_TROUBLE_INFO
{
	int                    nIndex;           // zone id
	EM_ZONE_TROUBLE_TYPE   emTroubleType;    // trouble type
	BYTE                   byReserved[1024]; // reserved
}NET_ZONE_TROUBLE_INFO;

// CLIENT_GetAlarmRegionInfo NET_EM_GET_ALARMREGION_INFO_ZONESTROUBLE output param
typedef struct tagNET_OUT_GET_ZONES_TROUBLE
{
	DWORD			      			dwSize;			                  // struct size
	int                             nZoneRet;                         //zone number
	NET_ZONE_TROUBLE_INFO           stuTroubleInfo[MAX_ZONE_NUMBER];  // trouble information
}NET_OUT_GET_ZONES_TROUBLE;

//Type of get operate
typedef enum tagNET_EM_GET_ALARMREGION_INFO
{
	NET_EM_GET_ALARMREGION_INFO_UNKNOWN,						//Unknown
	NET_EM_GET_ALARMREGION_INFO_ALARMCAPS,						//Get alarm capability.			CLIENT_GetAlarmRegionInfo:(pstuInParam: NET_IN_GET_ALARMCAPS     pstuOutParam: NET_OUT_GET_ALARMCAPS)
	NET_EM_GET_ALARMREGION_INFO_ARMMODE,						//Get arm mode.					CLIENT_GetAlarmRegionInfo:(pstuInParam: NET_IN_GET_ALARMMODE   pstuOutParam: NET_OUT_GET_ALARMMODE)
	NET_EM_GET_ALARMREGION_INFO_BYPASSMODE,						//Get bypass mode.				CLIENT_GetAlarmRegionInfo:(pstuInParam: NET_IN_GET_BYPASSMODE    pstuOutParam: NET_OUT_GET_BYPASSMODE)
	NET_EM_GET_ALARMREGION_INFO_AREAZONES,						//Get area zones.				CLIENT_GetAlarmRegionInfo:(pstuInParam: NET_IN_GET_AREAZONES    pstuOutParam: NET_OUT_GET_AREAZONES)
	NET_EM_GET_ALARMREGION_INFO_ALLINSLOTS,						//Get all in slots.				CLIENT_GetAlarmRegionInfo:(pstuInParam: NET_IN_GET_ALLINSLOTS    pstuOutParam: NET_OUT_GET_ALLINSLOTS)
	NET_EM_GET_ALARMREGION_INFO_ALLOUTSLOTS,					//Get all out slots.			CLIENT_GetAlarmRegionInfo:(pstuInParam: NET_IN_GET_ALLOUTSLOTS    pstuOutParam: NET_OUT_GET_ALLOUTSLOTS)
	NET_EM_GET_ALARMREGION_INFO_ZONECONNECTIONSSTATUS,			//Get zone connection status.	CLIENT_GetAlarmRegionInfo:(pstuInParam: NET_IN_GET_CONNECTIONSTATUS    pstuOutParam: NET_OUT_GET_CONNECTIONSTATUS)
	NET_EM_GET_ALARMREGION_INFO_AREASTATUS,						//Get area status.				CLIENT_GetAlarmRegionInfo:(pstuInParam: NET_IN_GET_AREAS_STATUS    pstuOutParam: NET_OUT_GET_AREAS_STATUS)
	NET_EM_GET_ALARMREGION_INFO_OUTPUTSTATE,					//Get output state.				CLIENT_GetAlarmRegionInfo:(pstuInParam: NET_IN_GET_OUTPUT_STATE    pstuOutParam: NET_OUT_GET_OUTPUT_STATE)
	NET_EM_GET_ALARMREGION_INFO_ZONESTROUBLE,					//Get zones trouble.			CLIENT_GetAlarmRegionInfo:(pstuInParam: NET_IN_GET_ZONES_TROUBLE    pstuOutParam: NET_OUT_GET_ZONES_TROUBLE)
}NET_EM_GET_ALARMREGION_INFO;

//Get operate of alarm region 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetAlarmRegionInfo(LLONG lLoginID, NET_EM_GET_ALARMREGION_INFO emType,const void *pstuInParam,void *pstuOutParam, int nWaitTime);

//Type of set operate
typedef enum tagNET_EM_SET_ALARMREGION_INFO
{
	NET_EM_SET_ALARMREGION_INFO_UNKNOWN,						//Unknown				
	NET_EM_SET_ALARMREGION_INFO_ARMMODE,						//Set arm mode			CLIENT_SetAlarmRegionInfo:(pstuInParam: NET_IN_SET_ALARMMODE    pstuOutParam: NET_OUT_SET_ALARMMODE)
	NET_EM_SET_ALARMREGION_INFO_BYPASSMODE,						//Set bypass mode		CLIENT_SetAlarmRegionInfo:(pstuInParam: NET_IN_SET_BYPASSMODE    pstuOutParam: NET_OUT_SET_BYPASSMODE)
	NET_EM_SET_ALARMREGION_INFO_OUTPUTSTATE,					//Set output state		CLIENT_SetAlarmRegionInfo:(pstuInParam: NET_IN_SET_OUTPUT_STATE    pstuOutParam: NET_OUT_SET_OUTPUT_STATE)
}NET_EM_SET_ALARMREGION_INFO;

//Set operate of alarm region 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetAlarmRegionInfo(LLONG lLoginID, NET_EM_SET_ALARMREGION_INFO emType,const void *pstuInParam,void *pstuOutParam, int nWaitTime);
/****************************** end western Europe alarm interface dont'n compatible with old interface***************************************/


// device notify type
typedef enum tagEM_DEVICE_NOTIFY_TYPE
{
	EM_DEVICE_NOTIFY_TYPE_UNKNOWN,							// unknown
	EM_DEVICE_NOTIFY_TYPE_NEW,								// new
	EM_DEVICE_NOTIFY_TYPE_UPDATE,							// update
	EM_DEVICE_NOTIFY_TYPE_REMOVE,							// remove
	EM_DEVICE_NOTIFY_TYPE_CONNECT,							// connect
} EM_DEVICE_NOTIFY_TYPE;

// fDeviceStateCallBack parameter
typedef struct tagNET_CB_ATTACH_DEVICE_STATE
{
	EM_DEVICE_NOTIFY_TYPE   		emNotifyType;    									// notify type
	int 							nRetCount;											// device num
	char							szDeviceIDs[MAX_LINK_DEVICE_NUM][DH_DEV_ID_LEN_EX];	// device id list
	BYTE 							byReserved[512];    								// reserved
}NET_CB_ATTACH_DEVICE_STATE;

// attach device state callback function,lAttachHandle is the returned value of CLIENT_AttachDeviceState, pstDeviceState is the returned value of deviceInfo
typedef void (CALLBACK *fDeviceStateCallBack)(LLONG lAttachHandle, NET_CB_ATTACH_DEVICE_STATE* pstDeviceState, LDWORD dwUser);

// input parameter of interface CLIENT_AttachDeviceState
typedef struct tagNET_IN_ATTACH_DEVICE_STATE
{
	DWORD                           dwSize;
	fDeviceStateCallBack         	cbDeviceState; 		// the callback function of attach device state
	LDWORD                          dwUser;             // user data
}NET_IN_ATTACH_DEVICE_STATE;

// output parameter of interface CLIENT_AttachDeviceState
typedef struct  tagNET_OUT_ATTACH_DEVICE_STATE
{
	DWORD           dwSize;
}NET_OUT_ATTACH_DEVICE_STATE;

// input parameter of interface CLIENT_AsyncAddDevice
typedef struct tagNET_IN_ASYNC_ADD_DEVICE
{
	DWORD                           dwSize;
	int								nCount;														//url num
	char         					szUrls[MAX_ADD_DEVICE_NUM][MAX_COMMON_STRING_512]; 			//urlsprotocol://username:password@IP:port(the port is default as protocol port)
}NET_IN_ASYNC_ADD_DEVICE;

// output parameter of interface CLIENT_AsyncAddDevice
typedef struct  tagNET_OUT_ASYNC_ADD_DEVICE
{
	DWORD           				dwSize;
	UINT							nTaskID;		// task ID
}NET_OUT_ASYNC_ADD_DEVICE;

// device add state
typedef enum tagEM_DEVICE_ADD_STATE
{
	EM_DEVICE_ADD_STATE_UNKNOWN,							// unknow
	EM_DEVICE_ADD_STATE_WAIT,								// wait
	EM_DEVICE_ADD_STATE_CONNECT,							// connect
	EM_DEVICE_ADD_STATE_FAILURE,							// failure 
	EM_DEVICE_ADD_STATE_SUCCESS,							// success
	EM_DEVICE_ADD_STATE_STOP,								// stop
} EM_DEVICE_ADD_STATE;

// fAddDeviceCallBack parameter
typedef struct tagNET_CB_ATTACH_ADD_DEVICE
{
	UINT                	nTaskID;       				// task ID
	EM_DEVICE_ADD_STATE		emAddState;					// device add state
	UINT					nIndex;						// device index in task(start 0)
	BYTE 					byReserved[512];            // reserved
}NET_CB_ATTACH_ADD_DEVICE;


// attach add device callback function,lAttachHandle is the returned value of CLIENT_AttachAddDevice, pstAddDevice is the returned value of deviceInfo
typedef void (CALLBACK *fAddDeviceCallBack)(LLONG lAttachHandle, NET_CB_ATTACH_ADD_DEVICE* pstAddDevice, LDWORD dwUser);

// input parameter of interface CLIENT_AttachAddDevice
typedef struct tagNET_IN_ATTACH_ADD_DEVICE
{
	DWORD                           dwSize;
	fAddDeviceCallBack         		cbAddDevice; 		// the callback function of attach add device 
	LDWORD                          dwUser;             // user data
}NET_IN_ATTACH_ADD_DEVICE;

// output parameter of interface CLIENT_AttachAddDevice
typedef struct  tagNET_OUT_ATTACH_ADD_DEVICE
{
	DWORD           dwSize;
}NET_OUT_ATTACH_ADD_DEVICE;

// input parameter of interface CLIENT_GetAddDeviceInfo
typedef struct tagNET_IN_GET_ADD_DEVICE_LIST_INFO
{
	DWORD                           dwSize;
	UINT 							nTaskID;					// task ID
	int								nCount;						// device num
	UINT							nIndex[MAX_ADD_DEVICE_NUM];	// device serial list(the index of NET_IN_ADD_DEVICE'szUrls start 0)
}NET_IN_GET_ADD_DEVICE_LIST_INFO;

// the result information of add device
typedef struct tagNET_GET_ADD_DEVICE_INFO
{
	char                	szDeviceID[DH_DEV_ID_LEN_EX];       // device ID
	char                	szUrl[DH_COMMON_STRING_512];        // url
	EM_DEVICE_ADD_STATE		emAddState;							// add state
	UINT					nErrorCode;							// error code
	BYTE 					byReserved[512];                    // reserved
}NET_GET_ADD_DEVICE_INFO;

// output parameter of interface CLIENT_GetAddDeviceInfo
typedef struct tagNET_OUT_GET_ADD_DEVICE_LIST_INFO
{
	DWORD                           dwSize;
	int 							nRetCount;          				// return count from device
	NET_GET_ADD_DEVICE_INFO			stuDeviceInfo[MAX_ADD_DEVICE_NUM];	// device info list
}NET_OUT_GET_ADD_DEVICE_LIST_INFO;

// input parameter of interface CLIENT_GetDeviceInfo
typedef struct tagNET_IN_GET_DEVICE_LIST_INFO
{
	DWORD                           dwSize;
	int 							nCount;												// device num
	char							szDeviceIDs[MAX_LINK_DEVICE_NUM][DH_DEV_ID_LEN_EX];	// device id list
}NET_IN_GET_DEVICE_LIST_INFO;

// the result information of added device
typedef struct tagNET_GET_DEVICE_INFO
{
	char                szDeviceID[DH_DEV_ID_LEN_EX];           		// device ID
	char                szUrl[DH_COMMON_STRING_512];           			// url
	char                szSerialNo[DH_COMMON_STRING_32];           		// serial number
	char                szDeviceType[DH_COMMON_STRING_64];      		// device type
	char                szDeviceClass[DH_DEV_CLASS_LEN];        		// device class
	int					nMacCount;										// device mac num	
	char                szMacs[MAX_MACADDR_NUM][DH_MACADDR_LEN];     	// device mac list
	char                szDevSoftVersion[DH_COMMON_STRING_128];       	// device software version
	char                szDeviceName[DH_DEV_NAME_LEN];          		// device name
	char                szDetail[DH_COMMON_STRING_512];          		// device detail
	UINT                nVideoInputCh;                          		// video input channels num
	UINT               	nVideoOutputCh;                         		// video output channels num
	UINT               	nAudioInputCh;                          		// audio input channels num
	UINT               	nAudioOutputCh;                         		// audio output channels num
	UINT               	nAlarmInputCh;                          		// alarm input channels num
	UINT                nAlarmOutputCh;                         		// alarm output channels num
	UINT				nErrorCode;										// device off-line error code
	UINT				nVtoDoors;										// entrance guard vto door total num
	BYTE				byOnline;										// whether the device is online 0:off-line 1:online
	BYTE 				byReserved[511];                    			// reserved
}NET_GET_DEVICE_INFO;

// output parameter of interface CLIENT_GetDeviceInfo
typedef struct tagNET_OUT_GET_DEVICE_LIST_INFO
{
	DWORD                           dwSize;
	int								nMaxCount;								// the count of the device in the user application
	int 							nRetCount;          					// return count from device
	NET_GET_DEVICE_INFO*			pstuDeviceInfo;							// device info list, user malloc and free the memory,apply to sizeof(NET_GET_DEVICE_INFO)*nMaxCount

}NET_OUT_GET_DEVICE_LIST_INFO;

// input parameter of interface CLIENT_SetConnectChannel
typedef struct tagNET_IN_SET_CONNECT_CHANNEL
{
	DWORD               dwSize;
	char                szDeviceID[DH_DEV_ID_LEN_EX];    	// device ID
	int					nCount;								// channel num
	UINT            	nChannels[MAX_DEVICE_CHANNEL_NUM];  // channel list
}NET_IN_SET_CONNECT_CHANNEL;

// output parameter of interface CLIENT_SetConnectChannel
typedef struct tagNET_OUT_SET_CONNECT_CHANNEL
{
	DWORD                           dwSize;
}NET_OUT_SET_CONNECT_CHANNEL;

// input parameter of interface CLIENT_GetChannelInfo
typedef struct tagNET_IN_GET_CHANNEL_INFO
{
	DWORD               dwSize;
	char                szDeviceID[DH_DEV_ID_LEN_EX];    	// device ID
}NET_IN_GET_CHANNEL_INFO;

// the result information of device channel
typedef struct tagNET_GET_CHANNEL_INFO
{
	UINT                nRemoteChannel;           						// remote channel
	int                 nLogicChannel;           						// logic channel, -1 means not allocation
	char                szName[DH_DEV_NAME_LEN];          				// name
	char                szDetail[DH_COMMON_STRING_512];          		// device detail
	char                szDeviceType[DH_COMMON_STRING_64];      		// device type
	char                szDeviceClass[DH_DEV_CLASS_LEN];        		// device class
	char                szIP[DH_MAX_IPADDR_LEN];          				// ip
	char                szMac[DH_MACADDR_LEN];     						// device mac address
	char                szSerialNo[DH_DEV_SERIALNO_LEN];           		// serial number
	char                szDevSoftVersion[DH_COMMON_STRING_128];       	// device software version
	UINT                nVideoInputCh;                          		// video input channels num
	UINT               	nVideoOutputCh;                         		// video output channels num
	UINT               	nAudioInputCh;                          		// audio input channels num
	UINT               	nAudioOutputCh;                         		// audio output channels num
	UINT               	nAlarmInputCh;                          		// alarm input channels num
	UINT                nAlarmOutputCh;                         		// alarm output channels num 
	BYTE				byOnline;										// whether the channel is online 0:off-line 1:online
	BYTE				byUsed;											// whether the channel is used by local device 0:unuse 1:used
	BYTE 				byReserved[510];                    			// reserved
}NET_GET_CHANNEL_INFO;

// output parameter of interface CLIENT_GetChannelInfo
typedef struct tagNET_OUT_GET_CHANNEL_INFO
{
	DWORD                           dwSize;
	int								nMaxCount;									// the count of the channel in the user application
	int								nRetCount;									// return channel count from device
	NET_GET_CHANNEL_INFO*			pstuChannelInfo;							// channel info list, user malloc and free the memory,apply to sizeof(NET_GET_CHANNEL_INFO)*nMaxCount
}NET_OUT_GET_CHANNEL_INFO;

// input parameter of interface CLIENT_RemoveDevice
typedef struct tagNET_IN_REMOVE_DEVICE
{
	DWORD                           dwSize;
	int 							nCount;													// device num
	char							szDeviceIDs[MAX_LINK_DEVICE_NUM][DH_DEV_ID_LEN_EX];		// device id list
}NET_IN_REMOVE_DEVICE;

// output parameter of interface CLIENT_RemoveDevice
typedef struct  tagNET_OUT_REMOVE_DEVICE
{
	DWORD           dwSize;
}NET_OUT_REMOVE_DEVICE;

// input parameter of interface CLIENT_CancelAddDeviceTask
typedef struct tagNET_IN_CANCEL_ADD_TASK
{
	DWORD                           dwSize;
	UINT 							nTaskID;		 // task ID
}NET_IN_CANCEL_ADD_TASK;

// output parameter of interface CLIENT_CancelAddDeviceTask
typedef struct  tagNET_OUT_CANCEL_ADD_TASK
{
	DWORD           dwSize;
}NET_OUT_CANCEL_ADD_TASK;

// input parameter of interface CLIENT_ConfirmAddDeviceTask
typedef struct tagNET_IN_CONFIRM_ADD_TASK
{
	DWORD                           dwSize;
	UINT 							nTaskID;		 // task ID
}NET_IN_CONFIRM_ADD_TASK;

// output parameter of interface CLIENT_ConfirmAddDeviceTask
typedef struct  tagNET_OUT_CONFIRM_ADD_TASK
{
	DWORD           dwSize;
}NET_OUT_CONFIRM_ADD_TASK;

// interface of attach device state
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachDeviceState(LLONG lLoginID, const NET_IN_ATTACH_DEVICE_STATE *pInParam, NET_OUT_ATTACH_DEVICE_STATE *pOutParam, int nWaitTime);

// interface of detach device state
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachDeviceState(LLONG lAttachHandle);

// interface of async add device
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AsyncAddDevice(LLONG lLoginID, const NET_IN_ASYNC_ADD_DEVICE *pInParam, NET_OUT_ASYNC_ADD_DEVICE *pOutParam, int nWaitTime);

// interface of attach add device
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachAddDevice(LLONG lLoginID, const NET_IN_ATTACH_ADD_DEVICE *pInParam, NET_OUT_ATTACH_ADD_DEVICE *pOutParam, int nWaitTime);

// interface of detach add device
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachAddDevice(LLONG lAttachHandle);

// interface of get adding device info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetAddDeviceInfo(LLONG lLoginID, const NET_IN_GET_ADD_DEVICE_LIST_INFO *pInParam, NET_OUT_GET_ADD_DEVICE_LIST_INFO *pOutParam, int nWaitTime);

// interface of get added device info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDeviceInfo(LLONG lLoginID, const NET_IN_GET_DEVICE_LIST_INFO *pInParam, NET_OUT_GET_DEVICE_LIST_INFO *pOutParam, int nWaitTime);

// interface of set connect channel
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetConnectChannel(LLONG lLoginID, const NET_IN_SET_CONNECT_CHANNEL *pInParam, NET_OUT_SET_CONNECT_CHANNEL *pOutParam, int nWaitTime);

// interface of get channel info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetChannelInfo(LLONG lLoginID, const NET_IN_GET_CHANNEL_INFO *pInParam, NET_OUT_GET_CHANNEL_INFO *pOutParam, int nWaitTime);

// interface of remove device
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RemoveDevice(LLONG lLoginID, const NET_IN_REMOVE_DEVICE *pInParam, NET_OUT_REMOVE_DEVICE *pOutParam, int nWaitTime);

// interface of cancel add device task
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CancelAddDeviceTask(LLONG lLoginID, const NET_IN_CANCEL_ADD_TASK *pInParam, NET_OUT_CANCEL_ADD_TASK *pOutParam, int nWaitTime);

// interface of confirm add device task
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ConfirmAddDeviceTask(LLONG lLoginID, const NET_IN_CONFIRM_ADD_TASK *pInParam, NET_OUT_CONFIRM_ADD_TASK *pOutParam, int nWaitTime);

#define MAX_BOARD_NUM 2												// the maximum number of board

// Board state
typedef enum tagNET_EM_BOARD_STATE
{
	NET_EM_BOARD_STATE_UNKNOWN = 0,									// unknown
	NET_EM_BOARD_STATE_MASTER,										// Master
	NET_EM_BOARD_STATE_SLAVE										// Slave
}NET_EM_BOARD_STATE;

// Board info
typedef struct tagNET_BOARD_STATE_INFO
{
	char				szTarget[DH_COMMON_STRING_64];				// Board name
	NET_EM_BOARD_STATE  emState;									// Current state
	int					nBoardSlot;									// BoardSlot number
	BYTE				byReserved[1024];							// reserved
}NET_BOARD_STATE_INFO;

// CLIENT_GetDCSDoubleDevBoardState input param
typedef struct tagNET_IN_GET_BOARD_STATE
{
	DWORD		dwSize;												// struct size:assignment when init the struct
}NET_IN_GET_BOARD_STATE;

// CLIENT_GetDCSDoubleDevBoardState output param
typedef struct tagNET_OUT_GET_BOARD_STATE
{
	DWORD						dwSize;								// struct size:assignment when init the struct
	int							nBoardRet;							// the return number of board 
	NET_BOARD_STATE_INFO		stuBoardStateList[MAX_BOARD_NUM];	// the list of board
}NET_OUT_GET_BOARD_STATE;

// Get DCSDoubleDev board state
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDCSDoubleDevBoardState(LLONG lLoginID, const NET_IN_GET_BOARD_STATE* pInParam, NET_OUT_GET_BOARD_STATE* pOutParam, int waittime);

//CLIENT_GetDiagnosisEncryptSystemInfo input param
typedef struct tagNET_IN_GET_ENCRYPT_SYSTEM_INFO
{
	DWORD					dwSize;
}NET_IN_GET_ENCRYPT_SYSTEM_INFO;

//CLIENT_GetDiagnosisEncryptSystemInfo output param
typedef struct tagNET_OUT_GET_ENCRYPT_SYSTEM_INFO
{
	DWORD					dwSize;
	char					szEncryptContent[MAX_ENCRYPT_SYSTEM_INFO_CONTENT_LEN];     // System info content(Encrypt)
}NET_OUT_GET_ENCRYPT_SYSTEM_INFO;

// Get encrypt system info, Used in diagnosis
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDiagnosisEncryptSystemInfo(LLONG lLoginID, const NET_IN_GET_ENCRYPT_SYSTEM_INFO* pInParam, NET_OUT_GET_ENCRYPT_SYSTEM_INFO* pOutParam, int nWaitTime);

// max count of log list
#define	MAX_LOG_LIST_COUNT	100

// Event type
typedef enum tagEM_QUERY_EVENT_LOG_TYPE
{
	EM_QUERY_EVENT_LOG_TYPE_UNKNOWN,								// unknown
	EM_QUERY_EVENT_LOG_TYPE_MOTION_DETECT,							// Motion detect
	EM_QUERY_EVENT_LOG_TYPE_INPUT_ALARM,							// Input alarm
	EM_QUERY_EVENT_LOG_TYPE_VIDEO_LOSS,								// Video loss
	EM_QUERY_EVENT_LOG_TYPE_NO_DISK,								// No disk
	EM_QUERY_EVENT_LOG_TYPE_DISK_ERROR,								// Disk error
	EM_QUERY_EVENT_LOG_TYPE_DISK_FULL,								// Disk full
	EM_QUERY_EVENT_LOG_TYPE_NET_ABORT,								// Net abort
	EM_QUERY_EVENT_LOG_TYPE_IP_CONFLICT,							// IP conflict
	EM_QUERY_EVENT_LOG_TYPE_TEMPERATURE_ALARM,						// Temperature alarm
	EM_QUERY_EVENT_LOG_TYPE_POWER_FAULT,							// Power fault
} EM_QUERY_EVENT_LOG_TYPE;

// Device alarm log list info
typedef struct tagNET_LOG_LIST_INFO 
{
	EM_QUERY_EVENT_LOG_TYPE		emEventType;						// event type
	int							nChannel;							// channel, -1 means independent of the channel
	NET_TIME					stStartTime;						// start time
	BYTE						byReserved[1024];					// reserved
} NET_LOG_LIST_INFO;

// CLIENT_QueryEventLog input param
typedef struct tagNET_IN_QUERY_EVENT_LOG
{
	DWORD						dwSize;								// struct size
	char						szUUID[MAX_COMMON_STRING_128];		// uuid
} NET_IN_QUERY_EVENT_LOG;

// CLIENT_QueryEventLog output param
typedef struct tagNET_OUT_QUERY_EVENT_LOG
{
	DWORD						dwSize;								// struct size
	int							nLogListCount;						// log list count
	NET_LOG_LIST_INFO			stLogList[MAX_LOG_LIST_COUNT];		// log list 
	char						szDeviceName[MAX_COMMON_STRING_64];	// device name
	int							nQueryID;							// query id
} NET_OUT_QUERY_EVENT_LOG;

// query device event log(Bosch customized)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryEventLog(LLONG lLoginID, const NET_IN_QUERY_EVENT_LOG* pInParam, NET_OUT_QUERY_EVENT_LOG* pOutParam, int nWaitTime);

// CLIENT_ConfirmEventLog input param
typedef struct tagNET_IN_CONFIRM_EVENT_LOG
{
	DWORD		dwSize;												// struct size
	char		szUUID[MAX_COMMON_STRING_64];						// UUID
	int			nQueryID;											// Query ID
} NET_IN_CONFIRM_EVENT_LOG;

// CLIENT_ConfirmEventLog output param
typedef struct tagNET_OUT_CONFIRM_EVENT_LOG
{
	DWORD						dwSize;								// struct size
} NET_OUT_CONFIRM_EVENT_LOG;

// Confirm event log(Bosch customized)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ConfirmEventLog(LLONG lLoginID, const NET_IN_CONFIRM_EVENT_LOG* pInParam, NET_OUT_CONFIRM_EVENT_LOG* pOutParam, int nWaitTime);

#define DH_MAX_DISKLISK_NUM 1024                                    // the max number of disk NO 

// CLIENT_GetStorageBoundTimeEx input param
typedef struct tagNET_IN_GET_BOUND_TIMEEX
{
	DWORD						dwSize;								// struct size
	int                         nDiskCount;                         // disk count
	int                         nDiskList[DH_MAX_DISKLISK_NUM];     // disk list
}NET_IN_GET_BOUND_TIMEEX;

// disk bound time info
typedef struct tagNET_BOUND_TIME_INFO
{
	UINT                        nDiskNO;				            // disk NO
	NET_TIME_EX                 stuStartTime;				        // Start Time
	NET_TIME_EX                 stuEndTime;				            // End Time
	BYTE				        byReserved[1024];					// reserved
}NET_BOUND_TIME_INFO;

// CLIENT_GetStorageBoundTimeEx output param
typedef struct tagNET_OUT_GET_BOUND_TIMEEX
{
	DWORD						dwSize;								// struct size
	int                         nRetDiskCount;                      // return disk count
	NET_BOUND_TIME_INFO         stuBoundTime[DH_MAX_DISKLISK_NUM];  // disk bound time info
}NET_OUT_GET_BOUND_TIMEEX;

// get storage bound timeEx
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetStorageBoundTimeEx(LLONG lLoginID, const NET_IN_GET_BOUND_TIMEEX* pInParam, NET_OUT_GET_BOUND_TIMEEX* pOutParam, int waittime);

// CLIENT_GetStoragePortInfo input param
typedef struct tagNET_IN_GET_PORTINFO
{
	DWORD						dwSize;								// struct size
}NET_IN_GET_PORTINFO;

// CLIENT_GetStoragePortInfo output param
typedef struct tagNET_OUT_GET_PORTINFO
{
	DWORD						dwSize;								// struct size
	UINT                        nTotal;                             // the number of interfaces to the bus
	UINT                        nPlug;                              // the number of mounted had disks, broken disk not included
	UINT                        nMask;                              // whether the hard disk is mounted on the bus channel,broken disk included
	UINT                        nBadDisk;                           // whether the broken hard disk is mounted on the channel
	UINT                        nIDEDisk;                           // the number of IDE disk
	UINT                        nESATA;                             // the total of eSATA
	UINT                        nUSB2;                              // the number of usb devices working in usb2.0 mode
	UINT                        nUSB3;                              // the number of usb devices working in usb3.0 mode
}NET_OUT_GET_PORTINFO;

// get storage port info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetStoragePortInfo(LLONG lLoginID, const NET_IN_GET_PORTINFO* pInParam, NET_OUT_GET_PORTINFO* pOutParam, int waittime);

// Max count of NAS file operate
#define MAX_NASFILE_COUNT	1024

// NAS file operate type
typedef enum tagEM_NAS_FILE_OPERATE_TYPE
{
	EM_NAS_FILE_OPERATE_TYPE_COPY,					// copy, corresponding to pInParam = NET_IN_COPY_NAS_FILE,pOutParam = NET_OUT_COPY_NAS_FILE
	EM_NAS_FILE_OPERATE_TYPE_MOVE,					// move, corresponding to pInParam = NET_IN_MOVE_NAS_FILE,pOutParam = NET_OUT_MOVE_NAS_FILE
	EM_NAS_FILE_OPERATE_TYPE_REMOVE,				// remove, corresponding to pInParam = NET_IN_REMOVE_NAS_FILE,pOutParam = NET_OUT_REMOVE_NAS_FILE
} EM_NAS_FILE_OPERATE_TYPE;

// NAS file copy/move option
typedef enum tagEM_NAS_FILE_OPTION 
{
	EM_NAS_FILE_OPTION_UNKNOWN,						// unknown
	EM_NAS_FILE_OPTION_U,							// source target is new than target file or target file don't exist
	EM_NAS_FILE_OPTION_F,							// overlay the target file directly with the source file
} EM_NAS_FILE_OPTION;

// input param of copy NAS file
typedef struct tagNET_IN_COPY_NAS_FILE 
{
	DWORD						dwSize;
	char						szID[MAX_COMMON_STRING_128];							// ID
	int							nSrcNum;												// src file number
	char						szSrcList[MAX_NASFILE_COUNT][MAX_COMMON_STRING_128];	// src file list
	char						szDstPath[MAX_COMMON_STRING_128];						// dst path
	EM_NAS_FILE_OPTION			emOption;												// copy option
} NET_IN_COPY_NAS_FILE ;

// output param of copy NAS file
typedef struct tagNET_OUT_COPY_NAS_FILE
{
	DWORD						dwSize;
} NET_OUT_COPY_NAS_FILE;

// input param of move NAS file
typedef struct tagNET_IN_MOVE_NAS_FILE 
{
	DWORD						dwSize;
	char						szID[MAX_COMMON_STRING_128];							// ID
	int							nSrcNum;												// src file number
	char						szSrcList[MAX_NASFILE_COUNT][MAX_COMMON_STRING_128];	// src file list
	char						szDstPath[MAX_COMMON_STRING_128];						// dst path
	EM_NAS_FILE_OPTION			emOption;												// move option
} NET_IN_MOVE_NAS_FILE;

// output param of move NAS file
typedef struct tagNET_OUT_MOVE_NAS_FILE 
{
	DWORD						dwSize;
} NET_OUT_MOVE_NAS_FILE;

// input param of remove NAS file
typedef struct tagNET_IN_REMOVE_NAS_FILE 
{
	DWORD						dwSize;
	char						szID[MAX_COMMON_STRING_128];							// ID
	int							nFileNum;												// delete file number 
	char						szFileName[MAX_NASFILE_COUNT][MAX_COMMON_STRING_128];	// file name list
} NET_IN_REMOVE_NAS_FILE;

// output param of remove NAS file
typedef struct tagNET_OUT_REMOVE_NAS_FILE 
{
	DWORD						dwSize;
} NET_OUT_REMOVE_NAS_FILE;

// NAS File Operate
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateNASFile(LLONG lLoginID, EM_NAS_FILE_OPERATE_TYPE emOperateType, void *pInParam, void *pOutParam, int nWaitTime);

// Max Count of File Compress
#define MAX_FILE_COMPRESS_COUNT	8

// file compress type
typedef enum tagEM_COMPRESS_TYPE
{
	EM_COMPRESS_TYPE_UNKNWON,						// unknown
	EM_COMPRESS_TYPE_ZIP,							// zip
} EM_COMPRESS_TYPE;

// input param of Compress operation
typedef struct tagNET_IN_COMPRESS_FILE 
{
	DWORD						dwSize;
	char						szID[MAX_COMMON_STRING_128];			// ID
	int							nSrcNum;								// Src File Number
	char						szSrcFileList[MAX_FILE_COMPRESS_COUNT][MAX_COMMON_STRING_128];	// Src File List
	char						szDstFile[MAX_COMMON_STRING_128];		// Dst File name
	char						szPassword[MAX_COMMON_STRING_64];		// password
	EM_COMPRESS_TYPE			emCompressType;							// Compress Type
} NET_IN_COMPRESS_FILE;

// output param of Compress operation
typedef struct tagNET_OUT_COMPRESS_FILE 
{
	DWORD						dwSize;
} NET_OUT_COMPRESS_FILE;

// input param of Decompress operation
typedef struct tagNET_IN_DECOMPRESS_FILE 
{
	DWORD						dwSize;
	char						szID[MAX_COMMON_STRING_128];			// ID
	char						szSrcFile[MAX_COMMON_STRING_128];		// Src File name
	char						szDstPath[MAX_COMMON_STRING_128];		// Dst Path
	char						szPassword[MAX_COMMON_STRING_64];		// password
} NET_IN_DECOMPRESS_FILE;

// output param of Decompress operation
typedef struct tagNET_OUT_DECOMPRESS_FILE 
{
	DWORD						dwSize;
} NET_OUT_DECOMPRESS_FILE;

// operate file compress
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateFileCompress(LLONG lLoginID, EM_FILE_COMPRESS_TYPE emOperateType, void *pInParam, void *pOutParam, int nWaitTime);



///////////////////////////////////////////NumberStatGroup//////////////////////////////////////////////////////////////////
#define MAX_GROUP_CHANNEL_NUM 1024						// The maximum number of channels in group
#define MAX_GROUPID_LEN 64								// The maximum length of group id
#define MAX_GROUPNAME_LEN 128							// The maximum length of group name

//Subtotal info
typedef struct tagNET_NUMBERSTATGROUP_SUBTOTAL
{
    int                 nTotal;                         // count since device operation
    int                 nHour;                          // count in the last hour
    int                 nToday;                         // count for today
    int                 nTotalInTimeSection;            // if do not call "clearSectionStat", just same as "nToday"
    BYTE                byReserved[252];
} NET_NUMBERSTATGROUP_SUBTOTAL;

// summary info
typedef struct tagNET_NUMBERSTATGROUP_SUMMARY
{
	char							szGroupID[MAX_GROUPID_LEN];					// Group ID
	char							szGroupName[MAX_GROUPNAME_LEN];				// Group name
	int								nChannelNum;								// The  number of Channels
	int								arChannelList[MAX_GROUP_CHANNEL_NUM];		// Channels list
	NET_TIME_EX						stuUTC;										// Statistical time
	int								nTimeZone;									// TimeZone index
	NET_NUMBERSTATGROUP_SUBTOTAL	stuEnteredSubtotal;							// Entered Subtotal
	NET_NUMBERSTATGROUP_SUBTOTAL	stuExitedSubtotal;							// Exited Subtotal
	int								nInsideSubtotal;							// Inside Subtotal
	BYTE							byReserved[1024];							// reserved
} NET_NUMBERSTATGROUP_SUMMARY;

//NumberStatGroup summary callback, lAttachHandle is the return value of CLIENT_AttachNumberStatGroupSummary
typedef void (CALLBACK *fNumberStatGroupSumCallBack) (LLONG lAttachHandle, NET_NUMBERSTATGROUP_SUMMARY* pBuf, DWORD dwBufLen, LDWORD dwUser);

// Attach NumberStatGroup summary--input
typedef struct tagNET_IN_ATTACH_NUMBERSTATGROUP_SUM
{
	DWORD						dwSize;								// struct size
	fNumberStatGroupSumCallBack cbNumberStatGroupSum;				// NumberStatGroup summary callback
	LDWORD						dwUser;								// user data   
}NET_IN_ATTACH_NUMBERSTATGROUP_SUM;

// Attach NumberStatGroup summary--output
typedef struct tagNET_OUT_ATTACH_NUMBERSTATGROUP_SUM
{
	DWORD						dwSize;								// struct size
}NET_OUT_ATTACH_NUMBERSTATGROUP_SUM;

// Attach NumberStatGroup summary
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachNumberStatGroupSummary(LLONG lLoginID, const NET_IN_ATTACH_NUMBERSTATGROUP_SUM* pInParam, NET_OUT_ATTACH_NUMBERSTATGROUP_SUM* pOutParam, int waittime);

// Detach NumberStatGroup summary
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachNumberStatGroupSummary(LLONG lAttachHandle);

// NumberStatGroup--Add group input
typedef struct tagNET_IN_ADD_NUMBERSTATGROUP_INFO
{
	DWORD						dwSize;								// struct size
	char						szGroupName[MAX_GROUPNAME_LEN];		// group name
	int							nChannelNum;							// channel number
	int							arChannelList[MAX_GROUP_CHANNEL_NUM];	// channel list
}NET_IN_ADD_NUMBERSTATGROUP_INFO;

// NumberStatGroup--Add group output
typedef struct tagNET_OUT_ADD_NUMBERSTATGROUP_INFO
{
	DWORD						dwSize;								// struct size
	char						szGroupID[MAX_GROUPID_LEN];			// GroupID
}NET_OUT_ADD_NUMBERSTATGROUP_INFO;

// NumberStatGroup--Add group
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddNumberStatGroup(LLONG lLoginID, const NET_IN_ADD_NUMBERSTATGROUP_INFO* pInParam, NET_OUT_ADD_NUMBERSTATGROUP_INFO* pOutParam, int waittime);

// NumberStatGroup--Delete group input
typedef struct tagNET_IN_DEL_NUMBERSTATGROUP_INFO
{
	DWORD						dwSize;								// struct size
	char						szGroupID[MAX_GROUPID_LEN];			// GroupID
}NET_IN_DEL_NUMBERSTATGROUP_INFO;

// NumberStatGroup--Delete group ouput
typedef struct tagNET_OUT_DEL_NUMBERSTATGROUP_INFO
{
	DWORD						dwSize;								// struct size
}NET_OUT_DEL_NUMBERSTATGROUP_INFO;

// NumberStatGroup--Delete group
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DelNumberStatGroup(LLONG lLoginID, const NET_IN_DEL_NUMBERSTATGROUP_INFO* pInParam, NET_OUT_DEL_NUMBERSTATGROUP_INFO* pOutParam, int waittime);

// Group info
typedef struct tagNET_NUMBERSTATGROUP_INFO
{
	char						szGroupID[MAX_GROUPID_LEN];				// Group id
	char						szGroupName[MAX_GROUPNAME_LEN];			// Group name
	int							nChannelNum;							// The number of channels
	int							arChannelList[MAX_GROUP_CHANNEL_NUM];	// Channels list
	BYTE						byReserved[512];						// 
}NET_NUMBERSTATGROUP_INFO;

// NumberStatGroup--Modify group info input
typedef struct tagNET_IN_MODIFY_NUMBERSTATGROUP_INFO
{
	DWORD						dwSize;									// struct size
	NET_NUMBERSTATGROUP_INFO	stuGroupInfo;
}NET_IN_MODIFY_NUMBERSTATGROUP_INFO;

// NumberStatGroup--Modify group info output
typedef struct tagNET_OUT_MODIFY_NUMBERSTATGROUP_INFO
{
	DWORD						dwSize;									// struct size
}NET_OUT_MODIFY_NUMBERSTATGROUP_INFO;

// NumberStatGroup--Modify group info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ModifyNumberStatGroup(LLONG lLoginID, const NET_IN_MODIFY_NUMBERSTATGROUP_INFO* pInParam, NET_OUT_MODIFY_NUMBERSTATGROUP_INFO* pOutParam, int waittime);

// NumberStatGroup--Get groups info input
typedef struct tagNET_IN_NUMBERSTATGROUPS_INFO
{
	DWORD						dwSize;									// struct size
	char						szGroupID[MAX_GROUPID_LEN];				// GroupID
}NET_IN_NUMBERSTATGROUPS_INFO;

// NumberStatGroup--Get groups info output
typedef struct tagNET_OUT_NUMBERSTATGROUPS_INFO
{
	DWORD						dwSize;									// struct size
	int							nGroupsRetNum;							// return number
	int							nGroupsMaxNum;							// The number of struct user malloc
	NET_NUMBERSTATGROUP_INFO*	pstuGroupList;							// The list of GroupInfo user malloc, sizeof(NET_NUMBERSTATGROUP_INFO) * nGroupsMaxNum
}NET_OUT_NUMBERSTATGROUPS_INFO;

// NumberStatGroup--Get groups info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetNumberStatGroups(LLONG lLoginID, const NET_IN_NUMBERSTATGROUPS_INFO* pInParam, NET_OUT_NUMBERSTATGROUPS_INFO* pOutParam, int waittime);

// NumberStatGroup--Get summary info input
typedef struct tagNET_IN_NUMBERSTATGROUPSUMMARY_INFO
{
	DWORD						dwSize;									// struct size
	char						szGroupID[MAX_GROUPID_LEN];				// GroupID
}NET_IN_NUMBERSTATGROUPSUMMARY_INFO;

// NumberStatGroup--Get summary info output
typedef struct tagNET_OUT_NUMBERSTATGROUPSUMMARY_INFO
{
	DWORD						dwSize;									// struct size
	NET_NUMBERSTATGROUP_SUMMARY	stuSummary;								// summary info
}NET_OUT_NUMBERSTATGROUPSUMMARY_INFO;

// NumberStatGroup--Get summary info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetNumberStatGroupSummary(LLONG lLoginID, const NET_IN_NUMBERSTATGROUPSUMMARY_INFO* pInParam, NET_OUT_NUMBERSTATGROUPSUMMARY_INFO* pOutParam, int waittime);

// The rule type of data
typedef enum tagEM_NUMBERSTATGROUP_RULE_TYPE
{
	EM_NUMBERSTATGROUP_RULE_UNKNOWN = 0,
	EM_NUMBERSTATGROUP_RULE_NUMBERSTAT,								// return Entered and Exited
	EM_NUMBERSTATGROUP_RULE_MANNUMBERDETECTION,						// return Inside
}EM_NUMBERSTATGROUP_RULE_TYPE;

// Granularity
typedef enum tagEM_GRANULARITY_TYPE
{
	EM_GRANULARITY_UNKNOWN = 0,
	EM_GRANULARITY_MINUTE,												// to minute
	EM_GRANULARITY_HOUR,												// to hour
	EM_GRANULARITY_DAY,												// to day
	EM_GRANULARITY_WEEK,												// to week
	EM_GRANULARITY_MONTH,												// to month
	EM_GRANULARITY_SEASON,												// to season
	EM_GRANULARITY_YEAR												// to year
}EM_GRANULARITY_TYPE;

// Query condition
typedef struct tagNET_IN_NUMBERSTATGROUP_START_FIND_INFO
{
	DWORD							dwSize;									// struct size
	char							szGroupID[MAX_GROUPID_LEN];				// Group ID, if "", find from all groups
	NET_TIME						stStartTime;							// start time
	NET_TIME						stEndTime;								// end time
	EM_NUMBERSTATGROUP_RULE_TYPE	emRuleType;								// The rule type of data
	EM_GRANULARITY_TYPE			emGranularity;							// Granularity
	UINT							nPlanID;								// PlanID, start from 1
}NET_IN_NUMBERSTATGROUP_START_FIND_INFO;

// Find output
typedef struct tagNET_OUT_NUMBERSTATGROUP_START_FIND_INFO
{
	DWORD							dwSize;									// struct size
	UINT							nTotalCount;							// The number of items which ware found
}NET_OUT_NUMBERSTATGROUP_START_FIND_INFO;

// NumberStatGroup--Start find
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartFindNumberStatGroup(LLONG lLoginID, const NET_IN_NUMBERSTATGROUP_START_FIND_INFO* pInParam, NET_OUT_NUMBERSTATGROUP_START_FIND_INFO* pOutParam, int nWaitTime);

// The record of numberstatgroup
typedef struct tagNET_NUMBERSTATGROUP_RECORD
{
	char							szGroupID[MAX_GROUPID_LEN];					// Group id
	char							szGroupName[MAX_GROUPNAME_LEN];				// Group name
	int								nChannelNum;								// The number of channels
	int								arChannelList[MAX_GROUP_CHANNEL_NUM];		// Channels list
	EM_NUMBERSTATGROUP_RULE_TYPE	emRuleName;									// Rule type
	NET_TIME_EX						stuStartTime;								// The start time of statistical
	NET_TIME_EX						stuEndTime;									// The end time of statistical

	UINT							nEnteredSubtotal;							// Enterd subtotal
	UINT							nExitedSubtotal;							// Exited subtotal
	UINT							nInsideSubtotal;							// inside subtotal
	BYTE							byReserved[1024];							// reserved
} NET_NUMBERSTATGROUP_RECORD;

// CLIENT_DoFindNumberStatGroup input
typedef struct tagNET_IN_NUMBERSTATGROUP_DO_FIND_INFO 
{
	DWORD                       dwSize;
	int                         nStartNo;           // start index
	int                         nCount;             // The count of records which you want to get 
}NET_IN_NUMBERSTATGROUP_DO_FIND_INFO;

// CLIENT_DoFindNumberStatGroup output
typedef struct tagNET_OUT_NUMBERSTATGROUP_DO_FIND_INFO
{
	DWORD                       dwSize;
	int                         nRetNum;            // The number of query result returned that time
	int	                        nMaxNum;            // number of user malloc
	NET_NUMBERSTATGROUP_RECORD* pstuInfo;           // query data, user malloc,size is sizeof(NET_NUMBERSTATGROUP_RECORD)*nMaxNum
}NET_OUT_NUMBERSTATGROUP_DO_FIND_INFO;

// doFind
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoFindNumberStatGroup(LLONG lFindHandle, const NET_IN_NUMBERSTATGROUP_DO_FIND_INFO* pInParam, NET_OUT_NUMBERSTATGROUP_DO_FIND_INFO* pOutParam, int nWaitTime);

// Stop find
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindNumberStatGroup(LLONG lFindHandle);

/**************************interfaces of secondary record analyse*************************/
#define MAX_SECONDARY_ANALYSE_TASK_NUM		32  // the max counts of secondary record analysis task
#define MAX_SECONDARY_ANALYSE_RULE_NUM		8	// the max counts of secondary record analysis rule
#define MAX_SECONDARY_ANALYSE_EVENT_NUM		8	// the max counts of secondary record analysis event

// the state of secondary record analysis
typedef enum tagEM_SECONDARY_ANALYSE_STATE
{
	EM_SECONDARY_ANALYSE_UNKNOWN,				// unknown
	EM_SECONDARY_ANALYSE_WAIT_DOWNLOAD,			// wait download
	EM_SECONDARY_ANALYSE_DOWNLOADING,			// downloading
	EM_SECONDARY_ANALYSE_WAIT_ANALYSE,			// wait analyse
	EM_SECONDARY_ANALYSE_ANALYSING,				// analysing
	EM_SECONDARY_ANALYSE_FINISH_ANALYSE,		// finish analyse
	EM_SECONDARY_ANALYSE_DOWNLOAD_FAILED,		// download failed
	EM_SECONDARY_ANALYSE_CANCELLED,				// cancelled
	EM_SECONDARY_ANALYSE_NOTENOUGH_ANALYSER,	// analyser is not enough
	EM_SECONDARY_ANALYSE_ANALYSER_ERROR,		// analyser is error
	EM_SECONDARY_ANALYSE_PAUSE_DOWNLOAD,		// download pause
	EM_SECONDARY_ANALYSE_PAUSE_ANALYSE,			// analyse pause
} EM_SECONDARY_ANALYSE_STATE;

// the secondary record analysis info
typedef struct tagNET_ANALYSE_TASK_INFO
{
	UINT							nTaskID;							// task ID
	EM_SECONDARY_ANALYSE_STATE		emAnalyseState;						// the state of secondary record analysis
	char							szTaskName[DH_COMMON_STRING_128];	// task name
	UINT							nProgress;							// progress
	BYTE				            byReserved[516];					// reserved
} NET_ANALYSE_TASK_INFO;

// the callback struct of secondary record analysis info
typedef struct tagNET_CB_SECONDARY_ANALYSE_INFO
{
	int						nRetAnalyseTaskCount;			// the count of the task 
	BYTE					byReserved1[4];					// byte alignment
	NET_ANALYSE_TASK_INFO	stuAnalyseTaskInfo[MAX_SECONDARY_ANALYSE_TASK_NUM];// the task info of secondary record analysis
	LDWORD 					dwUser;							// user data
	BYTE				    byReserved[512];				// reserved
} NET_CB_SECONDARY_ANALYSE_INFO;

// the callback function of secondary record analysis info
typedef int  (CALLBACK *fSecondaryAnalyseCallBack)(LLONG lAnalyseHandle, NET_CB_SECONDARY_ANALYSE_INFO *pstSecondaryAnalyseInfo);

// input parameter of attach secondary record analysis
typedef struct tagNET_IN_ATTACH_SECONDARY_ANALYSE_STATE
{
	DWORD							dwSize;					// the size of this struct
	BYTE							byReserved[4];			// byte alignment
    fSecondaryAnalyseCallBack	    cbSecondaryAnalyse;		// call back function
    LDWORD                  		dwUser;                 // user data
} NET_IN_ATTACH_SECONDARY_ANALYSE_STATE;

// output parameter of attach secondary record analysis
typedef struct tagNET_OUT_ATTACH_SECONDARY_ANALYSE_STATE
{
	DWORD							dwSize;					// the size of this struct
} NET_OUT_ATTACH_SECONDARY_ANALYSE_STATE;

// face analysis info
typedef struct tagNET_ANALYSE_RULE_FACE_ANALYSIS_INFO
{
	UINT			nSimilarity;										// similarity
	UINT			nGroupNum;											// the count of face group
	char			szGroupID[MAX_FACE_DB_NUM][DH_COMMON_STRING_64]; 	// the ID of face group
	BYTE			byReserved[1024];									// reserved
} NET_ANALYSE_RULE_FACE_ANALYSIS_INFO;

// rule type
typedef enum tagEM_ANALYSE_RULE_TYPE
{
	EM_ANALYSE_RULE_UNKNOWN,			// unknown
	EM_ANALYSE_RULE_FACE_ANALYSIS,		// face analysis, corresponding to NET_ANALYSE_RULE_FACE_ANALYSIS_INFO
	EM_ANALYSE_RULE_FACE_ATTRIBUTE,		// face attribute, no struct
} EM_ANALYSE_RULE_TYPE;

// event type
typedef enum tagEM_ANALYSE_EVENT_TYPE
{
    EM_ANALYSE_EVENT_UNKNOWN,                   // unknown
    EM_ANALYSE_EVENT_ALL,                       // all
    EM_ANALYSE_EVENT_FACE_DETECTION,            // face detection event, corresponding to DEV_EVENT_FACEDETECT_INFO
    EM_ANALYSE_EVENT_FACE_RECOGNITION,          // face recognition event, corresponding to DEV_EVENT_FACERECOGNITION_INFO
    EM_ANALYSE_EVENT_TRAFFICJUNCTION,           // traffic junction event, corresponding to DEV_EVENT_TRAFFICJUNCTION_INFO
    EM_ANALYSE_EVENT_HUMANTRAIT,                // humantrait event, corresponding to DEV_EVENT_HUMANTRAIT_INFO
    EM_ANALYSE_EVENT_XRAY_DETECTION,            // X ray detection event, corresponding to DEV_EVENT_XRAY_DETECTION_INFO
    EM_ANALYSE_EVENT_WORKCLOTHESDETECT,         // work clothes(helmet/clothes) detection, corresponding to DEV_EVENT_WORKCLOTHESDETECT_INFO
    EM_ANALYSE_EVENT_WORKSTATDETECTION,         // work state detection, corresponding to DEV_EVENT_WORKSTATDETECTION_INFO
    EM_ANALYSE_EVENT_CORSSLINEDETECTION,        // cross line event, corresponding to DEV_EVENT_CROSSLINE_INFO
    EM_ANALYSE_EVENT_CROSSREGIONDETECTION,      // cross region event, corresponding to DEV_EVENT_CROSSREGION_INFO
    EM_ANALYSE_EVENT_FEATURE_ABSTRACT,          // Feature abstract, corresponding to  DEV_EVENT_FEATURE_ABSTRACT_INFO
    EM_ANALYSE_EVENT_ELECTRIC_GLOVE_DETECT,     // Electric glove detection,  corresponding to DEV_EVENT_ELECTRIC_GLOVE_DETECT_INFO
    EM_ANALYSE_EVENT_ELECTRIC_LADDER_DETECT,    // Electric ladder detection,  corresponding to DEV_EVENT_ELECTRIC_LADDER_DETECT_INFO
    EM_ANALYSE_EVENT_ELECTRIC_CURTAIN_DETECT,   // Electric curtain detection,  corresponding to DEV_EVENT_ELECTRIC_CURTAIN_DETECT_INFO
    EM_ANALYSE_EVENT_ELECTRIC_FENCE_DETECT,     // Electric fence detection,  corresponding to DEV_EVENT_ELECTRIC_FENCE_DETECT_INFO
    EM_ANALYSE_EVENT_ELECTRIC_SIGNBOARD_DETECT, // Electric signboard detection,  corresponding to DEV_EVENT_ELECTRIC_SIGNBOARD_DETECT_INFO
    EM_ANALYSE_EVENT_ELECTRIC_BELT_DETECT,      // Electric belt detection,  corresponding to DEV_EVENT_ELECTRIC_BELT_DETECT_INFO

    EM_ANALYSE_EVENT_CROSSLINEDETECTION_EX = 2000, // cross line(expansion) event, corresponding to DEV_EVENT_CROSSLINE_INFO_EX
}  EM_ANALYSE_EVENT_TYPE;

// the info of secondary record analysis rule
typedef struct tagNET_ANALYSE_INFO
{
	EM_ANALYSE_RULE_TYPE	emAnalyseType;		// rule type
	BYTE					byReserved1[4];		// byte alignment
	void					*pRuleInfo;			// the info of this rule, determine the specific struct according to emAnalyseType 
	BYTE					byReserved[512];	// reserved
} NET_ANALYSE_INFO;

// the secondary record analysis task info which is want to be added
typedef struct tagNET_SECONDARY_ANALYSE_TASK_INFO
{
	char				szRecordPath[DH_COMMON_STRING_256];				// the path of this record
	int					nAnalyseCount;									// the count of rule
	NET_ANALYSE_INFO	stuAnalyseInfo[MAX_SECONDARY_ANALYSE_RULE_NUM];	// the info of rule
	char				szTaskName[DH_COMMON_STRING_128];				// task name
	BOOL				bNeedSave;										// is record saved to device
	BYTE				byReserved[1024];								// reserved
} NET_SECONDARY_ANALYSE_TASK_INFO;

// input parameter of adding secondary record analysis task
typedef struct  tagNET_IN_SECONDARY_ANALYSE_ADDTASK
{
	DWORD								dwSize;					// the size of this struct
	int									nAnalyseTaskCount;		// the count of the tasks
	NET_SECONDARY_ANALYSE_TASK_INFO		stuAnalyseTaskInfo[MAX_SECONDARY_ANALYSE_TASK_NUM];// the info of the tasks
} NET_IN_SECONDARY_ANALYSE_ADDTASK;

// the the info is returned by adding task
typedef struct tagNET_TASK_ADD_RESULT_INFO
{
	UINT		nTaskID;										// task ID, 0 means failed
	char		szLocalPath[DH_COMMON_STRING_256];				// thr record path on the device
	BYTE		byReserved[1024];								// reserved
} NET_TASK_ADD_RESULT_INFO;

// output parameter of adding secondary record analysis task
typedef struct  tagNET_OUT_SECONDARY_ANALYSE_ADDTASK
{
	DWORD						dwSize;									      // the size of this struct
	UINT						nRetTaskResultNum;							  // the count of the result of adding tasks
	NET_TASK_ADD_RESULT_INFO	stuResultInfo[MAX_SECONDARY_ANALYSE_TASK_NUM];// the infos are returned by adding tasks
} NET_OUT_SECONDARY_ANALYSE_ADDTASK;

// input parameter of starting secondary record analysis
typedef struct tagNET_IN_SECONDARY_ANALYSE_STARTTASK
{
	DWORD		dwSize;									// the size of this struct
	UINT		nTaskIdNum;								// the count of task, 0 means all
	UINT		nTaskID[MAX_SECONDARY_ANALYSE_TASK_NUM];// task ID
} NET_IN_SECONDARY_ANALYSE_STARTTASK;

// output parameter of starting secondary record analysis
typedef struct tagNET_OUT_SECONDARY_ANALYSE_STARTTASK
{
	DWORD		dwSize;									// the size of this struct
} NET_OUT_SECONDARY_ANALYSE_STARTTASK;

// input parameter of pause secondary record analysis
typedef struct tagNET_IN_SECONDARY_ANALYSE_PAUSETASK
{
	DWORD		dwSize;									// the size of this struct
	UINT		nTaskIdNum;								// the count of task
	UINT		nTaskID[MAX_SECONDARY_ANALYSE_TASK_NUM];// task ID
} NET_IN_SECONDARY_ANALYSE_PAUSETASK;

// output parameter of pause secondary record analysis
typedef struct tagNET_OUT_SECONDARY_ANALYSE_PAUSETASK
{
	DWORD		dwSize;									// the size of this struct
} NET_OUT_SECONDARY_ANALYSE_PAUSETASK;

// input parameter of parameter of delete secondary record analysis
typedef struct tagNET_IN_SECONDARY_ANALYSE_REMOVETASK
{
	DWORD		dwSize;									// the size of this struct
	UINT		nTaskIdNum;								// the count of task, 0 means all
	UINT		nTaskID[MAX_SECONDARY_ANALYSE_TASK_NUM];// task ID
} NET_IN_SECONDARY_ANALYSE_REMOVETASK;

// output parameter parameter of parameter of delete secondary record analysis
typedef struct tagNET_OUT_SECONDARY_ANALYSE_REMOVETASK
{
	DWORD		dwSize;									// the size of this struct
} NET_OUT_SECONDARY_ANALYSE_REMOVETASK;

// inpput parameter of start to find secondary record analysis
typedef struct tagNET_IN_SECONDARY_ANALYSE_STARTFIND_TASK
{
	DWORD		dwSize;									// the size of this struct
	UINT		nTaskNum;								// the count of task, 0 means all
	UINT		nTaskID[MAX_SECONDARY_ANALYSE_TASK_NUM];// task ID
} NET_IN_SECONDARY_ANALYSE_STARTFIND_TASK;

// output parameter of start to find secondary record analysis
typedef struct tagNET_OUT_SECONDARY_ANALYSE_STARTFIND_TASK
{
	DWORD		dwSize;						// the size of this struct
	UINT        nTotalCount;                // the total number of eligible tasks
} NET_OUT_SECONDARY_ANALYSE_STARTFIND_TASK;

// the state infomation of secondary record analysis
typedef struct tagNET_SECONDARY_ANALYSE_TASK_STATE_INFO
{
	UINT				nTaskID;							// task ID
	char				szTaskName[DH_COMMON_STRING_256];	// task name
	char				szRecordPath[DH_COMMON_STRING_256];	// the path of record
	BOOL				bNeedSave;							// is record saved to device
	char				szLoaclPath[DH_COMMON_STRING_256];	// the path of the record on device
	EM_SECONDARY_ANALYSE_STATE		emAnalyseState;			// state of task
	NET_TIME			stuStartTime;						// start time
	NET_TIME			stuFinishTime;						// finish time
	UINT				nProgress;							// progress
	int					nAnalyseCount;									// the count of rules
	NET_ANALYSE_INFO	stuAnalyseInfo[MAX_SECONDARY_ANALYSE_RULE_NUM];	// the info of rules
	BYTE				byReserved[1024];								// reserved
} NET_SECONDARY_ANALYSE_TASK_STATE_INFO;

// input parameter of find secondary record analysis
typedef struct tagNET_IN_SECONDARY_ANALYSE_DOFIND_TASK
{
	DWORD		dwSize;						// the size of this struct
	UINT		nBeginNumber;				// the begin number
	UINT		nCount;						// the number of this find
} NET_IN_SECONDARY_ANALYSE_DOFIND_TASK;

// output parameter of find secondary record analysis
typedef struct tagNET_OUT_SECONDARY_ANALYSE_DOFIND_TASK
{
	DWORD		dwSize;						// the size of this struct
	UINT		nFoundCount;				// the count of the tasks which are found
	NET_SECONDARY_ANALYSE_TASK_STATE_INFO	stuAnalyseTaskInfo[MAX_SECONDARY_ANALYSE_TASK_NUM]; // the state info of tasks
} NET_OUT_SECONDARY_ANALYSE_DOFIND_TASK;

// the event info of secondary record analysis
typedef struct tagNET_SECONDARY_ANALYSE_EVENT_INFO
{
	EM_ANALYSE_EVENT_TYPE		emEventType;		// event type
	BYTE						byReserved1[4];		// byte alignment
	void						*pstEventInfo;		// event info, determine the specific struct according to emEventType
													// EM_ANALYSE_EVENT_FACE_DETECTION (face detection event), corresponding to DEV_EVENT_FACEDETECT_INFO
													// EM_ANALYSE_EVENT_FACE_RECOGNITION (face recognition event), corresponding to DEV_EVENT_FACERECOGNITION_INFO
													// EM_ANALYSE_EVENT_TRAFFICJUNCTION (traffic junction event), corresponding to DEV_EVENT_TRAFFICJUNCTION_INFO
													// EM_ANALYSE_EVENT_HUMANTRAIT (humantrait event), corresponding to DEV_EVENT_HUMANTRAIT_INFO
													// EM_ANALYSE_EVENT_XRAY_DETECTION(X ray detection event), corresponding to DEV_EVENT_XRAY_DETECTION_INFO
													// EM_ANALYSE_EVENT_WORKCLOTHESDETECT (work clothes(helmet/clothes) detection), corresponding to DEV_EVENT_WORKCLOTHES_DETECT_INFO
													// EM_ANALYSE_EVENT_WORKSTATDETECTION (work state detection), corresponding to DEV_EVENT_WORKSTATDETECTION_INFO
													// EM_ANALYSE_EVENT_CORSSLINEDETECTION (cross line event), corresponding to DEV_EVENT_CROSSLINE_INFO
													// EM_ANALYSE_EVENT_CROSSLINEDETECTION_EX (cross line(expansion) event), corresponding to DEV_EVENT_CROSSLINE_INFO_EX
													// EM_ANALYSE_EVENT_CROSSREGIONDETECTION (cross region event), corresponding to DEV_EVENT_CROSSREGION_INFO
                                                    // EM_ANALYSE_EVENT_FEATURE_ABSTRACT(FeatureAbstract), corresponding to DEV_EVENT_FEATURE_ABSTRACT_INFO
                                                    // EM_ANALYSE_EVENT_ELECTRIC_GLOVE_DETECT(Electric glove detection),  corresponding to DEV_EVENT_ELECTRIC_GLOVE_DETECT_INFO
                                                    // EM_ANALYSE_EVENT_ELECTRIC_LADDER_DETECT(Electric ladder detection),  corresponding to DEV_EVENT_ELECTRIC_LADDER_DETECT_INFO
                                                    // EM_ANALYSE_EVENT_ELECTRIC_CURTAIN_DETECT(Electric curtain detection),  corresponding to DEV_EVENT_ELECTRIC_CURTAIN_DETECT_INFO
                                                    // EM_ANALYSE_EVENT_ELECTRIC_FENCE_DETECT(Electric fence detection),  corresponding to DEV_EVENT_ELECTRIC_FENCE_DETECT_INFO
                                                    // EM_ANALYSE_EVENT_ELECTRIC_SIGNBOARD_DETECT(Electric signboard detection),  corresponding to  DEV_EVENT_ELECTRIC_SIGNBOARD_DETECT_INFO
                                                    // EM_ANALYSE_EVENT_ELECTRIC_BELT_DETECT(Electric belt detection),  corresponding to DEV_EVENT_ELECTRIC_BELT_DETECT_INFO
	BYTE						byReserved[1024];	// reserved
} NET_SECONDARY_ANALYSE_EVENT_INFO;

// the call back struct of the result of secondary record analysis
typedef struct tagNET_CB_ANALYSE_RESULT_INFO
{
	UINT								nTaskID;			// task ID
	NET_TIME							stuPicTime;			// time of picture
	int									nRetEventCount;		// the count of events
	NET_SECONDARY_ANALYSE_EVENT_INFO	stuEventInfo[MAX_SECONDARY_ANALYSE_EVENT_NUM];// event info of secondary record analysis
	LDWORD 								dwUser;				// user data
	BYTE								byReserved[1024];	// reserved
} NET_CB_ANALYSE_RESULT_INFO;

// the call back function of the result of secondary record analysis
typedef int  (CALLBACK *fAnalyseResultCallBack)(LLONG lAnalyseHandle, NET_CB_ANALYSE_RESULT_INFO *pstAnalyseResultInfo, BYTE *pBuffer, DWORD dwBufSize);

// input parameter of attach the result of secondary record analysis
typedef struct tagNET_IN_ATTACH_SECONDARY_ANALYSE_RESULT
{
	DWORD					dwSize;										// the size of this struct
	int						nTaskNum;									// the count of tasks want to attach, 0 means all
	UINT					nTaskID[MAX_SECONDARY_ANALYSE_TASK_NUM];	// task ID
	int						nEventCount;								// the count of events want to attach
	EM_ANALYSE_EVENT_TYPE	emEventType[MAX_SECONDARY_ANALYSE_TASK_NUM];// event info
	BOOL					bNeedPicData;								// is need picture data
	fAnalyseResultCallBack	cbAnalyseResult;							// the call back function of the result of secondary record analysis
	LDWORD                  dwUser;                 					// user data
} NET_IN_ATTACH_SECONDARY_ANALYSE_RESULT;

// output parameter of attach the result of secondary record analysis
typedef struct tagNET_OUT_ATTACH_SECONDARY_ANALYSE_RESULT
{
	DWORD				dwSize;										// the size of this struct
} NET_OUT_ATTACH_SECONDARY_ANALYSE_RESULT;

// attach the state of secondary record analysis, the resource of pstInParam and pstOutParam is requested and released by user
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachRecordSecondaryAnalyseTaskState(LLONG lLoginID, NET_IN_ATTACH_SECONDARY_ANALYSE_STATE *pstInParam, NET_OUT_ATTACH_SECONDARY_ANALYSE_STATE *pstOutParam, int nWaitTime);

// detach the state of secondary record analysis
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachRecordSecondaryAnalyseState(LLONG lAnalyseHandle);

// add the task of secondary record analysis, the resource of pstInParam and pstOutParam is requested and released by user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RecordSecondaryAnalyseAddTask(LLONG lLoginID, NET_IN_SECONDARY_ANALYSE_ADDTASK *pstInParam, NET_OUT_SECONDARY_ANALYSE_ADDTASK *pstOutParam, int nWaitTime);

// start the task of secondary record analysis, the resource of pstInParam and pstOutParam is requested and released by user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RecordSecondaryAnalyseStartTask(LLONG lLoginID, NET_IN_SECONDARY_ANALYSE_STARTTASK *pstInParam, NET_OUT_SECONDARY_ANALYSE_STARTTASK *pstOutParam, int nWaitTime);

// pause the task of secondary record analysis, the resource of pstInParam and pstOutParam is requested and released by user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RecordSecondaryAnalysePauseTask(LLONG lLoginID, NET_IN_SECONDARY_ANALYSE_PAUSETASK *pstInParam, NET_OUT_SECONDARY_ANALYSE_PAUSETASK *pstOutParam, int nWaitTime);

// delete the task of secondary record analysis, the resource of pstInParam and pstOutParam is requested and released by user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RecordSecondaryAnalyseRemoveTask(LLONG lLoginID, NET_IN_SECONDARY_ANALYSE_REMOVETASK *pstInParam, NET_OUT_SECONDARY_ANALYSE_REMOVETASK *pstOutParam, int nWaitTime);

// start find the task of secondary record analysis, the resource of pstInParam and pstOutParam is requested and released by user
CLIENT_NET_API LLONG CALL_METHOD CLIENT_RecordSecondaryAnalyseStartFindTask(LLONG lLoginID, NET_IN_SECONDARY_ANALYSE_STARTFIND_TASK *pstInParam, NET_OUT_SECONDARY_ANALYSE_STARTFIND_TASK *pstOutParam, int nWaitTime);

// do find the task of secondary record analysis, the resource of pstInParam and pstOutParam is requested and released by user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RecordSecondaryAnalyseDoFindTask(LLONG lFindHandle, NET_IN_SECONDARY_ANALYSE_DOFIND_TASK *pstInParam, NET_OUT_SECONDARY_ANALYSE_DOFIND_TASK *pstOutParam, int nWaitTime);

// stop find the task of secondary record analysis
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RecordSecondaryAnalyseStopFindTask(LLONG lFindHandle);

// attach the result of secondary record analysis, the resource of pstInParam and pstOutParam is requested and released by user
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachRecordSecondaryAnalyseResult(LLONG lLoginID, NET_IN_ATTACH_SECONDARY_ANALYSE_RESULT *pstInParam, NET_OUT_ATTACH_SECONDARY_ANALYSE_RESULT *pstOutParam, int nWaitTime);

// detach the result of secondary record analysis
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachRecordSecondaryAnalyseResult(LLONG lAttachHandle);

//compare result
typedef enum tagEM_COMPARE_RESULT
{
    EM_COMPARE_RESULT_UNKNOWN=-1,
	EM_COMPARE_RESULT_SUCCESS,      //success
	EM_COMPARE_RESULT_OTHERERROR,   //other error
	EM_COMPARE_RESULT_NOTINDATABASE //not in face database
}EM_COMPARE_RESULT;

//open door type
typedef enum tagEM_FACE_OPEN_DOOR_TYPE
{
	EM_FACE_OPEN_DOOR_TYPE_UNKNOWN = 0,   // unknown
	EM_FACE_OPEN_DOOR_TYPE_REMOTEFACE,     // remote face
	EM_FACE_OPEN_DOOR_TYPE_REMOTEQRCODE    // remote QR code
}EM_FACE_OPEN_DOOR_TYPE;

//user type
typedef enum tagEM_USER_TYPE
{
    EM_USER_TYPE_UNKNOWN=-1,
	EM_USER_TYPE_ORDINARY,  //ordinary user
	EM_USER_TYPE_BLACKLIST, //blacklist user
	EM_USER_TYPE_VIP,       //VIP user
	EM_USER_TYPE_GUEST,     //guest user
	EM_USER_TYPE_PATROL,    //patrol user
	EM_USER_TYPE_DISABLED,  //disabled user
	EM_USER_TYPE_FROZEN,    //frozen user
	EM_USER_TYPE_LOGOUT,    //logout user
	EM_USER_TYPE_LOSSCARD   //loss card
}EM_USER_TYPE;

// info type
typedef enum tagEM_EDUCATION_INFO_TYPE
{
    EM_EDUCATION_INFO_TYPE_UNKNOWN,                         // unknown             
    EM_EDUCATION_INFO_TYPE_CHECK_IN,                        // check in            
    EM_EDUCATION_INFO_TYPE_SIGN_BACK,                       // sign back           
    EM_EDUCATION_INFO_TYPE_ROLL_CALL,                       // roll call           
    EM_EDUCATION_INFO_TYPE_LEARNING_ABNORMAL,               // learning abnormal   
    EM_EDUCATION_INFO_TYPE_EXAMINATION,                     // examination         
    EM_EDUCATION_INFO_TYPE_END_OF_STUDY,                    // end of study        
    EM_EDUCATION_INFO_TYPE_EXPERIENCE_LEARNING,             // experience learning 
    EM_EDUCATION_INFO_TYPE_NOT_LEARNING,                    // not learning        
    EM_EDUCATION_INFO_TYPE_MIDWAY_IN,                       // midway in           
    EM_EDUCATION_INFO_TYPE_MIDWAY_LEAVE                     // midway leave        
} EM_EDUCATION_INFO_TYPE;

// custom education info
typedef struct tagNET_CUSTOM_EDUCATION_INFO
{
    EM_EDUCATION_INFO_TYPE                emInfoType;                      // info type
    int                                   nStudentSeatNumber;              // student seat number, min:1
    char                                  szInfoContent[128];              // info content
} NET_CUSTOM_EDUCATION_INFO;
	
//match information
typedef struct tagNET_OPENDOOR_MATCHINFO
{
	char         szUserID[32];     //remote user ID
	char         szUserName[32];   //user name
	EM_USER_TYPE emUserType;       //user type
	char         szName[64];       //entrance guard name
	UINT         nMatchRate;       //match rate,range is 0-100
	EM_FACE_OPEN_DOOR_TYPE     emOpenDoorType;   //open door type
    NET_TIME                              stuActivationTime;                         //(cardimage)activation time
    NET_TIME                              stuExpiryTime;                             //(cardimage)expiry time
    int                                   nScore;                                    // credit score
    char                                  szCompanyName[MAX_COMPANY_NAME_LEN];       //company name
    char                                  szCompanionName[120];                      //companion name
    char                                  szCompanionCompany[MAX_COMPANY_NAME_LEN];  //company name of companion person
    char                                  szPermissibleArea[MAX_COMMON_STRING_128];  //permissible area
	char								  szSection[200];		//Section
    NET_CUSTOM_EDUCATION_INFO*            pstuCustomEducationInfo;                   // custom education info
	BYTE         byReserved[112];
}NET_OPENDOOR_MATCHINFO;

//image information
typedef struct tagNET_OPENDOOR_IMAGEINFO
{
	int nLibImageLen;    //face library image length, limit is 150k
	int nSnapImageLen;   //snap image length, limit is 150k
	char *pLibImage;     //face library image,memory is applied by user
	char *pSnapImage;    //snap image,memory is applied by user
    BYTE byReserved[1024];
}NET_OPENDOOR_IMAGEINFO;


//face open door input parameters
typedef struct tagNET_IN_FACE_OPEN_DOOR
{
    DWORD                  dwSize;         
    UINT                   nChannel;     //door channel id
    EM_COMPARE_RESULT      emCompareResult;//compare result
    NET_OPENDOOR_MATCHINFO stuMatchInfo;    //match information
    NET_OPENDOOR_IMAGEINFO stuImageInfo;   //image information
}NET_IN_FACE_OPEN_DOOR;

//face open door output parameters
typedef struct tagNET_OUT_FACE_OPEN_DOOR
{
    DWORD dwSize;
}NET_OUT_FACE_OPEN_DOOR;

//face open door
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FaceOpenDoor(LLONG lLoginID, NET_IN_FACE_OPEN_DOOR* pInParam, NET_OUT_FACE_OPEN_DOOR* pOutParam,int nWaitTime);


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Logic volume status
typedef enum tagEM_LOGIC_VOLUME_STATUS
{	
	EM_LOGIC_VOLUME_STATUS_UNKNOWN = -1,					// Unknown
	EM_LOGIC_VOLUME_STATUS_NOT_NEED_REPAIR,					// LV not need to repair
	EM_LOGIC_VOLUME_STATUS_LV_NEED_REPAIR,					// LV need to repair
	EM_LOGIC_VOLUME_STATUS_LV_REPAIRING,					// LV repairing
	EM_LOGIC_VOLUME_STATUS_LV_REPAIR_COMPLETE,				// LV repair completely
}EM_LOGIC_VOLUME_STATUS;

// CLIENT_NASGetLogicVolumeStatus interface input param
typedef struct tagNET_IN_NAS_GETLOGICVOLUMESTATUS
{
	DWORD			dwSize;
}NET_IN_NAS_GETLOGICVOLUMESTATUS;

// CLIENT_NASGetLogicVolumeStatus interface output param
typedef struct tagNET_OUT_NAS_GETLOGICVOLUMESTATUS
{
	DWORD						dwSize;											// Struct size
	EM_LOGIC_VOLUME_STATUS		emLVStatus;										// LV status
	char						szLvName[MAX_LV_NAME_NUM][MAX_LV_NAME_LEN];		// LV Name,Valid by emLVStatus is EM_LOGIC_VOLUME_STATUS_LV_NEED_REPAIR or EM_LOGIC_VOLUME_STATUS_LV_REPAIRING
	int							nRetLvNameNum;									// Return LV name num
}NET_OUT_NAS_GETLOGICVOLUMESTATUS;

// Get logic volume status
CLIENT_NET_API BOOL CALL_METHOD CLIENT_NASGetLogicVolumeStatus(LLONG lLoginID, const NET_IN_NAS_GETLOGICVOLUMESTATUS *pInParam, NET_OUT_NAS_GETLOGICVOLUMESTATUS *pOutParam, int nWaitTime);

// Logic volume repair status
typedef enum tagEM_LOGIC_VOLUME_REPAIR_STATUS
{	
	EM_LOGIC_VOLUME_REPAIR_STATUS_UNKNOWN = -1,				// Unknown
	EM_LOGIC_VOLUME_REPAIR_STATUS_FAILED,					// Repair failed
	EM_LOGIC_VOLUME_REPAIR_STATUS_SUCCESS,					// Repair success
}EM_LOGIC_VOLUME_REPAIR_STATUS;

// LV state
typedef struct tagNET_LV_STATE
{
	EM_LOGIC_VOLUME_REPAIR_STATUS	emLVRepairStatus;								// LV repair status
	char						    szLvName[MAX_LV_NAME_NUM][MAX_LV_NAME_LEN];		// LV name
	int								nRetLvNameNum;								    // Return LV name num
	BYTE							byReserved[1024];								// Reserved
}NET_LV_STATE;

// LV repair status callback,lAttachHandle is return value of CLIENT_AttachNASRepairState
typedef void (CALLBACK *fLVRepairStateCallBack) (LLONG lAttachHandle, NET_LV_STATE* pBuf, DWORD dwBufLen, LDWORD dwUser);

// CLIENT_AttachNASRepairState interface input param
typedef struct tagNET_IN_ATTACH_NAS_REPAIRSTATE
{
	DWORD						dwSize;								// Struct size
	fLVRepairStateCallBack      cbLVRepairState;					// LV repair state callback
	BYTE						byReserved[4];						// Reserved
	LDWORD						dwUser;								// User data  
}NET_IN_ATTACH_NAS_REPAIRSTATE;

// CLIENT_AttachNASRepairState interface output param
typedef struct tagNET_OUT_ATTACH_NAS_REPAIRSTATE
{
	DWORD						dwSize;                 // Struct size
}NET_OUT_ATTACH_NAS_REPAIRSTATE;

// Attach NAS repair state
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachNASRepairState(LLONG lLoginID, const NET_IN_ATTACH_NAS_REPAIRSTATE* pInParam, NET_OUT_ATTACH_NAS_REPAIRSTATE* pOutParam, int nWaitTime);

// Detach NAS repair state
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachNASRepairState(LLONG lAttachHandle);

// File finder data 
typedef struct tagNET_FILE_FINEDER
{
	unsigned int				nRetFileListsCount;									// Return count
	char						szFileLists[MAX_FILE_LIST_NUM][MAX_FILE_LIST_LEN];	// File list
	BOOL						bFindFinished;										// Whether file finder is finish or not,TRUE means finished,FALSE means is looking for
	BYTE						byReserved[1024];									// Reserved
}NET_FILE_FINEDER;

// File finder callback,lAttachHandle is return value of CLIENT_AttachNASFileFinder
typedef void (CALLBACK *fNasFileFinderCallback) (LLONG lAttachHandle, NET_FILE_FINEDER* pBuf, DWORD dwBufLen, LDWORD dwUser);

// CLIENT_AttachNASFileFinder interface input param 
typedef struct tagNET_IN_ATTACHNASFILEFINDER
{
	DWORD						dwSize;						   // Struct size
	int							nFindPathsNum;				   // Find paths num
	char						szFindPaths[MAX_FILE_FINDER_PATH_NUM][MAX_FILE_FINDER_PATH_LEN];		   // Find path list of file finder
	char						szKey[MAX_KEY_LEN];			   // Key of file finder
	unsigned int				nOffset;					   // Offset of file finder
	unsigned int				nCount;					       // Count  of file finder
	fNasFileFinderCallback		cbNasFileFinder;			   // File finder callback
	LDWORD						dwUser;						   // User data 
}NET_IN_ATTACHNASFILEFINDER;

// CLIENT_AttachNASFileFinder interface output param
typedef struct tagNET_OUT_ATTACHNASFILEFINDER
{
	DWORD						dwSize;							// Struct size
}NET_OUT_ATTACHNASFILEFINDER;

// Attach NAS file finder
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachNASFileFinder(LLONG lLoginID, const NET_IN_ATTACHNASFILEFINDER* pInParam, NET_OUT_ATTACHNASFILEFINDER* pOutParam, int nWaitTime);

// Detach NAS file finder
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachNASFileFinder(LLONG lAttachHandle);

// playback callback stream type
typedef enum tagEM_PLAYBACK_STREAM_TYPE
{
	EM_PLAYBACK_STREAM_TYPE_UNKNOWN = -1,     // Unknwon
	EM_PLAYBACK_STREAM_TYPE_ORIGINAL_STREAM,  // Only callback original stream
	EM_PLAYBACK_STREAM_TYPE_MAX,			  // Max
}EM_PLAYBACK_STREAM_TYPE;

// Set playback callback stream type
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetPlayBackStreamType(LLONG lLoginID, EM_PLAYBACK_STREAM_TYPE emStreamType);

// CLIENT_GetFingerprintCaps input param
typedef struct tagNET_IN_GET_FINGERPRINTCAPS
{
	DWORD						dwSize;						   // struct size
}NET_IN_GET_FINGERPRINTCAPS;

// CLIENT_GetFingerprintCaps output param
typedef struct tagNET_OUT_GET_FINGERPRINTCAPS
{
	DWORD						dwSize;							// struct size
	BOOL                        bSupportFingerprint;            // support fingerpirnt flag, TRUE:yes FALSE:no
}NET_OUT_GET_FINGERPRINTCAPS;

// get fingerprint caps
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetFingerprintCaps(LLONG lLoginID, NET_IN_GET_FINGERPRINTCAPS* pInParam, NET_OUT_GET_FINGERPRINTCAPS* pOutParam, int nWaitTime);

// Device program locates market area
typedef enum tagEM_DEVICE_MARKET_AREA
{
	EM_DEVICE_MARKET_AREA_UNKNOWN,		// Unknwon
	EM_DEVICE_MARKET_AREA_MAINLAND,		// Mainland
	EM_DEVICE_MARKET_AREA_OVERSEA,		// Oversea
}EM_DEVICE_MARKET_AREA;

// CLIENT_GetMarketArea interface input param
typedef struct tagNET_IN_GET_MARKET_AREA
{
	DWORD						dwSize;				// Struct size
}NET_IN_GET_MARKET_AREA;

// CLIENT_GetMarketArea interface output param
typedef struct tagNET_OUT_GET_MARKET_AREA
{
	DWORD						dwSize;				// Struct size
	EM_DEVICE_MARKET_AREA		emMarketArea;		// Market area
}NET_OUT_GET_MARKET_AREA;

// Get market area
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetMarketArea(LLONG lLoginID, const NET_IN_GET_MARKET_AREA* pInParam, NET_OUT_GET_MARKET_AREA* pOutParam, int nWaitTime);


/////////////////////////////////radar link SD API start//////////////////////////////
//radar start upgrade notify input param(corresponding to EM_RADAR_OPERATE_TYPE_STARTUPGRADE)
typedef struct tagNET_IN_RADAR_STARTUPGRADE
{
	DWORD                       dwSize;                  // structure size
}NET_IN_RADAR_STARTUPGRADE;

//radar start upgrade notify output param(corresponding to EM_RADAR_OPERATE_TYPE_STARTUPGRADE)
typedef struct tagNET_OUT_RADAR_STARTUPGRADE
{
	DWORD                       dwSize;                  // structure size
}NET_OUT_RADAR_STARTUPGRADE;

//get radar caps input param(corresponding to EM_RADAR_OPERATE_TYPE_GETCAPS)
typedef struct tagNET_IN_RADAR_GETCAPS
{
	DWORD                       dwSize;                  // structure size
	int							nChannel;				 // Channel
}NET_IN_RADAR_GETCAPS;

//get radar caps output param(corresponding to EM_RADAR_OPERATE_TYPE_GETCAPS)
typedef struct tagNET_OUT_RADAR_GETCAPS
{
	DWORD                       dwSize;                  // structure size
	int                         nDetectionRange;         // radar detection range, the result of expand 100 times, unit:m
	int                         nDetectionAngle;         // radar detection angle, the result of expand 100 times, unit:degree
	int                         nDetectionHuman;         // radar human detection range, the result of expand 100 times, unit:m
}NET_OUT_RADAR_GETCAPS;

//get radar caps input param(corresponding to EM_RADAR_OPERATE_TYPE_GETSTATUS)
typedef struct tagNET_IN_RADAR_GETSTATUS
{
	DWORD                       dwSize;                  // structure size
	int							nChannel;				 // Channel
}NET_IN_RADAR_GETSTATUS;

//radar status
typedef enum tagEM_RADAR_STATUS
{
	EM_RADAR_STATUS_UNKNOWN,                             // unknown
	EM_RADAR_STATUS_NORMAL,                              // normal
	EM_RADAR_STATUS_ABNORMAL,                            // abnormal
}EM_RADAR_STATUS;

//get radar status output param(corresponding to EM_RADAR_OPERATE_TYPE_GETSTATUS)
typedef struct tagNET_OUT_RADAR_GETSTATUS
{
	DWORD                       dwSize;                  // structure size
	EM_RADAR_STATUS             emRadarStatus;           // radar status
}NET_OUT_RADAR_GETSTATUS;

//the pixel coordinate of line in the picture
typedef struct tagNET_RADAR_PIXELLINE
{
	int                         nLeftX;                  // X coordinate of left vertex
	int                         nLeftY;                  // Y coordinate of left vertex
	int                         nRightX;                 // X coordinate of right vertex
	int                         nRightY;                 // Y coordinate of right vertex
	BYTE                        byReserved[64];          // reserved byte
}NET_RADAR_PIXELLINE;

//calculate the real size  of the map corresponding to the picture input param(corresponding to EM_RADAR_OPERATE_TYPE_CALCULATEREALSIZE)
typedef struct tagNET_IN_RADAR_CALCULATEREALSIZE
{
	DWORD                       dwSize;                  // structure size
	int							nChannel;				 // channel
	NET_RADAR_PIXELLINE         stuPixelLine;            // the pixel coordinate of line in the picture
	double                      dDistance;               // the real length of line express in the picture, unit:m
}NET_IN_RADAR_CALCULATEREALSIZE;

//calculate the real size  of the map corresponding to the picture output param(corresponding to EM_RADAR_OPERATE_TYPE_CALCULATEREALSIZE)
typedef struct tagNET_OUT_RADAR_CALCULATEREALSIZE
{
	DWORD                       dwSize;                  // structure size
	int                         nRealMapLength;          // real map height, unit:m(the result of expand 100 times)
	int                         nRealMapWidth;           // real map width, unit:m(the result of expand 100 times)
}NET_OUT_RADAR_CALCULATEREALSIZE;

//calibration pixel point in the map
typedef struct tagNET_RADAR_PIXELPOINT
{								
	int                         nPixelPointX;			 // X pixel point(0~8191) 
	int                         nPixelPointY;			 // Y pixel point(0~8191)
}NET_RADAR_PIXELPOINT;

//radar calibration input param(corresponding to EM_RADAR_OPERATE_TYPE_SETCALIBRATION)
typedef struct tagNET_IN_RADAR_SETCALIBRATION
{
	DWORD                       dwSize;                  // structure size
	BYTE                        byReserved[4];           // reserved byte
	NET_RADAR_PIXELPOINT        stuPixelPoint;           // calibration pixel point in the map
	double                      dInstallHeigt;           // the install height of SD, unit:m
}NET_IN_RADAR_SETCALIBRATION;

//radar calibration output param(corresponding to EM_RADAR_OPERATE_TYPE_SETCALIBRATION)
typedef struct tagNET_OUT_RADAR_SETCALIBRATION
{
	DWORD                       dwSize;                  // structure size
}NET_OUT_RADAR_SETCALIBRATION;

//radar operate type
typedef enum tagEM_RADAR_OPERATE_TYPE
{
	EM_RADAR_OPERATE_TYPE_STARTUPGRADE = 0,              // radar start upgrade notify,input:NET_IN_RADAR_STARTUPGRADE,output:NET_OUT_RADAR_STARTUPGRADE
	EM_RADAR_OPERATE_TYPE_GETCAPS = 1,                   // get radar caps,input:NET_IN_RADAR_GETCAPS,output:NET_OUT_RADAR_GETCAPS
	EM_RADAR_OPERATE_TYPE_GETSTATUS = 2,                 // get radar status,input:NET_IN_RADAR_GETSTATUS,output:NET_OUT_RADAR_GETSTATUS
	EM_RADAR_OPERATE_TYPE_CALCULATEREALSIZE = 3,         // calculate the real size  of the map corresponding to the picture,input:NET_IN_RADAR_CALCULATEREALSIZE,output:NET_OUT_RADAR_CALCULATEREALSIZE
	EM_RADAR_OPERATE_TYPE_SETCALIBRATION = 4,            // set radar calibration config,input:NET_IN_RADAR_SETCALIBRATION,output:NET_OUT_RADAR_SETCALIBRATION
}EM_RADAR_OPERATE_TYPE;

//radar operate
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RadarOperate(LLONG lLoginID, EM_RADAR_OPERATE_TYPE emType, void* pInBuf, void* pOutBuf, int nWaitTime);

#define NET_RADAR_MAX_NUM_ALARMPOINT    64               // the max num of radar alarm point

//point type
typedef enum tagEM_RADAR_POINTTYPE
{
	EM_RADAR_POINTTYPE_UNKNOWN,                          // unknown
	EM_RADAR_POINTTYPE_ALARMPOINT,                       // alarm point of alarm area
	EM_RADAR_POINTTYPE_LINKMONITORPOINT,                 // points being monitored by linkage
	EM_RADAR_POINTTYPE_DISAPPEARTRACKPOINT,              // disappear track point
}EM_RADAR_POINTTYPE;

//radar object type
typedef enum tagEM_RADAR_OBJECTTYPE
{
	EM_RADAR_OBJECTTYPE_UNKNOWN,                         // unknown
	EM_RADAR_OBJECTTYPE_PERSON,                          // person
	EM_RADAR_OBJECTTYPE_VEHICLE,                         // vehicle
	EM_RADAR_OBJECTTYPE_TREE,                            // tree
	EM_RADAR_OBJECTTYPE_BUILIDING,                       // building
	EM_RADAR_OBJECTTYPE_SCREEN,                          // screen
}EM_RADAR_OBJECTTYPE;

//single radar alarm point info
typedef struct tagNET_RADAR_ALARMPOINT_INFO
{
	EM_RADAR_POINTTYPE          emPointType;             // point type,the field is abandoned.please do not use, use nPointType
	int                         nPointType;              // point type
	//bit0:invalid
	//bit1:disappear track point
	//bit2:points being monitored by linkage
	//bit3:alarm point of alarm area
	int                         nRegionNumber;           // region number, range[0,10]([1,10] is defense area number,0 indicates that it does not belong to any defense area)
	EM_RADAR_OBJECTTYPE         emObjectType;            // radar object type
	int                         nTrackID;                // track ID, range[0,63]
	int                         nDistance;               // distance, the result of expand 100 times, unit:m
	int                         nAngle;                  // angle, the result of expand 100 times, unit:degree
	int                         nSpeed;                  // point speed, the result of expand 100 times, unit:s
	BYTE                        byReserved[512];         // reserved byte
}NET_RADAR_ALARMPOINT_INFO;

//notify radar alarm point info
typedef struct tagNET_RADAR_NOTIFY_ALARMPOINTINFO
{
	int                         nNumAlarmPoint;          // radar alarm point number
	NET_RADAR_ALARMPOINT_INFO   stuAlarmPoint[NET_RADAR_MAX_NUM_ALARMPOINT];  // radar alarm point info
	int							nChannel;				// channel
	BYTE                        byReserved[1020];        // reserved
}NET_RADAR_NOTIFY_ALARMPOINTINFO;

//radar alarm point info callback
typedef void (CALLBACK *fRadarAlarmPointInfoCallBack) (LLONG lLoginId, LLONG lAttachHandle, const NET_RADAR_NOTIFY_ALARMPOINTINFO* pBuf, DWORD dwBufLen, void* pReserved, LDWORD dwUser);

//attach radar alarm point info input param(corresponding to CLIENT_AttachRadarAlarmPointInfo)
typedef struct tagNET_IN_RADAR_ALARMPOINTINFO
{
	DWORD                       dwSize;                  // structure size
	fRadarAlarmPointInfoCallBack    cbAlarmPointInfo;    // radar alarm point info callback
	LDWORD                      dwUser;                  // user data
	int							nChannel;				 // channel
}NET_IN_RADAR_ALARMPOINTINFO;

//attach radar alarm point info output param(corresponding to CLIENT_AttachRadarAlarmPointInfo)
typedef struct tagNET_OUT_RADAR_ALARMPOINTINFO
{
	DWORD                       dwSize;                  // structure size
}NET_OUT_RADAR_ALARMPOINTINFO;

//attach radar alarm point info
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachRadarAlarmPointInfo(LLONG lLoginID, const NET_IN_RADAR_ALARMPOINTINFO * pstInParam, NET_OUT_RADAR_ALARMPOINTINFO* pstOutParam, int nWaitTime);

//detach radar alarm point info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachRadarAlarmPointInfo(LLONG lAttachHandle);

// The input param of CLIENT_GetRadarLinkSDState
typedef struct tagNET_IN_RADAR_GET_LINKSTATE
{
	DWORD						dwSize;					// structure size
	int							nChannel;				// channel id
	int							nSDLinkNum;				// The number of ip which state you want to get
	char						szSDLinkIP[MAX_RADAR_SD_NUM][32];//The array of ip which state you want to get
}NET_IN_RADAR_GET_LINKSTATE;

// Link device state
typedef enum tagNET_EM_RADAR_LINK_SD_STATE
{
	NET_EM_RADAR_LINK_SD_STATE_UNKNOWN = -1,					// Unknown
	NET_EM_RADAR_LINK_SD_STATE_NORMAL,							// Normal
	NET_EM_RADAR_LINK_SD_STATE_TIMEOUT,							// Timeout
	NET_EM_RADAR_LINK_SD_STATE_OFFLINE,							// Offline
	NET_EM_RADAR_LINK_SD_STATE_NOT_LINK,						// Not link
}NET_EM_RADAR_LINK_SD_STATE;

// Link device state information
typedef struct tagNET_LINKSTATE_INFO
{
	char						szSDLinkIP[32];			// Link device ip
	NET_EM_RADAR_LINK_SD_STATE	emState;				// Link device state
	int							nVirtualChannel;		// virtual channel number, be used to control sd, start from 1
	BYTE						byReserved[1020];		// reserved	
}NET_LINKSTATE_INFO;

// The output param of CLIENT_GetRadarLinkSDState
typedef struct tagNET_OUT_RADAR_GET_LINKSTATE
{
	DWORD						dwSize;					// structure size
	int							nSDLinkNum;				// The number of SD
	NET_LINKSTATE_INFO			stuSDLinkState[MAX_RADAR_SD_NUM];// The state of SD
}NET_OUT_RADAR_GET_LINKSTATE;

// The information of link-device
typedef struct tagNET_RADARLINKDEVICE_ADD_INFO
{
	char						szSDLinkIP[32];			 // Link device ip
	char						szUserName[128];		 // Username
	char						szPassword[32];			 // Password
	int							nPort;					 // Port
	BYTE						byReserved[316];		 // Reserved
}NET_RADARLINKDEVICE_ADD_INFO;

// Input param of CLIENT_AddRadarLinkSD
typedef struct tagNET_IN_RADAR_ADD_RADARLINKSD
{
	DWORD							dwSize;							// Structure size
	int								nChannelID;						// Channel ID
	NET_RADARLINKDEVICE_ADD_INFO	stuDevices[MAX_RADAR_SD_NUM];	// Link device list
	int								nDevicesNum;					// The number of devices wait to add
}NET_IN_RADAR_ADD_RADARLINKSD;

// Error code
typedef enum tagNET_EM_RADARLINKDEVICE_ADD_ERRORCODE
{
	EM_EM_RADARLINKDEVICE_ADD_UNKNOWN = -1,							// Unknown
	EM_EM_RADARLINKDEVICE_ADD_SUCCESS = 0,							// Success
	EM_EM_RADARLINKDEVICE_ADD_TIMEOUT,								// Timeout
	EM_EM_RADARLINKDEVICE_ADD_ACCOUNTERROR,							// Account error
	EM_EM_RADARLINKDEVICE_ADD_NOTSUPPORT,							// Device not support
}NET_EM_RADARLINKDEVICE_ADD_ERRORCODE;

// Add result
typedef struct tagNET_RADARLINKDEVICE_ADD_RESULT
{
	NET_EM_RADARLINKDEVICE_ADD_ERRORCODE	emErrorCode;			// Error code
	BYTE									byReserved[252];		// Reserved
}NET_RADARLINKDEVICE_ADD_RESULT;

// Output param of CLIENT_AddRadarLinkSD
typedef struct tagNET_OUT_RADAR_ADD_RADARLINKSD
{
	DWORD							dwSize;							// Structure size
	int								nRetResultNum;					// The number of result
	NET_RADARLINKDEVICE_ADD_RESULT	stuAddResult[MAX_RADAR_SD_NUM];	// The result of add
}NET_OUT_RADAR_ADD_RADARLINKSD;

// The information of link-device
typedef struct tagNET_RADARLINKDEVICE_DEL_INFO
{
	char						szSDLinkIP[32];			 // Link device ip
	BYTE						byReserved[224];		 // Reserved
}NET_RADARLINKDEVICE_DEL_INFO;

// Input param of CLIENT_DelRadarLinkSD
typedef struct tagNET_IN_RADAR_DEL_RADARLINKSD
{
	DWORD							dwSize;							// Structure size
	int								nChannelID;						// Channel id
	NET_RADARLINKDEVICE_DEL_INFO	stuDevices[MAX_RADAR_SD_NUM];	// Link device list
	int								nDevicesNum;					// The number of devices wait to delete.0 means delete all
}NET_IN_RADAR_DEL_RADARLINKSD;

// Output param of CLIENT_DelRadarLinkSD
typedef struct tagNET_OUT_RADAR_DEL_RADARLINKSD
{
	DWORD							dwSize;							// Structure size
}NET_OUT_RADAR_DEL_RADARLINKSD;

// Input param of CLIENT_RadarManualLocate
typedef struct tagNET_IN_RADAR_MANUAL_LOCATE
{
	DWORD							dwSize;							// Structure size
	int								nChannelID;						// Channel id
	NET_POINT						stuLocatePoint;					// The point of locate
}NET_IN_RADAR_MANUAL_LOCATE;

// Output param of CLIENT_RadarManualLocate
typedef struct tagNET_OUT_RADAR_MANUAL_LOCATE
{
	DWORD							dwSize;							// Structure size
}NET_OUT_RADAR_MANUAL_LOCATE;

// RFID card action
typedef enum tagNET_EM_RADAR_RFIDCARD_ACTION
{
	EM_RADAR_RFIDCARD_ACTION_UNKNOWN = 0,							// Unknown
	EM_RADAR_RFIDCARD_ACTION_LEAVE,									// Leave
	EM_RADAR_RFIDCARD_ACTION_ENTER,									// Enter
}NET_EM_RADAR_RFIDCARD_ACTION;

// RFID card information
typedef struct tagNET_RADAR_RFIDCARD_INFO
{
	char							szCardID[24];					// Card ID
	NET_EM_RADAR_RFIDCARD_ACTION	emCardAction;					// Card action
	BYTE							byReserved[124];				// Reserved
}NET_RADAR_RFIDCARD_INFO;

// Radar notify RFID card information
typedef struct tagNET_RADAR_NOTIFY_RFIDCARD_INFO
{
	int							nChannel;
	int							nCardNum;
	NET_RADAR_RFIDCARD_INFO		stuCardInfo[256];		 // RFID card information
	BYTE                        byReserved[1024];        // Reserved
}NET_RADAR_NOTIFY_RFIDCARD_INFO;

// callback of Radar RFID card information
typedef void (CALLBACK *fRadarRFIDCardInfoCallBack) (LLONG lLoginId, LLONG lAttachHandle, const NET_RADAR_NOTIFY_RFIDCARD_INFO* pBuf, DWORD dwBufLen, void* pReserved, LDWORD dwUser);

// CLIENT_AttachRadarRFIDCardInfo input param
typedef struct tagNET_IN_ATTACH_RADAR_RFIDCARD_INFO
{
	DWORD							dwSize;							// Structure size
	int								nChannelID;						// Channel id
	fRadarRFIDCardInfoCallBack		cbRFIDCardInfo;					// Callback of Radar RFID card information
	LDWORD							dwUser;							// User data
}NET_IN_ATTACH_RADAR_RFIDCARD_INFO;

// CLIENT_AttachRadarRFIDCardInfo output param
typedef struct tagNET_OUT_ATTACH_RADAR_RFIDCARD_INFO
{
	DWORD							dwSize;							// Structure size
}NET_OUT_ATTACH_RADAR_RFIDCARD_INFO;

// radar get link SD state
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetRadarLinkSDState(LLONG lLoginID, const NET_IN_RADAR_GET_LINKSTATE * pstInParam, NET_OUT_RADAR_GET_LINKSTATE* pstOutParam, int nWaitTime);

// Radar add link-SD
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddRadarLinkSD(LLONG lLoginID, const NET_IN_RADAR_ADD_RADARLINKSD * pstInParam, NET_OUT_RADAR_ADD_RADARLINKSD* pstOutParam, int nWaitTime);

// Radar delete link-SD
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DelRadarLinkSD(LLONG lLoginID, const NET_IN_RADAR_DEL_RADARLINKSD * pstInParam, NET_OUT_RADAR_DEL_RADARLINKSD* pstOutParam, int nWaitTime);

// Manual locate
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RadarManualLocate(LLONG lLoginID, const NET_IN_RADAR_MANUAL_LOCATE * pstInParam, NET_OUT_RADAR_MANUAL_LOCATE* pstOutParam, int nWaitTime);

// Radar attach RFID card information
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachRadarRFIDCardInfo(LLONG lLoginID, const NET_IN_ATTACH_RADAR_RFIDCARD_INFO * pstInParam, NET_OUT_ATTACH_RADAR_RFIDCARD_INFO* pstOutParam, int nWaitTime);

// Radar detach RFID card information
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachRadarRFIDCardInfo(LLONG lAttachHandle);

//radar region detection event(corresponding to DH_ALARM_RADAR_REGIONDETECTION)
typedef struct tagALARM_RADAR_REGIONDETECTION_INFO
{
	int                         nAction;                 // event action 1:Start 2:Stop
	NET_TIME_EX			        stuTime;				 // event occur time
	BYTE                	    byReserved[512];       	 // reserved byte 
}ALARM_RADAR_REGIONDETECTION_INFO;

//radar map param configuration(corresponding to NET_EM_CFG_RADAR_MAPPARA)
typedef struct tagNET_CFG_RADAR_MAPPARA_INFO
{
	DWORD                       dwSize;                  // structure size
	BYTE                        byReserved[4];           // reserved byte
	NET_RADAR_PIXELLINE         stuPixelLine;            // the pixel coordinates of line in the map
	double                      dDistance;               // the real length of line express in the map,unit:m
	NET_RADAR_PIXELPOINT        stuPixelPoint;           // the pixel coordinates of radar in the map
	double                      dRadarDirectionAngle;    // radar direction angle,unit:degree
}NET_CFG_RADAR_MAPPARA_INFO;

//Calibration position information
typedef struct tagNET_RADAR_CALIBRATIONPOS
{
	NET_RADAR_PIXELPOINT        stuPixelPoint;           // pixel point
	double                      dPositionX;              // horizontal, normalized to -1~1
	double                      dPositionY;              // vertical, normalized to -1~1
	double                      dZoom;                   // aperture magnification, normalized to 0~1
	BYTE                	    byReserved[512];       	 // reserved
}NET_RADAR_CALIBRATIONPOS;

// calibration parameters
typedef struct tagNET_RADAR_CALIBRATION_PARAS
{
	int							nCalibrationPosNum;		 // The number of calibration position
	BYTE                	    byReserved1[4];       	 // Byte alignment 
	NET_RADAR_CALIBRATIONPOS	stuCalibrationPos[4];	 // The array of calibration position
	char						szSDLinkIP[32];			 // The ip of device which was controlled
	double                      dLinkSDHeight;			 // Link SD install height, unit:m
	double                      dTiltRecoupAngle;		 // Link SD slope compensation angle
	BYTE                	    byReserved[1024];        // Reserved 
}NET_RADAR_CALIBRATION_PARAS;

//radar calibration configuration(corresponding to NET_EM_CFG_RADAR_CALIBRATION)
typedef struct tagNET_CFG_RADAR_CALIBRATION_INFO
{
	DWORD                       dwSize;									// structure size
	int							nCalibrationParasNum;					// The array of calibration parameters
	NET_RADAR_CALIBRATION_PARAS	stuCalibrationParas[MAX_RADAR_SD_NUM];	// calibration parameters
	double                      dInstallHeight;							// Radar install height, unit:m
	double                      dSlopeAngle;							// Radar Slope compensation angle
}NET_CFG_RADAR_CALIBRATION_INFO;

//radar link SD enable configuration(corresponding to NET_EM_CFG_RADAR_LINKSD)
typedef struct tagNET_CFG_RADAR_LINKSD_INFO
{
	DWORD                       dwSize;                  // structure size
	BOOL                        bRadarLink;              // radar link SD enable
}NET_CFG_RADAR_LINKSD_INFO;

#define NET_RADAR_MAX_NUM_RULELINE       10              // the max num of guard line
#define NET_RADAR_MAX_NUM_POLYGON         24             // the max num of guard line vertex

//radar guard type
typedef enum tagEM_RADAR_RULETYPE
{
	EM_RADAR_RULETYPE_UNKNOWN,                           // unknown
	EM_RADAR_RULETYPE_ALARM,                             // alarm
	EM_RADAR_RULETYPE_SHIELD,                            // shield
	EM_RADAR_RULETYPE_HIGHALARM,                         // High alarm
}EM_RADAR_RULETYPE;

#define RADAR_TARGET_FILTER_HUMAN	0x01				 // Human
#define RADAR_TARGET_FILTER_CAR		0x02				 // Car
#define RADAR_TARGET_FILTER_ANIMAL	0x04				 // Animal

//guard line
typedef struct tagNET_RADAR_RULELINE
{
	char                        szName[DH_COMMON_STRING_128];// guard name
	int                         nRegionNumber;               // region number,range[1,10]
	BOOL                        bEnable;                     // rule enable
	EM_RADAR_RULETYPE           emRuleType;                  // radar rule type
	DH_POINT		            stuPolygon[DH_MAX_POLYGON_NUM];	// polygon,Each of the points represents the guard line vertex coordinate
	int					        nPolygonPointNum;	         // return polygon point num,range[3, 24]
	int							nTargetFilter;				 // Target filtering bit1:Human, bit2:Car, bit3:Animal Config with|,Check with&
	int							nAlarmOutNumber;			 // Alarm output configuration association, correspond to nAlarmOutNumber in NET_RADAR_ANALYSERULE configuration 
	BYTE                        byReserved[504];             // Reserved
}NET_RADAR_RULELINE;

//radar guard line configuration(corresponding to NET_EM_CFG_RADAR_RULELINE)
typedef struct tagNET_CFG_RADAR_RULELINE_INFO
{
	DWORD                       dwSize;                  // structure size
	int                         nNumRuleLine;            // the num of rule line
	NET_RADAR_RULELINE          stuRuleLine[NET_RADAR_MAX_NUM_RULELINE];   //rule line
}NET_CFG_RADAR_RULELINE_INFO;

// Alarm linkage configuration
typedef struct tagNET_RADAR_ANALYSERULE
{
	char						szSDLinkIP[32];			 // The ip of device which was controlled
	int							nAlarmOutNumber;		 // The id of Alarm configuration
	BOOL                        bEnable;                 // alarm enable
	NET_CFG_ALARM_MSG_HANDLE    stuEventHandler;         // alarm link configuration
	BYTE                        byReserved[1024];        // Reserved
}NET_RADAR_ANALYSERULE;

//radar link analyse rule configuration(corresponding to NET_EM_CFG_RADAR_ANALYSERULE)
typedef struct tagNET_CFG_RADAR_ANALYSERULE_INFO
{
	DWORD                       dwSize;                  // structure size
	int							nAnalyseRuleNum;		 // The number of alarm linkage configuration
	NET_RADAR_ANALYSERULE		stuAnalyseRules[MAX_RADAR_SD_NUM];		 // The array of alarm linkage configuration
}NET_CFG_RADAR_ANALYSERULE_INFO;

//track switch mode
typedef enum tagEM_RADAR_TRACKSWITCHMODE
{
	EM_RADAR_TRACKSWITCHMODE_UNKNOWN,                    // unknown
	EM_RADAR_TRACKSWITCHMODE_ROTATION,                   // rotation
	EM_RADAR_TRACKSWITCHMODE_TIMEFIRST,                  // time priority
	EM_RADAR_TRACKSWITCHMODE_DISTANCEFIRST,              // distance priority
}EM_RADAR_TRACKSWITCHMODE;

//radar track global configuration(corresponding to NET_EM_CFG_RADAR_TRACKGLOBALCONFIG)
typedef struct tagNET_CFG_RADAR_TRACKGLOBALCONFIG_INFO
{
	DWORD                       dwSize;                  // structure size
	BOOL                        bSectorDisable;          // sector disable
	int                         nTrajectoryTime;         // trajectory time,unit:s,range[3,30]
	int                         nTrackSwitchTime;        // track switch time,unit:s,range[1,15]
	EM_RADAR_TRACKSWITCHMODE    emTrackSwitchMode;       // track switch mode
}NET_CFG_RADAR_TRACKGLOBALCONFIG_INFO;

// Radar scene type
typedef enum tagNET_EM_RADAR_SCENE_TYPE
{
	NET_EM_RADAR_SCENE_UNKNOWN = 0,						// Unknown
	NET_EM_RADAR_SCENE_DEFAULT,							// Default
	NET_EM_RADAR_SCENE_SHRUB,							// Shrub
	NET_EM_RADAR_SCENE_ROOMY,							// Roomy
	NET_EM_RADAR_SCENE_CUSTOM,							// Custom
}NET_EM_RADAR_SCENE_TYPE;

// Radar scene
typedef struct tagNET_RADAR_SCENE
{
	NET_EM_RADAR_SCENE_TYPE emType;						// Radar scene type
	BYTE					byReserved[508];			// Reserved
}NET_RADAR_SCENE;

// Radar Structured
typedef struct tagNET_RADAR_STRUCTURED
{
	BOOL					bEnable;					// Enable
	BYTE					byReserved[508];			// Reserved
}NET_RADAR_STRUCTURED;

// Radar capacity
typedef struct tagNET_RADAR_CAPACITY
{
	int						nPower;						// Power 1:50m; 2:100m; 3:150m
	BYTE					byReserved[508];			// Reserved
}NET_RADAR_CAPACITY;

// Radar Channel
typedef struct tagNET_RADAR_RADARCHANNEL
{
	int						nRoute;						// Channel, 1: Channel 1   2:Channel 2
	BYTE					byReserved[508];			// Reserved
}NET_RADAR_RADARCHANNEL;

// The screen ratio of radar link SD 
typedef struct tagNET_RADAR_TARGETRATIO
{
	int						nRatio;						// The reciprocal of ratio
	BYTE					byReserved[60];				// Reserved
}NET_RADAR_TARGETRATIO;

//Radar param configuration (corresponding to NET_EM_CFG_RADAR_RADARPARA)
typedef struct tagNET_CFG_RADAR_RADARPARA_INFO
{
	DWORD                       dwSize;                  // structure size
	NET_RADAR_SCENE				stuScene;			     // Radar scene
	NET_RADAR_STRUCTURED		stuStructured;			 // Radar Structured
	NET_RADAR_CAPACITY			stuCapacity;			 // Radar capacity
	NET_RADAR_RADARCHANNEL		stuRadarChannel;		 // Radar Signal
	NET_RADAR_TARGETRATIO		stuTargetRatio;			 // The screen ratio of radar link SD 
}NET_CFG_RADAR_RADARPARA_INFO;

//Remote device linkage enable information
typedef struct tagNET_REMOTESDLINK_INFO
{
	char						szSDLinkIP[32];			 // The ip of SD
	BOOL						bRadarLink;				 // enable
	BYTE						byReserved[476];		 // Reserved
}NET_REMOTESDLINK_INFO;

//Radar remote SD link enable configuration(corresponding to NET_EM_CFG_RADAR_REMOTESDLINK)
typedef struct tagNET_CFG_RADAR_REMOTESDLINK_INFO
{
	DWORD                       dwSize;                  // structure size
	int							nLinkNum;				 // The number of linkage SD
	NET_REMOTESDLINK_INFO		stuLinkInfos[MAX_RADAR_SD_NUM];// Remote SD link enable information
}NET_CFG_RADAR_REMOTESDLINK_INFO;

//Remote link device information
typedef struct tagNET_RADARLINKDEVICE_INFO
{
	char						szSDLinkIP[32];			 // The ip of SD
	char						szVendor[32];			 // Vendor
	int							nPort;					 // Port(not used, Please use CLIENT_AddRadarLinkSD instead)
	char						szUserName[128];		 // Username(not used, Please use CLIENT_AddRadarLinkSD instead)
	char						szPassword[32];			 // Password(not used, Please use CLIENT_AddRadarLinkSD instead)
	char						szDeviceType[32];		 // Device type
	char						szDeviceName[128];		 // Device name
	BYTE						byReserved[124];		 // Reserved
}NET_RADARLINKDEVICE_INFO;

//Remote link devices information configuration (corresponding to NET_EM_CFG_RADAR_RADARLINKDEVICE)
typedef struct tagNET_CFG_RADAR_RADARLINKDEVICE_INFO
{
	DWORD                       dwSize;                  // structure size
	int							nDevNum;				 // The number of remote devices
	NET_RADARLINKDEVICE_INFO	stuDevInfo[MAX_RADAR_SD_NUM]; // The array of remote devices
}NET_CFG_RADAR_RADARLINKDEVICE_INFO;

// OSD overlay area
typedef enum tagNET_EM_OSD_AREA
{
	NET_EM_OSD_AREA_UNKNOWN,							 // Unknown
	NET_EM_OSD_AREA_LEFT_TOP,							 // Left-top
	NET_EM_OSD_AREA_MID_TOP,							 // Mid-top
	NET_EM_OSD_AREA_RIGHT_TOP,							 // Right-top
	NET_EM_OSD_AREA_MID_LEFT,							 // Mid-left
	NET_EM_OSD_AREA_MID_RIGHT,							 // Mid-right
	NET_EM_OSD_AREA_LEFT_BOTTOM,						 // Left-bottom
	NET_EM_OSD_AREA_MID_BOTTOM,							 // Mid-bottom
	NET_EM_OSD_AREA_RIGHT_BOTTOM,						 // Right-bottom
}NET_EM_OSD_AREA;

//Radar map OSD overlay param configuration(corresponding to NET_EM_CFG_RADAR_MAPOSDPARA)
typedef struct tagNET_CFG_RADAR_MAPOSDPARA_INFO
{
	DWORD                       dwSize;                  // structure size
	NET_EM_OSD_AREA				emOSDArea;				 // Overlay position
}NET_CFG_RADAR_MAPOSDPARA_INFO;

/////////////////////////////////radar link SD API end////////////////////////////////

#define NET_CFG_MAX_CTRLTYPE_NUM       16            // max gateway control method
#define NET_MAX_ALL_SNAP_CAR_COUNT	   32			 // All snap car class count

// gateway control method enumeration
typedef enum tagNET_EM_CFG_TRAFFICSTROBE_CTRTYPE
{
	NET_EM_CFG_CTRTYPE_UNKNOWN = 0,                 // undefined
	NET_EM_CFG_CTRTYPE_TRAFFICTRUSTLIST,            // via white list control gateway, only white list vehicle open gateway
	NET_EM_CFG_CTRTYPE_ALLSNAPCAR,                  // vehicle open gateway for all snapshots
	NET_EM_CFG_CTRTYPE_ORDER,                       // open gateway commend sent from upper level
} NET_EM_CFG_TRAFFICSTROBE_CTRTYPE;

// All snap car class
typedef enum tagNET_EM_CFG_ALL_SNAP_CAR
{
	NET_EM_CFG_ALL_SNAP_CAR_UNKNOWN,				// Unknown
	NET_EM_CFG_ALL_SNAP_CAR_PLATE,					// Plate
	NET_EM_CFG_ALL_SNAP_CAR_NOPLATE,				// No plate
}NET_EM_CFG_ALL_SNAP_CAR;

// Gateway stationary open config
typedef struct tagNET_CFG_STATIONARY_OPEN
{
	BOOL							bEnable;			// enable
	NET_CFG_TIME_SCHEDULE			stTimeShecule;		// stationary open time schedule
}NET_CFG_STATIONARY_OPEN;

// Gateway config info(corresponding NET_EM_CFG_TRAFFICSTROBE command)
typedef struct tagNET_CFG_TRAFFICSTROBE_INFO
{
	DWORD								dwSize;										// struct size
	BOOL								bEnable;									// enable
	int									nCtrlTypeCount;								// gateway control method number
	NET_EM_CFG_TRAFFICSTROBE_CTRTYPE    emCtrlType[NET_CFG_MAX_CTRLTYPE_NUM];		// gateway control method
	int									nAllSnapCarCount;							// All Snap Car class number
	NET_EM_CFG_ALL_SNAP_CAR				emAllSnapCar[NET_MAX_ALL_SNAP_CAR_COUNT];	// All Snap Car class	
	NET_ALARM_MSG_HANDLE				stuEventHandler;							// enable gateway link parameter
	NET_ALARM_MSG_HANDLE				stuEventHandlerClose;						// disable gateway link parameter
	char								szOrderIP[DH_MAX_IPADDR_EX_LEN];			// platform ip of order open gateway
	NET_EM_CFG_TRAFFICSTROBE_CTRTYPE	emCtrlTypeOnDisconnect;						// gateway control method when platform ip disconnect with device
	NET_CFG_STATIONARY_OPEN				stuStationaryOpen;							// Gateway stationary open config
}NET_CFG_TRAFFICSTROBE_INFO;

// CLIENT_DialRecognitionAddTask interface input param
typedef struct tagNET_IN_DIALRECOGNITION_ADD_TASK
{
	DWORD				dwSize;				// Struct size
	unsigned int		nChannel;			// Channel
	unsigned int		nPresetID;			// Preset ID.if device is general IPC,this value must be 0,otherwise the task will fail to add.
}NET_IN_DIALRECOGNITION_ADD_TASK;

// Add result
typedef enum tagEM_ADD_RESULT
{
	EM_ADD_RESULT_UNKNOWN,			// Unknown
	EM_ADD_RESULT_SUCCESS,			// Add success
	EM_ADD_RESULT_PRESET_ERROR,		// Preset error
}EM_ADD_RESULT;

// CLIENT_DialRecognitionAddTask interface output param
typedef struct tagNET_OUT_DIALRECOGNITION_ADD_TASK
{
	DWORD				dwSize;								// Struct size
	EM_ADD_RESULT		emAddResult;						// Add result
	char				szTaskID[MAX_TASK_ID_LEN];			// Task ID,It is valid when emAddResult is EM_ADD_RESULT_SUCCESS
}NET_OUT_DIALRECOGNITION_ADD_TASK;

// Add instrument idetification task
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DialRecognitionAddTask(LLONG lLoginID, const NET_IN_DIALRECOGNITION_ADD_TASK* pInParam, NET_OUT_DIALRECOGNITION_ADD_TASK* pOutParam, int nWaitTime);

// Current task state
typedef enum tagEM_CURRENT_TASK_STATE
{
	EM_CURRENT_TASK_STATE_UNKNWON,			// Unknown
	EM_CURRENT_TASK_STATE_FAILED,			// task processing failed
	EM_CURRENT_TASK_STATE_SUCCEEDED,		// task processing succeeded
}EM_CURRENT_TASK_STATE;

// Error code type
typedef enum tagEM_ERROR_CODE_TYPE
{
	EM_ERROR_CODE_TYPE_UNKNOWN,				// Unknown
	EM_ERROR_CODE_TYPE_NORMAL,				// Normal
	EM_ERROR_CODE_TYPE_GET_PICTURE_ERROR,	// Get picture error
	EM_ERROR_CODE_TYPE_ALGO_ERROR,			// Algorithm error
}EM_ERROR_CODE_TYPE;

// Instrument type
typedef enum tagEM_INSTRUMENT_TYPE
{
	EM_INSTRUMENT_TYPE_UNKNOWN,			// Unknown
	EM_INSTRUMENT_TYPE_STATE,			// State type
	EM_INSTRUMENT_TYPE_STATEMATCH,		// State match type
	EM_INSTRUMENT_TYPE_METER,			// Meter type
	EM_INSTRUMENT_TYPE_CHAR,			// Digital recognition type
	EM_INSTRUMENT_TYPE_OIL,				// Oil type
	EM_INSTRUMENT_TYPE_SWIIDEN,			// Switch identification type
	EM_INSTRUMENT_TYPE_LIGHT,			// Light type
	EM_INSTRUMENT_TYPE_SWITCH,			// Switch type
	EM_INSTRUMENT_TYPE_APPEARANCE,		// Appearance type
}EM_INSTRUMENT_TYPE;

// Picture type
typedef enum tagEM_PIC_TYPE
{
	EM_PIC_TYPE_UNKNOWN = -1,		// Unknown
	EM_PIC_TYPE_ALGORITHMICALLY_PROCESSED,			// Algorithmically processed picture
}EM_PIC_TYPE;

// Image info
typedef struct tagNET_IMAGE_INFO
{
	EM_PIC_TYPE			emPicType;							// Picture type
	unsigned int		nOffset;							// Offset in binary data
	unsigned int		nLength;							// Length,Unit:Byte
	char				szFilePath[MAX_FILE_PATH_LEN];		// File path
	BYTE				byReserved[1024];					// Reserved
}NET_IMAGE_INFO;

// Node info
typedef struct tagNET_NODE_INFO
{
	unsigned int			nChannel;									// Channel
	unsigned int			nPresetID;									// PresetID
	EM_INSTRUMENT_TYPE		emInstrumentType;							// Instrument Type
	NET_IMAGE_INFO			stuImgaeInfo[MAX_IMAGE_INFO_NUM];			// Image info
	int						nRetImageInfoNum;							// Return image info num
	char					szDialResult[MAX_DIAL_RESULT_LEN];			// Dial result
}NET_NODE_INFO;

// Task state
typedef struct tagNET_TASK_STATE
{
	char					szTaskID[MAX_TASK_ID_LEN];			// Task ID
	EM_CURRENT_TASK_STATE	emTaskState;						// Current task state
	EM_ERROR_CODE_TYPE		emErrorCode;						// Error code
	NET_NODE_INFO			stuNodeInfo;						// Node info, it will return when emTaskState is EM_CURRENT_TASK_STATE_SUCCEEDED
}NET_TASK_STATE;

// Task state Callback,lAttachHandle is return value of CLIENT_AttachDialRecognitionTaskProc
typedef void (CALLBACK *fTaskStateCallback) (LLONG lAttachHandle, NET_TASK_STATE* pBuf, BYTE *pBuffer, DWORD dwBufSize, LDWORD dwUser);

// CLIENT_AttachDialRecognitionTaskProc interface input param
typedef struct tagNET_IN_ATTACH_TASK_PROC
{
	DWORD									dwSize;								// Struct size
	BYTE									byReserved[4];						// Reserved
	fTaskStateCallback						cbTaskState;						// Task state call back
	LDWORD									dwUser;								// User data
}NET_IN_ATTACH_TASK_PROC;

// CLIENT_AttachDialRecognitionTaskProc interface output param
typedef struct tagNET_OUT_ATTACH_TASK_PROC
{
	DWORD									dwSize;								// Struct size
}NET_OUT_ATTACH_TASK_PROC;

// Attach dial recognition task proc
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachDialRecognitionTaskProc(LLONG lLoginID, const NET_IN_ATTACH_TASK_PROC* pInParam, NET_OUT_ATTACH_TASK_PROC* pOutParam, int nWaitTime);

// Detach dial recognition task proc
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachDialRecognitionTaskProc(LLONG lAttachHandle);

// Local certificate type
typedef enum tagEM_LOCAL_CERTIFICATE_TYPE
{
	EM_LOCAL_CERTIFICATE_TYPE_UNKNOWN,				// Unknown
	EM_LOCAL_CERTIFICATE_TYPE_IDENTITY_AUTH_CERT,   // Identity auth cert
	EM_LOCAL_CERTIFICATE_TYPE_DATA_AUTH_CERT,		// Data auth cert for signal and code stream data signature
}EM_LOCAL_CERTIFICATE_TYPE;

// Confidential specific network type
typedef enum tagEM_NETWORK_TYPE
{
	EM_NETWORK_TYPE_PUBLIC_SECURITY_INFO_NETWORK,		// Public security info network
	EM_NETWORK_TYPE_VIDEO_PRIVATE_NETWORK,				// Video private network
}EM_NETWORK_TYPE;

// Digital certificate type
typedef enum tagEM_DIGITAL_CERTIFICATE_TYPE
{
	EM_DIGITAL_CERTIFICATE_TYPE_UNKNOWN,			// Unknwon
	EM_DIGITAL_CERTIFICATE_TYPE_GM,					// GM
	EM_DIGITAL_CERTIFICATE_TYPE_GENERAL,			// General

	EM_DIGITAL_CERTIFICATE_TYPE_MAX,				// Max value
}EM_DIGITAL_CERTIFICATE_TYPE;

// CLIENT_GetCertReqInfo interface input param
typedef struct tagNET_IN_GET_CERT_REQINFO
{	
	DWORD						dwSize;										// struct size
	EM_LOCAL_CERTIFICATE_TYPE   emLocalCertType;							// Local cert type
	int							nForm;										// Form of request file,0 means PKCS#10,default value is 0
	char						szCountry[MAX_COUNTRY_CODE_LEN];			// The country code of certificate holder
	char						szProvince[MAX_PROVINCE_CODE_LEN];			// The province code of certificate holder
	char						szCity[MAX_CITY_CODE_LEN];					// The city code of certificate holder
	char						szArea[MAX_AREA_CODE_LEN];					// The area code of certificate holder
	EM_NETWORK_TYPE				emSpecificNetworkType;						// Confidential specific network type
	EM_DIGITAL_CERTIFICATE_TYPE	 emDigitalCertificateType;					// Digital certificate type 
	char						szCommonName[160];							// Common name
	char						szOrganization[64];							// Organization name
	char						szOrganizationUnit[64];						// Organization unit
}NET_IN_GET_CERT_REQINFO;

// CLIENT_GetCertReqInfo interface output param
typedef struct tagNET_OUT_GET_CERT_REQINFO
{	
	DWORD						dwSize;									// Struct size
	int							nReqInfoLen;							// Return request info len
	char						szReqInfo[MAX_REQ_INFO_LEN];			// Return request info
	char						szSigInfo[1024];						// Certificate signature info
	char						szSigAlg[64];							// Signature algorithm
	char						szCACertSN[40];							// Cert SN
	char						szIssuer[512];							// Issuer info
}NET_OUT_GET_CERT_REQINFO;

// Get Cert request info,the resource of pstInParam and pstOutParam is requested and released by user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetCertReqInfo(LLONG lLoginID, NET_IN_GET_CERT_REQINFO *pstInParam, NET_OUT_GET_CERT_REQINFO *pstOutParam, int nWaitTime);
// Certificate type
typedef enum tagEM_CERT_TYPE
{
	EM_CERT_TYPE_UNKNWON,					// Unknown
	EM_CERT_TYPE_CA_CERT,					// CA cert
	EM_CERT_TYPE_ADMIN_CERT,				// Local admin login cert 
	EM_CERT_TYPE_IDENTITY_AUTH_CERT,		// Identity auth cert
	EM_CERT_TYPE_DATA_AUTH_CERT,	     	// Data auth cert for signal and code stream data signature
	EM_CERT_TYPE_REMOTE_IDENTITY_AUTH_CERT,	// Remote identity auth cert(Used only when checked)
	EM_CERT_TYPE_REMOTE_DATA_AUTH_CERT,		// Remote data auth cert for signal and code stream data signature(Used only when checked)
	EM_CERT_TYPE_MAX,						// Enum max value
}EM_CERT_TYPE;

// Server name
typedef enum tagEM_CERT_SERVER_NAME
{
	EM_CERT_SERVER_NAME_GENERAL,				// General
	EM_CERT_SERVER_NAME_802_1X,					// 802.1x
	EM_CERT_SERVER_NAME_HTTPS,					// HTTP over ssl/tls

	EM_CERT_SERVER_NAME_MAX,					// Max value,invalid
}EM_CERT_SERVER_NAME;

// CLIENT_ImportCert interface input param
typedef struct tagNET_IN_IMPORT_CERT
{
	DWORD					dwSize;						// struct size
	EM_CERT_TYPE			emCertType;					// Cert type
	char*					pszCert;					// Cert content,User applies memory,size is nCertLen
	int						nCertLen;					// Cert content len,not exceed 5300 Bytes
	BOOL					bActiveCert;				// Whether or not active cert,TRUE means active,FALSE means not active,It is Valid when emDigitalCertificateType is EM_DIGITAL_CERTIFICATE_TYPE_GENERAL
	char					szUserName[64];				// Administrator,It is valid when emCertType is EM_CERT_TYPE_ADMIN_CERT
	EM_DIGITAL_CERTIFICATE_TYPE	 emDigitalCertificateType;	// Digital certificate type 
	int						nKeyLen;					// The private key corresponding to the cert len, not exceed 8192 Bytes
	char*					pszKey;						// The private key corresponding to the cert,User applies memory,size is nKeyLen,It is Valid when emDigitalCertificateType is EM_DIGITAL_CERTIFICATE_TYPE_GENERAL
	char					szKeyPassword[64];			// Key password,It is Valid when emDigitalCertificateType is EM_DIGITAL_CERTIFICATE_TYPE_GENERAL
	int						nKeyPasswordLen;			// Key password len
	EM_CERT_SERVER_NAME		emServerNames[8];			// Server name list,It is Valid when emDigitalCertificateType is EM_DIGITAL_CERTIFICATE_TYPE_GENERAL
														// General mutual exclusion other server,If want to send General, then nServerNameNum must be 1,emServerNames[0]=EM_CERT_SERVER_NAME_GENERAL
	int						nServerNameNum;				// Server name num			
}NET_IN_IMPORT_CERT;

// Support cert list info
typedef struct tagNET_SUPPORT_CERT_LIST_INFO
{
	EM_CERT_TYPE			emCertType;					// Cert type
	NET_TIME				stuEffectiveDate;			// Cert effective Date
	NET_TIME				stuExpirationDate;			// Cert expiration Date
	char					szCertSN[40];				// Cert SN
	char					szDeviceIdentifier[160];	// Device identifier
	char					szRealCertSN[80];			// Real cert SN
	BYTE					byReserved[944];			// Reserved
}NET_SUPPORT_CERT_LIST_INFO;

// CLIENT_ImportCert interface output param
typedef struct tagNET_OUT_IMPORT_CERT
{
	DWORD							dwSize;							// struct size
	int								nRetSupportCertListNum;			// Return support cert list num
	NET_SUPPORT_CERT_LIST_INFO		stuSupportCertList[8];			// Support cert list info
}NET_OUT_IMPORT_CERT;

// Import cert,the resource of pstInParam and pstOutParam is requested and released by user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ImportCert(LLONG lLoginID, NET_IN_IMPORT_CERT *pstInParam, NET_OUT_IMPORT_CERT *pstOutParam, int nWaitTime);

// CLIENT_ImportCRL interface input param
typedef struct tagNET_IN_IMPORT_CRL
{
	DWORD				dwSize;					// struct size
	int					nCRLLen;				// CRL conten len,not exceed 5300 Bytes
	char*				pszCRL;					// CRL content,User applies memory,size is nCRLLen
	EM_DIGITAL_CERTIFICATE_TYPE	 emDigitalCertificateType;	// Digital certificate type
	BYTE				byReserved[4];						// Reserved
}NET_IN_IMPORT_CRL;

// CLIENT_ImportCRL interface output param
typedef struct tagNET_OUT_IMPORT_CRL
{
	DWORD				dwSize;					// struct size
}NET_OUT_IMPORT_CRL;

// Import CRL,the resource of pstInParam and pstOutParam is requested and released by user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ImportCRL(LLONG lLoginID, NET_IN_IMPORT_CRL *pstInParam, NET_OUT_IMPORT_CRL *pstOutParam, int nWaitTime);

// Protocol name
typedef enum tagEM_PROTOCOL_NAME
{
	EM_PROTOCOL_NAME_UNKNOWN,		// Unknown		
	EM_PROTOCOL_NAME_GB28181,		// Gb28181
	EM_PROTOCOL_NAME_MAX,			// Max
}EM_PROTOCOL_NAME;

// CLIENT_IntervideoManagerGetVersion interface input param
typedef struct tagNET_IN_GET_VERSION
{
	DWORD				dwSize;					// Struct size
	EM_PROTOCOL_NAME	emProtocolName;			// Protocol name		
}NET_IN_GET_VERSION;

// CLIENT_IntervideoManagerGetVersion interface output param
typedef struct tagNET_OUT_GET_VERSION
{
	DWORD				dwSize;													// Struct size
	char				szGB28181Version[MAX_GB28181_PROTOCOL_VERSION];			// GB28181 version
}NET_OUT_GET_VERSION;

// Get protocol version,the resource of pstInParam and pstOutParam is requested and released by user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_IntervideoManagerGetVersion(LLONG lLoginID, NET_IN_GET_VERSION *pstInParam, NET_OUT_GET_VERSION *pstOutParam, int nWaitTime);

// CLIENT_NASFileSetUserAuthInfo interface input param
typedef struct tagNET_IN_SET_USER_AUTH_INFO
{
	DWORD			dwSize;										// Struct size
	char			szPassword[DH_COMMON_STRING_128];			// Password
	char			szPasswordHint[DH_COMMON_STRING_128];		// Password hint
	char			szPhoneNo[DH_COMMON_STRING_32];				// Phone no,optional
	char			szEmail[DH_COMMON_STRING_128];				// Email,optional
}NET_IN_SET_USER_AUTH_INFO;

// CLIENT_NASFileSetUserAuthInfo interface output param
typedef struct tagNET_OUT_SET_USER_AUTH_INFO
{
	DWORD			dwSize;										// Struct size
}NET_OUT_SET_USER_AUTH_INFO;

// Set user auth info,the resource of pInParam and pOutParam is requested and released by user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_NASFileSetUserAuthInfo(LLONG lLoginID, const NET_IN_SET_USER_AUTH_INFO* pInParam, NET_OUT_SET_USER_AUTH_INFO* pOutParam, int nWaitTime);

// CLIENT_NASFileModifyPassword interface input param
typedef struct tagNET_IN_MODIFY_PASSWORD
{
	DWORD			dwSize;										// Struct size
	char			szOldPassword[DH_COMMON_STRING_128];		// Old password
	char			szNewPassword[DH_COMMON_STRING_128];		// New password
	char			szPasswordHint[DH_COMMON_STRING_128];		// Password hint
}NET_IN_MODIFY_PASSWORD;

// CLIENT_NASFileModifyPassword interface output param
typedef struct tagNET_OUT_MODIFY_PASSWORD
{
	DWORD			dwSize;										// Struct size
}NET_OUT_MODIFY_PASSWORD;

// Modify privacy space password,the resource of pInParam and pOutParam is requested and released by user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_NASFileModifyPassword(LLONG lLoginID, const NET_IN_MODIFY_PASSWORD* pInParam, NET_OUT_MODIFY_PASSWORD* pOutParam, int nWaitTime);

// CLIENT_NASFileAuthenticate interface input param
typedef struct tagNET_IN_AUTHENTICATE
{
	DWORD			dwSize;										// Struct size
	char			szPassword[DH_COMMON_STRING_128];			// Verify password 
}NET_IN_AUTHENTICATE;

// CLIENT_NASFileAuthenticate interface output param
typedef struct tagNET_OUT_AUTHENTICATE
{
	DWORD			dwSize;										// Struct size
}NET_OUT_AUTHENTICATE;

// Authenticate password,the resource of pInParam and pOutParam is requested and released by user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_NASFileAuthenticate(LLONG lLoginID, const NET_IN_AUTHENTICATE* pInParam, NET_OUT_AUTHENTICATE* pOutParam, int nWaitTime);


//Exmodule type
typedef enum tagEM_EXMODULE_TYPE
{
	EM_EXMODULE_TYPE_UNKNOWN,			//unknown
	EM_EXMODULE_TYPE_M_BUS,				//M-BUS
	EM_EXMODULE_TYPE_RS_485,			//RS-485
}EM_EXMODULE_TYPE;

//CLIENT_GetExModuleInfo input param(emType: NET_EM_GET_EXMODULE_INFO_DETAIL)
typedef struct tagNET_IN_GETEXMODULEDETAIL
{
	DWORD 				dwSize;					//Struct size
	EM_EXMODULE_TYPE 	emType;					//module type
	int					nAddr;					//module id
}NET_IN_GETEXMODULEDETAIL;
//CLIENT_GetExModuleInfo output param(emType: NET_EM_GET_EXMODULE_INFO_DETAIL)
typedef struct tagNET_OUT_GETEXMODULEDETAIL
{
	DWORD					dwSize;					//Struct size
	int						nAlarmInChannelCount;	//Input channel number
	int						alarmInChannels[16];	//Input channel ID
	int						nAlarmOutChannelCount;	//Ouput channel number
	int						alarmOutChannels[16];	//Output channel ID
}NET_OUT_GETEXMODULEDETAIL;

typedef enum tagNET_EM_GET_EXMODULE_INFO
{
	NET_EM_GET_EXMODULE_INFO_UNKNOWN,			//Unknown
	NET_EM_GET_EXMODULE_INFO_DETAIL,			//Get exmodule detail(CLIENT_GetExModuleInfo:	InParam:NET_IN_GETEXMODULEDETAIL, OutParam:NET_OUT_GETEXMODULEDETAIL)
	NET_EM_GET_EXMODULE_INFO_STATE,				//Get exmodule state(CLIENT_GetExModuleInfo:	InParam:NET_IN_EXMODULE_INFO, OutParam:NET_OUT_EXMODULE_INFO_ALL)
}NET_EM_GET_EXMODULE_INFO;
//Get ExModule Infotmation
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetExModuleInfo(LLONG lLoginID, NET_EM_GET_EXMODULE_INFO emType,const void *pstuInParam, void *pstuOutParam, int nWaitTime);

// CLIENT_GetNationInfo input param
typedef struct tagNET_IN_GET_NATIONINFO
{
	DWORD                       dwSize;                                     // Struct size
}NET_IN_GET_NATIONINFO;

#define NET_COUNTRYZONE_LENGTH 64                                           // country length
#define NET_COUNTRYABBR_LENGTH 4                                            // short of country
#define NET_LANGUAGE_LENGTH 12                                              // Language length
#define NET_TIMEZONE_LENGTH 80                                              // Time zone length

typedef struct tagNET_NATION_INFO{
	char                        szCountry[NET_COUNTRYZONE_LENGTH];          // country
	char                        szAbbreviation[NET_COUNTRYABBR_LENGTH];     // short of country
	char                        szLanguage[NET_LANGUAGE_LENGTH];            // Language
	EM_VIDEO_STANDARD           emVideoStandard;                            // video standard
	char                        szTimeZoneDesc[NET_TIMEZONE_LENGTH];        // Time zone describe
	BYTE                        byReserved[128];                            // Reserved byte
}NET_NATION_INFO;

// CLIENT_GetNationInfo output param
typedef struct tagNET_OUT_GET_NATIONINFO
{
	DWORD                       dwSize;                                     // Struct size
	int                         nNationInfoCnt;                             // Country count
	NET_NATION_INFO             arrNationInfo[300];                         // corresponding information of country, is array
}NET_OUT_GET_NATIONINFO;

// Get the corresponding table of country,language and standard for equipment
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetNationInfo(LLONG lLoginID, NET_IN_GET_NATIONINFO* pInParam, NET_OUT_GET_NATIONINFO* pOutParam, int waittime);

// CLIENT_GetLanguageList input param
typedef struct tagNET_IN_GET_LANGUAGELIST
{
	DWORD                       dwSize;                                         // Struct size
}NET_IN_GET_LANGUAGELIST;

#define NET_LANGUAGELIST_LENGTH 12                                              // LanguageList Length

// CLIENT_GetLanguageList output param
typedef struct tagNET_OUT_GET_LANGUAGELIST
{
	DWORD                       dwSize;                                         // Struct size
	int                         nLangueListCnt;                                 // Language list count
	char                        arrLanguageList[50][NET_LANGUAGELIST_LENGTH];   // Language list, is array	
}NET_OUT_GET_LANGUAGELIST;

// Get the corresponding table of language for equipment
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetLanguageList(LLONG lLoginID, NET_IN_GET_LANGUAGELIST* pInParam, NET_OUT_GET_LANGUAGELIST* pOutParam, int waittime);

#define MAX_SCENEID_LEN 32		//Max length of scene ID
//CLINET_ConfirmSceneChangeResult input param. 
typedef struct tagNET_IN_CONFIRMSCENECHANGERESULT_INFO
{
	DWORD 	dwSize;								// struct size
	char	szSceneID[MAX_SCENEID_LEN];						// Scene ID
	BOOL 	bResult;							// Result: TRUE:Succeed  FALSE:failed
}NET_IN_CONFIRMSCENECHANGERESULT_INFO;
//CLINET_ConfirmSceneChangeResult output param
typedef struct tagNET_OUT_CONFIRMSCENECHANGERESULT_INFO
{
	DWORD dwSize;								//struct size
}NET_OUT_CONFIRMSCENECHANGERESULT_INFO;
// Confirm the result of scene change,the resource of pstuInParam and pstuOutParam is requested and released by user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ConfirmSceneChangeResult(LLONG lLoginID, const NET_IN_CONFIRMSCENECHANGERESULT_INFO *pstuInParam, NET_OUT_CONFIRMSCENECHANGERESULT_INFO *pstuOutParam, int nWaitTime);

// output param of CLIENT_ConfirmAuthorizedResult
typedef struct tagNET_IN_CONFIRM_AUTHORIZED_RESULT
{
	DWORD					dwSize;				// struct size
	int						nResult;			// 0:QRCode valid, else:QRCode invalid
	char*					pszQRCode;			// QR code info, encoded by base64
}NET_IN_CONFIRM_AUTHORIZED_RESULT;

// input param of CLIENT_ConfirmAuthorizedResult
typedef struct tagNET_OUT_CONFIRM_AUTHORIZED_RESULT
{
	DWORD					dwSize;				// struct size
}NET_OUT_CONFIRM_AUTHORIZED_RESULT;

// confirm smart home QRCode authorized result
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ConfirmAuthorizedResult(LLONG lLoginID, const NET_IN_CONFIRM_AUTHORIZED_RESULT* pstInParam, NET_OUT_CONFIRM_AUTHORIZED_RESULT* pstOutParam, int nWaitTime);
typedef struct tagNET_IN_GET_SENSOR_COLLECT_SUPPORT_LIST
{
	DWORD								dwSize;						// Struct size
} NET_IN_GET_SENSOR_COLLECT_SUPPORT_LIST;

// Sensor Media Type
typedef enum tagEM_SENSOR_MEDIA_TYPE
{
	EM_SENSOR_MEDIA_TYPE_UNKNOWN,									// unknown
	EM_SENSOR_MEDIA_TYPE_COAXIAL,									// coaxial access sensor
	EM_SENSOR_MEDIA_TYPE_433,										// 433 access sensor
} EM_SENSOR_MEDIA_TYPE;

// Wireless Sensor Type
typedef enum tagEM_WIRELESS_SENSOR_TYPE
{
	EM_WIRELESS_SENSOR_TYPE_UNKNOWN,								// Unknown
	EM_WIRELESS_SENSOR_TYPE_HUMIDITY_SENSOR,						// Humidity Sensor
	EM_WIRELESS_SENSOR_TYPE_TEMP_SENSOR,							// Temp Sensor
	EM_WIRELESS_SENSOR_TYPE_DOOR_MAGNETISM,							// Door Magnetism
	EM_WIRELESS_SENSOR_TYPE_URGENCY_BUTTON,							// Urgency Button
	EM_WIRELESS_SENSOR_TYPE_PASSIVE_INFRARED,						// Passive Infrared
	EM_WIRELESS_SENSOR_TYPE_CURTAIN_SENSOR,							// Curtain Sensor
	EM_WIRELESS_SENSOR_TYPE_WATER_SENSOR,							// Water Sensor
	EM_WIRELESS_SENSOR_TYPE_SMOKING_SENSOR,							// Smoking Sensor
	EM_WIRELESS_SENSOR_TYPE_COAXIAL_EXTALARM,						// Coaxial external alarm
} EM_WIRELESS_SENSOR_TYPE;

// sensorID info 
typedef struct tagNET_SENSOR_ID_INFO 
{
	EM_SENSOR_MEDIA_TYPE				emMediaType;				// Media Type
	DWORD								nAPIndex;					// AP Index
	DWORD								nAlarmChannel;				// Alarm Channel
	NET_WIRELESS_DEVICE_TYPE			emDeviceType;				// Wireless Device Type
	EM_WIRELESS_SENSOR_TYPE				emSensorType;				// Wireless Sensor Type
	BYTE								byReserved[128];			// reserved
} NET_SENSOR_ID_INFO;

// max count of senserID info
#define	MAX_SENSOR_ID_COUNT				256

// CLIENT_GetSensorCollectSupportList output param
typedef struct tagNET_OUT_GET_SENSOR_COLLECT_SUPPORT_LIST
{
	DWORD								dwSize;						// Struct size
	int									nCount;						// sensorID count
	NET_SENSOR_ID_INFO					stInfo[MAX_SENSOR_ID_COUNT];// sensorID info	
} NET_OUT_GET_SENSOR_COLLECT_SUPPORT_LIST;

// Get Sensor Collect Support list, user mallloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSensorCollectSupportList(LLONG lLoginID, const NET_IN_GET_SENSOR_COLLECT_SUPPORT_LIST* pInParam, NET_OUT_GET_SENSOR_COLLECT_SUPPORT_LIST* pOutParam, int nWaitTime);


// Start Wireless AlarmBell input params, DH_CTRL_START_REMOTELOWRATEWPAN_ALARMBELL control type of CLIENT_ControlDeviceEx 
typedef struct tagNET_IN_START_REMOTELOWRATEWPAN_ALARMBELL
{
    DWORD								dwSize;						// Struct size
    int									nChannelID;					// channel ID (-1 means all channels)
} NET_IN_START_REMOTELOWRATEWPAN_ALARMBELL;

// Start Wireless AlarmBell output params, DH_CTRL_START_REMOTELOWRATEWPAN_ALARMBELL control type of CLIENT_ControlDeviceEx 
typedef struct tagNET_OUT_START_REMOTELOWRATEWPAN_ALARMBELL
{
    DWORD								dwSize;						// Struct size      
} NET_OUT_START_REMOTELOWRATEWPAN_ALARMBELL;

// Stop Wireless AlarmBell input params, DH_CTRL_STOP_REMOTELOWRATEWPAN_ALARMBELL control type of CLIENT_ControlDeviceEx 
typedef struct tagNET_IN_STOP_REMOTELOWRATEWPAN_ALARMBELL
{
    DWORD								dwSize;						// Struct size
    int									nChannelID;					// channel ID (-1 means all channels)          
} NET_IN_STOP_REMOTELOWRATEWPAN_ALARMBELL;

// Stop Wireless AlarmBell output params, DH_CTRL_STOP_REMOTELOWRATEWPAN_ALARMBELL control type of CLIENT_ControlDeviceEx 
typedef struct tagNET_OUT_STOP_REMOTELOWRATEWPAN_ALARMBELL
{
    DWORD								dwSize;						// Struct size       
} NET_OUT_STOP_REMOTELOWRATEWPAN_ALARMBELL;

// call status
typedef enum tagEM_CALL_STATUS
{
	EM_CALL_STATUS_UNKNOWN,
	EM_CALL_STATUS_TRYING,					// Call request is being processed
	EM_CALL_STATUS_RINGING,					// When the caller is called, the called ringback event
	EM_CALL_STATUS_PREPARECONNECTED,		// The other party's call is connected
	EM_CALL_STATUS_CONNECTED,				// The other party's call was formally established
	EM_CALL_STATUS_CALLED,					// Called event
	EM_CALL_STATUS_PREPARELEAVINGMESSAGE,	// Received a message request event
	EM_CALL_STATUS_LEAVINGMESSAGECONNECTED,	// Message Call event
	EM_CALL_STATUS_CALLEND,					// Call end event
	EM_CALL_STATUS_CALLTRANSFER,			// Transfer a call to another device
	EM_CALL_STATUS_CALLTRANSFERCONNECTED,	// Call transfer
	EM_CALL_STATUS_HELD,					// Call hold
	EM_CALL_STATUS_RESUME,					// Call recall
	EM_CALL_STATUS_DND,						// Do not disturb
	EM_CALL_STATUS_REMOTESDPCHANGE,			// Remote SDP change
	EM_CALL_STATUS_REFUSE,					// Reject
}EM_CALL_STATUS;

typedef struct tagNET_IN_VTP_THIRDCALL_STATUS
{
	DWORD			dwSize;
	EM_CALL_STATUS	emCallStatus;				// call status
}NET_IN_VTP_THIRDCALL_STATUS;

typedef struct tagNET_OUT_VTP_THIRDCALL_STATUS
{
	DWORD			dwSize;
	char			szCallID[64];				// call id
}NET_OUT_VTP_THIRDCALL_STATUS;

// Proxy Server Info
typedef struct tagNET_PROXY_SERVER_INFO 
{
	char								szIP[DH_MAX_IPADDR_LEN_EX];		// IP Address
	UINT								nPort;							// port
	BYTE								byReserved[84];					// Reserved
} NET_PROXY_SERVER_INFO ;

// CLIENT_CheckCloudUpgrader input param
typedef struct tagNET_IN_CHECK_CLOUD_UPGRADER
{
	DWORD								dwSize;			// Struct Size
	UINT								nWay;			// Check Way, 0-Direct connect server, 1-Through proxy server, 2-Get the results of cache detection
	NET_PROXY_SERVER_INFO				stProxy;		// Proxy server, when way==1 proxy is valid
} NET_IN_CHECK_CLOUD_UPGRADER;

// Cloud Upgrader Check State
typedef enum tagEM_CLOUD_UPGRADER_CHECK_STATE
{
	EM_CLOUD_UPGRADER_CHECK_STATE_UNKNOWN,				// Unknown
	EM_CLOUD_UPGRADER_CHECK_STATE_NONE,					// None
	EM_CLOUD_UPGRADER_CHECK_STATE_REGULAR,				// Regular (User confirmation is required, only to high version)
	EM_CLOUD_UPGRADER_CHECK_STATE_EMERGENCY,			// Emergency (Automatic device detection and execution, can be to low version)
	EM_CLOUD_UPGRADER_CHECK_STATE_AUTOMATIC,			// Automatic (New upgrader package, automatic upgrade)
} EM_CLOUD_UPGRADER_CHECK_STATE;

// Cloud Upgrader Package Type
typedef enum tagEM_CLOUD_UPGRADER_PACKAGE_TYPE
{
	EM_CLOUD_UPGRADER_PACKAGE_TYPE_UNKNOWN,				// Unknown
	EM_CLOUD_UPGRADER_PACKAGE_TYPE_ALL,					// All
	EM_CLOUD_UPGRADER_PACKAGE_TYPE_PTZ,					// Ptz
	EM_CLOUD_UPGRADER_PACKAGE_TYPE_WEB,					// Web
	EM_CLOUD_UPGRADER_PACKAGE_TYPE_LOGO,				// Logo
	EM_CLOUD_UPGRADER_PACKAGE_TYPE_CUSTOM,				// Custom
	EM_CLOUD_UPGRADER_PACKAGE_TYPE_GUI,					// Gui
	EM_CLOUD_UPGRADER_PACKAGE_TYPE_PD,					// PD
	EM_CLOUD_UPGRADER_PACKAGE_TYPE_DATA,				// Data
	EM_CLOUD_UPGRADER_PACKAGE_TYPE_PTZ_POWER,			// Ptz_power
	EM_CLOUD_UPGRADER_PACKAGE_TYPE_PTZ_LIGHT,			// Ptz_light
	EM_CLOUD_UPGRADER_PACKAGE_TYPE_PTZ_HEATER,			// Ptz_heater
} EM_CLOUD_UPGRADER_PACKAGE_TYPE;

// CLIENT_CheckCloudUpgrader output param
typedef struct tagNET_OUT_CHECK_CLOUD_UPGRADER 
{
	DWORD								dwSize;									// Struct Size
	EM_CLOUD_UPGRADER_CHECK_STATE		emState;								// State
	EM_CLOUD_UPGRADER_PACKAGE_TYPE		emPackageType;							// Package Type
	char								szOldVersion[MAX_COMMON_STRING_64];		// Old Version
	char								szNewVersion[MAX_COMMON_STRING_64];		// New Version
	char								szAttention[MAX_COMMON_STRING_2048];	// Attention
	char								szPackageURL[MAX_COMMON_STRING_256];	// Package URL
	char								szPackageID[MAX_COMMON_STRING_64];		// Package ID
	char								szCheckSum[MAX_COMMON_STRING_64];		// Check Sum
	char								szBuildTime[MAX_COMMON_STRING_32];		// Build Time
} NET_OUT_CHECK_CLOUD_UPGRADER;

// Check Cloud Upgrader, user mallloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CheckCloudUpgrader(LLONG lLoginID, const NET_IN_CHECK_CLOUD_UPGRADER* pInParam, NET_OUT_CHECK_CLOUD_UPGRADER* pOutParam, int nWaitTime);

// Cloud Upgrader Info
typedef struct tagNET_CLOUD_UPGRADER_INFO
{
	char								szPackageURL[MAX_COMMON_STRING_256];	// Package URL
	char								szPackageID[MAX_COMMON_STRING_64];		// Package ID
	char								szCheckSum[MAX_COMMON_STRING_64];		// Check Sum
	BYTE								byReserved[1024];						// Reserved
} NET_CLOUD_UPGRADER_INFO;

// CLIENT_ExecuteCloudUpgrader input param
typedef struct tagNET_IN_EXECUTE_CLOUD_UPGRADER
{
	DWORD								dwSize;									// Struct Size
	char								szNewVersion[MAX_COMMON_STRING_64];		// New Version
	UINT								nWay;									// Check Way, 0-Direct connect server, 1-Through proxy server
	NET_PROXY_SERVER_INFO				stProxy;								// Proxy server, when way==1 proxy is valid
	NET_CLOUD_UPGRADER_INFO				stInfo;									// Cloud Upgrader Info
} NET_IN_EXECUTE_CLOUD_UPGRADER;

// CLIENT_ExecuteCloudUpgrader output param
typedef struct tagNET_OUT_EXECUTE_CLOUD_UPGRADER
{
	DWORD								dwSize;									// Struct Size
} NET_OUT_EXECUTE_CLOUD_UPGRADER;

// Execute Cloud Upgrader, user mallloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ExecuteCloudUpgrader(LLONG lLoginID, const NET_IN_EXECUTE_CLOUD_UPGRADER* pInParam, NET_OUT_EXECUTE_CLOUD_UPGRADER* pOutParam, int nWaitTime);

// CLIENT_GetCloudUpgraderState input param
typedef struct tagNET_IN_GET_CLOUD_UPGRADER_STATE 
{
	DWORD								dwSize;									// Struct Size
} NET_IN_GET_CLOUD_UPGRADER_STATE;

// Cloud Upgrader Stat
typedef enum tagEM_CLOUD_UPGRADER_STATE
{
	EM_CLOUD_UPGRADER_STATE_UNKNOWN,				// unknown
	EM_CLOUD_UPGRADER_STATE_NOUPGRADE,				// "Noupgrade"
	EM_CLOUD_UPGRADER_STATE_PREPARING,				// "Preparing"
	EM_CLOUD_UPGRADER_STATE_DOWNLOADING,			// "Downloading"
	EM_CLOUD_UPGRADER_STATE_DOWNLOADFAILED,			// "DownloadFailed"
	EM_CLOUD_UPGRADER_STATE_UPGRADING,				// "Upgrading"
	EM_CLOUD_UPGRADER_STATE_INVALID,				// "Invalid"
	EM_CLOUD_UPGRADER_STATE_FAILED,					// "Failed"
	EM_CLOUD_UPGRADER_STATE_SUCCEEDED,				// "Succeeded"
} EM_CLOUD_UPGRADER_STATE;

// CLIENT_GetCloudUpgraderState output param
typedef struct tagNET_OUT_GET_CLOUD_UPGRADER_STATE 
{
	DWORD								dwSize;					// Struct Size
	EM_CLOUD_UPGRADER_STATE				emState;				// State
	UINT								nProgress;				// Progress, nProgress is valid When State is Downloading/Upgrading
} NET_OUT_GET_CLOUD_UPGRADER_STATE;

// Get Cloud Upgrader State, user mallloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetCloudUpgraderState(LLONG lLoginID, const NET_IN_GET_CLOUD_UPGRADER_STATE* pInParam, NET_OUT_GET_CLOUD_UPGRADER_STATE* pOutParam, int nWaitTime);

// CLIENT_GetVideoDiagnosisChannelNumber interface input param
typedef struct tagNET_IN_GET_SUPPORT_CHANNEL_NUM
{
	DWORD				dwSize;						// Struct size
}NET_IN_GET_SUPPORT_CHANNEL_NUM;

// CLIENT_GetVideoDiagnosisChannelNumber output param
typedef struct tagNET_OUT_GET_SUPPORT_CHANNEL_NUM
{
	DWORD				dwSize;					// Struct size
	int					nCount;					// IVS-V support detection channel number
}NET_OUT_GET_SUPPORT_CHANNEL_NUM;

// Get support IVS-V channel number
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetVideoDiagnosisChannelNumber(LLONG lLoginID, const NET_IN_GET_SUPPORT_CHANNEL_NUM* pInParam, NET_OUT_GET_SUPPORT_CHANNEL_NUM* pOutParam, int nWaitTime);

#define	MAX_VIDEO_CHANNEL_COUNT		128											//	Max Count Of Video Channel

// CLIENT_GetRemoteLowRateWPANCaps input param
typedef struct tagNET_IN_GET_REMOTELOWRATEWPAN_CAPS
{
	DWORD								dwSize;									// Struct Size 
	int									nChannelCount;							// Video Channel Count
	int									stChannels[MAX_VIDEO_CHANNEL_COUNT];	// Video Channels
} NET_IN_GET_REMOTELOWRATEWPAN_CAPS;

// RemoteLowRateWPAN Caps
typedef struct tagNET_REMOTE_LOW_RATE_WPAN_CAPS 
{
	BOOL								bSupportWirelessGateway;				// Is Device Support Wireless Gateway
	BYTE								byRevserved[256];						// Reserved
} NET_REMOTE_LOW_RATE_WPAN_CAPS;

// Return Code Type
typedef enum tagEM_RETURN_CODE_TYPE
{
	EM_RETURN_CODE_TYPE_UNKNOWN,				// Unknown
	EM_RETURN_CODE_TYPE_OK,						// Success
	EM_RETURN_CODE_TYPE_FAILED,					// Failed
	EM_RETURN_CODE_TYPE_TIMEOUT,				// Timeout
} EM_RETURN_CODE_TYPE;

// CLIENT_GetRemoteLowRateWPANCaps output param
typedef struct tagNET_OUT_GET_REMOTELOWRATEWPAN_CAPS
{
	DWORD								dwSize;									// Struct Size
	int									nRetChannelCount;						// Return Channel Count
	NET_REMOTE_LOW_RATE_WPAN_CAPS		stCaps[MAX_VIDEO_CHANNEL_COUNT];		// Device Caps
	int									nRetCodeCount;							// Return Code Count
	EM_RETURN_CODE_TYPE					stReturnCode[MAX_VIDEO_CHANNEL_COUNT];	// Return Code
} NET_OUT_GET_REMOTELOWRATEWPAN_CAPS;

// Get RemoteLowRateWPAN Caps, user mallloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetRemoteLowRateWPANCaps(LLONG lLoginID, const NET_IN_GET_REMOTELOWRATEWPAN_CAPS* pInParam, NET_OUT_GET_REMOTELOWRATEWPAN_CAPS* pOutParam, int nWaitTime);


// CLIENT_GetCoaxialSensorInfo input param
typedef struct tagNET_IN_GET_COAXIAL_SENSOR_INFO 
{
	DWORD								dwSize;							// Struct Size
	int									nChannel;						// channel ID (-1 means all channels)  
} NET_IN_GET_COAXIAL_SENSOR_INFO;

// Sensor Class Type
typedef enum tagEM_SENSOR_CLASS_TYPE
{
	EM_SENSOR_CLASS_TYPE_UNKOWN,				// Unknown
	EM_SENSOR_CLASS_TYPE_ALARM_IN,				// Alarm In
	EM_SENSOR_CLASS_TYPE_ALARM_OUT,				// Alarm Out
	EM_SENSOR_CLASS_TYPE_ANALOGALARM,			// Analogalarm
} EM_SENSOR_CLASS_TYPE;

#define MAX_COAXIAL_SENSOR_INFO_COUNT	256			// Max Count Of Coaxial Sensor Info

// Coaxial Sensor Info
typedef struct tagNET_COAXIAL_SENSOR_INFO 
{
	NET_SENSOR_ID_INFO					stSensorID;							// Sensor ID 
	BOOL								bIsOnLine;							// IsOnline
	char								szAlarmName[MAX_COMMON_STRING_128];	// Alarm Name
	EM_SENSOR_CLASS_TYPE				emSensorClass;						// Sensor Class
	char								szSN[MAX_COMMON_STRING_32];			// Serial Number
	BYTE								byRevserved[256];					// Reserved
} NET_COAXIAL_SENSOR_INFO;

// CLIENT_GetCoaxialSensorInfo output param
typedef struct tagNET_OUT_GET_COAXIAL_SENSOR_INFO 
{
	DWORD								dwSize;											// Struct Size
	int									nRetCount;										// Retuen Count
	NET_COAXIAL_SENSOR_INFO				stSensorInfo[MAX_COAXIAL_SENSOR_INFO_COUNT];	// Coaxial Sensor Info
} NET_OUT_GET_COAXIAL_SENSOR_INFO;


// Get Coaxial Sensor Info, user mallloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetCoaxialSensorInfo(LLONG lLoginID, const NET_IN_GET_COAXIAL_SENSOR_INFO* pInParam, NET_OUT_GET_COAXIAL_SENSOR_INFO* pOutParam, int nWaitTime);

#define MAX_VIDEO_URL_LEN       256         // max length of video URL

// video source info
typedef struct tagNET_VIDEO_SOURCE_INFO
{
	EM_DEV_PROTOCOL_TYPE	emProtocolType;						// protocol type of device
	char                	szIp[DH_MAX_IPADDR_OR_DOMAIN_LEN];  // ip address of remote device
	int                 	nPort;                      		// port of remote device
	char                	szUser[DH_NEW_USER_NAME_LENGTH];    // user name of remote device
    char                	szPwd[DH_NEW_USER_PSW_LENGTH];      // password of remote device
    int                 	nChannelID;                         // channel id of remote device
    char                	szStreamUrl[MAX_VIDEO_URL_LEN];     // URL of video source, it is effect when emProtocolType is EM_DEV_PROTOCOL_GENERAL
	BYTE					byReserved[512];					// Reserved
} NET_VIDEO_SOURCE_INFO;

// image quality
 typedef enum tagEM_TRANSCODE_IMAGE_QUALITY
{
    EM_TRANSCODE_IMAGE_QUALITY_SELFADAPT,               // self adaption
    EM_TRANSCODE_IMAGE_QUALITY_Q10,                     // 10%
    EM_TRANSCODE_IMAGE_QUALITY_Q30,                     // 30%
    EM_TRANSCODE_IMAGE_QUALITY_Q50,                     // 50%
    EM_TRANSCODE_IMAGE_QUALITY_Q60,                     // 60%
    EM_TRANSCODE_IMAGE_QUALITY_Q80,                     // 80%
    EM_TRANSCODE_IMAGE_QUALITY_Q100,                   // 100%
} EM_TRANSCODE_IMAGE_QUALITY;

// the type of vitrual transcode video compression
typedef enum tagEM_TRANSCODE_VIDEO_COMPRESSION
{
	EM_TRANSCODE_VIDEO_AUTO,							// auto
	EM_TRANSCODE_VIDEO_MPEG4,							// MPEG4
	EM_TRANSCODE_VIDEO_MPEG2,							// MPEG2
	EM_TRANSCODE_VIDEO_MPEG1,							// MPEG1
	EM_TRANSCODE_VIDEO_MJPG,							// MJPG
	EM_TRANSCODE_VIDEO_H263,							// H.263
	EM_TRANSCODE_VIDEO_H264,							// H.264
    EM_TRANSCODE_VIDEO_H265,							// H.265
} EM_TRANSCODE_VIDEO_COMPRESSION;

// format of transcode video
typedef struct tagNET_TRANSCODE_VIDEO_FORMAT
{
	EM_TRANSCODE_VIDEO_COMPRESSION 	emCompression;				// the type of video compression
	UINT							nWidth;						// the wigth of video 
	UINT							nHeight;					// the height of video
	NET_EM_BITRATE_CONTROL			emBitRateControl;			// bit stream control mode
	UINT							nBitRate;					// video bit rate (kbps)
	float							fFrameRate;					// frame rate 
	UINT							nIFrameInterval;			// I frame interval(1-100). For example, 50 means there is I frame in each 49 B frame or P frame.
	EM_TRANSCODE_IMAGE_QUALITY		emImageQuality;				// image quality
	BYTE							byReserved[512];			// Reserved
} NET_TRANSCODE_VIDEO_FORMAT;

// format of transcode audio
typedef struct tagNET_TRANSCODE_AUDIO_FORMAT
{
	NET_EM_AUDIO_FORMAT			emCompression;				// the type of audio compression
	UINT						nFrequency;					// sampling frequency
	BYTE						byReserved[512];			// Reserved
} NET_TRANSCODE_AUDIO_FORMAT;

// Input param of CLIENT_GetVirtualChannelOfTransCode
typedef struct tagNET_IN_GET_VIRTUALCHANNEL_OF_TRANSCODE
{
	DWORD						dwSize;							// size of the struct
	NET_VIDEO_SOURCE_INFO		stuVideoSourceInfo;				// video source info		
	NET_TRANSCODE_VIDEO_FORMAT	stuTransVideoFormat;			// format of transcode video
	NET_TRANSCODE_AUDIO_FORMAT	stuTransAudioFormat;			// format of transcode audio
} NET_IN_GET_VIRTUALCHANNEL_OF_TRANSCODE;

// Output param of CLIENT_GetVirtualChannelOfTransCode
typedef struct tagNET_OUT_GET_VIRTUALCHANNEL_OF_TRANSCODE
{
	DWORD						dwSize;							// size of the struct
	UINT						nVirtualChannel;				// virtual channel
} NET_OUT_GET_VIRTUALCHANNEL_OF_TRANSCODE;

// Output param of CLIENT_GetCapsOfTransCode
typedef struct tagNET_IN_TRANDCODE_GET_CAPS
{
    DWORD						dwSize;							// size of the struct
} NET_IN_TRANDCODE_GET_CAPS;

// Input param of CLIENT_GetCapsOfTransCode
typedef struct tagNET_OUT_TRANSCODE_GET_CAPS
{
    DWORD						dwSize;							// size of the struct
    int                         nMinVirtualChannel;             // minimum value of virtual channel
    int                         nMaxVirtualChannel;             // maximum value of virtual channel
	BOOL                        bSupportErrorCode;              // whether real-time reporting of compressed error code is supported
} NET_OUT_TRANSCODE_GET_CAPS;

// Virtual transcoding channel status
typedef enum tagEM_VIRCHANNEL_STATUS
{
    EM_VIRCHANNEL_STATUS_UNKNOWN    		= -1,	// unknown
    EM_VIRCHANNEL_STATUS_OVER_DECODE,               // excess decode 
    EM_VIRCHANNEL_STATUS_OVER_COMPRESS,             // excess compress
    EM_VIRCHANNEL_STATUS_NO_ORIGI_STREAM,           // no orignial stream
    EM_VIRCHANNEL_STATUS_SLAVE_OFFLINE,				// virtual channel is offline
    EM_VIRCHANNEL_STATUS_UNKNOWN_FAILURE 	= 255,	// unknown failure
} EM_VIRCHANNEL_STATUS;

// info of virtual transcoding channel status
typedef struct tagNET_CB_VIRTUALCHANNEL_STATUS_INFO
{
    UINT                        nVirChannelID;                  // virtual transcoding channel
    EM_VIRCHANNEL_STATUS        emVirChannelStatus;             // virtual transcoding channel status
    BYTE						byReserved[1024];			    // reserved
} NET_CB_VIRTUALCHANNEL_STATUS_INFO;

// callback function of attach virtual transcoding channel status, lAttachHandle is returned by CLIENT_AttachVirtualChannelStatus
typedef int  (CALLBACK *fVirtualChannelStatusCallBack)(const LLONG lAttachHandle, const NET_CB_VIRTUALCHANNEL_STATUS_INFO *pstVirChnStatusInfo, const LDWORD dwUser);

// Input param CLIENT_AttachVirtualChannelStatus
typedef struct tagNET_IN_ATTACH_VIRTUALCHANNEL_STATUS
{
    DWORD						    dwSize;							// struct size
    BYTE                            byReserved[4];                  // for alignment
    fVirtualChannelStatusCallBack   cbVirtualChannelStatus;         // callback function of attach virtual transcoding channel status
    LDWORD                          dwUser;                 	    // user data
} NET_IN_ATTACH_VIRTUALCHANNEL_STATUS;

// get the virtual channel(virtual channel is used to realplay and playback),  resource of pInParam and pOutParam is requested and released by user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetVirtualChannelOfTransCode(LLONG lLoginID, const NET_IN_GET_VIRTUALCHANNEL_OF_TRANSCODE* pInParam, NET_OUT_GET_VIRTUALCHANNEL_OF_TRANSCODE* pOutParam, int nWaitTime);

// get capability of trans code, resource of pInParam and pOutParam is requested and released by user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetCapsOfTransCode(LLONG lLoginID, const NET_IN_TRANDCODE_GET_CAPS* pInParam, NET_OUT_TRANSCODE_GET_CAPS* pOutParam, int nWaitTime);

// attach virtual transcoding channel status, pInParam is requested and released by user
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachVirtualChannelStatus(LLONG lLoginID, const NET_IN_ATTACH_VIRTUALCHANNEL_STATUS* pInParam, const int nWaitTime);

// detach virtula transcoding channel status, lAttachHandle is returned by CLIENT_AttachVirtualChannelStatus
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachVirtualChannelStatus(LLONG lAttachHandle);

/////////////////////////////////MobilePusher API  Start/////////////////////////////////
// CLIENT_GetMobilePusherCaps input Parameter
typedef struct tagNET_IN_GET_MOBILE_PUSHER_CAPS 
{
	DWORD						dwSize;					// structure size
} NET_IN_GET_MOBILE_PUSHER_CAPS;

// CLIENT_GetMobilePusherCaps output Parameter
typedef struct tagNET_OUT_GET_MOBILE_PUSHER_CAPS 
{
	DWORD						dwSize;					// structure size
	BOOL						bEnablePush;			// whether devide support enable push subscripitions 
	BOOL						bAddNotification;		// whether device support adding push subscripitions
	BOOL						bDelNotification;		// whether device support delete push subscripitions
    BOOL                        bSupportPriority;       // DMSS mobile pusher, whether device support priority, MobileAPP needs to determine the configuration of the primary server
    BOOL                        bPushEventSchedule;     // Support push in customized time period
} NET_OUT_GET_MOBILE_PUSHER_CAPS;

// Get MObile Pusher Caps, user malloc and free memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetMobilePusherCaps(LLONG lLoginID, NET_IN_GET_MOBILE_PUSHER_CAPS *pInParam, NET_OUT_GET_MOBILE_PUSHER_CAPS *pOutParam, int nWaitTime);

// CLIENT_EnablePushMobilePusher input Parameter
typedef struct tagNET_IN_ENABLE_PUSH_MOBILE_PUSHER
{
	DWORD						dwSize;					// structure size
	BOOL						bEnablePush;			// enable Mobile Pusher 
} NET_IN_ENABLE_PUSH_MOBILE_PUSHER;

// CLIENT_EnablePushMobilePusher output Parameter
typedef struct tagNET_OUT_ENABLE_PUSH_MOBILE_PUSHER 
{
	DWORD						dwSize;					// structure size
} NET_OUT_ENABLE_PUSH_MOBILE_PUSHER;

// enbale Mobile Pusher, user malloc and free memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_EnablePushMobilePusher(LLONG lLoginID, NET_IN_ENABLE_PUSH_MOBILE_PUSHER *pInParam, NET_OUT_ENABLE_PUSH_MOBILE_PUSHER *pOutParam, int nWaitTime);

// Push server config info
typedef struct tagNET_PUSH_SERVER_INFO_EX
{
    char                            szAddress[MAX_URL_LEN];                     // ip address
    int                             nPort;                                      // port
	BYTE							byReserved[512];							// reserved 
} NET_PUSH_SERVER_INFO_EX;

// 
typedef struct tagNET_REGISTER_GROUP
{
    int                  nIndex;                 // Channel number, - 1 means subscription by library, channel is not distinguished, and it is a subset of indexes in mobilepushnotification
    int                  nGroupCount;            // Number of face database ID sets
    char                 szGroup[64][64];        // Face database ID set
    BYTE		         byReserved[128];	     // Reserved
} NET_REGISTER_GROUP;

// The custom filter of evnet FaceComparision
typedef struct tagNET_CUSTOM_TILTER_OF_FACE_COMPARISION
{
    int                 nRegisterGroupCount;    // The count of register group
    NET_REGISTER_GROUP  stuRegisterGroup[256];  // Register group
    BYTE		        byReserved[1028];	    // Reserved
} NET_CUSTOM_TILTER_OF_FACE_COMPARISION;


// Subscrbie info
typedef struct tagNET_SUBSCRIBE_INFO_EX
{
    char                            szCode[MAX_COMMON_STRING_64];				// Event code
    char							szSubCode[MAX_COMMON_STRING_64];			// Sub Event code
    int                             nChnNum;									// channel number 
    int                             nIndexs[MAX_MOBILE_CHANNEL_NUM];			// channel aggregate
    char                            szNumber[DH_COMMON_STRING_16];				// effective when attach "CallNoAnswered " 
																				// no responsion number (pushing notify to mobile when device call to these number)
    char                            szSound[DH_COMMON_STRING_64];				// played sound file when receiving event 
    char                            szIndexsExt[DH_COMMON_STRING_32][DH_COMMON_STRING_16];     //channel aggregate extension
    void*                           pstuCustomFilter;                           // Custom filter, the type decided by szCode.Other unsupported types are filled in NULL
                                                                                // When szCode is "FaceComparision", the type is: NET_CUSTOM_TILTER_OF_FACE_COMPARISION (currently only supported)
	BYTE							byReserved[504];							// reserved
} NET_SUBSCRIBE_INFO_EX;

// CLIENT_AddMobilePusherNotification input Parameter
typedef struct tagNET_IN_ADD_MOBILE_PUSHER_NOTIFICATION
{
	DWORD						dwSize;									// structure size
	char						szRegisterID[MAX_REGISTER_ID_LEN];		// RegisterID
	char						szAppID[MAX_APP_ID_LEN];				// AppID
	EM_MOBILE_SERVER_TYPE		emServerType;							// Server Type
	EM_PUSH_GATEWAY_TYPE        emPushGatewayType;                      // Push Gateway Type
	int                         nPeriodOfValidity;						// Period Of Validity, unit:second
    char                        szAuthServerAddr[MAX_URL_LEN];			// Android server address
    int                         nAuthServerPort;						// Android server port 
	NET_PUSH_SERVER_INFO_EX     stuPushServerMain;						// push server config 
    char                        szPushServerAddr[MAX_URL_LEN];			// push server address 
    int                         nPushServerPort;						// push server port
    char                        szDevName[MAX_COMMON_STRING_64];		// Device name
    char                        szDevID[MAX_COMMON_STRING_64];			// Device ID
    char                        szUser[MAX_COMMON_STRING_64];			// Push verification username
    char                        szCertificate[MAX_IOS_CERTIFICATE_LEN]; // Certificate
    char                        szSecretKey[MAX_IOS_SECRET_KEY_LEN];    // Secret Key
    int                         nSubScribeNum;                          // number of subscribe
    NET_SUBSCRIBE_INFO_EX      *pstuSubscribes;                         // subscribe info, user malloc memory,apply to sizeof(NET_SUBSCRIBE_INFO)*nSubScribeMax
	DH_TSECT                    stuAllEventPushTime[DH_N_WEEKS][DH_N_TSECT];   //The backup push time period is a 7 * 6 two-dimensional array, with 7 elements corresponding to 7 days per week (the first is Sunday), and up to 6 separate time periods per day. 
// The first number 1 of each time period represents the enabled time period, and 0 is the non enabled state. By default, the configuration is issued for seven days and enabled in full time period (24 hours) every day. If this field is not available, all time periods of the device will be pushed.
} NET_IN_ADD_MOBILE_PUSHER_NOTIFICATION;

// CLIENT_AddMobilePusherNotification output Parameter
typedef struct tagNET_OUT_ADD_MOBILE_PUSHER_NOTIFICATION 
{
	DWORD						dwSize;									// structure size
} NET_OUT_ADD_MOBILE_PUSHER_NOTIFICATION;

// Add Mobile Pusher Notification, user malloc and free memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddMobilePusherNotification(LLONG lLoginID, NET_IN_ADD_MOBILE_PUSHER_NOTIFICATION *pInParam, NET_OUT_ADD_MOBILE_PUSHER_NOTIFICATION *pOutParam, int nWaitTime);

// CLIENT_DelMobilePusherNotification input Parameter
typedef struct tagNET_IN_DEL_MOBILE_PUSHER_NOTIFICATION
{
	DWORD						dwSize;									// structure size
	char						szRegisterID[MAX_REGISTER_ID_LEN];		// RegisterID
	char						szAppID[MAX_APP_ID_LEN];				// AppID
} NET_IN_DEL_MOBILE_PUSHER_NOTIFICATION;

// CLIENT_DelMobilePusherNotification output Parameter
typedef struct tagNET_OUT_DEL_MOBILE_PUSHER_NOTIFICATION 
{
	DWORD						dwSize;									// structure size
} NET_OUT_DEL_MOBILE_PUSHER_NOTIFICATION;

// Delete Mobile Pusher Notification, user malloc and free memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DelMobilePusherNotification(LLONG lLoginID, NET_IN_DEL_MOBILE_PUSHER_NOTIFICATION *pInParam, NET_OUT_DEL_MOBILE_PUSHER_NOTIFICATION *pOutParam, int nWaitTime);
/////////////////////////////////MobilePusher API  End/////////////////////////////////

typedef struct tagNET_CREDENTIAL_INFO
{
    char                        CredentialHolder[16];                           // credential holder
    NET_TIME                    stuValidDateStart;                              // start time of valid date
    NET_TIME                    stuValidDateEnd;                                // end time of valid date
    NET_ACCESS_METHOD           emType;                                         // open door type
    DWORD                       nIndex;                                         // index
    char                        szCardNo[DH_MAX_CARDINFO_LEN];                  // card number
    BYTE                        byReserved[1024];                               // Reserved byte
}NET_CREDENTIAL_INFO;

// notify the OfflineAuth info
typedef struct tagNET_SMARTLOCK_NOTIFY_OFFLINEAUTH
{
    char                        szSerialNumber[32];                             // Serial Number
    DWORD                       nACK;                                           // Acknowledge number
    NET_CREDENTIAL_INFO         stCredentialInfo;                               // credenital info
    BYTE                        byReserved[1024];                               // Reserved byte
}NET_SMARTLOCK_NOTIFY_OFFLINEAUTH;

// off-line authorization info callback
typedef void (CALLBACK *fSmartLockOfflineAuthCallBack) (LLONG lLoginId, LLONG lAttachHandle, const NET_SMARTLOCK_NOTIFY_OFFLINEAUTH* pBuf, LDWORD dwUser);

// attach SmartLock OfflineAuth input params(corresponding to CLIENT_AttachSmartLockOfflineAuth)
typedef struct tagNET_IN_SMARTLOCK_OFFLINEAUTH
{
    DWORD                               dwSize;                                 // Struct size
    char                                szUUID[36];                             // Universally unique identifier
    fSmartLockOfflineAuthCallBack       cbOfflineAuth;                          // OfflineAuth info callback
    LDWORD                              dwUser;                                 // user data 
}NET_IN_SMARTLOCK_OFFLINEAUTH;

// attach SmartLock OfflineAuth output params(corresponding to CLIENT_AttachSmartLockOfflineAuth)
typedef struct tagNET_OUT_SMARTLOCK_OFFLINEAUTH
{
    DWORD                               dwSize;                                 // Struct size
}NET_OUT_SMARTLOCK_OFFLINEAUTH;

// attach SmartLock OfflineAuth 
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachSmartLockOfflineAuth(LLONG lLoginID, const NET_IN_SMARTLOCK_OFFLINEAUTH * pstInParam, NET_OUT_SMARTLOCK_OFFLINEAUTH* pstOutParam, int nWaitTime);

// detach SmartLock retransmission
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachSmartLockOfflineAuth(LLONG lAttachHandle);

// acknowledge SmartLock OfflineAuth input params(corresponding to CLIENT_AckSmartLockOfflineAuth)
typedef struct tagNET_IN_SMARTLOCK_ACK_OFFLINEAUTH
{
    DWORD                               dwSize;                                 // Struct size
    char                                szUUID[36];                             // Universally unique identifier
    char                                szSerialNumber[32];                     // Serial Number
    DWORD                               nACK;                                   // Acknowledge number
}NET_IN_SMARTLOCK_ACK_OFFLINEAUTH;

// acknowledge SmartLock OfflineAuth output params(corresponding to CLIENT_AckSmartLockOfflineAuth)
typedef struct tagNET_OUT_SMARTLOCK_ACK_OFFLINEAUTH
{
    DWORD                               dwSize;                                 // Struct size
}NET_OUT_SMARTLOCK_ACK_OFFLINEAUTH;

// acknowledge SmartLock OfflineAuth
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AckSmartLockOfflineAuth(LLONG lLoginID, NET_IN_SMARTLOCK_ACK_OFFLINEAUTH* pstInParam, NET_OUT_SMARTLOCK_ACK_OFFLINEAUTH* pstOutParam, int nWaitTime);

// CLIENT_EncryptString input param
typedef struct tagNET_IN_ENCRYPT_STRING
{
	DWORD						dwSize;							// Struct size
	char						szCard[33];						// Card Number
	BYTE                        byReserved1[3];                 // Byte pairs
    char                        szKey[33];                      // Secret Key
    BYTE                        byReserved2[3];                 // Byte pairs	
} NET_IN_ENCRYPT_STRING;

// CLIENT_EncryptString output param
typedef struct tagNET_OUT_ENCRYPT_STRING 
{
	DWORD						dwSize;							// Struct size
	char						szEncryptString[1024];			// Encrypted string
} NET_OUT_ENCRYPT_STRING;

// Encrypt String user malloc and free memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_EncryptString(const NET_IN_ENCRYPT_STRING *pInParam, NET_OUT_ENCRYPT_STRING *pOutParam, int nWaitTime);

// CLIENT_PreUploadRemoteFile input params(set upload file length)
typedef struct tagNET_IN_PRE_UPLOAD_REMOTE_FILE
{
    DWORD               dwSize;                         // Struct size
    char*               pszFileSrc;                     // Path of source file
    char*               pszFileDst;                     // Path of saved file in device
} NET_IN_PRE_UPLOAD_REMOTE_FILE;

// Error reason type
typedef enum tagEM_REASON_TYPE
{
    EM_REASON_TYPE_UNKNOWN,                                 // Unknown
    EM_REASON_TYPE_OVERNUMBER,                              // File number is over
    EM_REASON_TYPE_FULLSTORAGE,                             // The file storage is full 
    EM_REASON_TYPE_TOOLARGE_FILE,                           // The file is too large
    EM_REASON_TYPE_INVALID_FILETYPE,                        // Invalid file type
    EM_REASON_TYPE_UNAUTH_UPLOAD,                           // Without upload authorized
    EM_REASON_TYPE_EXCEPTION_NAME,                          // Exception name of file
    EM_REASON_TYPE_TOOLONG_NAME,                            // The file name is too long
    EM_REASON_TYPE_EXIST_NAME,                              // The file name already exists
} EM_REASON_TYPE;

// CLIENT_PreUploadRemoteFile output params(set upload file length)
typedef struct tagNET_OUT_PRE_UPLOAD_REMOTE_FILE
{
    DWORD               dwSize;                         // Struct size
    BOOL                bContinue2Upload;               // Flag of whether continue upload or not, true: upload, false: not upload
    EM_REASON_TYPE      emType;                         // Reason of error, when bContinue2Upload is false, emType is valid                    
} NET_OUT_PRE_UPLOAD_REMOTE_FILE;

// Set upload file length, user malloc memory of pInParam and pOutParam
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PreUploadRemoteFile(LLONG lLoginID, const NET_IN_PRE_UPLOAD_REMOTE_FILE* pInParam, NET_OUT_PRE_UPLOAD_REMOTE_FILE* pOutParam, int nWaitTime);
//Supported Event of install diagnostic

//CLIENT_GetInstallDiagnosticStatCaps input param
typedef struct tagNET_IN_GET_CAPS_INSTALL_DIAGNOSTIC_STAT
{
	DWORD				dwSize;
}NET_IN_GET_CAPS_INSTALL_DIAGNOSTIC_STAT;

// channel's information
typedef struct tagNET_INSTALL_DIAGNOSTIC_STAT_CAPS_INFO
{
	int					nChannel;				//Channel ID
	int					nEventNum;				//Event num
	int					nEventsCode[32];		//Event list
	BYTE				bReserved[256];
}NET_INSTALL_DIAGNOSTIC_STAT_CAPS_INFO;
//CLIENT_GetInstallDiagnosticStatCaps output param
typedef struct tagNET_OUT_GET_CAPS_INSTALL_DIAGNOSTIC_STAT
{
	DWORD									dwSize;				//struct size
	int										nCapsNum;			//caps num
	NET_INSTALL_DIAGNOSTIC_STAT_CAPS_INFO	stuCaps[16];		//caps list
}NET_OUT_GET_CAPS_INSTALL_DIAGNOSTIC_STAT;

//Get install diagnostic stat caps,user malloc memory of pInParam and pOutParam 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetInstallDiagnosticStatCaps(LLONG lLoginID, const NET_IN_GET_CAPS_INSTALL_DIAGNOSTIC_STAT* pInParam, NET_OUT_GET_CAPS_INSTALL_DIAGNOSTIC_STAT* pOutParam, int nWaitTime);

//Stat information
typedef struct tagNET_INSTALL_DIAGNOSTIC_STAT_DATALIST
{
	int						nPitchAngle;	//Pitch angle(head up/down).Range[-90, 90], 0: Upside  180: Useless value
	int						nYawAngle;		//Yaw angle(turn right/left)Range[-90, 90], 0: Upside  180: Useless value
	int						nRollAngle;		//Roll angle(Rotate).Range[-90, 90], 0: Upside  180: Useless value
	int						nQuality;		//Quality.Range[1, 100], 0: Useless value
	int						nWidth;			//Pixel width
	int						nHeight;		//Pixel height
	BYTE					byReserved[64];	//Reserved
}NET_INSTALL_DIAGNOSTIC_STAT_DATALIST;
//Result information
typedef struct tagNET_INSTALL_DIAGNOSTIC_STAT_RESULT
{
	int										nEventCode;			//Event code
	int										nDatalistLen;		//Data num
	NET_INSTALL_DIAGNOSTIC_STAT_DATALIST	stuDataList[128];	//Data list
	BYTE									byReserved[256];	//Reserved
}NET_INSTALL_DIAGNOSTIC_STAT_RESULT;
//Diagnostic stat
typedef struct tagNET_INSTALL_DIAGNOSTIC_STAT
{
	int										nChannel;			//channel
	int										nResultNum;			//Result num
	NET_INSTALL_DIAGNOSTIC_STAT_RESULT		stuResult[32];		//Result array
	BYTE									byReserved[512];	//Reserved
}NET_INSTALL_DIAGNOSTIC_STAT;
//Callback of CLIENT_AttachInstallDiagnosticStat 
typedef void (CALLBACK	*fInstallDiagnosticStatCallBack)(LLONG lAttachHandle, NET_INSTALL_DIAGNOSTIC_STAT* pBuf, DWORD dwBufLen, LDWORD dwUser);
//Filter of CLIENT_AttachInstallDiagnosticStat
typedef struct tagNET_ATTACH_DIAGNOSTIC_FILTER
{
	int						nChannelNum;						//Channel num
	int						nChannels[16];						//Channel list
	int						nEventNum;							//Event num
	int						nEventsCode[32];					//Event list
	BYTE					byReserved[128];					//Reserved
}NET_ATTACH_DIAGNOSTIC_FILTER;
//Input param of CLIENT_AttachInstallDiagnosticStat
typedef struct tagNET_IN_ATTACH_INSTALL_DIAGNOSTIC_STAT
{
	DWORD								dwSize;					//Struct size
	NET_ATTACH_DIAGNOSTIC_FILTER		stuFilter;				//Filter 
	fInstallDiagnosticStatCallBack		cbDiagnosticStat;		//Callback function
	LDWORD								dwUser;					//User data
}NET_IN_ATTACH_INSTALL_DIAGNOSTIC_STAT;
//Output param of CLIENT_AttachInstallDiagnosticStat
typedef struct tagNET_OUT_ATTACH_INSTALL_DIAGNOSTIC_STAT
{
	DWORD					dwSize;								//Struct size
}NET_OUT_ATTACH_INSTALL_DIAGNOSTIC_STAT;
//Attach install diagnostic stat
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachInstallDiagnosticStat(LLONG lLoginID, const NET_IN_ATTACH_INSTALL_DIAGNOSTIC_STAT* pInParam, NET_OUT_ATTACH_INSTALL_DIAGNOSTIC_STAT* pOutParam, int nWaitTime);
//Detach install diagnostic stat
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachInstallDiagnosticStat(LLONG lAttachHandle);
//CLIENT_GetSCADADeviceStatus's input param
typedef struct tagNET_IN_GET_SCADA_STATUS
{
	DWORD				dwSize;										// Struct sizr
}NET_IN_GET_SCADA_STATUS;
//Device status
//Device status 
typedef struct tagNET_SCADA_DEV_INFO
{
	char						szDeviceID[32];						// Device ID
	char						szDeviceName[32];					// Device name
	EM_SCADA_DEVICE_STATUS		emDevStatus;						// Device status
}NET_SCADA_DEV_INFO;
//Device information
typedef struct tagNET_SCADA_STATUS_INFO
{
	EM_ALARM_SCADA_DEV_TYPE					emDevType;				// Device type
	int										nDevInfoNum;			// Count device 
	NET_SCADA_DEV_INFO						stuDevInfo[128];		// Device information
}NET_SCADA_STATUS_INFO;
//CLIENT_GetSCADADeviceStatus's output param
typedef struct tagNET_OUT_GET_SCADA_STATUS
{
	DWORD					dwSize;									// struct size
	int						nDevStatusNum;							// Count device status
	NET_SCADA_STATUS_INFO	stuStatusInfo[64];						// Device status
}NET_OUT_GET_SCADA_STATUS;
//Get list of controller
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSCADADeviceStatus(LLONG lLoginID, const NET_IN_GET_SCADA_STATUS* pInParam, NET_OUT_GET_SCADA_STATUS* pOutParam, int nWaitTime);


// CLIENT_OperateCalibrateInfo input param(EM_CALIBRATEINFO_OPERATE_GET)
typedef struct tagNET_IN_GET_CALIBRATEINFO_INFO
{
	DWORD		dwSize;		// Struct size
	UINT		nID;		// Ponit ID
}NET_IN_GET_CALIBRATEINFO_INFO;
// Position information
typedef struct tagNET_GET_CALIBRATEINFO_CALCINFO_INFO
{
	float		fPosition[3];	// Positon and zoom(normalization[-1,1])
	UINT		nLocation[2];	// Position in picture
}NET_GET_CALIBRATEINFO_CALCINFO_INFO;
// Calibrate point information
typedef struct tagNET_GET_CALIBRATEINFO_POINT_INFO
{
	UINT		nID;			// Ponit id
	char		szName[DH_COMMON_STRING_128];		// Point name
	BOOL		bEnable;		// Enable
	UINT		nLongitude;		// Longitude
	UINT		nLatitude;		// Latitude
	double		fAltitude;		// Altitude
	NET_GET_CALIBRATEINFO_CALCINFO_INFO stuCalcInfo[5][2];	// Calibrate info.First dimension:Different calibrate point, Second dimension:Visible light(first index) and thermo(second index)
	int			nPointNum;		// Point count
	BYTE		byReserved[4];	// Align
}NET_GET_CALIBRATEINFO_POINT_INFO;
// CLIENT_OperateCalibrateInfo output param(EM_CALIBRATEINFO_OPERATE_GET) 
typedef struct tagNET_OUT_GET_CALIBRATEINFO_INFO
{
	DWORD		dwSize;		// Struct size
	NET_GET_CALIBRATEINFO_POINT_INFO	stuPointInfo; // Calibrate point information
}NET_OUT_GET_CALIBRATEINFO_INFO;
// CLIENT_OperateCalibrateInfo input param(EM_CALIBRATEINFO_OPERATE_SET) 
typedef struct tagNET_IN_SET_CALIBRATEINFO_INFO
{
	DWORD		dwSize;			// struct size
	NET_GET_CALIBRATEINFO_POINT_INFO	stuPointInfo;	//Calibrate point info
}NET_IN_SET_CALIBRATEINFO_INFO;
// CLIENT_OperateCalibrateInfo output param(EM_CALIBRATEINFO_OPERATE_SET) 
typedef struct tagNET_OUT_SET_CALIBRATEINFO_INFO
{
	DWORD		dwSize;		// struct size
}NET_OUT_SET_CALIBRATEINFO_INFO;
// CLIENT_OperateCalibrateInfo input param(EM_CALIBRATEINFO_OPERATE_DELETE) 
typedef struct tagNET_IN_DELETE_CALIBRATEINFO_INFO
{
	DWORD		dwSize;		// struct size
	UINT		nID;		// ponit id
}NET_IN_DELETE_CALIBRATEINFO_INFO;
// CLIENT_OperateCalibrateInfo output param(EM_CALIBRATEINFO_OPERATE_DELETE) 
typedef struct tagNET_OUT_DELETE_CALIBRATEINFO_INFO
{
	DWORD		dwSize;		// struct size
}NET_OUT_DELETE_CALIBRATEINFO_INFO;
// CLIENT_OperateCalibrateInfo input param(EM_CALIBRATEINFO_OPERATE_GETALL) 
typedef struct tagNET_IN_GETALL_CALIBRATEINFO_INFO
{
	DWORD		dwSize;		//struct size
}NET_IN_GETALL_CALIBRATEINFO_INFO;
// GPS information
typedef struct tagNET_DEVLOCATION_INFO
{
	UINT							unLongitude;							                    // Longitude Unit:0.01 degreerange:[0, 360]
	UINT							unLatitude;								                    // Latitude Unit:0.01 degreerange:[0, 360]
	double                          dbAltitude;                                                 // Altitude Unit:meter
	BOOL                            bConfigEnable;                                              // Enable
	float							fHeight;													// Device height, Unit:meter
}NET_DEVLOCATION_INFO;
// Calibrate unit information
typedef struct tagNET_CALIBRATE_UNIT_INFO
{
	UINT		nHeight;			// Solution height
	UINT		nWidth;				// Solution wight
	float		nPosition[3];		// Position(P/T/Z normalization[-1,1])
	UINT		nLocation[2];		// Position in picture
	UINT		nHFOV;				// Horizontal visual(Unit0.01 degree)
	UINT		nVFOV;				// Vertical visual(Unit0.01 degree)
}NET_CALIBRATE_UNIT_INFO;
// Calibrate information
typedef struct tagNET_CALIBRATE_INFO
{
	NET_CALIBRATE_UNIT_INFO stuCalibrateUnitInfo[5][2];		// Calibrate unit information
	int nInfoNum;			// info count
}NET_CALIBRATE_INFO;
// Calibrate point info
typedef struct tagNET_LOCATION_CALIBRATE_POINT_INFO
{
	UINT		nID;							// Point id
	char		szName[DH_COMMON_STRING_128];	// Point name
	BOOL		bEnable;						// Enable
	UINT		nLongitude;						// Longitude
	UINT		nLatitude;						// Latitude
	double		fAltitude;						// Altitude
	NET_CALIBRATE_INFO	stuCalibrateInfo;		// Calibrate information
	BYTE		byReserved1[4];					// Align
}NET_LOCATION_CALIBRATE_POINT_INFO;
// Calibrate detail information
#define MAX_CALIBRATE_POINT_NUM 64 //Max Calibrate point count
typedef struct tagNET_LOCATION_CALIBRATE_INFO
{
	UINT		nVisualMaxHFOV;				// Horizontal perspective(visible light)
	UINT		nVisualMaxVFOV;				// Vertical perspective(visible light)
	UINT		nThermoMaxHFOV;				// Horizontal perspective(thermo)
	UINT		nThermoMaxVFOV;				// Horizontal perspective(thermo)
	NET_LOCATION_CALIBRATE_POINT_INFO	stuPointInfo[MAX_CALIBRATE_POINT_NUM];	// Calibrate point information
	int			nPointNum;					// Calibrate point count
	BYTE		byReserved1[4];				// Align
}NET_LOCATION_CALIBRATE_INFO;
// CLIENT_OperateCalibrateInfo output param(EM_CALIBRATEINFO_OPERATE_GETALL) 
typedef struct tagNET_OUT_GETALL_CALIBRATEINFO_INFO
{
	DWORD		dwSize;											// Struct size
	NET_DEVLOCATION_INFO			stuGPSInfo;					// GPS information
	NET_LOCATION_CALIBRATE_INFO		stuLocationCalibrateInfo;	// Calibrate information
}NET_OUT_GETALL_CALIBRATEINFO_INFO;
// The operate tyep of calibrate info
typedef enum tagEM_CALIBRATEINFO_OPERATE_TYPE
{
	EM_CALIBRATEINFO_OPERATE_GET,			// Get calibrate info,	pStuInParam = NET_IN_GET_CALIBRATEINFO_INFO,	  pStuOutParam = NET_OUT_GET_CALIBRATEINFO_INFO
	EM_CALIBRATEINFO_OPERATE_SET,			// Set calibrate info,	pStuInParam = NET_IN_SET_CALIBRATEINFO_INFO,	  pStuOutParam = NET_OUT_SET_CALIBRATEINFO_INFO
	EM_CALIBRATEINFO_OPERATE_DELETE,		// Delete calibrate info,	pStuInParam = NET_IN_DELETE_CALIBRATEINFO_INFO,	  pStuOutParam = NET_OUT_DELETE_CALIBRATEINFO_INFO
	EM_CALIBRATEINFO_OPERATE_GETALL,		// Get all calibrate info,	pStuInParam = NET_IN_GETALL_CALIBRATEINFO_INFO,   pStuOutParam = NET_OUT_GETALL_CALIBRATEINFO_INFO
}EM_CALIBRATEINFO_OPERATE_TYPE;
// Function of operate calibrate information
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateCalibrateInfo(LLONG lLoginID, EM_CALIBRATEINFO_OPERATE_TYPE emType, const	void* pStuInParam, void* pStuOutParam, int nWaitTime);

// horizontal rotation info
typedef struct tagNET_PAN_GROUP_INFO
{
	char					szName[32];								// horizontal rotation group's name
	unsigned int 			nSpeed;									// speed of horizontal rotation(0~7)
	BOOL 					bEnable;								// enable
	unsigned int 			nInterval;								// residence time(s)
	BYTE					byReserved[64];							// Reserved data
}NET_PAN_GROUP_INFO;

// CLIENT_PTZSetPanGroup's input param
typedef struct tagNET_IN_SET_PAN_GROUP_PARAM
{
	DWORD					dwSize;									// struct size
	int						nChannel;								// channel ID,the value range from 0 to the device channel number
	unsigned int			nIndex;									// index of horizontal rotation group
	NET_PAN_GROUP_INFO		stuPanGroupInfo;						// info of horizontal rotation group
}NET_IN_SET_PAN_GROUP_PARAM;

// CLIENT_PTZSetPanGroup's output param
typedef struct tagNET_OUT_SET_PAN_GROUP_PARAM
{
	DWORD					dwSize;									// struct size
}NET_OUT_SET_PAN_GROUP_PARAM;

//set horizontal rotation group(thermal imaging)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PTZSetPanGroup(LLONG lLoginID, const NET_IN_SET_PAN_GROUP_PARAM* pInParam, NET_OUT_SET_PAN_GROUP_PARAM* pOutParam, int nWaitTime);


// CLIENT_PTZGetPanGroup's input param
typedef struct tagNET_IN_GET_PAN_GROUP_PARAM
{
	DWORD					dwSize;									// struct size
	int						nChannel;								// channel ID,the value range from 0 to the device channel number
}NET_IN_GET_PAN_GROUP_PARAM;

// CLIENT_PTZGetPanGroup's input param
typedef struct tagNET_OUT_GET_PAN_GROUP_PARAM
{
	DWORD					dwSize;									// struct size
	int						nRetNum;								// horizontal rotation array actually number returned
	NET_PAN_GROUP_INFO		stuPanGroupInfo[8];						// info of horizontal rotation group
}NET_OUT_GET_PAN_GROUP_PARAM;

//get horizontal rotation group info(thermal imaging)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PTZGetPanGroup(LLONG lLoginID, const NET_IN_GET_PAN_GROUP_PARAM* pInParam, NET_OUT_GET_PAN_GROUP_PARAM* pOutParam, int nWaitTime);

//CLIENT_PTZGotoPanPosition's input param
typedef struct tagNET_IN_GOTO_PAN_POSITION
{
	DWORD					dwSize;									// struct size
	int						nChannel;								// channel ID
	unsigned int			nIndex;									// index of horizontal rotation group, starting from 1
}NET_IN_GOTO_PAN_POSITION;

//CLIENT_PTZGotoPanPosition's output param
typedef struct tagNET_OUT_GOTO_PAN_POSITION
{
	DWORD					dwSize;									// struct size
}NET_OUT_GOTO_PAN_POSITION;

//goto the designated location(thermal imaging)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PTZGotoPanPosition(LLONG lLogindID, const NET_IN_GOTO_PAN_POSITION* pInParam, NET_OUT_GOTO_PAN_POSITION* pOutParam, int nWaitTime);

// limit mode
typedef enum tagNET_EM_PAN_GROUP_LIMIT_MODE
{
	NET_EM_PAN_GROUP_LIMIT_MODE_LEFT = 1,				// left
	NET_EM_PAN_GROUP_LIMIT_MODE_RIGHT,					// right
	NET_EM_PAN_GROUP_LIMIT_MODE_UP,						// up
	NET_EM_PAN_GROUP_LIMIT_MODE_DOWN,					// down
} NET_EM_PAN_GROUP_LIMIT_MODE; 

// set horizontal rotation group limit value, In Param
typedef struct tagNET_IN_PAN_GROUP_LIMIT_INFO
{
	DWORD							 dwSize;						// struct size
	int								 nChannelID;					// channel ID
	unsigned int					 nIndex;						// index of horizontal rotation group, starting from 1
	NET_EM_PAN_GROUP_LIMIT_MODE	 emPanGroupLimitMode;				//  limit Horizontal Rotation GroupLimit Type							 		 							 
} NET_IN_PAN_GROUP_LIMIT_INFO;

// set horizontal rotation group limit value, Out Param
typedef struct tagNET_OUT_PAN_GROUP_LIMIT_INFO
{
	DWORD							dwSize;		// struct size
} NET_OUT_PAN_GROUP_LIMIT_INFO;

// set horizontal rotation group limit value
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PTZSetPanGroupLimit(LLONG lLoginID, const NET_IN_PAN_GROUP_LIMIT_INFO *pstInParam, NET_OUT_PAN_GROUP_LIMIT_INFO *pstOutParam, DWORD dwWaitTime);

// resume ptz last task, in param
typedef struct tagNET_IN_RESUME_PTZ_LASTTASK_INFO
{
	DWORD							dwSize;							// struct size
	int								nChannelID;						// channel ID
} NET_IN_RESUME_PTZ_LASTTASK_INFO;

// resume ptz last task, out param
typedef struct tagNET_OUT_RESUME_PTZ_LASTTASK_INFO
{
	DWORD							dwSize;							// struct size
} NET_OUT_RESUME_PTZ_LASTTASK_INFO;

//Two roles:
// 1Implementing effective historical tasks that were interrupted last time include:tracing,cruising,line sweeping, 
//	  horizontal rotation, interruption of command execution by man made mobile platform, rather than normal termination.
// 2This order will enable Fire Intelligence Interaction
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ResumePtzLastTask(LLONG lLoginID, const NET_IN_RESUME_PTZ_LASTTASK_INFO *pstInParam, NET_OUT_RESUME_PTZ_LASTTASK_INFO *pstOutParam, DWORD dwWaitTime);

// pause current  ptz action , in param
typedef struct tagNET_IN_PAUSE_PTZ_ACTION_INFO
{
	DWORD							dwSize;							// struct size
	int								nChannelID;						// channel ID
} NET_IN_PAUSE_PTZ_ACTION_INFO;

// pause current  ptz action , out param
typedef struct tagNET_OUT_PAUSE_PTZ_ACTION_INFO
{
	DWORD							dwSize;							// struct size
} NET_OUT_PAUSE_PTZ_ACTION_INFO;

// pause current  ptz action
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PausePtzAction(LLONG lLoginID, const NET_IN_PAUSE_PTZ_ACTION_INFO *pstInParam, NET_OUT_PAUSE_PTZ_ACTION_INFO *pstOutParam, DWORD dwWaitTime);



/////////////////////////////////interfaces of intelligent analysis service; start/////////////////////////////////
#define MAX_ANALYSE_REMAIN_CAPACITY_NUM     32      // max number of remain capacity
#define MAX_ANALYSE_RULE_COUNT              32      // max number of rules
#define MAX_ANALYSE_PICTURE_FILE_NUM        32      // max number of picture files
#define MAX_ANALYSE_TASK_NUM                64      // max number of analyse tasks
#define MAX_ANALYSE_FILTER_EVENT_NUM        64      // max number of events are used for filtering
#define MAX_ANALYSE_ALGORITHM_NUM           16      // max number of algorithms
#define MAX_ANALYSE_TOTALCAPS_NUM           32      // max number of total capacity

// info of remain capacity
typedef struct tagNET_REMAIN_ANALYSE_CAPACITY
{
    UINT                    nMaxStreamNum;      // number of remaining video streams for analyse that can be analyzed
    EM_SCENE_CLASS_TYPE     emClassType;        // class type
    BYTE                    byReserved[1024];   // Reserved bytes
} NET_REMAIN_ANALYSE_CAPACITY;

// caps of remain analyse
typedef struct tagNET_CB_REMAIN_CAPACITY
{
    UINT                            nRemainCapacityNum;                                     // number of remain capacity
    NET_REMAIN_ANALYSE_CAPACITY     stuRemainCapacities[MAX_ANALYSE_REMAIN_CAPACITY_NUM];   // info of remain capacities
    BYTE                            byReserved[1024];                                       // Reserved bytes
} NET_CB_REMAIN_CAPACITY;

// function of attach remain analyse resource, lAttachHandle returned by CLIENT_AttachRemainAnalyseResource
typedef void (CALLBACK *fAttachRemainAnalyseResourceCB) (LLONG lAttachHandle, NET_CB_REMAIN_CAPACITY* pstRemainCapacity, LDWORD dwUser);

// input parameter of CLIENT_AttachRemainAnalyseResource
typedef struct tagNET_IN_ATTACH_REMAIN_ANALYSE_RESOURCE
{
    DWORD                             dwSize;                             // struct size
    BYTE                              byReserved[4];                      // for alignment
    fAttachRemainAnalyseResourceCB    cbAttachResource;                   // function of attach remain intelligent analyse resource
    LDWORD                            dwUser;                             // user data
} NET_IN_ATTACH_REMAIN_ANALYSE_RESOURCE;

// type of analyse data source
typedef enum tagEM_DATA_SOURCE_TYPE
{
    EM_DATA_SOURCE_REMOTE_REALTIME_STREAM = 1,  // remote stream, Corresponding to NET_REMOTE_STREAM_INFO
    EM_DATA_SOURCE_PUSH_PICFILE,                // picture file which is pushed actively, Corresponding to NET_PUSH_PICFILE_INFO
} EM_DATA_SOURCE_TYPE;

// the type of face feature
typedef enum tagNET_EM_FACEFEATURE_TYPE
{
	NET_EM_FACEFEATURE_UNKNOWN,			// unknown
	NET_EM_FACEFEATURE_SEX,				// sex
	NET_EM_FACEFEATURE_AGE,				// age
	NET_EM_FACEFEATURE_EMOTION,			// emotion
	NET_EM_FACEFEATURE_GLASSES,			// glasses
	NET_EM_FACEFEATURE_RACE,			// race
	NET_EM_FACEFEATURE_EYE,				// eye
	NET_EM_FACEFEATURE_MOUTH,			// mouth
	NET_EM_FACEFEATURE_MASK,			// mask
	NET_EM_FACEFEATURE_BEARD,			// beard
	NET_EM_FACEFEATURE_ATTRACTIVE,		// attractive
} NET_EM_FACEFEATURE_TYPE;

// Rule type EVENT_IVS_FACEANALYSIS configuration
typedef struct tagNET_FACEANALYSIS_RULE_INFO
{
	DWORD                   	dwSize;                             	// struct size
	int							nDetectRegionPoint;						// Detect region point number
	POINTCOORDINATE				stuDetectRegion[20];						// Detect region
	int                 		nSensitivity;                           // sensitivity, range [1,10], the higher the sensitivity, the easier to detect
	int							nLinkGroupNum;							// the count of link group 
	NET_CFG_LINKGROUP_INFO		stuLinkGroup[20];						// the list of link group
	NET_CFG_STRANGERMODE_INFO	stuStrangerMode;						// Stranger Mode
    BOOL                		bSizeFileter;                           // whether rule special dimension filter is valid or not
	NET_CFG_SIZEFILTER_INFO 	stuSizeFileter;                         // rule special dimension filter
	BOOL						bFeatureEnable;							// whether to open the face feature detection
	int							nFaceFeatureNum;						// the count of face feature 
	NET_EM_FACEFEATURE_TYPE 	emFaceFeatureType[32];					// the list of face feature
	BOOL						bFeatureFilter;							// when open the face featureif the face image's quality is too badwhether to report
																		// true-not report false-report
	int							nMinQuality;							// the threshold of face image quality, use with bFeatureFilter range[1,100]
} NET_FACEANALYSIS_RULE_INFO;

// human face type for video analysing 
typedef enum tagNET_ANALYSE_HUMANFACE_TYPE
{
    NET_ANALYSE_HUMANFACE_TYPE_UNKNOWN,        // Unknown
    NET_ANALYSE_HUMANFACE_TYPE_NORMAL,         // Normal
    NET_ANALYSE_HUMANFACE_TYPE_HIDEEYE,        // Hide eye
    NET_ANALYSE_HUMANFACE_TYPE_HIDENOSE,       // Hide nose
    NET_ANALYSE_HUMANFACE_TYPE_HIDEMOUTH,      // Hide mouth
    NET_ANALYSE_HUMANFACE_TYPE_ADJACENTFACE,   // Adjacent face
    NET_ANALYSE_HUMANFACE_TYPE_ABNORMALFACE,   // Abnormal face
    NET_ANALYSE_HUMANFACE_TYPE_HELMETFACE,     // Helmet face
}NET_ANALYSE_HUMANFACE_TYPE;

// Rule type: EVENT_IVS_HUMANTRAIT configuration
typedef struct tagNET_HUMANTRAIT_RULE_INFO
{
	DWORD                   	dwSize;                             			// struct size
    int                    		nHumanFaceTypeNum;                              // Supported facial recognition type number
    NET_ANALYSE_HUMANFACE_TYPE 	emHumanFaceType[8];           					// Supported facial recognition type list

    int                         nMinDuration;                                   // the shortest duration(s)
    int                         nTriggerTargets;                                // The people number that trigger alarm
    int                         nSensitivity;                                   // Sensitivity   1~10
    BOOL                        bSizeFileter;                                   // Size filter enable
    NET_CFG_SIZEFILTER_INFO     stuSizeFileter;                             	// Size filter info
    BOOL                        bFeatureEnable;                                 // whether to open the face feature detection
    BOOL                        bFeatureFilter;                                 // Under the precondition of bFeatureEnable, if image quality is poor, whether or not to report,true:not report, false:report
    int                         nMinQuality;                                    // Image quality threshold ,use with bFeatureFilter

    int					        nFaceFeatureNum;								// the count of face feature 
    NET_EM_FACEFEATURE_TYPE     emFaceFeatureType[32];							// he list of face feature
}NET_HUMANTRAIT_RULE_INFO;

// Detection direction
typedef enum tagEM_DETECT_DIRECTION_TYPE
{
	EM_DETECT_DIRECTION_UNKNOWN = 0,												// Unknown
	EM_DETECT_DIRECTION_LEFT_TO_RIGHT,												// From left to right
	EM_DETECT_DIRECTION_RIGHT_TO_LEFT,												// From right to left
}EM_DETECT_DIRECTION_TYPE;

// XRAYdetection scheme
typedef enum tagEM_XRAY_SCHEME_TYPE
{
	EM_XRAY_SCHEME_UNKNOWN,			// Unknown
	EM_XRAY_SCHEME_TONGFANG_100,	// TongFang 100
	EM_XRAY_SCHEME_TONGFANG_200,	// TongFang 200
	EM_XRAY_SCHEME_TONGFANG_300,	// TongFang 300
	EM_XRAY_SCHEME_TONGFANG_400,	// TongFang 400
	EM_XRAY_SCHEME_ANTIANXIA_100,	// AnTianXia 100
	EM_XRAY_SCHEME_ANTIANXIA_200,	// AnTianXia 200
	EM_XRAY_SCHEME_DAHUA_100,		// DaHua 100
	EM_XRAY_SCHEME_DAHUA_200,		// DaHua 200
	EM_XRAY_SCHEME_DAHUA_300,		// DaHua 300
	EM_XRAY_SCHEME_DAHUA_400,		// DaHua 400
	EM_XRAY_SCHEME_DAHUA_301,		// DaHua 301
	EM_XRAY_SCHEME_SHANGCHEN_HIGH,	// Shang chen high detection
	EM_XRAY_SCHEME_SHANGCHEN_LOW,	// Shang chen low error detection
} EM_XRAY_SCHEME_TYPE;

// Upload rule of X ray object
typedef struct tagNET_XRAY_OBJECT_UPLOAD_RULE
{
	BOOL					bUploadEnable;				// Enable
	UINT					nSimilarity;				// Similarity, [1,100]
	BYTE                    byReserved[128];            // Reserved bytes
} NET_XRAY_OBJECT_UPLOAD_RULE;

// XRAY object detection rule
typedef struct tagNET_XRAY_OBJECT_DETECT_RULE
{
	EM_INSIDE_OBJECT_TYPE		emObjectType;				// Object name
	BOOL						bDetectEnable;				// Enable
	EM_DANGER_GRADE_TYPE		emDangerGrade;				// Safety level
	NET_XRAY_OBJECT_UPLOAD_RULE	stuUploadRuleInfo;			// Upload rule of X ray object
	BYTE                    	byReserved[512];            // Reserved bytes
} NET_XRAY_OBJECT_DETECT_RULE;

// Configuration of rule:EVENT_IVS_XRAY_DETECT_BYOBJECT(X RAY detection by object)
typedef struct tagNET_XRAY_DETECT_BYPBJECT_RULE_INFO
{
    DWORD                       dwSize;                             // Struct size
    int                         nDetectRegionPoint;                 // Detect region point number
    POINTCOORDINATE             stuDetectRegion[20];                // Detect region
    UINT                        nSensitivity;                       // Sensitivity,[1,10]
    EM_DETECT_DIRECTION_TYPE    emDirectionType;                    // Detection direction
    EM_XRAY_SCHEME_TYPE         emSchemeType;                       // Detection scheme
    UINT                        nObjectRuleNum;                     // Number of XRAY object detection rule
    NET_XRAY_OBJECT_DETECT_RULE stuObjectRuleInfo[128];             // XRAY object detection rule
    EM_XRAY_VIEW_TYPE           emViewType;                         // View type
} NET_XRAY_DETECT_BYPBJECT_RULE_INFO;

// non-motor feature 
typedef enum tagEM_NONMOTOR_FEATURE
{
    EM_NONMOTOR_FEATURE_UNKNOWN,                    // unknown
    EM_NONMOTOR_FEATURE_HELMET,                     // helmet
    EM_NONMOTOR_FEATURE_NUMOFCYCLING,               // number of cycling
    EM_NONMOTOR_FEATURE_NONMOTORCOLOR,              // nonmotor color
    EM_NONMOTOR_FEATURE_SEX,                        // sex
    EM_NONMOTOR_FEATURE_AGE,                        // age
    EM_NONMOTOR_FEATURE_HAT,                        // hat
    EM_NONMOTOR_FEATURE_BAG,                        // bag
    EM_NONMOTOR_FEATURE_CARRIERBAG,                 // carrierbag
    EM_NONMOTOR_FEATURE_UMBRELLA,                   // umbrella
    EM_NONMOTOR_FEATURE_UPPERBODYCOLOR,             // upperbody color
    EM_NONMOTOR_FEATURE_LOWERBODYCOLOR,             // lowerbody color
    EM_NONMOTOR_FEATURE_UPCLOTHES,                  // upclothes
    EM_NONMOTOR_FEATURE_DOWNCLOTHES,                // downclothes
    EM_NONMOTOR_FEATURE_CATEGORY,                   // category
}EM_NONMOTOR_FEATURE;

// Rule type: EVENT_IVS_NONMOTORDETECT configuration
typedef struct tagNET_NONMOTORDETECT_RULE_INFO
{
	DWORD                   	dwSize;                             			// struct size
    int					        nFeatureNum;								    // The number of feature which non-motor was supported
    EM_NONMOTOR_FEATURE      	emFeatureList[32];             					// The list of feature which non-motor was supported
}NET_NONMOTORDETECT_RULE_INFO;

// Rule type: EVENT_IVS_VEHICLEDETECT configuration
typedef struct tagNET_VEHICLEDETECT_RULE_INFO
{
	DWORD                   	dwSize;                             			// struct size
    int                         nSnapThreshold;                                 // shooting threshod
	
}NET_VEHICLEDETECT_RULE_INFO;

// Rule of helmet detection
typedef struct tagNET_HELMET_DETECT_RULE
{
	BOOL				bEnable;			// Whether to detect helmet or not
	BOOL				bWear;				// Whether to wear helmet or not
	BOOL				bDetectColor;		// Whether to appoint the color of helmet
	EM_CLOTHES_COLOR	emHelmetColor;		// Color of helmet, it is effect when bDetectColor == TRUE 
	BYTE                byReserved[128];		// Reserved bytes
} NET_HELMET_DETECT_RULE;

// Rule work clothes detection
typedef struct tagNET_WORKCLOTH_DETECT_RULE
{
	BOOL				bEnable;			// Whether to detect work clothes or not
	BOOL				bWear;				// Whether to wear work clothes or not
	BOOL				bDetectColor;		// Whether to apponit the color of work clothes
	EM_CLOTHES_COLOR	emClothesColor;		// Color of work clothes, it is effect when bDetectColor == TRUE
	BYTE                byReserved[128];		// Reserved bytes
} NET_WORKCLOTH_DETECT_RULE;

// Rule of work vest detection
typedef struct tagNET_WORKVEST_DETECT_RULE
{
	BOOL				bEnable;			// Whether to detect work vest
	BOOL				bWear;				// Whether to wear work vest or not
	BOOL				bDetectColor;		// Whether to apponit the color of work vest
	EM_CLOTHES_COLOR	emVestColor;		// Color of work vest, it is effect when bDetectColor == TRUE 
	BYTE                byReserved[128];		// Reserved bytes
} NET_WORKVEST_DETECT_RULE;

// Descript of work ckothes
typedef struct tagNET_WORKCLOTHES_DESCRIPT
{
	NET_HELMET_DETECT_RULE		stuHelemetRule;		// Detection rule of helmet
	NET_WORKCLOTH_DETECT_RULE	stuWorkClothRule;	// Detection rule of work clothes
	NET_WORKVEST_DETECT_RULE	stuWorkVestRule;	// Detection rule of work vest
	BYTE                		byReserved[1024];	// Reserved bytes
} NET_WORKCLOTHES_DESCRIPT;

// Rule type: EVENT_IVS_WORKCLOTHDETECT(work clothes detection) configuration
typedef struct tagNET_WORKCLOTHDETECT_RULE_INFO
{
	DWORD                   	dwSize;                             	// Struct size
	UINT						nDetectRegionPoint;						// Count of detection region points
	POINTCOORDINATE				stuDetectRegion[20];						// Detection region
	UINT						nDescriptNum;							// Count of wokr clothes descript
	NET_WORKCLOTHES_DESCRIPT	stuWorkClothesDescript[64];				// Descript of work clothes, the relationship between the datas is or
} NET_WORKCLOTHDETECT_RULE_INFO;

// Conditional expression of trigger alarm
typedef enum tagEM_CONDITION_EXPR_TYPE
{
	EM_CONDITION_EXPR_UNKNOWN		= 0,		// unknown
	EM_CONDITION_EXPR_GREATER,				// greater
	EM_CONDITION_EXPR_LESS, 				// less
	EM_CONDITION_EXPR_EQUAL,				// equal
} EM_CONDITION_EXPR_TYPE;

// Descript of work state
typedef struct tagNET_WORKSTAT_DESCRIPT
{
	NET_WORKCLOTHES_DESCRIPT	stuWorkClothesDescript;	// Descript of work clothes
	UINT						nTriggerNum;			// People number of trigger alarm
	EM_CONDITION_EXPR_TYPE		emConditionExpr;		// Conditional expressionit is used with nTriggerNum. Trigger alarm when (emConditionExpr nTriggerNum) is satisfied.
	UINT						nStatInterval;			// Statustucs ubtervaluint:second1-86400
	BYTE                		byReserved[1024];		// Reserved bytes
} NET_WORKSTAT_DESCRIPT;

// Rule type:EVENT_IVS_WORKSTATDETECTION(work state detection) configuration
typedef struct tagNET_WORKSTATDETECTION_RULE_INFO
{
	DWORD                   	dwSize;                             	// Struct size
	UINT						nStatDescriptNum;						// Count of sork state descript
	NET_WORKSTAT_DESCRIPT		stuWorkStatDescript[64];					// Work state descript
} NET_WORKSTATDETECTION_RULE_INFO;

// Rule type:EVENT_IVS_CROSSLINEDETECTION(cross line event) configuration
typedef struct tagNET_CROSSLINE_RULE_INFO
{
	DWORD                   dwSize;                             	    // Struct size
	int						nDirection;									// Detect direction:0:left to right;1:right to left;2:both
	int						nDetectLinePoint;							// Detect line point number
	POINTCOORDINATE			stuDetectLine[20];							// Detect line
	int                 	nPtzPresetId;								// PTZ preset Id 0~65535
	BOOL                	bSizeFileter;                               // Size filter enable
	NET_CFG_SIZEFILTER_INFO stuSizeFileter;                             // Size filter info
	int                 	nTriggerPosition;                           // Trigger possition number
	BYTE                	bTriggerPosition[8];                        // Trigger possition,0-object out frame center, 1-object out frame left center, 2-object out frame top center, 3-object out frame right center, 4-object out frame bottom center
	int						nTrackDuration;								// Track Duration,unit:second, value[0-300], 0 second:keep tracking,1~300se:track duration
	UINT					nVehicleSubTypeNum;							// Count of vehicle sub type
	EM_CATEGORY_TYPE		emVehicleSubType[128];						// Vehicle sub type
} NET_CROSSLINE_RULE_INFO;

// Rule type:EVENT_IVS_CROSSREGIONDETECTION(cross region event) configuration
typedef struct tagNET_CROSSREGION_RULE_INFO
{
	DWORD                   dwSize;                             	    // Struct size
	int						nDirection;									// Detect direction:0:Enter;1:Leave;2:Both
	int						nDetectRegionPoint;							// Detect line point number
	POINTCOORDINATE			stuDetectRegion[20];						// Detect line
	BOOL                	bSizeFileter;                               // Size filter enable
	NET_CFG_SIZEFILTER_INFO stuSizeFileter;                             // Size filter info
	int                 	nActionType;                                // Action type number
	BYTE                	bActionType[4];                             // Action type list,0-apaer 1-disapaer 2-in area 3-cross area
	int                 	nMinTargets;                                // The min object number(it will work when bActionType = 2 )
	int                 	nMaxTargets;                                // The max object number(it will work when bActionType = 2 )
	int                 	nMinDuration;                               // Min duration, s(it will work when bActionType = 2 )
	int                 	nReportInterval;                            // Report interval time, s(it will work when bActionType = 2 )
	int						nTrackDuration;								// Track Duration,0 second:keep tracking,1~300se:track duration
	UINT					nVehicleSubTypeNum;							// Count of vehicle sub type
	EM_CATEGORY_TYPE		emVehicleSubType[128];						// Vehicle sub type
} NET_CROSSREGION_RULE_INFO;

// The type of feature abstract
typedef enum tagEM_FEATURE_ABSTRACT_TYPE
{
    EM_FEATURE_ABSTRACT_UNKNOWN = -1,      // Unknown
    EM_FEATURE_ABSTRACT_FACE,              // Face
    EM_FEATURE_ABSTRACT_HUMAN_TRAIT,       // Human trait
    EM_FEATURE_ABSTRACT_VEHICLE,           // Vehicle
    EM_FEATURE_ABSTRACT_NON_MOTOR_VEHICLE, // Non motor vehicle
}EM_FEATURE_ABSTRACT_TYPE;


// Rule type:EVENT_IVS_FEATURE_ABSTRACT(Feature abstract event) configuration
typedef struct tagNET_FEATURE_ABSTRACT_RULE_INFO
{
    DWORD                   dwSize;                     // Struct size
    int                     nFeature;                   // The number of feature
    char                    szFeatureVersions[10][32];  // The version of get picture's feature, up to 10 versions
    EM_FEATURE_ABSTRACT_TYPE emAbstractType;            // The type of feature abstract
}NET_FEATURE_ABSTRACT_RULE_INFO;

// Feature of electric glove
typedef struct tagNET_ELECTRIC_GLOVE_FEATURE
{
    BOOL                bInsulate;              // Is it insulation, TRUE:insulation glove, FALSE:general glove
    BYTE                byReserved[1028];       // Reserved
} NET_ELECTRIC_GLOVE_FEATURE;

// Condition of electric glove detection
typedef struct tagNET_ELECTRIC_GLOVE_DETECT_CONDITION
{
    BOOL                        bExist;             // Whether to detect, use with bglovefeature and stuglovefeature
                                                    // (1) If bglovefeature = false, it indicates detect having glove or not
                                                    // (2) If bGloveFeature=TRUE and bExist=TRUE, it indicates detect glove eligible for stuGloveFeature
                                                    // (3) If bGloveFeature=TRUE, bExist=FALSE, it indicates detect glove which do not meet the stuGloveFeature
    BOOL                        bGloveFeature;      // Whether stuGloveFeature is valid
    NET_ELECTRIC_GLOVE_FEATURE  stuGloveFeature;    // Feature of electric glove
    BYTE                        byReserved[512];    // Reserved
} NET_ELECTRIC_GLOVE_DETECT_CONDITION;

// Rule type:EVENT_IVS_ELECTRIC_GLOVE_DETECT(electric glove detection) configuration
typedef struct tagNET_ELECTRIC_GLOVE_DETECT_RULE_INFO
{
    DWORD                                   dwSize;                         // Struct size
    int                                     nDetectRegionPoint;             // Top points number of detection area
    POINTCOORDINATE                         stuDetectRegion[20];            // Detection area
    NET_CFG_SIZEFILTER_INFO                 stuSizeFileter;                 // Size filter info
    BOOL                                    bSizeFileter;                   // Size filter enable

    UINT                                    nDetectConditionNum;            // Detection confition number
    NET_ELECTRIC_GLOVE_DETECT_CONDITION     stuGloveDetectCondition[32];    // Glove detection conditions, which are logical or relationships
} NET_ELECTRIC_GLOVE_DETECT_RULE_INFO;

// Feature of electric ladder
typedef struct tagNET_ELECTRIC_LADDER_FEATURE
{
    BOOL                bInsulate;              // Is it insulation, TRUE:insulation ladder, FALSE:general ladder
    BYTE                byReserved[1028];       // Reserved
} NET_ELECTRIC_LADDER_FEATURE;

// Condition of electric ladder detection
typedef struct tagNET_ELECTRIC_LADDER_DETECT_CONDITION
{
    BOOL                        bExist;             // Whether to detect, use with bLadderFeature and stuLadderFeature
                                                    // (1) If bLadderFeature = false, it indicates detect having ladder or not
                                                    // (2) If bLadderFeature=TRUE and bExist=TRUE, it indicates detect ladder eligible for stuLadderFeature
                                                    // (3) If bLadderFeature=TRUE, bExist=FALSE, it indicates detect ladder which do not meet the stuLadderFeature
    BOOL                        bLadderFeature;     // Whether stuLadderFeature is valid
    NET_ELECTRIC_LADDER_FEATURE stuLadderFeature;   // Feature of electric ladder
    BYTE                        byReserved[512];    // Reserved
} NET_ELECTRIC_LADDER_DETECT_CONDITION;

// Rule type:EVENT_IVS_ELECTRIC_LADDER_DETECT(electric ladder detection) configuration
typedef struct tagNET_ELECTRIC_LADDER_DETECT_RULE_INFO
{
    DWORD                                   dwSize;                         // Struct size
    int                                     nDetectRegionPoint;             // Top points number of detection area
    POINTCOORDINATE                         stuDetectRegion[20];            // Detection area
    NET_CFG_SIZEFILTER_INFO                 stuSizeFileter;                 // Size filter info
    BOOL                                    bSizeFileter;                   // Size filter enable

    UINT                                    nDetectConditionNum;            // Detection confition number
    NET_ELECTRIC_LADDER_DETECT_CONDITION    stuLadderDetectCondition[32];   // Ladder detection conditions, which are logical or relationships
} NET_ELECTRIC_LADDER_DETECT_RULE_INFO;

// Color operation relationship
typedef enum tagEM_COLOR_OPERATE_TYPE
{
    EM_COLOR_OPERATE_TYPE_UNKNOWN   = -1,   // Unknown
    EM_COLOR_OPERATE_TYPE_UNEQUAL,          // !=
    EM_COLOR_OPERATE_TYPE_EQUAL,            // == 
} EM_COLOR_OPERATE_TYPE;

// Feature of color
typedef struct tagNET_COLOR_FEATRUE
{
    EM_COLOR_OPERATE_TYPE   emColorOperate;     // Color operation relationship
    EM_UNIFIED_COLOR_TYPE   emColor;            // Color type
    BYTE                    byReserved[128];    // Reserved
} NET_COLOR_FEATRUE;

// Feature of electric curtain
typedef struct tagNET_ELECTRIC_CURTAIN_FEATURE
{
    NET_COLOR_FEATRUE   stuColorFeature;        // Feature of color
    BYTE                byReserved[1024];       // Reserved
} NET_ELECTRIC_CURTAIN_FEATURE;

// Condition of electric curtain detection
typedef struct tagNET_ELECTRIC_CURTAIN_DETECT_CONDITION
{
    BOOL                            bExist;             // Whether to detect, use with bCurtainFeature and stuCurtainFeature
                                                        // (1) If bCurtainFeature = false, it indicates detect having curtain or not
                                                        // (2) If bCurtainFeature=TRUE and bExist=TRUE, it indicates detect curtain eligible for stuCurtainFeature
                                                        // (3) If bCurtainFeature=TRUE, bExist=FALSE, it indicates detect curtain which do not meet the stuCurtainFeature
    BOOL                            bCurtainFeature;    // Whether stuCurtainFeature is valid
    NET_ELECTRIC_CURTAIN_FEATURE    stuCurtainFeature;  // Feature of electric curtain
    BYTE                            byReserved[512];    // Reserved
} NET_ELECTRIC_CURTAIN_DETECT_CONDITION;

// Rule type:EVENT_IVS_ELECTRIC_CURTAIN_DETECT(electric curtain detection) configuration
typedef struct tagNET_ELECTRIC_CURTAIN_DETECT_RULE_INFO
{
    DWORD                                   dwSize;                         // Struct size
    int                                     nDetectRegionPoint;             // Top points number of detection area
    POINTCOORDINATE                         stuDetectRegion[20];            // Detection area
    NET_CFG_SIZEFILTER_INFO                 stuSizeFileter;                 // Size filter info
    BOOL                                    bSizeFileter;                   // Size filter enable

    UINT                                    nDetectConditionNum;            // Detection confition number
    NET_ELECTRIC_CURTAIN_DETECT_CONDITION   stuCurtainDetectCondition[32];  // Curtain detection conditions, which are logical or relationships
} NET_ELECTRIC_CURTAIN_DETECT_RULE_INFO;

// Feature of electric fence
typedef struct tagNET_ELECTRIC_FENCE_FEATURE
{
    EM_ELECTRIC_FENCE_TYPE  emFenceType;            // Type of electric fence
    BYTE                    byReserved[1028];       // Reserved
} NET_ELECTRIC_FENCE_FEATURE;

// Condition of electric fence detection
typedef struct tagNET_ELECTRIC_FENCE_DETECT_CONDITION
{
    BOOL                            bExist;             // Whether to detect, use with bFenceFeature and stuFenceFeature
                                                        // (1) If bFenceFeature = false, it indicates detect having fence or not
                                                        // (2) If bFenceFeature=TRUE and bExist=TRUE, it indicates detect fence eligible for stuFenceFeature
                                                        // (3) If bFenceFeature=TRUE, bExist=FALSE, it indicates detect fence which do not meet the stuFenceFeature
    BOOL                            bFenceFeature;      // Whether stuFenceFeature is valid
    NET_ELECTRIC_FENCE_FEATURE      stuFenceFeature;    // Feature of electric fence
    BYTE                            byReserved[512];    // Reserved
} NET_ELECTRIC_FENCE_DETECT_CONDITION;

// Rule type:EVENT_IVS_ELECTRIC_FENCE_DETECT(electric fence detection) configuration
typedef struct tagNET_ELECTRIC_FENCE_DETECT_RULE_INFO
{
    DWORD                                   dwSize;                         // Struct size
    int                                     nDetectRegionPoint;             // Top points number of detection area
    POINTCOORDINATE                         stuDetectRegion[20];            // Detection area
    NET_CFG_SIZEFILTER_INFO                 stuSizeFileter;                 // Size filter info
    BOOL                                    bSizeFileter;                   // Size filter enable

    UINT                                    nDetectConditionNum;            // Detection confition number
    NET_ELECTRIC_FENCE_DETECT_CONDITION     stuFenceDetectCondition[32];    // Fence detection conditions, which are logical or relationships
} NET_ELECTRIC_FENCE_DETECT_RULE_INFO;

// Feature of electric signboard
typedef struct tagNET_ELECTRIC_SIGNBOARD_FEATURE
{
    EM_ELECTRIC_SIGNBOARD_TYPE  emSignboardType;        // Type of electric signboard
    BYTE                        byReserved[1028];       // Reserved
} NET_ELECTRIC_SIGNBOARD_FEATURE;

// Condition of electric signboard
typedef struct tagNET_ELECTRIC_SIGNBOARD_DETECT_CONDITION
{
    BOOL                            bExist;                 // Whether to detect, use with bSignboardFeature and stuSignboardFeature
                                                            // (1) If bSignboardFeature = false, it indicates detect having signboard or not
                                                            // (2) If bSignboardFeature=TRUE and bExist=TRUE, it indicates detect signboard eligible for stuSignboardFeature
                                                            // (3) If bSignboardFeature=TRUE, bExist=FALSE, it indicates detect signboard which do not meet the stuSignboardFeature
    BOOL                            bSignboardFeature;      // Whether stuSignboardFeature is valid
    NET_ELECTRIC_SIGNBOARD_FEATURE  stuSignboardFeature;    // Feature of signboard fence
    BYTE                            byReserved[512];        // Reserved
} NET_ELECTRIC_SIGNBOARD_DETECT_CONDITION;

// Rule type:EVENT_IVS_ELECTRIC_SIGNBOARD_DETECT(electric signboard detection) configuration
typedef struct tagNET_ELECTRIC_SIGNBOARD_DETECT_RULE_INFO
{
    DWORD                                   dwSize;                         // Struct size
    int                                     nDetectRegionPoint;             // Top points number of detection area
    POINTCOORDINATE                         stuDetectRegion[20];            // Detection area
    NET_CFG_SIZEFILTER_INFO                 stuSizeFileter;                 // Size filter info
    BOOL                                    bSizeFileter;                   // Size filter enable

    UINT                                    nDetectConditionNum;            // Detection confition number
    NET_ELECTRIC_SIGNBOARD_DETECT_CONDITION stuSignboardCondition[32];      // Ladder detection conditions, which are logical or relationships
} NET_ELECTRIC_SIGNBOARD_DETECT_RULE_INFO;

// Feature of electric belt
typedef struct tagNET_ELECTRIC_BELT_FEATURE
{
    EM_BELT_WARE_TYPE           emBeltWareType;         // Ware type of electric belt
    BYTE                        byReserved[1028];       // Reserved
} NET_ELECTRIC_BELT_FEATURE;

// Condition of electric belt
typedef struct tagNET_ELECTRIC_BELT_DETECT_CONDITION
{
    BOOL                            bExist;                 // Whether to detect, use with bBeltFeature and stuBeltFeature
                                                            // (1) If bBeltFeature = false, it indicates detect having ladder or not
                                                            // (2) If bBeltFeature=TRUE and bExist=TRUE, it indicates detect ladder eligible for stuBeltFeature
                                                            // (3) If bBeltFeature=TRUE, bExist=FALSE, it indicates detect ladder which do not meet the stuBeltFeature
    BOOL                            bBeltFeature;           // Whether stuBeltFeature is valid
    NET_ELECTRIC_BELT_FEATURE       stuBeltFeature;         // Feature of electric belt
    BYTE                            byReserved[512];        // Reserved
} NET_ELECTRIC_BELT_DETECT_CONDITION;

// Rule type:EVENT_IVS_ELECTRIC_BELT_DETECT(electric belt detection) configuration
typedef struct tagNET_ELECTRIC_BELT_DETECT_RULE_INFO
{
    DWORD                                   dwSize;                         // Struct size
    int                                     nDetectRegionPoint;             // Top points number of detection area
    POINTCOORDINATE                         stuDetectRegion[20];            // Detection area
    NET_CFG_SIZEFILTER_INFO                 stuSizeFileter;                 // Size filter info
    BOOL                                    bSizeFileter;                   // Size filter enable

    UINT                                    nDetectConditionNum;            // Detection confition number
    NET_ELECTRIC_BELT_DETECT_CONDITION      stuBeltCondition[32];           // Belt detection conditions, which are logical or relationships
} NET_ELECTRIC_BELT_DETECT_RULE_INFO;

// info of analyse rule
typedef struct tagNET_ANALYSE_RULE_INFO
{
    EM_SCENE_CLASS_TYPE             emClassType;                        // class type
    DWORD                           dwRuleType;                         // rule type, see "intelligent analyse event type" in dhnetsdk.h
                                                                        // EVENT_IVS_FACEANALYSIS(face analysis), corresponding struct NET_FACEANALYSIS_RULE_INFO
                                                                        // EVENT_IVS_NONMOTORDETECT(nonmotor detect), corresponding struct NET_NONMOTORDETECT_RULE_INFO
                                                                        // EVENT_IVS_VEHICLEDETECT(vehicle detect), corresponding struct NET_VEHICLEDETECT_RULE_INFO
                                                                        // EVENT_IVS_HUMANTRAIT(humantrait detect), corresponding struct NET_HUMANTRAIT_RULE_INFO
                                                                        // EVENT_IVS_XRAY_DETECT_BYOBJECT(X ray object detect) corresponding struct NET_XRAY_DETECT_BYPBJECT_RULE_INFO
                                                                        // EVENT_IVS_WORKCLOTHES_DETECT(work clothes detection), corresponding struct NET_WORKCLOTHDETECT_RULE_INFO
                                                                        // EVENT_IVS_WORKSTATDETECTION(work state detection), corresponding struct NET_WORKSTATDETECTION_RULE_INFO
                                                                        // EVENT_IVS_CROSSLINEDETECTION(cross line detection), corresponding struct NET_CROSSLINE_RULE_INFO
                                                                        // EVENT_IVS_CROSSREGIONDETECTION(cross region detection), corresponding struct NET_CROSSREGION_RULE_INFO
                                                                        // EVENT_IVS_FEATURE_ABSTRACT(FeatureAbstract), corresponding struct NET_FEATURE_ABSTRACT_RULE_INFO 
                                                                        // EVENT_IVS_ELECTRIC_GLOVE_DETECT(electric glove detection), corresponding struct ET_ELECTRIC_GLOVE_DETECT_RULE_INFO
                                                                        // EVENT_IVS_ELECTRIC_LADDER_DETECT(electric ladder detection), corresponding struct NET_ELECTRIC_LADDER_DETECT_RULE_INFO
                                                                        // EVENT_IVS_ELECTRIC_CURTAIN_DETECT(electric curtain detection), corresponding struct NET_ELECTRIC_CURTAIN_DETECT_RULE_INFO
                                                                        // EVENT_IVS_ELECTRIC_FENCE_DETECT(electric fence detection), corresponding struct NET_ELECTRIC_FENCE_DETECT_RULE_INFO
                                                                        // EVENT_IVS_ELECTRIC_SIGNBOARD_DETECT(electric signboard detection), corresponding struct NET_ELECTRIC_SIGNBOARD_DETECT_RULE_INFO
                                                                        // EVENT_IVS_ELECTRIC_BELT_DETECT(electric belt detection), corresponding struct NET_ELECTRIC_BELT_DETECT_RULE_INFO
    void*                           pReserved;                          // rule config, the rule config struct is determined by dwRuleType, see the comments of dwRuleType
    UINT                            nObjectTypeNum;                     // count of object types, 0 means no types
    EM_ANALYSE_OBJECT_TYPE          emObjectTypes[16];                  // object types
    BYTE                            byReserved[956];                    // reserved bytes
} NET_ANALYSE_RULE_INFO;

// analyse rule
typedef struct tagNET_ANALYSE_RULE
{
    NET_ANALYSE_RULE_INFO           stuRuleInfos[MAX_ANALYSE_RULE_COUNT];       // info of analyse rules
    UINT                            nRuleCount;                                 // number of analyse rules
    BYTE                            byReserved[1028];                           // reserved bytes
} NET_ANALYSE_RULE;

// protocol type of video stream
typedef enum tagEM_STREAM_PROTOCOL_TYPE
{
    EM_STREAM_PROTOCOL_UNKNOWN,         // unknown
    EM_STREAM_PROTOCOL_PRIVATE_V2,      // private v2
    EM_STREAM_PROTOCOL_PRIVATE_V3,      // private v3
    EM_STREAM_PROTOCOL_RTSP,            // rtsp
    EM_STREAM_PROTOCOL_ONVIF,           // Onvif
    EM_STREAM_PROTOCOL_GB28181,         // GB28181
} EM_STREAM_PROTOCOL_TYPE;

// start rule of analyse task
typedef enum tagEM_ANALYSE_TASK_START_RULE
{
    EM_ANALYSE_TASK_START_NOW,          // start now
    EM_ANALYSE_TASK_START_LATER,        // start later
} EM_ANALYSE_TASK_START_RULE;

// info of remote video stream
typedef struct tagNET_REMOTE_REALTIME_STREAM_INFO
{
    DWORD                           dwSize;                                 // struct size
    EM_ANALYSE_TASK_START_RULE      emStartRule;                            // starting rule of analyse task
    NET_ANALYSE_RULE                stuRuleInfo;                            // info of analyse rule
    EM_STREAM_PROTOCOL_TYPE         emStreamProtocolType;                   // protocol type of video stream
    char                            szPath[DH_COMMON_STRING_256];           // path of video stream
    char                	        szIp[DH_MAX_IPADDR_OR_DOMAIN_LEN];      // IP address
	WORD                 	        wPort;                      		    // port
    BYTE                            byReserved[2];                          // for alignment
    char                	        szUser[DH_COMMON_STRING_64];            // user name
    char                	        szPwd[DH_COMMON_STRING_64];             // password
    int                 	        nChannelID;                             // channel ID
    UINT                            nStreamType;                            // Stream type, 0-main stream, 1-extra stream 1, 2-extra stream 2
} NET_REMOTE_REALTIME_STREAM_INFO;

// push picture file info
typedef struct tagNET_PUSH_PICFILE_INFO
{
    DWORD                           dwSize;                                 // struct size
    EM_ANALYSE_TASK_START_RULE      emStartRule;                            // starting rule of analyse task
    NET_ANALYSE_RULE                stuRuleInfo;                            // info of analyse rule
} NET_PUSH_PICFILE_INFO;

// output parameter of CLIENT_AddAnalyseTask
typedef struct tagNET_OUT_ADD_ANALYSE_TASK
{
    DWORD                           dwSize;                                 // struct size
    UINT                            nTaskID;                                // task ID
    UINT                            nVirtualChannel;                        // virtual channel
} NET_OUT_ADD_ANALYSE_TASK;

// input parameter of CLIENT_StartAnalyseTask
typedef struct tagNET_IN_START_ANALYSE_TASK
{
    DWORD                           dwSize;                                 // struct size
    UINT                            nTaskID;                                // task ID
} NET_IN_START_ANALYSE_TASK;

// output parameter of CLIENT_StartAnalyseTask
typedef struct tagNET_OUT_START_ANALYSE_TASK
{
    DWORD                           dwSize;                                 // struct size
} NET_OUT_START_ANALYSE_TASK;

// input parameter of CLIENT_RemoveAnalyseTask 
typedef struct tagNET_IN_REMOVE_ANALYSE_TASK
{
    DWORD                           dwSize;                                 // struct size
    UINT                            nTaskID;                                // task ID
} NET_IN_REMOVE_ANALYSE_TASK;

// output parameter of CLIENT_RemoveAnalyseTask
typedef struct tagNET_OUT_REMOVE_ANALYSE_TASK
{
    DWORD                           dwSize;                                 // struct size
} NET_OUT_REMOVE_ANALYSE_TASK;

// analyse task state
typedef enum tagEM_ANALYSE_STATE
{
    EM_ANALYSE_STATE_UNKNOWN,             // unknown
    EM_ANALYSE_STATE_IDLE,                // idle
    EM_ANALYSE_STATE_ANALYSING,           // analysing
    EM_ANALYSE_STATE_ANALYSING_WAITPUSH,  // analysing and waitting push data
    EM_ANALYSE_STATE_FINISH,              // finish
    EM_ANALYSE_STATE_ERROR,               // error
    EM_ANALYSE_STATE_REMOVED,             // removed
} EM_ANALYSE_STATE;

// info of analyse task
typedef struct tagNET_ANALYSE_TASKS_INFO
{
    UINT                            nTaskID;                                // task ID
    EM_ANALYSE_STATE                emAnalyseState;                         // analyse state
    BYTE                            byReserved[1024];                       // reserved bytes
} NET_ANALYSE_TASKS_INFO;

// input parameter of CLIENT_FindAnalyseTask
typedef struct tagNET_IN_FIND_ANALYSE_TASK
{
    DWORD                           dwSize;                                 // struct size
} NET_IN_FIND_ANALYSE_TASK;

// out parameter of CLIENT_FindAnalyseTask
typedef struct tagNET_OUT_FIND_ANALYSE_TASK
{
    DWORD                           dwSize;                                 // struct size
    UINT                            nTaskNum;                               // number of analyse tasks
    NET_ANALYSE_TASKS_INFO          stuTaskInfos[MAX_ANALYSE_TASK_NUM];     // info of analyse tasks
} NET_OUT_FIND_ANALYSE_TASK;

// The info of picture which si pused by user
typedef struct tagNET_PUSH_PICTURE_INFO
{
    char                            szFileID[DH_COMMON_STRING_128];         // file ID
    UINT                            nOffset;                                // the offset length of the picture file in the bin data, unit:byte
    UINT                            nLength;                                // the length of the picture file, unit:byte
    NET_XRAY_CUSTOM_INFO            stuXRayCustomInfo;                      // Customer-defined information. It is used for X-ray.
    BYTE                            byReserved[768];                        // reserved bytes
} NET_PUSH_PICTURE_INFO;

// Input param of push picture
typedef struct tagNET_IN_PUSH_ANALYSE_PICTURE_FILE
{
    DWORD                           dwSize;                                         // struct size
    UINT                            nTaskID;                                        // task ID
    NET_PUSH_PICTURE_INFO           stuPushPicInfos[MAX_ANALYSE_PICTURE_FILE_NUM];  // info of push pictures
    UINT                            nPicNum;                                        // number of push pictures
    UINT                            nBinBufLen;                                     // length of bin data buf, unit:byte
    char*                           pBinBuf;                                        // bin data buf, application and release by user
} NET_IN_PUSH_ANALYSE_PICTURE_FILE;

// Output param of push picture
typedef struct tagNET_OUT_PUSH_ANALYSE_PICTURE_FILE
{
    DWORD                           dwSize;                                 // struct size
} NET_OUT_PUSH_ANALYSE_PICTURE_FILE;

// callback info of attach analyse state
typedef struct tagNET_CB_ANALYSE_TASK_STATE_INFO
{
    NET_ANALYSE_TASKS_INFO          stuTaskInfos[MAX_ANALYSE_TASK_NUM];     // info of analyse task
    UINT                            nTaskNum;                               // number of task
    BYTE                            byReserved[1024];                       // reserved bytes
} NET_CB_ANALYSE_TASK_STATE_INFO;

// callback function of attach analyse state, lAttachHandle is returned by interface CLIENT_AttachAnalyseTaskStat
typedef int  (CALLBACK *fAnalyseTaskStateCallBack)(LLONG lAttachHandle, NET_CB_ANALYSE_TASK_STATE_INFO *pstAnalyseTaskStateInfo, LDWORD dwUser);

// input parameter of CLIENT_AttachAnalyseTaskState
typedef struct tagNET_IN_ATTACH_ANALYSE_TASK_STATE
{
    DWORD                           dwSize;                                 // struct size
    UINT                            nTaskIDs[MAX_ANALYSE_TASK_NUM];         // task IDs
    UINT                            nTaskIdNum;                             // number of analyse task, 0 is means attach all
    fAnalyseTaskStateCallBack       cbAnalyseTaskState;                     // callback function of attach analyse state
    LDWORD                          dwUser;                 			    // user data
} NET_IN_ATTACH_ANALYSE_TASK_STATE;

// filter condition of attach analyse result
typedef struct tagNET_ANALYSE_RESULT_FILTER
{
    DWORD                           dwAlarmTypes[MAX_ANALYSE_FILTER_EVENT_NUM];     // event types, see "intelligent analyse event type" in dhnetsdk.h
    UINT                            nEventNum;                                      // number of events which are used as filter condition
    BYTE                            byReserved[1024];                               // reserved bytes
} NET_ANALYSE_RESULT_FILTER;

// file analyse state
typedef enum tagEM_FILE_ANALYSE_STATE
{
    EM_FILE_ANALYSE_UNKNOWN     = -1,   // unknown
    EM_FILE_ANALYSE_EXECUTING,          // in analysis
    EM_FILE_ANALYSE_FINISH,             // finish
    EM_FILE_ANALYSE_FAILED,             // failed
} EM_FILE_ANALYSE_STATE;

// Custorm data for task
typedef struct tagNET_TASK_CUSTOM_DATA
{
    char                    szClientIP[128];            // Client IP
    char                    szDeviceID[128];            // Device ID
    BYTE                    byReserved[256];            // Reserved
} NET_TASK_CUSTOM_DATA;

// result of analyse task
typedef struct tagNET_ANALYSE_TASK_RESULT
{
    UINT                            nTaskID;                                // task ID
    char                            szFileID[DH_COMMON_STRING_128];         // file ID, used for file analyse
    EM_FILE_ANALYSE_STATE           emFileAnalyseState;                     // file analyse state
    char                            szFileAnalyseMsg[DH_COMMON_STRING_256]; // additional info about file analyse, usually it is failure info.
    NET_SECONDARY_ANALYSE_EVENT_INFO stuEventInfos[MAX_SECONDARY_ANALYSE_EVENT_NUM];// info of events
    int                             nEventCount;                            // number of events
    NET_TASK_CUSTOM_DATA            stuCustomData;                          // custorm data for task
    BYTE                            byReserved[512];                        // reserved bytes
} NET_ANALYSE_TASK_RESULT;

// callback info of analyse result
typedef struct tagNET_CB_ANALYSE_TASK_RESULT_INFO
{
    NET_ANALYSE_TASK_RESULT         stuTaskResultInfos[MAX_ANALYSE_TASK_NUM];   // result of analyse tasks
    UINT                            nTaskResultNum;                             // numbet of tasks
    BYTE                            byReserved[1028];                           // reserved bytes
} NET_CB_ANALYSE_TASK_RESULT_INFO;

// callback function of attach analyse result, lAttachHandle is returned by CLIENT_AttachAnalyseTaskResult
typedef int  (CALLBACK *fAnalyseTaskResultCallBack)(LLONG lAttachHandle, NET_CB_ANALYSE_TASK_RESULT_INFO *pstAnalyseTaskResult, const char *pBuf, const DWORD dwBufSize, LDWORD dwUser);

// input parameter of CLIENT_AttachAnalyseTaskResult
typedef struct tagNET_IN_ATTACH_ANALYSE_RESULT
{
    DWORD                           dwSize;                                 // struct size
    UINT                            nTaskIDs[MAX_ANALYSE_TASK_NUM];         // task IDs
    UINT                            nTaskIdNum;                             // number of tasks, 0 is means attach all
    NET_ANALYSE_RESULT_FILTER       stuFilter;                              // filter confition
    BYTE                            byReserved[4];                          // for alignment
    fAnalyseTaskResultCallBack      cbAnalyseTaskResult;                    // callback function of attach analyse result
    LDWORD                          dwUser;                                 // user data
} NET_IN_ATTACH_ANALYSE_RESULT;

// input parameter of CLIENT_SetAnalyseTaskCustomData
typedef struct tagNET_IN_SET_ANALYSE_TASK_CUSTOM_DATA
{
    DWORD                           dwSize;                                 // struct size
    UINT                            nTaskID;                                // task ID
    NET_TASK_CUSTOM_DATA            stuTaskCustomData;                      // custom data for task
} NET_IN_SET_ANALYSE_TASK_CUSTOM_DATA;

// output parameter of CLIENT_SetAnalyseTaskCustomData
typedef struct tagNET_OUT_SET_ANALYSE_TASK_CUSTOM_DATA
{
    DWORD                           dwSize;                                 // struct size
} NET_OUT_SET_ANALYSE_TASK_CUSTOM_DATA;

// algorithm vendor
typedef enum tagEM_ALGORITHM_VENDOR
{
    EM_ALGORITHM_VENDOR_UNKNOWN,               // unknown
    EM_ALGORITHM_VENDOR_DAHUA,                 // DaHua
    EM_ALGORITHM_VENDOR_SHANGTANG,             // ShangTang
    EM_ALGORITHM_VENDOR_HUAFU,                 // HuaFu
    EM_ALGORITHM_VENDOR_SHENMO,                // ShenMo
} EM_ALGORITHM_VENDOR;

// info of algorithm
typedef struct tagNET_ALGORITHM_INFO
{
    EM_SCENE_CLASS_TYPE             emClassType;                        // calss type
    char                            szVersion[DH_COMMON_STRING_32];     // algorithm version
    EM_ALGORITHM_VENDOR             emAlgorithmVendor;                  // algorithm vendor
    char                            szAlgorithmLibVersion[DH_COMMON_STRING_32];  // Algorithmic Library File Version
    BYTE                            byReserved[992];                   // reserved bytes
} NET_ALGORITHM_INFO;

// total info of analyse capacity
typedef struct tagNET_TOTAL_CAP
{
    EM_SCENE_CLASS_TYPE             emClassType;                                // class type
    DWORD                           dwRuleTypes[MAX_ANALYSE_RULE_COUNT];        // rule types, see "intelligent analyse event type" in dhnetsdk.h
    UINT                            nRuleNum;                                   // number of rules
    UINT                            nMaxStreamNum;                              // max number of video streams which are analysed at the same time.
    BYTE                            byReserved[1024];                           // reserved bytes
} NET_TOTAL_CAP;

// algorithm of analyse caps
typedef struct tagNET_ANALYSE_CAPS_ALGORITHM
{
    DWORD                           dwSize;                                         // struct size
    NET_ALGORITHM_INFO              stuAlgorithmInfos[MAX_ANALYSE_ALGORITHM_NUM];   // info of Algorithms
    UINT                            nAlgorithmNum;                                  // number of Algorithm
} NET_ANALYSE_CAPS_ALGORITHM;

// total capacity of analyse
typedef struct tagNET_ANALYSE_CAPS_TOTAL
{
    DWORD                           dwSize;                                         // struct size
    NET_TOTAL_CAP                   stuTotalCaps[MAX_ANALYSE_TOTALCAPS_NUM];        // info of total capacities
    UINT                            nTotalCapsNum;                                  // number of total capacities
} NET_ANALYSE_CAPS_TOTAL;

// The capacity of independent Upgrade of Algorithms
typedef struct tagNET_ANALYSE_CAPS_SUPPORT_ALGORITHM_UPGRADE
{
    DWORD                           dwSize;                                         // struct size
    BOOL                            bSupportOnlyAlgorithmUpgrade;                   // Whether to support independent upgrading of algorithms
} NET_ANALYSE_CAPS_SUPPORT_ALGORITHM_UPGRADE;

// type of analyse capacity
typedef enum tagEM_ANALYSE_CAPS_TYPE
{
    EM_ANALYSE_CAPS_ALGORITHM = 1,      // algorithm, Corresponding to NET_ANALYSE_CAPS_ALGORITHM
    EM_ANALYSE_CAPS_TOTALCAPS,          // total capacity, Corresponding to NET_ANALYSE_CAPS_TOTAL
    EM_ANALYSE_CAPS_SUPPORT_ALGORITHM_UPGRADE,  // he capacity of independent Upgrade of Algorithms, corresponding to NET_ANALYSE_CAPS_SUPPORT_ALGORITHM_UPGRADE
} EM_ANALYSE_CAPS_TYPE;

// get capacity of intelligent analyse, the struct of pstOutParam will be selected according to the value of emCapsType, pstOutParam is application and released by user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetAnalyseCaps(LLONG lLoginID, EM_ANALYSE_CAPS_TYPE emCapsType, void *pOutParam, int nWaitTime);

// add analyse task, the struct of pInParam will be selected according to the value of emDataSourceType, pInParam and pOutParam are application and released by user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddAnalyseTask(LLONG lLoginID, EM_DATA_SOURCE_TYPE emDataSourceType, void *pInParam, NET_OUT_ADD_ANALYSE_TASK *pOutParam, int nWaitTime);

// start analyse task, pInParam and pOutParam are application and released by user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartAnalyseTask(LLONG lLoginID, NET_IN_START_ANALYSE_TASK *pInParam, NET_OUT_START_ANALYSE_TASK *pOutParam, int nWaitTime);

// remove(stop) analyse task, pInParam and pOutParam are application and released by user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RemoveAnalyseTask(LLONG lLoginID, NET_IN_REMOVE_ANALYSE_TASK *pInParam, NET_OUT_REMOVE_ANALYSE_TASK *pOutParam, int nWaitTime);

// find analyse task info, pInParam and pOutParam are application and released by user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FindAnalyseTask(LLONG lLoginID, NET_IN_FIND_ANALYSE_TASK *pInParam, NET_OUT_FIND_ANALYSE_TASK *pOutParam, int nWaitTime);

// Push pictures to dev
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PushAnalysePictureFile(LLONG lLoginID, NET_IN_PUSH_ANALYSE_PICTURE_FILE *pInParam, NET_OUT_PUSH_ANALYSE_PICTURE_FILE *pOutParam, int nWaitTime);

// attach analyse task state, pInParam is application and released by user
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachAnalyseTaskState(LLONG lLoginID, NET_IN_ATTACH_ANALYSE_TASK_STATE *pInParam, int nWaitTime);

// detach analyse task state, lAttachHandle is returned by interface CLIENT_AttachAnalyseTaskState
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachAnalyseTaskState(LLONG lAttachHandle);

// attach analyse task result, pInParam is application and released by user
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachAnalyseTaskResult(LLONG lLoginID, NET_IN_ATTACH_ANALYSE_RESULT *pInParam, int nWaitTime);

// detach analyse task result, lAttachHandle is returned by interface CLIENT_AttachAnalyseTaskResult
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachAnalyseTaskResult(LLONG lAttachHandle);

// attach analyse remain resource, pInParam is application and released by user
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachRemainAnalyseResource(LLONG lLoginID, NET_IN_ATTACH_REMAIN_ANALYSE_RESOURCE *pInParam, int nWaitTime);

// detach analyse remain resource, lAttachHandleis returned by interface CLIENT_AttachRemainAnalyseResource
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachRemainAnalyseResource(LLONG lAttachHandle);

// Set custom data of task
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetAnalyseTaskCustomData(LLONG lLoginID, const NET_IN_SET_ANALYSE_TASK_CUSTOM_DATA *pInParam, NET_OUT_SET_ANALYSE_TASK_CUSTOM_DATA *pOutParam, const int nWaitTime);

/////////////////////////////////interfaces of intelligent analysis service; end/////////////////////////////////

// input parameter of CLIENT_GetLensInfo
typedef struct tagNET_IN_GETLENSINFO
{
    DWORD                           dwSize;                                 // struct size
    UINT                            nChannel;                               // video channel number
} NET_IN_GETLENSINFO;
// lens type
typedef enum tagEM_LENS_TYPE
{
    EM_LENS_TYPE_UNKNOWN = -1,                  // unknown
    EM_LENS_TYPE_FIXED_FOCUS,                   // fixed focus
    EM_LENS_TYPE_INTERNEL_ZOOM,                 // internel zoom lens
    EM_LENS_TYPE_MANUAL_ZOOM,                   // manual zoom lens
    EM_LENS_TYPE_EXTERNEL_ZOOM,                 // externel zoom lens
} EM_LENS_TYPE;

// output parameter of CLIENT_GetLensInfo
typedef struct tagNET_OUT_GETLENSINFO
{
    DWORD                           dwSize;                                 // struct size
    EM_LENS_TYPE                    emLensType;                             // lens type
} NET_OUT_GETLENSINFO;

// get lens info, pInParam and pOutParam are application and released by user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetLensInfo(LLONG lLoginID, NET_IN_GETLENSINFO *pInParam, NET_OUT_GETLENSINFO *pOutParam, int nWaitTime);

// lens action
typedef enum tagEM_LENS_ACTION
{
    EM_LENS_ACTION_UNKNOWN = -1,                                // unknown
    EM_LENS_ACTION_SINGLE_STEP,                                 // single step(single click +-)
    EM_LENS_ACTION_START_CONTINUOUS_ADJUSTMENT,                 // start continuous adjustment(long press +-)
    EM_LENS_ACTION_END_CONTINUOUS_ADJUSTMENT,                   // end continuous adjustment(end long press +-)
} EM_LENS_ACTION;

// command information
typedef struct tagNET_CMD_INFO
{
    int                            nZoom;                                     // zoom step length, minus sign indicates direction of reduction, when focus is not zero, zoom must be zero
    int                            nFocus;                                    // focus step length, minus sign indicates direction of reduction, when zoom is not zero, focus must be zero
    EM_LENS_ACTION                 emLensAction;                              // lens action
    BYTE                           byReserved[1024];                          // reserved bytes
} NET_CMD_INFO;

// input parameter of CLIENT_AdjustRelativeLensFocus
typedef struct tagNET_IN_ADJUSTRELATIVELENSFOCUS
{
    DWORD                           dwSize;                                 // struct size
    UINT                            nChannel;                               // video channel number
    NET_CMD_INFO                    stuCmdInfo;                             // command information
} NET_IN_ADJUSTRELATIVELENSFOCUS;

// output parameter of CLIENT_AdjustRelativeLensFocus
typedef struct tagNET_OUT_ADJUSTRELATIVELENSFOCUS
{
    DWORD                           dwSize;                                 // struct size
} NET_OUT_ADJUSTRELATIVELENSFOCUS;

// adjustment of relative lens focus, pInParam and pOutParam are application and released by user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AdjustRelativeLensFocus(LLONG lLoginID, NET_IN_ADJUSTRELATIVELENSFOCUS *pInParam, NET_OUT_ADJUSTRELATIVELENSFOCUS *pOutParam, int nWaitTime);

// Security gate person alarm statistics info
typedef struct tagNET_SECURITYGATE_ALARM_STATISTICS_INFO
{
	char								szUUID[36];							// UUID	
	UINT								nStatisticsInfoID;					// statistics info id
	NET_TIME_EX							stuBeginTime;						// begin time
	NET_TIME_EX							stuEndTime;							// end time
	UINT								nPassIn;							// num of person in
	UINT								nAlarmIn;							// num of alarm in
	UINT								nPassOut;							// num of person out
	UINT								nAlarmOut;							// num of alarm out
	BYTE								byReserved[1024];					// reserved
}NET_SECURITYGATE_ALARM_STATISTICS_INFO;

// Security gate person alarm  callback
typedef void (CALLBACK *fSecurityGateAttachAlarmStatistics)(LLONG lAttachHandle, NET_SECURITYGATE_ALARM_STATISTICS_INFO* pInfo, LDWORD dwUser);

// Input param of CLIENT_SecurityGateAttachAlarmStatistics
typedef struct tagNET_IN_SECURITYGATE_ATTACH_ALARM_STATISTICS
{
	DWORD								dwSize;								// struct size
	char								szUUID[36];							// UUID
	fSecurityGateAttachAlarmStatistics	cbNotify;							// callback function
	LDWORD								dwUser;								// user info
}NET_IN_SECURITYGATE_ATTACH_ALARM_STATISTICS;

// Output param of CLIENT_SecurityGateAttachAlarmStatistics
typedef struct tagNET_OUT_SECURITYGATE_ATTACH_ALARM_STATISTICS
{
	DWORD								dwSize;								// struct size
}NET_OUT_SECURITYGATE_ATTACH_ALARM_STATISTICS;

// Atatch security gate alarm statistics info
CLIENT_NET_API LLONG CALL_METHOD CLIENT_SecurityGateAttachAlarmStatistics(LLONG lLoginID, const NET_IN_SECURITYGATE_ATTACH_ALARM_STATISTICS* pInParam, NET_OUT_SECURITYGATE_ATTACH_ALARM_STATISTICS* pOutParam, int nWaitTime);


// Cancel atatch security gate alarm statistics info
// lAttachHandle is the value returned by CLIENT_SecurityGateAttachAlarmStatistics
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SecurityGateDetachAlarmStatistics(LLONG lAttachHandle);
// Camera config info
typedef struct tagNET_CAMERA_CFG_INFO
{
    char        szIP[32];           // IP
    UINT        nPort;              // Port
    char        szLoginName[32];    // Login name
    char        szLoginPwd[32];     // Login password. The password empty represent not modify the pasword ,when set config.
    BYTE        byReserved[1024];   // Reserve byte
}NET_CAMERA_CFG_INFO;

// Input parameter of CLIENT_SetCameraCfg 
typedef struct tagNET_IN_SET_CAMERA_CFG
{
    DWORD                   dwSize;             // struct size
    int                     nCameraNo;          // Camera number
    NET_CAMERA_CFG_INFO     stuCameraInfo;      // Camera config info
} NET_IN_SET_CAMERA_CFG;

// Output parameter of CLIENT_SetCameraCfg
typedef struct tagNET_OUT_SET_CAMERA_CFG
{
    DWORD                           dwSize;     // struct size
} NET_OUT_SET_CAMERA_CFG;

// Input parameter of CLIENT_GetCameraCfg 
typedef struct tagNET_IN_GET_CAMERA_CFG
{
    DWORD                   dwSize;             // struct size
    int                     nCameraNo;          // Camera number
} NET_IN_GET_CAMERA_CFG;

// Output parameter of CLIENT_GetCameraCfg 
typedef struct tagNET_OUT_GET_CAMERA_CFG
{
    DWORD                   dwSize;             // struct size
    int                     nCameraNo;          // Camera number
    NET_CAMERA_CFG_INFO     stuCameraInfo;      // Camera config info
} NET_OUT_GET_CAMERA_CFG;

// Entry direction
typedef enum tagEM_ENTRY_DIRECTION
{
    EM_ENTRY_UNKNOWN,                            // Unknown
    EM_ENTRY_NORTH_TO_SOUTH,                     // north to south         
    EM_ENTRY_EASTNORTH_TO_WESTSOUTH,             // east-north to east-south 
    EM_ENTRY_EAST_TO_WEST,                       // east to west
    EM_ENTRY_EASTSOUTH_TO_WESTNORTH,             // east-south to west-north
    EM_ENTRY_SOUTH_TO_NORTH,                     // south to north
    EM_ENTRY_WESTSOUTH_TO_EASTSOUTH,             // wast-south to east-north
    EM_ENTRY_WEST_TO_EAST,                       // wast to east
    EM_ENTRY_WESTNORTH_TO_EASTSOUTH,             // wast-north to east-south
} EM_ENTRY_DIRECTION;


// Entry type
typedef enum tagEM_ENTRY_TYPE
{
    EM_ENTRY_TYPE_UNKNOWN,                        // Unknown
    EM_ENTRY_TYPE_TURN_LEFT,                      // turn left
    EM_ENTRY_TYPE_STRAIGHT,                       // straight
    EM_ENTRY_TYPE_TRUN_RIGHT,                     // turn right
    EM_ENTRY_TYPE_TURN_ROUND,                     // turn round
}EM_ENTRY_TYPE;

// Channel config
typedef struct tagNET_CHANNEL_CFG_INFO
{
    int                     nCameraNo;          // The camera number of repoted 
    EM_ENTRY_DIRECTION      emEntryDirection;   // entry direction
    EM_ENTRY_TYPE           emEntryType[16];     // entry type
	int						nRetEntryTypeNum;		// The number of entry type
	int						nLaneNo;			// Lane number
    BYTE                    byReserved[956];   // Reserved
}NET_CHANNEL_CFG_INFO;

// Input parameter of CLIENT_SetChannelCfg 
typedef struct tagNET_IN_SET_CHANNEL_CFG
{
    DWORD                   dwSize;             // struct size
    int                     nChannelNo;         // test channel
    NET_CHANNEL_CFG_INFO    stuChannelInfo;     // channel config info
} NET_IN_SET_CHANNEL_CFG;

// Output parameter of CLIENT_SetChannelCfg 
typedef struct tagNET_OUT_SET_CHANNEL_CFG
{
    DWORD                   dwSize;             // struct size
} NET_OUT_SET_CHANNEL_CFG;

// Input parameter of  CLIENT_GetChannelCfg 
typedef struct tagNET_IN_GET_CHANNEL_CFG
{
    DWORD                   dwSize;             // struct size
    int                     nChannelNo;         // task channel
} NET_IN_GET_CHANNEL_CFG;

// Output parameter of  CLIENT_GetChannelCfg 
typedef struct tagNET_OUT_GET_CHANNEL_CFG
{
    DWORD                   dwSize;             // struct size
    int                     nChannelNo;         // test channel
    NET_CHANNEL_CFG_INFO    stuChannelInfo;     // channel config info
} NET_OUT_GET_CHANNEL_CFG;

// The light detection mode
typedef enum tagEM_TRAFFIC_LIGHT_DETECT_MODE
{
    EM_TRAFFIC_DETECT_UNKNOWN = -1,              // Unknown
    EM_TRAFFIC_DETECT_RED,                       // red 
    EM_TRAFFIC_DETECT_GREEN,                     // green
}EM_TRAFFIC_LIGHT_DETECT_MODE;

// Input parameter of CLIENT_SetDetectMode 
typedef struct tagNET_IN_SET_DETECT_MODE
{
    DWORD                     dwSize;            // struct size
    int                       nDetectTimeout;    // detection time out 
    EM_TRAFFIC_LIGHT_DETECT_MODE    emDetectionMode;   // mode

} NET_IN_SET_DETECT_MODE;

// Output parameter of CLIENT_SetDetectMode 
typedef struct tagNET_OUT_SET_DETECT_MODE
{
    DWORD                     dwSize;            // struct size
} NET_OUT_SET_DETECT_MODE;

// Input parameter of CLIENT_GetDetectMode 
typedef struct tagNET_IN_GET_DETECT_MODE
{
    DWORD                     dwSize;            // struct size
} NET_IN_GET_DETECT_MODE;

// Output parameter of CLIENT_GetDetectMode 
typedef struct tagNET_OUT_GET_DETECT_MODE
{
    DWORD                     dwSize;            // struct size
    int                       nDetectTimeout;    // detection time out 
    EM_TRAFFIC_LIGHT_DETECT_MODE    emDetectionMode;   // mode
} NET_OUT_GET_DETECT_MODE;

// Camera connect status
typedef enum tagEM_CAMERA_CONNECT_STATE
{
	EM_CAMERA_CONNECT_STATE_UNKNOWN = -1,				// Unknown
	EM_CAMERA_CONNECT_STATE_UNCONNECT,					// Unconnect
	EM_CAMERA_CONNECT_STATE_CONNECTED,					// Connected
}EM_CAMERA_CONNECT_STATE;

// Traffic light status
typedef enum tagEM_TRAFFIC_LIGHT_DETECT_STATE
{
	EM_TRAFFIC_DETECT_STATE_UNKNOWN = -1,              // Unknown
	EM_TRAFFIC_DETECT_STATE_RED,                       // Red
	EM_TRAFFIC_DETECT_STATE_GREEN,                     // Green
}EM_TRAFFIC_LIGHT_DETECT_STATE;

// The status of the specified traffic light
typedef struct tagNET_LIGHTINFO_CFG
{
	int								nLightNo;			// The channel of light
	EM_TRAFFIC_LIGHT_DETECT_STATE	emLightState;		// The status of traffic light
	BYTE							byReserved[504];	// Reserved
}NET_LIGHTINFO_CFG;

//  Input parameter of CLIENT_GetCameraInfo
typedef struct tagNET_IN_GET_CAMERA_INFO
{
	DWORD						dwSize;				// struct size
	int							nCameraNo;			// Camera number
}NET_IN_GET_CAMERA_INFO;

//  Output parameter of CLIENT_GetCameraInfo
typedef struct tagNET_OUT_GET_CAMERA_INFO
{
	DWORD						dwSize;				// struct size
	int							nCameraNo;			// Camera number
	EM_CAMERA_CONNECT_STATE		emConnectState;		// Camera connect status
	int							nRetLightInfoNum;		// The count of stuLightInfos's size
	NET_LIGHTINFO_CFG			stuLightInfos[16];	// The status of the specified traffic light
}NET_OUT_GET_CAMERA_INFO;

// Set camera config, pInParam and pOutParam are application and released by user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetCameraCfg(LLONG lLoginID, NET_IN_SET_CAMERA_CFG *pInParam, NET_OUT_SET_CAMERA_CFG *pOutParam, int nWaitTime);

// Get camera config, pInParam and pOutParam are application and released by user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetCameraCfg(LLONG lLoginID, NET_IN_GET_CAMERA_CFG *pInParam, NET_OUT_GET_CAMERA_CFG *pOutParam, int nWaitTime);

// Set channel config, pInParam and pOutParam are application and released by user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetChannelCfg(LLONG lLoginID, NET_IN_SET_CHANNEL_CFG *pInParam, NET_OUT_SET_CHANNEL_CFG *pOutParam, int nWaitTime);

// Get channel config, pInParam and pOutParam are application and released by user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetChannelCfg(LLONG lLoginID, NET_IN_GET_CHANNEL_CFG *pInParam, NET_OUT_GET_CHANNEL_CFG *pOutParam, int nWaitTime);

// Set detect mode, pInParam and pOutParam are application and released by user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDetectMode(LLONG lLoginID, NET_IN_SET_DETECT_MODE *pInParam, NET_OUT_SET_DETECT_MODE *pOutParam, int nWaitTime);

// Get detect mode, pInParam and pOutParam are application and released by user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDetectMode(LLONG lLoginID, NET_IN_GET_DETECT_MODE *pInParam, NET_OUT_GET_DETECT_MODE *pOutParam, int nWaitTime);

// Get camera information, pInParam and pOutParam are application and released by user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetCameraInfo(LLONG lLoginID, NET_IN_GET_CAMERA_INFO *pInParam, NET_OUT_GET_CAMERA_INFO *pOutParam, int nWaitTime);

// Input parameter of CLIENT_GetAreaInfo 
typedef struct tagNET_IN_GETAREA_INFO
{
    DWORD					 dwSize;				// struct size
    int                      nChannel;              // Channel
}NET_IN_GETAREA_INFO;


// The type of detected area
typedef enum tagEM_AREA_RULE_TYPE
{
    EM_AREA_RULE_UNKNOWN,                           // Unknown
    EM_AREA_RULE_QUEUE_DETECTION,                   // The area of detect queue
    EM_AREA_RULE_MAN_NUM_DETECTION,                 // The area of detect man number
}EM_AREA_RULE_TYPE;

// The area info
typedef struct tagNET_GETAREA_INFO
{
    unsigned short              nAreaId;                // The area ID
    BYTE                        byReserved1[2];          // reserved used to byte alignment
    EM_AREA_RULE_TYPE           emAreaRuleType;         // The type of detected area
    int                         nPointNum;              // The number of point in detect region
    NET_POINT                   stuDetectRegion[20];    // The detect region in 8192 coordinate system
    char                        szAreaName[64];         // Area name
    BYTE                        byReserved[1024];       // reserved
}NET_GETAREA_INFO;

// Output parameter of CLIENT_GetAreaInfo 
typedef struct tagNET_OUT_GETAREA_INFO
{
    DWORD						dwSize;					// struct size
    int                         nChannle;               // channel
    int                         nAreaCount;             // Area count
    NET_GETAREA_INFO            stuAreaInfo[20];        // Area info
}NET_OUT_GETAREA_INFO;

// Get people count in area
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetAreaInfo(LLONG lLoginID, const NET_IN_GETAREA_INFO* pInParam, NET_OUT_GETAREA_INFO* pOutParam, int nWaitTime);

// Input parameter of CLIENT_GetRealTimeVehiclesInfoByRegion 
typedef struct tagNET_IN_GET_VEHICLES_INFO
{
    DWORD                       dwSize;             // struct size
    UINT                        nChannel;           // Channel
    int                         nPointNum;          // The numb of point, at least 4 points
    NET_POINT                   stuPoint[32];       // The polygon in 8192 coordinate system, which means the range of X-axis and Y-axis is 0 to 8192
}NET_IN_GET_VEHICLES_INFO;

// The real time vehicle info
typedef struct tagNET_VEHICLES_INFO_IN_REGION
{
    UINT                        nVehicleQuantity;   // The num of vehicle
    BYTE                        byReserved[1024];   // Reserved byte
}NET_VEHICLES_INFO_IN_REGION;

// Output parameter of  CLIENT_GetRealTimeVehiclesInfoByRegion 
typedef struct tagNET_OUT_GET_VEHICLES_INFO
{
    DWORD                       dwSize;             // struct size
    NET_VEHICLES_INFO_IN_REGION stuVehiclesInfo;    // The real time info of vehicle
}NET_OUT_GET_VEHICLES_INFO;

// Get the vehicle info in real time that are in exact video region in device channel, pInParam and pOutParam are application and released by user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetRealTimeVehiclesInfoByRegion(LLONG lLoginID, NET_IN_GET_VEHICLES_INFO *pInParam, NET_OUT_GET_VEHICLES_INFO *pOutParam, int nWaitTime);

// people info in the region
typedef struct tagNET_REGION_PEOPLE_STAT_INFO
{
	UINT					nRegionID;				// region ID
	char					szRegionName[128];		// region name
	UINT					nRegionPointNum;		// points count of the region
	NET_POINT				stuRegionPoint[20];		// points of region
	UINT					nPeopleNum;				// people number in the region
	BYTE                    byReserved[1024];       // reserved
} NET_REGION_PEOPLE_STAT_INFO;

// into of detection area
typedef struct tagNET_CROWD_STAT_DATA
{
	UINT							nChannelID;				// channel ID
	UINT							nGloabalPeopleNum;		// total people number in detection area
	UINT							nRegionNum;				// count of regions in detection area
	NET_REGION_PEOPLE_STAT_INFO		stuRegionPeople[8];		// info of regions in detection area
	BYTE                    		byReserved[1024];		// reserved
} NET_CROWD_STAT_DATA;

//  call back info of attach crowd distri map
typedef struct tagNET_CB_CROWD_DISTRI_STREAM_INFO
{
	UINT					nCrowStatNum;				// count of  detection area
	NET_CROWD_STAT_DATA		stuCrowdStatData[8];			// into of detection area
	BYTE                    byReserved[2048];			// reserved
} NET_CB_CROWD_DISTRI_STREAM_INFO;

// callback function of attach crowd distri map, lAttachHandle is returned by interface CLIENT_AttachCrowdDistriMap
typedef void (CALLBACK *fCrowdDistriStream)(LLONG lAttachHandle, NET_CB_CROWD_DISTRI_STREAM_INFO* pstResult, LDWORD dwUser);

// Input param of interface CLIENT_AttachCrowdDistriMap
typedef struct tagNET_IN_ATTACH_CROWDDISTRI_MAP_INFO
{
	DWORD                           dwSize;                                 // struct size
	UINT							nChannelID;								// channel ID
	fCrowdDistriStream				cbCrowdDistriStream;					// callback function of attach crowd distri map
	LDWORD                  		dwUser;                     			// user data
} NET_IN_ATTACH_CROWDDISTRI_MAP_INFO;

// Output param of interface CLIENT_AttachCrowdDistriMap
typedef struct tagNET_OUT_ATTACH_CROWDDISTRI_MAP_INFO
{
	DWORD                           dwSize;                                 // struct size
} NET_OUT_ATTACH_CROWDDISTRI_MAP_INFO;

/**************************************************************************************
*   Funcname: CLIENT_AttachCrowdDistriMap
*   Purpose: Attach crowd distri map info
*   InputParam:	LLONG							:lLoginID			// login handle
*   InputParam:	NET_IN_ATTACH_CROWDDISTRI_MAP_INFO*	:pstInParam		// input param, is is application by user
*   OutPutParam:	NET_OUT_ATTACH_CROWDDISTRI_MAP_INFO*	:pstOutParam 		// output param, is is application by user
*   InputParam:	int								:nWaitTime		// wait time
*   Return:		LLONG
*   Created:		%2019%:%06%:%11% by 27774  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachCrowdDistriMap(LLONG lLoginID, NET_IN_ATTACH_CROWDDISTRI_MAP_INFO *pstInParam, NET_OUT_ATTACH_CROWDDISTRI_MAP_INFO *pstOutParam, int nWaitTime);

/**************************************************************************************
*   Funcname: CLIENT_DetachCrowdDistriMap
*   Purpose: Detach crowd distri map info
*   InputParam:	LLONG					:lAttachHandle			// attach handleit is returned by CLIENT_AttachCrowdDistriMap
*   Return:		LLONG
*   Created:		%2019%:%06%:%11% by 27774  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachCrowdDistriMap(LLONG lAttachHandle);



// Ping info
typedef struct tagNET_PING_INFO
{
    char                        szAddress[128];      // The ip or domain name 
    BYTE                        byReserved[512];     // Reserved        
}NET_PING_INFO;


// Input param of interface CLIENT_GetPingStatus
typedef struct tagNET_IN_GET_PING_STATUS_INFO
{
    DWORD                       dwSize;             // struct size
    NET_PING_INFO               stuPingInfo;        // Ping info
}NET_IN_GET_PING_STATUS_INFO;

// ping status info
typedef struct tagNET_PING_STATUS_INFO
{
    float                       fAveDelay;           // Average network delay ,nint second
    float                       fLossRate;           // The rate of lost packet, range is 0 to 1
    BYTE                        byReserved[512];     // Reserved        
}NET_PING_STATUS_INFO;

// CLIENT_GetPingStatus 
typedef struct tagNET_OUT_GET_PING_STATUS_INFO
{
    DWORD                       dwSize;             // struct size
    NET_PING_STATUS_INFO        stuPingStatus;      // ping status info
}NET_OUT_GET_PING_STATUS_INFO;

// Get the ping status of the specified IP
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetPingStatus(LLONG lLoginID, NET_IN_GET_PING_STATUS_INFO *pInParam, NET_OUT_GET_PING_STATUS_INFO *pOutParam, int nWaitTime);

// input param of interface CLIENT_GetDevRemoteChannelAlarmState
typedef struct tagNET_IN_GET_REMOTE_CHANNEL_ALARM_STATE
{
	DWORD           dwSize;                 // struct size
	UINT			nChannelNum;			// count of alarm channel
	UINT			nChannel[128];			// info of alarm channel
} NET_IN_GET_REMOTE_CHANNEL_ALARM_STATE;

// state of alarm channel
typedef struct tagNET_ALARM_CHANNEL_STATE
{
	int				nChannel;				// channel ID
	DWORD			dwAlatmInState;			// state alarm input channel on remote devicebit by biteach of the bits means the state of the alarm input channel
	BYTE            byReserved[256];			// reserved
} NET_ALARM_CHANNEL_STATE;

// output param ot the interface CLIENT_GetDevRemoteChannelAlarmState
typedef struct tagNET_OUT_GET_REMOTE_CHANNEL_ALARM_STATE
{
	DWORD           			dwSize;                 	// struct size
	UINT						nAlarmChannelNum;			// count of alarm channel
	NET_ALARM_CHANNEL_STATE		stuAlarmChannelState[128];	// state of alarm channel
} NET_OUT_GET_REMOTE_CHANNEL_ALARM_STATE;

// get the alarm channel state on the remote device
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDevRemoteChannelAlarmState(LLONG lLoginID, NET_IN_GET_REMOTE_CHANNEL_ALARM_STATE *pstInParam, NET_OUT_GET_REMOTE_CHANNEL_ALARM_STATE *pstOutParam, int nWaitTime);

// progress type of access control
typedef enum tagEM_ACCESSCONTROL_PROGRESS_TYPE
{
	EM_ACCESSCONTROL_PROGRESS_IMPORT,			// import progress
	EM_ACCESSCONTROL_PROGRESS_DEPLOY,			// deploy progress
} EM_ACCESSCONTROL_PROGRESS_TYPE;

// state of access control fast import
typedef enum tagEM_ACCESSCONTROL_IMPORT_STATE
{
	EM_ACCESSCONTROL_IMPORT_UNKNOWN,		// unknown
	EM_ACCESSCONTROL_IMPORT_ONGING,			// importing
	EM_ACCESSCONTROL_IMPORT_END,			// import end, begin to create DB
	EM_ACCESSCONTROL_IMPORT_BUSY,			// system is busy
	EM_ACCESSCONTROL_IMPORT_DATAERROR,		// packet data check failed
	EM_ACCESSCONTROL_IMPORT_INVALID,		// illegal packet data
	EM_ACCESSCONTROL_IMPORT_SYNC_SUCCESS,	// sync success
	EM_ACCESSCONTROL_IMPORT_SYNC_FALIED,	// sunc failed
	EM_ACCESSCONTROL_IMPORT_DBFULL,			// data db is full
	EM_ACCESSCONTROL_IMPORT_SDFULL,			// sd is full
	EM_ACCESSCONTROL_IMPORT_CIPHER_ERROR,	// password error
	EM_ACCESSCONTROL_IMPORT_SEND_FAIL,		// fail to send access control data
} EM_ACCESSCONTROL_IMPORT_STATE;

// state of import access control
typedef struct tagNET_IMPORT_ACCESSCONTROL_STATE
{
	unsigned int	        			nProgress;			// progress
	EM_ACCESSCONTROL_PROGRESS_TYPE		emProcessType;		// progress type
	EM_ACCESSCONTROL_IMPORT_STATE		emState;			// import state
	BYTE			        			byReserved[512];		// reserved
} NET_IMPORT_ACCESSCONTROL_STATE;

// call back function of access control fast import
typedef void (CALLBACK *fImportAccessControlDataCallBack) (LLONG lImportHandle, NET_IMPORT_ACCESSCONTROL_STATE *pstAccessControlState, LDWORD dwUser);

// input param of interface CLIENT_ImportAccessControlData
typedef struct tagNET_IN_IMPORT_ACCESS_CONTROL_DATA
{
	DWORD								dwSize;								// struct size
	DWORD								dwDataType;							// mask of data type, 0x01:talk book; 0x02:custom password; 0x04:card info;
																			// 0x08:face info; 0x10:fingerprint info; 0x20:remote device info; 0x40:person info
	char								szPassWord[DH_COMMON_STRING_64];	// password
	char								szFilePath[MAX_FILE_PATH_LEN];		// access control file path
	UINT								nBeforeLen;							// the size of file before compress
	BYTE			        			byReserved[4];						// alignment
	fImportAccessControlDataCallBack	cbImportState;						// call back function of access control fast import
	LDWORD 								dwUser;								// user data
} NET_IN_IMPORT_ACCESS_CONTROL_DATA;

// output param of interface CLIENT_ImportAccessControlData
typedef struct tagNET_OUT_IMPORT_ACCESS_CONTROL_DATA
{
	DWORD								dwSize;								// struct size
} NET_OUT_IMPORT_ACCESS_CONTROL_DATA;

// accsee control data fast import
CLIENT_NET_API LLONG CALL_METHOD CLIENT_ImportAccessControlData(LLONG lLoginID, NET_IN_IMPORT_ACCESS_CONTROL_DATA* pstInParam, 
																NET_OUT_IMPORT_ACCESS_CONTROL_DATA* pstOutParam, const int nWaitTime);

// stop to import access control control data
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopImportAccessControlData(LLONG lImportHandle);

// errcode of access control fast check
typedef enum tagEM_EXPORT_FAST_CHECK_ERRORCODE
{
	EM_EXPORT_FAST_CHECK_SUCCESS			= 1,		// request of fast check is success
	EM_EXPORT_FAST_CHECK_NO_AUTHORITY		= 2,		// no authority
	EM_EXPORT_FAST_CHECK_NO_THIS_FILE		= 3,		// file does not exist
	EM_EXPORT_FAST_CHECK_EXPORT_END			= 4,		// finish to export
	EM_EXPORT_FAST_CHECK_EXPORTING			= 5,		// exporting
	EM_EXPORT_FAST_CHECK_FILE_READY			= 8,		// the file is ready
	EM_EXPORT_FAST_CHECK_FILE_FAILED		= 9,		// fail to prepare file
	EM_EXPORT_FAST_CHECK_WAIT_FILE			= 10,	// request of fast check is success, and need to wait the file
	EM_EXPORT_FAST_CHECK_SYSTEM_BUSY		= 11,	// system is busy
	EM_EXPORT_FAST_CHECK_NO_PASSWORD		= 12,	// no password
} EM_EXPORT_FAST_CHECK_ERRORCODE;

// state of access control fast check
typedef struct tagNET_EXPORT_FAST_CHECK_STATE
{
	unsigned int					nProgress;			// progress
	EM_EXPORT_FAST_CHECK_ERRORCODE	emErrorCode;		// error code
	char							*pDataBuf;			// fast check data
	DWORD							dwDataLen;			// data length
	BYTE							byReserved[516];		// reserved
} NET_EXPORT_FAST_CHECK_STATE;

// call back function of access control fast check
typedef void (CALLBACK *fExportFastCheckCallBack)(LLONG lExportHandle, NET_EXPORT_FAST_CHECK_STATE *pstFastCheckState, LDWORD dwUser);

// input param of interface CLIENT_ExportAccessControlFastCheckData
typedef struct tagNET_IN_EXPORT_ACCESSCONTROL_FASTCHECK_DATA
{
	DWORD							dwSize;								// struct size
	DWORD							dwDataType;							// mask of data type, 0x01:talk book; 0x02:custom password; 0x04:card info;
																		// 0x08:face info; 0x10:fingerprint info; 0x20:remote device info; 0x40:person info
	char							szPassWord[DH_COMMON_STRING_64];	// password
	fExportFastCheckCallBack		cbExportFastCheckCallBack;			// call back function of access control fast check
	LDWORD 							dwUser;								// user data
} NET_IN_EXPORT_ACCESSCONTROL_FASTCHECK_DATA;

// output param of interface CLIENT_ExportAccessControlFastCheckData
typedef struct tagNET_OUT_EXPORT_ACCESSCONTROL_FASTCHECK_DATA
{
	DWORD							dwSize;							// struct size
} NET_OUT_EXPORT_ACCESSCONTROL_FASTCHECK_DATA;

// access control fast check
CLIENT_NET_API LLONG CALL_METHOD CLIENT_ExportAccessControlFastCheckData(LLONG lLoginID, NET_IN_EXPORT_ACCESSCONTROL_FASTCHECK_DATA* pstInParam, 
																NET_OUT_EXPORT_ACCESSCONTROL_FASTCHECK_DATA* pstOutParam, const int nWaitTime);

// stop access control fast check
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopExportAccessControlFastCheckData(LLONG lExportHandle);

// input param of CLIENT_GetUSBInfo
typedef struct tagNET_IN_GET_USB_INFO
{
	DWORD		dwSize;						// struct size
}NET_IN_GET_USB_INFO;

// USB transmit protocol type
typedef enum tagEM_USB_PROTOCOL_TYPE
{
	EM_USB_PROTOCOL_TYPE_UNKNOWN,			// unknown
	EM_USB_PROTOCOL_TYPE_V2,				// USB 2.0
	EM_USB_PROTOCOL_TYPE_V3,				// USB 3.0
}EM_USB_PROTOCOL_TYPE;

// out param of CLIENT_GetUSBInfo
typedef struct tagNET_OUT_GET_USB_INFO
{
	DWORD					dwSize;			// struct size
	EM_USB_PROTOCOL_TYPE	emType;			// USB transmit protocol type
}NET_OUT_GET_USB_INFO;

// get USB info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetUSBInfo(LLONG lLoginID, NET_IN_GET_USB_INFO* pstuIn, NET_OUT_GET_USB_INFO* pstuOut, int nWaitTime);


// query type of recharge business
typedef enum tagEM_RECHARGE_BUSINESS_QUERY_TYPE
{
	EM_RECHARGE_BUSINESS_QUERY_TYPE_UNKNOWN = 0,			// unknown
	EM_RECHARGE_BUSINESS_QUERY_TYPE_CARD,					// card
	EM_RECHARGE_BUSINESS_QUERY_TYPE_HUMANFACE,				// face
}EM_RECHARGE_BUSINESS_QUERY_TYPE;


// operate type of recharge business
typedef enum tagEM_RECHARGE_BUSINESS_OPERATE_TYPE
{
	EM_RECHARGE_BUSINESS_OPERATE_TYPE_UNKNOWN = 0,			// unknown
	EM_RECHARGE_BUSINESS_OPERATE_TYPE_QUERY,				// query
	EM_RECHARGE_BUSINESS_OPERATE_TYPE_RECHARGE,				// recharge
}EM_RECHARGE_BUSINESS_OPERATE_TYPE;

// account query event info of recharge business
typedef struct tagNET_RECHARGE_BUSINESS_QUERY_EVENT_INFO
{
	EM_RECHARGE_BUSINESS_QUERY_TYPE		emQueryType;		// query type
	char								szCardNo[32];		// card no
	char								szUserID[32];		// user id
	NET_TIME_EX							stuTime;			// local time of device
	char*								pszFaceData;		// face data: invalid when emType is EM_RECHARGE_BUSINESS_TYPE_CARD
	int									nFaceDataLen;		// face data len
}NET_RECHARGE_BUSINESS_QUERY_EVENT_INFO;

// account recharge event info of recharge business
typedef struct tagNET_RECHARGE_BUSINESS_RECHARGE_EVENT_INFO
{
	EM_RECHARGE_BUSINESS_QUERY_TYPE		emQueryType;		// query type
	char								szCardNo[32];		// card no
	char								szUserID[32];		// user id
	NET_TIME_EX							stuTime;			// local time of device
	char*								pszFaceData;		// face data: invalid when emType is EM_RECHARGE_BUSINESS_TYPE_CARD
	int									nFaceDataLen;		// face data len
	int									nAmount;			// recharge amount,range is [100, 9999900], unit: cent,must be 100 multiples
}NET_RECHARGE_BUSINESS_RECHARGE_EVENT_INFO;

// recharge business info
typedef struct tagNET_RECHARGE_BUSINESS_INFO
{
	EM_RECHARGE_BUSINESS_OPERATE_TYPE	emOperateType;		// operate type
	BYTE								byReserved[4];		// byte alignment
	char								szBusinessID[32];	// business id
	void*								pstuEventInfo;		// event info
															// NET_RECHARGE_BUSINESS_QUERY_EVENT_INFO when emOperateType is EM_RECHARGE_BUSINESS_OPERATE_TYPE_QUERY
															// NET_RECHARGE_BUSINESS_RECHARGE_EVENT_INFO when emOperateType is EM_RECHARGE_BUSINESS_OPERATE_TYPE_RECHARGE
}NET_RECHARGE_BUSINESS_INFO;

// callback function of CLIENT_AttachRechargeBusiness
typedef void (CALLBACK *fRechargeBusiness)(LLONG lAttachHandle, NET_RECHARGE_BUSINESS_INFO* pInfo, LDWORD dwUser);

// input param of CLIENT_AttachRechargeBusiness
typedef struct tagNET_IN_ATTACH_RECHARGE_BUSINESS
{
	DWORD								dwSize;				// struct size
	BYTE								szReserved[4];		// reserved
	fRechargeBusiness					cbNotify;			// callback
	LDWORD								dwUser;				// user info
}NET_IN_ATTACH_RECHARGE_BUSINESS;


// output param of CLIENT_AttachRechargeBusiness
typedef struct tagNET_OUT_ATTACH_RECHARGE_BUSINESS
{
	DWORD								dwSize;				// struct size
}NET_OUT_ATTACH_RECHARGE_BUSINESS;

// attach recharge business
CLIENT_NET_API	LLONG CALL_METHOD CLIENT_AttachRechargeBusiness(LLONG lLoginID, NET_IN_ATTACH_RECHARGE_BUSINESS* pInParam, NET_OUT_ATTACH_RECHARGE_BUSINESS* pOutParam, int nWaitTime);

// detach recharge business
// lAttachHandle is the value returned by CLIENT_AttachRechargeBusiness
CLIENT_NET_API	BOOL CALL_METHOD CLIENT_DetachRechargeBusiness(LLONG lAttachHandle);

// error code of recharge business
typedef enum tagEM_RECHARGE_BUSINESS_ERROR_CODE
{
	EM_RECHARGE_BUSINESS_ERRORCODE_UNKNOWN = -1,				// unknown
	EM_RECHARGE_BUSINESS_ERRORCODE_NONE,						// no error
	EM_RECHARGE_BUSINESS_ERRORCODE_UNAUTHORIZED_CARD = 11,		// unauthrized card
	EM_RECHARGE_BUSINESS_ERRORCODE_INVALID_CARD = 14,			// invalid card
	EM_RECHARGE_BUSINESS_ERRORCODE_EXCEED_MAX_AMOUNT = 48,		// exceed max amount
	EM_RECHARGE_BUSINESS_ERRORCODE_INVALID_TERMINAL = 89,		// invalid terminal
	EM_RECHARGE_BUSINESS_ERRORCODE_SYSTEM_EXCEPTION = 96,		// system exception
	EM_RECHARGE_BUSINESS_ERRORCODE_EXCEED_DAY_RECHARGE_NUM = 107,				// exceed max recharge num in one day
	EM_RECHARGE_BUSINESS_ERRORCODE_EXCEED_SINGLE_MAX_RECHARGE_AMOUNT = 108,		// exceed max recharge amount at a time
}EM_RECHARGE_BUSINESS_ERROR_CODE;

// input param of CLIENT_SetRechargeBusinessQueryResult
typedef struct tagNET_IN_RECHARGE_BUSINESS_QUERY_RESULT
{
	DWORD								dwSize;						// struct size
	char								szCardNo[32];				// card no
	char								szUserID[32];				// user id
	char								szBusinessID[32];			// business id, returned by calback function of CLIENT_AttachRechargeBusiness
	UINT								nBalance;					// balance, unit: cent
	EM_RECHARGE_BUSINESS_ERROR_CODE		emErrorCode;				// error code
}NET_IN_RECHARGE_BUSINESS_QUERY_RESULT;

// output param of CLIENT_SetRechargeBusinessQueryResult
typedef struct tagNET_OUT_RECHARGE_BUSINESS_QUERY_RESULT 
{
	DWORD								dwSize;						// struct size
}NET_OUT_RECHARGE_BUSINESS_QUERY_RESULT;

// set query result of recharge business
CLIENT_NET_API	BOOL CALL_METHOD CLIENT_SetRechargeBusinessQueryResult(LLONG lLoginID, NET_IN_RECHARGE_BUSINESS_QUERY_RESULT* pInParam, NET_OUT_RECHARGE_BUSINESS_QUERY_RESULT* pOutParam, int nWaitTime);

// input param of CLIENT_SetRechargeBusinessRechargeResult
typedef struct tagNET_IN_RECHARGE_BUSINESS_RECHARGE_RESULT 
{
	DWORD								dwSize;						// struct size
	char								szCardNo[32];				// card no
	char								szUserID[32];				// user id
	char								szBusinessID[32];			// business id, returned by calback function of CLIENT_AttachRechargeBusiness
	UINT								nBalance;					// balance, unit: cent
	EM_RECHARGE_BUSINESS_ERROR_CODE		emErrorCode;				// error code
}NET_IN_RECHARGE_BUSINESS_RECHARGE_RESULT;

// output param of CLIENT_SetRechargeBusinessRechargeResult
typedef struct tagNET_OUT_RECHARGE_BUSINESS_RECHARGE_RESULT 
{
	DWORD								dwSize;						// struct size
}NET_OUT_RECHARGE_BUSINESS_RECHARGE_RESULT;

// set recharge result of recharge business
CLIENT_NET_API	BOOL CALL_METHOD CLIENT_SetRechargeBusinessRechargeResult(LLONG lLoginID, NET_IN_RECHARGE_BUSINESS_RECHARGE_RESULT* pInParam, NET_OUT_RECHARGE_BUSINESS_RECHARGE_RESULT* pOutParam, int nWaitTime);



// input param of CLIENT_SetPersonInfoInputResult
typedef struct tagNET_IN_PERSON_INFO_INPUT_RESULT
{
	DWORD								dwSize;						// struct size
	int									nChannelID;					// channel ID
	UINT								nResult;					// 0:success  1: citizen information is not in the database
	BYTE								byReserved[4];				// byte alignment
	char								szCitizenID[64];			// citizen id
}NET_IN_PERSON_INFO_INPUT_RESULT;


// input param of  CLIENT_SetPersonInfoInputResult
typedef struct tagNET_OUT_PERSON_INFO_INPUT_RESULT
{
	DWORD								dwSize;						// struct size
}NET_OUT_PERSON_INFO_INPUT_RESULT;


// set person input result to device
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetPersonInfoInputResult(LLONG lLoginID, NET_IN_PERSON_INFO_INPUT_RESULT* pInParam, NET_OUT_PERSON_INFO_INPUT_RESULT* pOutParam, int nWaitTime);

// input param of CLIENT_PlayBackBySecondaryAnalyse
typedef struct tagNET_IN_PLAYBACK_BY_SECONDARYANALYSE
{
	DWORD								dwSize;					// struct size
	int									nChannelID;				// channel id
	NET_TIME							stBeginTime;			// begin time
	NET_TIME							stEndTime;				// end time
	HWND								hWnd;					// play window
	fDownLoadPosCallBack				cbDownLoadPos;			// download pos callback 
	LDWORD								dwPosUser;				// user data of cbDownLoadPos
	fDataCallBack						fDownLoadDataCallBack;	// download data callback
	LDWORD								dwDataUser;				// user data of fDownLoadDataCallBack
	int									nPlayDirection;			// play direction, 0:forward; 1:backward;	
	int									nTaskID;				// task id
}NET_IN_PLAYBACK_BY_SECONDARYANALYSE;


// output param of CLIENT_PlayBackBySecondaryAnalyse
typedef struct tagNET_OUT_PLAYBACK_BY_SECONDARYANALYSE
{
	DWORD								dwSize;					// struct size
}NET_OUT_PLAYBACK_BY_SECONDARYANALYSE;


// play back by secondary ananlyse
CLIENT_NET_API LLONG CALL_METHOD CLIENT_PlayBackBySecondaryAnalyse(LLONG lLoginID, NET_IN_PLAYBACK_BY_SECONDARYANALYSE* pInParam, NET_OUT_PLAYBACK_BY_SECONDARYANALYSE* pOutParam,int nWaitTime);

// Input param of CLIENT_GetDevWifiListInfo
typedef struct tagNET_IN_GET_DEV_WIFI_LIST
{
    DWORD                   dwSize;             // Struct size
    UINT                    nPort;              // Dev port 
    char                    szDevIP[64];        // Dev IP
} NET_IN_GET_DEV_WIFI_LIST;


// Output param of CLIENT_GetDevWifiListInfo
typedef struct tagNET_OUT_GET_DEV_WIFI_LIST
{
    DWORD                   dwSize;                             // Struct size
    UINT                    nWlanDevCount;                      // Count of wlan
    DHDEV_WLAN_DEVICE_EX    stuWlanDev[MAX_WLAN_DEVICE_NUM];    // Wlan info
} NET_OUT_GET_DEV_WIFI_LIST;


// Input param of CLIENT_SetDevWifiInfo
typedef struct tagNET_IN_SET_DEV_WIFI
{
    DWORD               dwSize;                     // Struct size
    UINT                nPort;                      // Dev port
    char                szDevIP[64];                // Dev IP
    int                 nEnable;                    // Is enable, 0: yes, 1: not
    char                szSSID[36];                 // SSID
    int                 nLinkMode;                  // Link mode:0auto,1adhoc,2Infrastructure
    int                 nEncryption;                // Encryption0off,2WEP64bit,3WEP128bit, 4:WPA-PSK-TKIP, 5: WPA-PSK-CCMP(AES), 6:WPA2-PSK-TKIP 7:WPA2-PSK-AES 8:WPA-TKIP 9:WPA-AES 
                                                    // 10:WPA2-TKIP 11:WPA2-AES 12:AUTO 13:WEP-OPEN 14:WEP-SHARED  
    int                 nKeyType;                   // 0Hex,1ASCII
    int                 nKeyID;                     // Key ID
    char                szKeys[4][32];              // Keys, it is effect when nEncryption is not about WPA
    char                szWPAKeys[128];             // WPA key, it is effect when nEncryption is about WPA; The length is 128, and it is not need '\0'
    int                 nKeyFlag;                  // Key flag
    int                 nConnectedFlag;            // Connect flag 0: no connect, 1: connect
} NET_IN_SET_DEV_WIFI;

//Output param of  CLIENT_SetDevWifiInfo
typedef struct tagNET_OUT_SET_DEV_WIFI
{
    DWORD               dwSize;                     // Struct size
} NET_OUT_SET_DEV_WIFI;

// Get the wifi list on the device, it is not need to login
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDevWifiListInfo(NET_IN_GET_DEV_WIFI_LIST *pInParam, NET_OUT_GET_DEV_WIFI_LIST *pOutParam, const int nWaitTime);

//  Set wifi info to deviceit is not need to login
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDevWifiInfo(NET_IN_SET_DEV_WIFI *pInParam, NET_OUT_SET_DEV_WIFI *pOutParam, const int nWaitTime);


// Snap object infomation
typedef struct tagNET_SNAP_OBJECT_INFO
{
    NET_RECT             stuBoundingBox;                    // Bounding box, coordinate system is [0, 8192]
    BYTE                 byReserved[512];                   // Reserved   
} NET_SNAP_OBJECT_INFO;

// Input param of CLIENT_SnapPictureByAnalyseObject
typedef struct tagNET_IN_SNAP_BY_ANALYSE_OBJECT
{
    DWORD                               dwSize;             // Struct size
    UINT                                nChannelID;         // Channel ID
    BYTE                                byReserved[4];      // Byte align
    UINT                                nSnapObjectNum;     // Count of snap objects
    NET_SNAP_OBJECT_INFO                stuSnapObjects[32]; // Snap object info
} NET_IN_SNAP_BY_ANALYSE_OBJECT;

// Output param of CLIENT_SnapPictureByAnalyseObject
typedef struct tagNET_OUT_SNAP_BY_ANALYSE_OBJECT
{
    DWORD                               dwSize;             // Struct size 
} NET_OUT_SNAP_BY_ANALYSE_OBJECT;

// Snap picture by object
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SnapPictureByAnalyseObject(LLONG lLoginID, NET_IN_SNAP_BY_ANALYSE_OBJECT* pInParam, NET_OUT_SNAP_BY_ANALYSE_OBJECT* pOutParam,int nWaitTime);


// State information of intelligent algorithms
typedef struct tagNET_INTELLI_STATE_INFO
{
    BOOL                            bSupportOnlyAlgorithmUpgrade;                   // Whether to support independent algorithm upgrade
    UINT                            nAlgorithmNum;                                  // Number of algorithm 
    NET_ALGORITHM_INFO              stuAlgorithmInfos[MAX_ANALYSE_ALGORITHM_NUM];   // Version of algorithm 
    BYTE							byReserve[1024];								// Reserved
}NET_INTELLI_STATE_INFO;


// State information callback function of intelligent algorithm
typedef void (CALLBACK *fIntelliState)(LLONG lAttachHandle, NET_INTELLI_STATE_INFO* pInfo, LDWORD dwUser);

// Param of CLIENT_AttachIntelliState 
typedef struct tagNET_IN_ATTACH_INTELLI_STATE
{
    DWORD								dwSize;				// Struct size
    BYTE								szReserved[4];		// Reserved
    fIntelliState					    cbNotify;			// Callback function
    LDWORD								dwUser;				// User Info
}NET_IN_ATTACH_INTELLI_STATE;


// CLIENT_AttachIntelliState 
typedef struct tagNET_OUT_ATTACH_INTELLI_STATE
{
    DWORD								dwSize;				// Struct size
}NET_OUT_ATTACH_INTELLI_STATE;

// Attach the status information of the intelligent algorithm
CLIENT_NET_API	LLONG CALL_METHOD CLIENT_AttachIntelliState(LLONG lLoginID, NET_IN_ATTACH_INTELLI_STATE* pInParam, NET_OUT_ATTACH_INTELLI_STATE* pOutParam, int nWaitTime);

// Detach the status information of the intelligent algorithm
// lAttachHandle is the return value of CLIENT_AttachIntelliState 
CLIENT_NET_API	BOOL CALL_METHOD CLIENT_DetachIntelliState(LLONG lAttachHandle);

// input param of CLIENT_GetGDPRAbility
typedef struct tagNET_IN_GET_GDPR_ABILITY
{
	DWORD						dwSize;			// struct size
}NET_IN_GET_GDPR_ABILITY;

// GDPR ability
enum EM_GDPR_ABILITY
{
	EM_GDPR_ABILITY_V1_STREAM = 0x01,			// support GDPR1.0 realplay and playback
	EM_GDPR_ABILITY_V2_STREAM = 0x02,			// support GDPR2.0 realplay and playback
	EM_GDPR_ABILITY_DOWNLOAD  = 0x04,			// support GDPR download
};

// output param of CLIENT_GetGDPRAbility
typedef struct tagNET_OUT_GET_GDPR_ABILITY
{
	DWORD						dwSize;			// struct size
	int							nAbility;		// ability, respond to EM_GDPR_ABILITY, support '|' operator
}NET_OUT_GET_GDPR_ABILITY;


// get GDPR ability
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetGDPRAbility(LLONG lLoginID, NET_IN_GET_GDPR_ABILITY* pInParam, NET_OUT_GET_GDPR_ABILITY* pOutParam, int nWaitTime);

// set GDPR enable
CLIENT_NET_API void	CALL_METHOD CLIENT_SetGDPREnable(BOOL bEnable);

// Error code of downloading remote facelib
typedef enum tagEM_FACEDB_ERRCODE
{
    EM_FACEDB_ERRCODE_UNKNOWN  = -1,       // Unknown
    EM_FACEDB_ERRCODE_SUCCESS,             // Success
    EM_FACEDB_ERRCODE_CONNECT_FAIL = 2,    // Connect fail
    EM_FACEDB_ERRCODE_LOGIN_FAIL,          // Login fail
    EM_FACEDB_ERRCODE_RECV_TIMEOUT,        // Receive timeout
    EM_FACEDB_ERRCODE_STRING_NULL,         // The target string is empty
    EM_FACEDB_ERRCODE_FILE_DIRECTORY_NOT_EXIST,    // No directory or file exists
    EM_FACEDB_ERRCODE_STORAGE_FAIL,        // Storage fail
} EM_FACEDB_ERRCODE;

// Callback info of downloading remote face data base
typedef struct tagNET_CB_FACEDB_DOWNLOAD_RESULT
{
    char                szFaceDbVersion[32];                    // Face data base version
    UINT                nTotalDownloadCount;                    // Total download count
    UINT                nSuccessDownloadCount;                  // Success download count
    EM_FACEDB_ERRCODE   emFaceDbErrCode;                        // Error code of downloading remote face data base
    BYTE                byReserved[1024];                       // Reserved 
} NET_CB_FACEDB_DOWNLOAD_RESULT;

// Callback function of downloading remote face data base, lAttachHandle is returned by CLIENT_AttachFaceDbDownLoadResult
typedef void (CALLBACK *fFaceDbDownLoadResult)(LLONG lAttachHandle, NET_CB_FACEDB_DOWNLOAD_RESULT* pstResult, LDWORD dwUser);

// Input param of CLIENT_AttachFaceDbDownLoadResult
typedef struct tagNET_IN_ATTACH_FACEDB_DOWNLOAD_RESULT
{
    DWORD                           dwSize;                         // Struct size
    BYTE                            byReserved[4];                  // Alignment
    fFaceDbDownLoadResult           cbFaceDbDownLoadResult;         // Callback function of downloading remote face data base
    LDWORD                          dwUser;                         // User data
} NET_IN_ATTACH_FACEDB_DOWNLOAD_RESULT;

// Output param of CLIENT_AttachFaceDbDownLoadResult
typedef struct tagNET_OUT_ATTACH_FACEDB_DOWNLOAD_RESULT
{
    DWORD                           dwSize;                 // struct size
} NET_OUT_ATTACH_FACEDB_DOWNLOAD_RESULT;

// Attach the result of downloading face data base
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachFaceDbDownLoadResult(LLONG lLoginID, NET_IN_ATTACH_FACEDB_DOWNLOAD_RESULT* pInParam, NET_OUT_ATTACH_FACEDB_DOWNLOAD_RESULT* pOutParam, int nWaitTime);

// Detach the result of downloading face data base, lAttachHandle is returned by CLIENT_AttachFaceDbDownLoadResult
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachFaceDbDownLoadResult(LLONG lAttachHandle);

// Task info of downloading face data base
typedef struct tagNET_FACEDB_DOWNLOAD_TASK_INFO
{
    UINT                nURLNum;                            // Count of image URL
    char                szURLList[4][256];                  // Image URL list, A face image may be stored on multiple FTP servers.
    char                szID[32];                           // ID
    char                szFaceUUID[32];                     // Face unique code, each time the platform updates the face image, it needs to update the field for device-side comparison whether to re-download the face image or not
    BYTE                byReserved[2048];                   // Reserved
} NET_FACEDB_DOWNLOAD_TASK_INFO;

// Input param of CLIENT_AddFaceDbDownLoadTask
typedef struct tagNET_IN_ADD_FACEDB_DOWNLOAD_TASK
{
    DWORD                               dwSize;                 // Struct size
    BOOL                                bIsEnd;                 // Is last packet(not used)
    char                                szFaceDbVersion[32];    // Face data base version
    BYTE                                byReserved[4];          // Alignment
    UINT                                nTaskNum;               // The number of download tasks of face data base, specified by users, can support up to 100 tasks
    NET_FACEDB_DOWNLOAD_TASK_INFO       *pstTaskInfo;           // Task info of download face data base, IT is specified by users, and the size is nTaskNum*sizeof(NET_FACELIB_DOWNLOAD_TASK_INFO)
    UINT                                nPacketTotal;           // Total number of packet 
    UINT                                nPacketIndex;           // Index of packet
} NET_IN_ADD_FACEDB_DOWNLOAD_TASK;

// Output param of CLIENT_AddFaceDbDownLoadTask
typedef struct tagNET_OUT_ADD_FACEDB_DOWNLOAD_TASK
{
    DWORD                           dwSize;                 // Struct size
} NET_OUT_ADD_FACEDB_DOWNLOAD_TASK;

// Add task of download face data base
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddFaceDbDownLoadTask(LLONG lLoginID, NET_IN_ADD_FACEDB_DOWNLOAD_TASK* pInParam, NET_OUT_ADD_FACEDB_DOWNLOAD_TASK* pOutParam, int nWaitTime);

// Callback info of downloading plate number library
typedef struct tagNET_CB_PLATENUMBERDB_DOWNLOAD_RESULT
{
    char                               szPlateNumberDbVersion[32];                     // palte number database version
    UINT                               nTotalDownloadCount;                            // total download count
    UINT                               nSuccessDownloadCount;                          // success download count
    EM_FACEDB_ERRCODE                  emPlateNumberDbErrorCode;                       // plate number database error code
    BYTE                               byReserved[1020];                               // reserved
} NET_CB_PLATENUMBERDB_DOWNLOAD_RESULT;

// Callback function of downloading plate number database, lAttachHandle is returned by CLIENT_AttachPlateNumberDbDownloadResult
typedef void (CALLBACK *fPlateNumberDbDownloadResult)(LLONG lAttachHandle, NET_CB_PLATENUMBERDB_DOWNLOAD_RESULT* pstResult, LDWORD dwUser);

// Input param of CLIENT_AttachPlateNumberDbDownloadResult
typedef struct tagNET_IN_ATTACH_PLATENUMBERDB_DOWNLOAD_RESULT
{  
    DWORD                              dwSize;                                         // Struct size
    BYTE                               byReserved[4];                                  // byte alignment
    fPlateNumberDbDownloadResult       cbPlateNumberDbDownloadResult;                  // plate number database download result callback function
    LDWORD                             dwUser;                                         // user data
} NET_IN_ATTACH_PLATENUMBERDB_DOWNLOAD_RESULT;

// Output param of CLIENT_AttachPlateNumberDbDownloadResult
typedef struct tagNET_OUT_ATTACH_PLATENUMBERDB_DOWNLOAD_RESULT
{
    DWORD                              dwSize;                                         // Struct size
} NET_OUT_ATTACH_PLATENUMBERDB_DOWNLOAD_RESULT;

// attach the result of downloading plate number database 
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachPlateNumberDbDownloadResult(LLONG lLoginID, NET_IN_ATTACH_PLATENUMBERDB_DOWNLOAD_RESULT* pInParam, NET_OUT_ATTACH_PLATENUMBERDB_DOWNLOAD_RESULT* pOutParam, int nWaitTime);

// detach the result of downloading plate number database, lAttachHandle is returned by CLIENT_AttachPlateNumberDbDownloadResult
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachPlateNumberDbDownloadResult(LLONG lAttachHandle);

// Task info of download plate number database
typedef struct tagNET_PLATE_NUMBER_DB_DOWNLOAD_TASK_INFO
{
    UINT                                          nURLNum;                             // url number of plate number picture
    char                                          szURLList[4][256];                   // url address list of plate number picture
    BYTE                                          byReserved[1020];                    // reserved
} NET_PLATE_NUMBER_DB_DOWNLOAD_TASK_INFO;

// Input param of CLIENT_AddPlateNumberDbDownloadTask
typedef struct tagNET_IN_ADD_PLATE_NUMBER_DB_DOWNLOAD_TASK
{
    DWORD                                         dwSize;                              // Struct size
    UINT                                          nTaskNum;                            // Download task number, specified by users, can support up to 100 tasks
	NET_PLATE_NUMBER_DB_DOWNLOAD_TASK_INFO       *pstTaskInfo;                        // Task info of download plate number database, memory is specified by users, and the size is nTaskNum*sizeof(NET_PLATE_NUMBER_DB_DOWNLOAD_TASK_INFO)
    char                                          szPlateNumberDbVersion[32];          // Plate number database version
    UINT                                          nPacketTotal;                        // total number of packet
    UINT                                          nPacketIndex;                        // Index of packet
} NET_IN_ADD_PLATE_NUMBER_DB_DOWNLOAD_TASK;

// Output param of CLIENT_AddPlateNumberDbDownloadTask
typedef struct tagNET_OUT_ADD_PLATE_NUMBER_DB_DOWNLOAD_TASK
{
    DWORD                                         dwSize;                              // Struct size
} NET_OUT_ADD_PLATE_NUMBER_DB_DOWNLOAD_TASK;

// Add plate number database download task
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddPlateNumberDbDownloadTask(LLONG lLoginID, NET_IN_ADD_PLATE_NUMBER_DB_DOWNLOAD_TASK* pInParam, NET_OUT_ADD_PLATE_NUMBER_DB_DOWNLOAD_TASK* pOutParam, int nWaitTime);

// Input param of CLIENT_GetPlateNumberDbVersion
typedef struct tagNET_IN_GET_PLATE_NUMBER_DB_VERSION
{
    DWORD                                         dwSize;                              // Struct size
} NET_IN_GET_PLATE_NUMBER_DB_VERSION;

// Output param of CLIENT_GetPlateNumberDbVersion
typedef struct tagNET_OUT_GET_PLATE_NUMBER_DB_VERSION
{
    DWORD                                         dwSize;                              // Struct size
    char                                          szPlateNumberDbVersion[32];         // Plate number database version, if no or normal, is 0
} NET_OUT_GET_PLATE_NUMBER_DB_VERSION;

// Get plate number database version
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetPlateNumberDbVersion(LLONG lLoginID, NET_IN_GET_PLATE_NUMBER_DB_VERSION* pInParam, NET_OUT_GET_PLATE_NUMBER_DB_VERSION* pOutParam, int nWaitTime);

// Protocol type of FTP server
typedef enum tagEM_FTP_PROTOCOL_TYPE
{
    EM_FTP_PROTOCOL_TYPE_UNKNOWN        = -1,           // unknown
    EM_FTP_PROTOCOL_TYPE_FTPS,                          // ftps
} EM_FTP_PROTOCOL_TYPE;

// FTP server info
typedef struct tagNET_FTP_SERVER_INFO
{
    char                    szIP[32];               // IP address
    char                    szUserName[32];         // User name
    char                    szPassword[32];         // Password
    UINT                    nPort;                  // Port
    EM_FTP_PROTOCOL_TYPE    emFtpProtocolType;      // Protocol type of FTP server
    UINT                    nTimeOut;               // Time out of connect, unit : Millisecond
    char                    szDirectory[128];       // Root directory for storing video
    BYTE                    byReserved[1020];       // Reserved
} NET_FTP_SERVER_INFO;

// Input param of CLIENT_SendFtpUploadServerInfo
typedef struct tagNET_IN_SEND_FTP_UPLOAD_SERVER_INFO
{
    DWORD                   dwSize;                 // Struct size
    UINT                    nFtpServerNum;          // Count of FTP servers
    NET_FTP_SERVER_INFO     stuFtpServerInfo[4];    // FTP server info
} NET_IN_SEND_FTP_UPLOAD_SERVER_INFO;

// Output param of CLIENT_SendFtpUploadServerInfo
typedef struct tagNET_OUT_SEND_FTP_UPLOAD_SERVER_INFO
{
    DWORD                           dwSize;                 // Struct size
} NET_OUT_SEND_FTP_UPLOAD_SERVER_INFO;

// Send the retransmit FTP server info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SendFtpUploadServerInfo(LLONG lLoginID, NET_IN_SEND_FTP_UPLOAD_SERVER_INFO* pInParam, NET_OUT_SEND_FTP_UPLOAD_SERVER_INFO* pOutParam, int nWaitTime);

// Result code of file upload
typedef enum tagEM_FILE_UPLOAD_RESULT_CODE
{
    EM_FILE_UPLOAD_RESULT_CODE_UNKNOWN      = -1,       // Unknown
    EM_FILE_UPLOAD_RESULT_CODE_SUCCESS,                 // Success
    EM_FILE_UPLOAD_RESULT_CODE_CONNECT_FAIL = 2,        // Connect failed
    EM_FILE_UPLOAD_RESULT_CODE_LOGIN_FAIL,              // Login failed
    EM_FILE_UPLOAD_RESULT_CODE_RCV_TIMEOUT,             // Receive data time out
    EM_FILE_UPLOAD_RESULT_CODE_OBJ_STR_NULL,            // The target string is empty
    EM_FILE_UPLOAD_RESULT_CODE_NO_FOLD_FILE,            // No directory or file exists
    EM_FILE_UPLOAD_RESULT_CODE_STORE_FAIL,              // File Storage Failure
    EM_FILE_UPLOAD_RESULT_CODE_SEND_FAIL,               // Send data failed
} EM_FILE_UPLOAD_RESULT_CODE;

// Info of file upload results
typedef struct tagNET_FILE_UPLOAD_RESULT_INFO
{
    char                        szFileUrl[256];             // File path
    EM_FILE_UPLOAD_RESULT_CODE  emResultCode;               // Result code of file upload
    BYTE                        byReserved[1020];           // Reserved
} NET_FILE_UPLOAD_RESULT_INFO;

// Callback info of file upload result
typedef struct tagNET_CB_FILE_UPLOAD_RESULT
{
    UINT                            nResultNum;                     // Number of file upload results
    NET_FILE_UPLOAD_RESULT_INFO     stuUploadResultInfo[4];         // Info of file upload results
    BYTE                            byReserved[1024];               // Reserved
} NET_CB_FILE_UPLOAD_RESULT;

// Callback function of attach file upload result, lAttachHandle is returned by CLIENT_AttachFileUploadResult
typedef void (CALLBACK *fFileUploadResult)(LLONG lAttachHandle, NET_CB_FILE_UPLOAD_RESULT* pstResult, LDWORD dwUser);

// Input param of CLIENT_AttachFileUploadResult
typedef struct tagNET_IN_ATTACH_FILE_UPLOAD_RESULT
{
    DWORD                           dwSize;                         // Struct size
    BYTE                            byReserved[4];                  // Byte alignment
    fFileUploadResult               cbFileUploadResult;             // Callback function of attach file upload result
    LDWORD                          dwUser;                         // User data
} NET_IN_ATTACH_FILE_UPLOAD_RESULT;

// Output param of CLIENT_AttachFileUploadResult
typedef struct tagNET_OUT_ATTACH_FILE_UPLOAD_RESULT
{
    DWORD                           dwSize;                         // Struct size
} NET_OUT_ATTACH_FILE_UPLOAD_RESULT;

// Attach file upload result
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachFileUploadResult(LLONG lLoginID, NET_IN_ATTACH_FILE_UPLOAD_RESULT* pInParam, NET_OUT_ATTACH_FILE_UPLOAD_RESULT* pOutParam, const int nWaitTime);

// Detach file upload result, lAttachHandle is returned by CLIENT_AttachFileUploadResult
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachFileUploadResult(LLONG lAttachHandle);

// CLIENT_GetFaceDbVersion 
typedef struct tagNET_IN_GET_FACE_DB_VERSION
{
	DWORD                           dwSize;                         // Struct size
} NET_IN_GET_FACE_DB_VERSION;

// Output param CLIENT_GetFaceDbVersion
typedef struct tagNET_OUT_GET_FACE_DB_VERSION
{
	DWORD                           dwSize;                         // Struct size
	char                            szFaceDbVersion[32];            // Face database version, Face database version number is "0", if no face downloaded or device abnormal face not downloaded completely
	UINT                            nTotalCount;                    // Total number of files to download
	UINT                            nSuccessDCount;                 // Number of files downloaded
} NET_OUT_GET_FACE_DB_VERSION;

// Get face database version
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetFaceDbVersion(LLONG lLoginID, NET_IN_GET_FACE_DB_VERSION* pInParam, NET_OUT_GET_FACE_DB_VERSION* pOutParam, const int nWaitTime);

// Input param of CLIENT_ControlThermoSensor 
typedef struct tagNET_IN_CONTROL_THERMO_SENSOR
{
    DWORD               dwSize;             // struct size
    int                 nChannel;           // Channel
    int                 nState;             // Thermal imaging core switch, 0 - off; 1 - Open
    BYTE                byReserverd[4];     // Reserved bytes for byte alignment
} NET_IN_CONTROL_THERMO_SENSOR;

// Output param of CLIENT_ControlThermoSensor 
typedef struct tagNET_OUT_CONTROL_THERMO_SENSOR
{
    DWORD               dwSize;             // struct size
} NET_OUT_CONTROL_THERMO_SENSOR;


// Input param of CLIENT_GetDistanceRes 
typedef struct tagNET_IN_GET_DISTANCE_RES
{
    DWORD               dwSize;             // struct size
    UINT                nChannel;           // Channel
} NET_IN_GET_DISTANCE_RES;


// 
typedef enum tagEM_GET_DISTANCE_RES_STATUS
{
    EM_GET_DISTANCE_RES_UNKNOWN = -1,               // Unknown
    EM_GET_DISTANCE_RES_SUCCESS,                    // Success
    EM_GET_DISTANCE_RES_BEYOND_PITCH_LIMIT,         // Beyond pitch limit
    EM_GET_DISTANCE_RES_INTERFACE_EXCEPTION,        // Interface exception
    EM_GET_DISTANCE_RES_GENERAL_ERROR,              // General Error
    EM_GET_DISTANCE_RES_LASER_NO_DATA_RETURN,       // Laser Range Finder No Data Return
    EM_GET_DISTANCE_RES_LASER_DATA_LENGTH_ERROR,    // Data Length Error Returned by Laser Range Finder
    EM_GET_DISTANCE_RES_LASER_DATA_FORMAT_ERROR,    // The data format returned by laser rangefinder is incorrect
    EM_GET_DISTANCE_RES_LASER_DATA_VERIFIED_ERROR,  // Failure to verify data returned by laser rangefinder
}EM_GET_DISTANCE_RES_STATUS;

// Output param of CLIENT_GetDistanceRes 
typedef struct tagNET_OUT_GET_DISTANCE_RES
{
    DWORD                       dwSize;             // struct size
    UINT                        nDistance;          // Target Distance, Unit Meter
    int                         nOverTimeStatus;    // Timeout state (0, timeout 1 not timeout)
    EM_GET_DISTANCE_RES_STATUS  emStatus;           // Result status
} NET_OUT_GET_DISTANCE_RES;

// Forced Opening or Closing of Thermal Imaging Refrigerator Core
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ControlThermoSensor(LLONG lLoginID, NET_IN_CONTROL_THERMO_SENSOR* pInParam, NET_OUT_CONTROL_THERMO_SENSOR* pOutParam,int nWaitTime);

// Obtaining the Distance of the Target in the Central Position of the Picture
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDistanceRes(LLONG lLoginID, NET_IN_GET_DISTANCE_RES* pInParam, NET_OUT_GET_DISTANCE_RES* pOutParam,int nWaitTime);

// Types of thermal imaging logs for queries
typedef enum tagEM_THREM_LOG_TYPE
{
    EM_THREM_LOG_UNKNOWN = -1,              // Unknown, only for query results, not for query conditions
    EM_THREM_LOG_ALL,                       // All, only for query conditions, not for query results
    EM_THREM_LOG_CORE_OP,                   // Operational Relevance of Operating Operations on Machine Core
    EM_THREM_LOG_LASER,                     // Laser ranging operation correlation
    EM_THREM_LOG_PTZ,                       // PTZ
    EM_THREM_LOG_VISUAL_ZOOM,               // Visual zoom
    EM_THREM_LOG_VISUAL_FOCUS,              // Visual focus
    EM_THREM_LOG_THERM_ZOOM,                // Thermal imaging zoom
    EM_THREM_LOG_THERM_FOCUS,               // Thermal imaging focusing
    EM_THREM_LOG_CLEAR_LOG,                 // Clear log
    EM_THREM_LOG_TEMPERATURE,               // Temperature
}EM_THREM_LOG_TYPE;

// Input param of CLIENT_StartFindThermLog 
typedef struct tagNET_IN_START_FIND_THERM_LOG
{
    DWORD               dwSize;             // struct size
    EM_THREM_LOG_TYPE	emLogType;			// Log type of query
    NET_TIME			stuStartTime;		// Start time of query
    NET_TIME			stuEndTime;			// End time of query
} NET_IN_START_FIND_THERM_LOG;

// Output param of CLIENT_StartFindThermLog 
typedef struct tagNET_OUT_START_FIND_THERM_LOG
{
    DWORD               dwSize;             // struct size
} NET_OUT_START_FIND_THERM_LOG;

// Input param of CLIENT_GetThermLogCount 
typedef struct tagNET_IN_GET_THERM_LOG_COUNT
{
    DWORD               dwSize;             // struct size
} NET_IN_GET_THERM_LOG_COUNT;

// Output param of CLIENT_GetThermLogCount 
typedef struct tagNET_OUT_GET_THERM_LOG_COUNT
{
    DWORD               dwSize;             // struct size
    int                 nLogCount;          // count of log
} NET_OUT_GET_THERM_LOG_COUNT;

// Input param of  CLIENT_DoSeekFindThermLog 
typedef struct tagNET_IN_DO_SEEK_FIND_THERM_LOG
{
    DWORD               dwSize;             // struct size
    int                 nOffset;            // Starting from satisfying the condition, offset bar records start querying
    int                 nCount;             // Number of log entries per query
    BYTE                byReserve[4];       // Reserve bytes for byte alignment
} NET_IN_DO_SEEK_FIND_THERM_LOG;

// Thermal imaging log information
typedef struct tagNET_THERM_LOG
{
    NET_TIME             stuTime;            // Log time
    EM_THREM_LOG_TYPE	 emLogType;			 // Log type
    char                 szDetail[512];      // Log data
    BYTE                 byReserve[1024];    // Reserve
} NET_THERM_LOG;

// Output param of CLIENT_DoSeekFindThermLog 
typedef struct tagNET_OUT_DO_SEEK_FIND_THERM_LOG
{
    DWORD               dwSize;             // struct size
    int                 nMaxCount;          // User-specified number of allocation structures, greater than or equal to nCount of NET_IN_DO_SEEK_FIND_THERM_LOG
    NET_THERM_LOG*      pstuLogInfo;        // Returns log information, and the cache size is specified by the user
    int                 nRetCount;          // The number of entries queried, 0, means that no more logs can be queried (cannot be judged by foundless than the count requested). Devices may be limited by memory and other constraints, can not be returned at one time.)
    BYTE                byReserve[4];       // Reserve bytes for byte alignment
} NET_OUT_DO_SEEK_FIND_THERM_LOG;

// Start querying thermal imaging log
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartFindThermLog(LLONG lLoginID, const NET_IN_START_FIND_THERM_LOG* pInParam, NET_OUT_START_FIND_THERM_LOG* pOutParam, int nWaitTime);

// Get the current number of thermal imaging logs
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetThermLogCount(LLONG lLogID, NET_IN_GET_THERM_LOG_COUNT* pInParam, NET_OUT_GET_THERM_LOG_COUNT* pOutParam, int nWaitTime);

// Query current thermal imaging log records
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoSeekFindThermLog(LLONG lLogID, NET_IN_DO_SEEK_FIND_THERM_LOG* pInParam, NET_OUT_DO_SEEK_FIND_THERM_LOG* pOutParam, int nWaitTime);

// Stop querying thermal imaging log
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindThermLog(LLONG lLogID);

// course state
typedef enum tagEM_COURSE_STATE
{
    EM_COURSE_STATE_UNKNOWN,                                                        // unknown
    EM_COURSE_STATE_NOT_RECORD,                                                     // don't record
    EM_COURSE_STATE_IN_RECORDING,                                                   // recording
    EM_COURSE_STATE_ALREADY_RECORDED,                                               // recorded
} EM_COURSE_STATE;

// course info
typedef struct tagNET_COURSE
{
    NET_TIME                        stuStartTime;                                   // start time
    NET_TIME                        stuEndTime;                                     // end time
    char                            szCourseName[DH_COMMON_STRING_64];              // course name
    char                            szTeacherName[DH_COMMON_STRING_64];             // teacher name
    char                            szIntroduction[DH_COMMON_STRING_128];           // course introduction
    int                             nCanStartStreamNum;                             // start stream enable logical channel number
    int                             nIsRecordNum;                                   // record enable logical channel number
    EM_CAN_START_STREAM             emCanStartStream[64];                           // start stream enbale
    EM_IS_RECORD                    emIsRecord[64];                                 // record enbale
    UINT                            nCompositeChannelMode;                          // composite channel mode; 0: invalid, 1: movie, 2: nomal, 3: classic  
    EM_COURSE_STATE                 emCourseState;                                  // course state
    BYTE                            byReserved[128];                                // reserved
} NET_COURSE;

// CLIENT_AddCourse input param
typedef struct tagNET_IN_ADD_COURSE
{
    DWORD                           dwSize;                                         // struct size
    int                             nCourseNum;                                     // course number
    NET_COURSE                      stuCourseInfo[64];                              // course info
}NET_IN_ADD_COURSE; 

// CLIENT_AddCourse output param
typedef struct tagNET_OUT_ADD_COURSE
{
    DWORD                           dwSize;                                         // struct size
    int                             nIdNum;                                         // course ID number
    int                             nId[64];                                        // course ID; -1:no such ID, -2:ID already exist, -3: datebase if full
}NET_OUT_ADD_COURSE;

// add course
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddCourse(LLONG lLoginID, const NET_IN_ADD_COURSE *pstInParam, NET_OUT_ADD_COURSE *pstOutParam, int nWaitTime);

// CLIENT_DeleteCourse input param
typedef struct tagNET_IN_DELETE_COURSE
{
    DWORD                           dwSize;                                         // struct size
    int                             nIdNum;                                         // course ID number
    int                             nId[64];                                        // course ID
}NET_IN_DELETE_COURSE; 

// CLIENT_DeleteCourse output param
typedef struct tagNET_OUT_DELETE_COURSE
{
    DWORD                           dwSize;                                         // struct size
    int                             nResultIdNum;                                   // course ID number
    int                             nResultId[64];                                  // course ID; -1:successs, original id:fail
}NET_OUT_DELETE_COURSE;

// delete course
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DeleteCourse(LLONG lLoginID, const NET_IN_DELETE_COURSE *pstInParam, NET_OUT_DELETE_COURSE *pstOutParam, int nWaitTime);

// CLIENT_ModifyCourse input param
typedef struct tagNET_IN_MODIFY_COURSE
{
    DWORD                           dwSize;                                         // struct size
    int                             nCourseNum;                                     // course number
    NET_COURSE                      stuCourseInfo[64];                              // course info
    int                             nId[64];                                        // course ID
}NET_IN_MODIFY_COURSE; 

// CLIENT_ModifyCourse output param
typedef struct tagNET_OUT_MODIFY_COURSE
{
    DWORD                           dwSize;                                         // struct size
    int                             nResultIDNum;                                   // course ID number
    int                             nResultID[64];                                  // course ID; original ID: success, -1: no such data, -2: time conflict
}NET_OUT_MODIFY_COURSE;

// modify course
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ModifyCourse(LLONG lLoginID, const NET_IN_MODIFY_COURSE *pstInParam, NET_OUT_MODIFY_COURSE *pstOutParam, int nWaitTime);

// CLIENT_QueryCourseOpen input param
typedef struct tagNET_IN_QUERY_COURSE_OPEN
{
    DWORD                           dwSize;                                         // struct size
    NET_TIME                        stuStartTime;                                   // start time
    NET_TIME                        stuEndTime;                                     // end time
}NET_IN_QUERY_COURSE_OPEN; 

// CLIENT_QueryCourseOpen output param
typedef struct tagNET_OUT_QUERY_COURSE_OPEN
{
    DWORD                           dwSize;                                         // struct size
    int                             nTotalNum;                                      // total number
    int                             nFindID;                                        // find ID
}NET_OUT_QUERY_COURSE_OPEN;

// query course open
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryCourseOpen(LLONG lLoginID, const NET_IN_QUERY_COURSE_OPEN *pstInParam, NET_OUT_QUERY_COURSE_OPEN *pstOutParam, int nWaitTime);

// CLIENT_QueryCourse input param
typedef struct tagNET_IN_QUERY_COURSE
{
    DWORD                           dwSize;                                         // struct size
    int                             nFindID;                                        // find ID
    int                             nOffset;                                        // offset
    int                             nCount;                                         // find count
}NET_IN_QUERY_COURSE; 
// course info and ID
typedef struct tagNET_COURSE_RESULT
{
    NET_COURSE                      stuCourseInfo;                                  // course info
    int                             nId;                                            // course ID
    BYTE                            byReserved[4];                                  // reserved
} NET_COURSE_RESULT;
// CLIENT_QueryCourse output param
typedef struct tagNET_OUT_QUERY_COURSE
{
    DWORD                           dwSize;                                         // struct size
    int                             nCountResult;                                   // find count
    NET_COURSE_RESULT               stuCourseResult[64];                            // find course info
}NET_OUT_QUERY_COURSE;

// query course
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryCourse(LLONG lLoginID, const NET_IN_QUERY_COURSE *pstInParam, NET_OUT_QUERY_COURSE *pstOutParam, int nWaitTime);

// CLIENT_QueryCourseClose input param
typedef struct tagNET_IN_QUERY_COURSE_CLOSE
{
    DWORD                           dwSize;                                         // struct size
    int                             nFindID;                                        // course number
}NET_IN_QUERY_COURSE_CLOSE; 

// CLIENT_QueryCourseClose output param
typedef struct tagNET_OUT_QUERY_COURSE_CLOSE
{
    DWORD                           dwSize;                                         // struct size
}NET_OUT_QUERY_COURSE_CLOSE;

// query course close
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryCourseClose(LLONG lLoginID, const NET_IN_QUERY_COURSE_CLOSE *pstInParam, NET_OUT_QUERY_COURSE_CLOSE *pstOutParam, int nWaitTime);

// open play group
CLIENT_NET_API LLONG CALL_METHOD CLIENT_OpenPlayGroup();

// input param of CLIENT_AddPlayHandleToPlayGroup
typedef struct tagNET_IN_ADD_PLAYHANDLE_TO_PLAYGROUP
{
	DWORD			dwSize;					// struct size
	BYTE			byReserved[4];			// byte alignment
	LLONG			lPlayGroupHandle;		// play group handle, returned by CLIENT_OpenPlayGroup
	LLONG			lPlayHandle;			// play handle(currently only supports playback)
}NET_IN_ADD_PLAYHANDLE_TO_PLAYGROUP;

// output param of CLIENT_AddPlayHandleToPlayGroup
typedef struct tagNET_OUT_ADD_PLAYHANDLE_TO_PLAYGROUP
{
	DWORD			dwSize;					// struct size	
}NET_OUT_ADD_PLAYHANDLE_TO_PLAYGROUP;

// add play handle to play group to ensure simulcast
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddPlayHandleToPlayGroup(const NET_IN_ADD_PLAYHANDLE_TO_PLAYGROUP* pInParam, NET_OUT_ADD_PLAYHANDLE_TO_PLAYGROUP* pOutParam);

// pause or resume play group
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PausePlayGroup(LLONG lPlayGroupHandle, BOOL bPause);

// input param of CLIENT_QueryPlayGroupTime
typedef struct tagNET_IN_QUERY_PLAYGROUP_TIME
{
	DWORD			dwSize;					// struct size		
	BYTE			byReserved[4];			// byte alignment
	LLONG			lPlayGroupHandle;		// play group handle, returned by CLIENT_OpenPlayGroup
}NET_IN_QUERY_PLAYGROUP_TIME;

// output param of CLIENT_QueryPlayGroupTime
typedef struct tagNET_OUT_QUERY_PLAYGROUP_TIME
{
	DWORD			dwSize;					// struct size	
	NET_TIME_EX		stuTime;				// play time
}NET_OUT_QUERY_PLAYGROUP_TIME;

// query play group time
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryPlayGroupTime(const NET_IN_QUERY_PLAYGROUP_TIME* pInParam, NET_OUT_QUERY_PLAYGROUP_TIME* pOutParam);

// input param of CLIENT_SetPlayGroupBaseChannel
typedef struct tagNET_IN_SET_PLAYGROUP_BASECHANNEL
{
	DWORD			dwSize;					// struct size	
	BYTE			byReserved[4];			// byte alignment	
	LLONG			lPlayGroupHandle;		// play group handle, returned by CLIENT_OpenPlayGroup
	LLONG			lPlayHandle;			// play handle(currently only supports playback)
}NET_IN_SET_PLAYGROUP_BASECHANNEL;

// output param of CLIENT_SetPlayGroupBaseChannel
typedef struct tagNET_OUT_SET_PLAYGROUP_BASECHANNEL
{
	DWORD			dwSize;					// struct size		
}NET_OUT_SET_PLAYGROUP_BASECHANNEL;

// set play group base channel
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetPlayGroupBaseChannel(const NET_IN_SET_PLAYGROUP_BASECHANNEL* pInParam, NET_OUT_SET_PLAYGROUP_BASECHANNEL* pOutParam);

// input param of CLIENT_DeleteFromPlayGroup
typedef struct tagNET_IN_DELETE_FROM_PLAYGROUP
{
	DWORD			dwSize;					// struct size	
	BYTE			byReserved[4];			// byte alignment	
	LLONG			lPlayGroupHandle;		// play group handle, returned by CLIENT_OpenPlayGroup
	LLONG			lPlayHandle;			// play handle(currently only supports playback)
}NET_IN_DELETE_FROM_PLAYGROUP;

// output param of CLIENT_DeleteFromPlayGroup
typedef struct tagNET_OUT_DELETE_FROM_PLAYGROUP
{
	DWORD			dwSize;					// struct size	
}NET_OUT_DELETE_FROM_PLAYGROUP;

// remove play handle from play group
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DeleteFromPlayGroup(const NET_IN_DELETE_FROM_PLAYGROUP* pInParam, NET_OUT_DELETE_FROM_PLAYGROUP* pOutParam);

// close play group
// lPlayGroupHandle is the value returned by CLIENT_OpenPlayGroup
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ClosePlayGroup(LLONG lPlayGroupHandle);



// Input param of CLIENT_GetChannelOfAudioInput
typedef struct tagNET_IN_GET_CHANNEL_OF_AUDIO_INPUT
{
    DWORD								dwSize;					// Structural size
}NET_IN_GET_CHANNEL_OF_AUDIO_INPUT;

// Output param of CLIENT_GetChannelOfAudioInput
typedef struct tagNET_OUT_GET_CHANNEL_OF_AUDIO_INPUT
{
    DWORD								dwSize;					// Structural size
    UINT                                nChannels;              // Number of Audio Input Channels Supported
}NET_OUT_GET_CHANNEL_OF_AUDIO_INPUT;

// Input param of CLIENT_GetChannelOfAudioOutput
typedef struct tagNET_IN_GET_CHANNEL_OF_AUDIO_OUTPUT
{
    DWORD								dwSize;					// Structural size
}NET_IN_GET_CHANNEL_OF_AUDIO_OUTPUT;

// Output param of CLIENT_GetChannelOfAudioOutput
typedef struct tagNET_OUT_GET_CHANNEL_OF_AUDIO_OUTPUT
{
    DWORD								dwSize;					// Structural size
    UINT                                nChannels;              // Number of Audio Input Channels Supported
}NET_OUT_GET_CHANNEL_OF_AUDIO_OUTPUT;

// Number of channels for obtaining audio input
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetChannelOfAudioInput(LLONG lLoginID, NET_IN_GET_CHANNEL_OF_AUDIO_INPUT* pInParam, NET_OUT_GET_CHANNEL_OF_AUDIO_INPUT* pOutParam,int nWaitTime);

// Number of channels for obtaining audio output
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetChannelOfAudioOutput(LLONG lLoginID, NET_IN_GET_CHANNEL_OF_AUDIO_OUTPUT* pInParam, NET_OUT_GET_CHANNEL_OF_AUDIO_OUTPUT* pOutParam,int nWaitTime);

// Input param of CLIENT_ExitApp 
typedef struct tagNET_IN_EXIT_APP
{
    DWORD               dwSize;             // struct size	
} NET_IN_EXIT_APP;

// output param of CLIENT_ExitApp 
typedef struct tagNET_OUT_EXIT_APP
{
    DWORD               dwSize;             // struct size	
} NET_OUT_EXIT_APP;

// Exit application program
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ExitApp(LLONG lLoginID, NET_IN_EXIT_APP* pInParam, NET_OUT_EXIT_APP* pOutParam, int nWaitTime);

// input param of CLIENT_SetPlayGroupDirection
typedef struct tagNET_IN_SET_PLAYGROUP_DIRECTION
{
	DWORD				dwSize;								// struct size
	int					nPlayDirection;						// play direction, 0:forward; 1:backward
	LLONG				lPlayGroupHandle;					// play group handle, returned by CLIENT_OpenPlayGroup
}NET_IN_SET_PLAYGROUP_DIRECTION;

// output param of CLIENT_SetPlayGroupDirection
typedef struct tagNET_OUT_SET_PLAYGROUP_DIRECTION
{
	DWORD				dwSize;								// struct size
}NET_OUT_SET_PLAYGROUP_DIRECTION;

// set play group direction
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetPlayGroupDirection(const NET_IN_SET_PLAYGROUP_DIRECTION* pInParam, NET_OUT_SET_PLAYGROUP_DIRECTION* pOutParam);


// input param of CLIENT_SetPlayGroupSpeed
typedef struct tagNET_IN_SET_PLAYGROUP_SPEED
{
	DWORD				dwSize;								// struct size
	EM_PLAY_BACK_SPEED	emSpeed;							// play speed
	LLONG				lPlayGroupHandle;					// play group handle, returned by CLIENT_OpenPlayGroup	
}NET_IN_SET_PLAYGROUP_SPEED;

// output param of CLIENT_SetPlayGroupSpeed
typedef struct tagNET_OUT_SET_PLAYGROUP_SPEED
{
	DWORD				dwSize;								// struct size
}NET_OUT_SET_PLAYGROUP_SPEED;

// set play group speed
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetPlayGroupSpeed(const NET_IN_SET_PLAYGROUP_SPEED* pInParam, NET_OUT_SET_PLAYGROUP_SPEED* pOutParam);

// fast play of play group
// lPlayGroupHandle is the value returned by CLIENT_OpenPlayGroup
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FastPlayGroup(LLONG lPlayGroupHandle);

// slow play of play group
// lPlayGroupHandle is the value returned by CLIENT_OpenPlayGroup
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SlowPlayGroup(LLONG lPlayGroupHandle);

// normal play of play group
// lPlayGroupHandle is the value returned by CLIENT_OpenPlayGroup
CLIENT_NET_API BOOL CALL_METHOD CLIENT_NormalPlayGroup(LLONG lPlayGroupHandle);

// input param of CLIENT_StartSearchDevicesForAOL
typedef struct tagNET_IN_AOL_STARTSEARCH_DEVICE
{
	DWORD                   dwSize;								// struct size
	char                    szLocalIp[MAX_LOCAL_IP_LEN];		// local IP
	fSearchDevicesCBEx      cbSearchDevices;					// search device call back
	void*                   pUserData;							// user data	
}NET_IN_AOL_STARTSEARCH_DEVICE;

// output param of CLIENT_StartSearchDevicesForAOL
typedef struct tagNET_OUT_AOL_STARTSEARCH_DEVICE
{
	DWORD                   dwSize;								// struct size
}NET_OUT_AOL_STARTSEARCH_DEVICE;

// asynchronism search device for AOL
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartSearchDevicesForAOL(NET_IN_AOL_STARTSEARCH_DEVICE* pInParam, NET_OUT_AOL_STARTSEARCH_DEVICE* pOutParam);

// input param of CLIENT_SearchDevicesByIPsForAOL
typedef struct tagNET_IN_AOL_SEARCHDEVICE_BYIPS
{		
	DWORD					dwSize;								// struct size	
	int                 	nIpNum;								// the IPs number for search
    char                	szIP[DH_MAX_SAERCH_IP_NUM][64];		// the IPs for search	
	char*					szLocalIp;							// local ip
	fSearchDevicesCB		cbSearchDevices;					// call back function
	LDWORD					dwUserData;							// user data	
}NET_IN_AOL_SEARCHDEVICE_BYIPS;

// output param of CLIENT_SearchDevicesByIPsForAOL
typedef struct tagNET_OUT_AOL_SEARCHDEVICE_BYIPS
{
	DWORD					dwSize;								// struct size
}NET_OUT_AOL_SEARCHDEVICE_BYIPS;

// search device cross VLAN for AOL
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SearchDevicesByIPsForAOL(NET_IN_AOL_SEARCHDEVICE_BYIPS* pInParam, NET_OUT_AOL_SEARCHDEVICE_BYIPS* pOutParam, int nWaitTime);


// input param of CLIENT_ResetSystemEx
typedef struct tagNET_IN_RESET_SYSTEM_EX
{
	DWORD 					dwSize;								// struct size
	UINT					nType;								// 0:hard reset; 1:soft reset
}NET_IN_RESET_SYSTEM_EX;

// output param of CLIENT_ResetSystemEx
typedef struct tagNET_OUT_RESET_SYSTEM_EX
{
	DWORD 					dwSize;								// struct size
}NET_OUT_RESET_SYSTEM_EX;

// reset the system(clear user data and reboot to device init state)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ResetSystemEx(LLONG lLoginID,const NET_IN_RESET_SYSTEM_EX* pstInParam, NET_OUT_RESET_SYSTEM_EX* pstOutParam, int nWaitTime);

// error code of export AOL log file
typedef enum tagEM_EXPORT_AOL_LOGFILE_ERRORCODE
{
	EM_EXPORT_AOL_LOGFILE_SUCCESS			= 1,				// request of export is success
	EM_EXPORT_AOL_LOGFILE_NO_AUTHORITY		= 2,				// no access
	EM_EXPORT_AOL_LOGFILE_NO_THIS_FILE		= 3,				// file not exist
	EM_EXPORT_AOL_LOGFILE_EXPORT_END		= 4,				// file download end
	EM_EXPORT_AOL_LOGFILE_EXPORTING			= 5,				// exporting
	EM_EXPORT_AOL_LOGFILE_FILE_SUCCESS		= 6,				// stop download success
	EM_EXPORT_AOL_LOGFILE_FILE_FAIL			= 7,				// stop download fail
	EM_EXPORT_AOL_LOGFILE_FILE_READY		= 8,				// the file is ready
	EM_EXPORT_AOL_LOGFILE_FILE_FAILED		= 9,				// fail to prepare file
	EM_EXPORT_AOL_LOGFILE_WAIT_FILE			= 10,				// request of export is success, and need to wait the file
	EM_EXPORT_AOL_LOGFILE_SYSTEM_BUSY		= 11,				// system is busy
} EM_EXPORT_AOL_LOGFILE_ERRORCODE;

// export AOL log file state
typedef struct tagNET_EXPORT_AOL_LOGFILE_STATE
{
	unsigned int					nProgress;					// progress
	EM_EXPORT_AOL_LOGFILE_ERRORCODE	emErrorCode;				// error code
	char							*pDataBuf;					// export data
	DWORD							dwDataLen;					// data len
	BYTE							byReserved[516];			// reserved
} NET_EXPORT_AOL_LOGFILE_STATE;

// call back function of CLIENT_ExportAOLLogFile
typedef void (CALLBACK *fExportAOLLogFileCallBack)(LLONG lExportHandle, NET_EXPORT_AOL_LOGFILE_STATE *pstLogFileState, LDWORD dwUser);

// input file of CLIENT_ExportAOLLogFile
typedef struct tagNET_IN_EXPORT_AOL_LOGFILE
{
	DWORD							dwSize;						// struct size	
	BYTE							byReserved[4];				// reserved
	fExportAOLLogFileCallBack		cbExport;					// call back function
	LDWORD 							dwUser;						// user data
}NET_IN_EXPORT_AOL_LOGFILE;

// output file of CLIENT_ExportAOLLogFile
typedef struct tagNET_OUT_EXPORT_AOL_LOGFILE
{
	DWORD							dwSize;						// struct size
}NET_OUT_EXPORT_AOL_LOGFILE;

// export AOL log file
CLIENT_NET_API LLONG CALL_METHOD CLIENT_ExportAOLLogFile(LLONG lLoginID, const NET_IN_EXPORT_AOL_LOGFILE* pInParam, NET_OUT_EXPORT_AOL_LOGFILE* pOutParam, int nWaitTime);

// stop export AOL log file
// lExportHandle is the value returned by CLIENT_ExportAOLLogFile
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopExportAOLLogFile(LLONG lExportHandle);


// Input param of CLIENT_DeleteAllDiagnosisFaultCode
typedef struct tagNET_IN_DELETE_ALLDIAGNOSIS_FAULTCODE
{
	DWORD							dwSize;						// struct size
}NET_IN_DELETE_ALLDIAGNOSIS_FAULTCODE;

// Output param of CLIENT_DeleteAllDiagnosisFaultCode
typedef struct tagNET_OUT_DELETE_ALLDIAGNOSIS_FAULTCODE
{
	DWORD							dwSize;						// struct size
}NET_OUT_DELETE_ALLDIAGNOSIS_FAULTCODE;

// delete all diagnosis fault code
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DeleteAllDiagnosisFaultCode(LLONG lLoginID, const NET_IN_DELETE_ALLDIAGNOSIS_FAULTCODE* pInParam, NET_OUT_DELETE_ALLDIAGNOSIS_FAULTCODE* pOutParam, int nWaitTime);

// Temperature information of pig
typedef struct tagNET_PIG_TEMPERATURE_DATA
{
    NET_RECT            stuRect;                // Object rect 
    UINT                nID;                    // Object ID
    float               fMaxTemperature;        // Max temperature
    float               fMinTemperature;        // Min temperature
    float               fAverageTemperature;    // Average temperature
    BYTE                byReserve[1024];        // Reserve
} NET_PIG_TEMPERATURE_DATA;

// Pig body temperature information array
typedef struct tagNET_PIG_TEMPERATURE_INFO
{
    UINT                        nPigNum;            // Count of pigs
    NET_PIG_TEMPERATURE_DATA    stuPigInfo[48];     // Info of pigs
    BYTE                        byReserve[1024];    // Reserve
} NET_PIG_TEMPERATURE_INFO;

// Custom snap type
typedef enum tagEM_CUSTOM_SNAP_TYPE
{
    EM_CUSTOM_SNAP_UNKNOWN,                 // Unknown
    EM_CUSTOM_SNAP_PIG_TEMPERATURE,         // Pig temperature detection, Corresponding to struct NET_PIG_TEMPERATURE_INFO
} EM_CUSTOM_SNAP_TYPE;

// Call back info of CLIENT_AttachCustomSnapInfo
typedef struct tagNET_CB_CUSTOM_SNAP_INFO
{
    UINT                        nChannelID;         // Channel ID
    NET_TIME                    stuSnapTime;        // Snap time
    EM_CUSTOM_SNAP_TYPE         emCustomSnapType;   // Custom snap type
    void*                       pDetailInfo;        // Detail info about picture, Determine the specific structure type based on the emCustomSnapType value
    BYTE                        byReserve[1024];    // Reserve
} NET_CB_CUSTOM_SNAP_INFO;

// Call back function of CLIENT_AttachCustomSnapInfo, lAttachHandle is returned by CLIENT_AttachCustomSnapInfo
typedef void (CALLBACK *fAttachCustomSnapInfo)(LLONG lAttachHandle, NET_CB_CUSTOM_SNAP_INFO* pstResult, const char *pBuf, const DWORD dwBufSize, LDWORD dwUser);

// Input param of CLIENT_AttachCustomSnapInfo
typedef struct tagNET_IN_ATTACH_CUSTOM_SNAP_INFO
{
    DWORD                           dwSize;                         // Struct size
    int                             nChannelID;                     // Channel ID
    fAttachCustomSnapInfo           cbCustomSnapInfo;               // Call back function
    LDWORD                          dwUser;                         // User data
} NET_IN_ATTACH_CUSTOM_SNAP_INFO;

// Output param of CLIENT_AttachCustomSnapInfo
typedef struct tagNET_OUT_ATTACH_CUSTOM_SNAP_INFO
{
    DWORD                           dwSize;                         // Struct size
} NET_OUT_ATTACH_CUSTOM_SNAP_INFO;

// Attach timed custom snapshot(in use for intelligent pig temperature detection)
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachCustomSnapInfo(LLONG lLoginID, NET_IN_ATTACH_CUSTOM_SNAP_INFO* pInParam, NET_OUT_ATTACH_CUSTOM_SNAP_INFO* pOutParam, const int nWaitTime);

// Detach timed custom snapshot(in use for intelligent pig temperature detection)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachCustomSnapInfo(LLONG lAttachHandle);



// Input param of  CLIENT_GetInstalledAppInfo
typedef struct tagNET_IN_GET_INSTALLED_APP_INFO
{
    DWORD                           dwSize;                     // Struct size
} NET_IN_GET_INSTALLED_APP_INFO;

// Capability information of app
typedef struct tagNET_APP_CAPS
{
    BOOL                bShowWebConsole;        // Whether supportting web Console
    BOOL                bShowPerformance;       // Whether viewing performance is supported
    BOOL                bShowDebug;             // Whether debugging is supported
    BYTE                byReserved[128];        // Reserved
}NET_APP_CAPS;

//Running status of app
typedef enum tagEM_APP_RUNNING_STATE
{
    EM_APP_RUNNING_STATE_UNKNOWN,           // Unknown
    EM_APP_RUNNING_STATE_RUNNING,           // Running 
    EM_APP_RUNNING_STATE_STOP,              // Stop
    EM_APP_RUNNING_STATE_ERROR,             // Error
} EM_APP_RUNNING_STATE;

// License status of app
typedef enum tagEM_APP_LICENSE_STATE
{
    EM_APP_LICENSE_STATE_UNKNOEN,        // Unknown
    EM_APP_LICENSE_STATE_IN_TRAL,        // In tral
    EM_APP_LICENSE_STATE_IN_LICENSE,     // In license 
    EM_APP_LICENSE_STATE_EXPIRED,        // Expired
}EM_APP_LICENSE_STATE;

// Debuging status of app
typedef enum tagEM_APP_DEBUG_STATE
{
    EM_APP_DEBUG_STATE_UNKNOWN,         // Unknown
    EM_APP_DEBUG_STATE_ENABLE,          // Enable to debug
    EM_APP_DEBUG_STATE_DISABLE,         // Disable to debug
}EM_APP_DEBUG_STATE;

// The information of installed APP list 
typedef struct tagNET_INSTALLED_APP_INFO
{
    char                    szAppName[128];         // APP name
    char                    szVersion[64];          // APP version
    char                    szExtend[64];           // Extended information
    UINT                    nAppID;                 // APP ID
    EM_APP_DEBUG_STATE      emAppDebugState;        // Debuging status of app
    EM_APP_RUNNING_STATE    emAppRunningState;      // Running status of app
    EM_APP_LICENSE_STATE    emAppLicenseState;      // License status of app
    NET_APP_CAPS    stuAppCaps;             // Capability information of app
    BYTE                    byReserved[256];        // Reserved
} NET_INSTALLED_APP_INFO;


// Output param of  CLIENT_GetInstalledAppInfo 
typedef struct tagNET_OUT_GET_INSTALLED_APP_INFO
{
    DWORD                           dwSize;                     // Struct size
    UINT                            nListCount;                 // Returns the number of installed APP list information
    NET_INSTALLED_APP_INFO           stuAppInfoList[16];    // The information of installed APP list 
} NET_OUT_GET_INSTALLED_APP_INFO;

// Input param of CLIENT_StartApp 
typedef struct tagNET_IN_START_APP
{
    DWORD                           dwSize;                     // Struct size
    UINT                            nAppID;                     // The ID of application program
    char                            szAppName[128];             // The name of application program
} NET_IN_START_APP;

// Output param of CLIENT_StartApp 
typedef struct tagNET_OUT_START_APP
{
    DWORD                           dwSize;                     // Struct size
} NET_OUT_START_APP;


// Input param of CLIENT_StopApp
typedef struct tagNET_IN_STOP_APP
{
    DWORD                           dwSize;                     // Struct size
    UINT                            nAppID;                     // The ID of application program
    char                            szAppName[128];             // The name of application program
} NET_IN_STOP_APP;

// Output param of CLIENT_StopApp 
typedef struct tagNET_OUT_STOP_APP
{
    DWORD                           dwSize;                     // Struct size
} NET_OUT_STOP_APP;

// Input param of CLIENT_RemoveApp 
typedef struct tagNET_IN_REMOVE_APP
{
    DWORD                           dwSize;                     // Struct size
    UINT                            nAppID;                     // The ID of application program
    char                            szAppName[128];             // The name of application program
} NET_IN_REMOVE_APP;

// Output param of CLIENT_RemoveApp 
typedef struct tagNET_OUT_REMOVE_APP
{
    DWORD                           dwSize;                     // Struct size
} NET_OUT_REMOVE_APP;

// Get information of installed application program
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetInstalledAppInfo(LLONG lLoginID, const NET_IN_GET_INSTALLED_APP_INFO* pInParam, NET_OUT_GET_INSTALLED_APP_INFO* pOutParam, int nWaitTime);

// Start application program
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartApp(LLONG lLoginID, const NET_IN_START_APP* pInParam, NET_OUT_START_APP* pOutParam, int nWaitTime);

// Stop application program
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopApp(LLONG lLoginID, const NET_IN_STOP_APP* pInParam, NET_OUT_STOP_APP* pOutParam, int nWaitTime);

// Remove application program
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RemoveApp(LLONG lLoginID, const NET_IN_REMOVE_APP* pInParam, NET_OUT_REMOVE_APP* pOutParam, int nWaitTime);

// Input param of CLIENT_GetASGState
typedef struct tagNET_IN_ACCESS_GET_ASG_STATE
{
    DWORD           dwSize;                            
}NET_IN_ACCESS_GET_ASG_STATE;

// door wing state
typedef enum tagEM_DOOR_WING_STATE
{
    EM_DOOR_WING_STATE_UNKNOWN,                      // unknown
    EM_DOOR_WING_STATE_CLOSE,                        // close
    EM_DOOR_WING_STATE_ENTER_OPEN,                  // import open
    EM_DOOR_WING_STATE_LEAVE_OPEN,                  // export open
} EM_DOOR_WING_STATE;

// Can communicate state
typedef enum tagEM_CAN_COMMUNICATE_STATE
{
    EM_CAN_COMMUNICATE_STATE_UNKNOWN = -1,           // unknown
    EM_CAN_COMMUNICATE_STATE_NORMAL,                 // normal
    EM_CAN_COMMUNICATE_STATE_ABNORMAL,               // abnormal 
} EM_CAN_COMMUNICATE_STATE;

// Onput param ofCLIENT_GetASGState
typedef struct tagNET_OUT_ACCESS_GET_ASG_STATE
{
    DWORD                             dwSize;
    int                               nInfraredStateNum;              // Infrared state number
    int                               szInfraredStateMask[6];         // Infreared state mask; 
                                                                      // Array[0] bit0 represents the 1th way, bit7 represents the 8th way, array [1] bit0 represents the 9th way, bit7 represents the 16th way;
                                                                      // Bit definition, 0: off (not blocked), 1: on (blocked)
    EM_DOOR_WING_STATE                emDoorWingState;                // door wing state
    EM_CAN_COMMUNICATE_STATE          emCanState;                     // Can communicate state
    int                               nEnterNum;                      // enter number
    int                               nLeaveNum;                      // leave number       
}NET_OUT_ACCESS_GET_ASG_STATE;

// get ASG state
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetASGState(LLONG lLoginID, const NET_IN_ACCESS_GET_ASG_STATE* pInParam, NET_OUT_ACCESS_GET_ASG_STATE* pOutParam, int nWaitTime);


// Input param of CLIENT_StartFindXRayPkg
typedef struct tagNET_IN_START_FIND_XRAY_PKG
{
    DWORD                   dwSize;                 // Struct size
    EM_RESULT_ORDER_TYPE    emTimeOrder;            // the order of result order 
    NET_TIME			    stuStartTime;		    // Start time of finding
    NET_TIME			    stuEndTime;			    // End time of finding
    UINT                    nSimilarityRange[2];    // Similarity range,Index 0:minimum value;Index1:maximum value
    UINT                    nObjTypeNum;            // Object type num 
    EM_INSIDE_OBJECT_TYPE	emObjType[32];		    // Object type array
} NET_IN_START_FIND_XRAY_PKG;


// Output param of CLIENT_StartFindXRayPkg 
typedef struct tagNET_OUT_START_FIND_XRAY_PKG
{
    DWORD                   dwSize;                 // Struct size
    UINT                    nTotal;                 // The taotal count of the package
} NET_OUT_START_FIND_XRAY_PKG;



// Input param of CLIENT_DoFindXRayPkg
typedef struct tagNET_IN_DO_FIND_XRAY_PKG
{
    DWORD                   dwSize;                 // Struct size
	    UINT                nOffset;                // Offset 
    UINT                    nCount;                 // The fount you need to find
} NET_IN_DO_FIND_XRAY_PKG;

// Object info
typedef struct tagNET_PKG_OBJECT_INFO
{
    EM_INSIDE_OBJECT_TYPE	emObjType;		    	// Object type
    EM_DANGER_GRADE_TYPE	emDangerGrade;			// Danger grade
    UINT                    nSimilarity;	    	// Similarity,range 0~100
    BYTE                    byReserved[132];    	// Reserved
}NET_PKG_OBJECT_INFO;

// View info
typedef struct tagNET_PKG_VIEW_INFO
{
    EM_XRAY_VIEW_TYPE       emViewType;					// View type
    UINT                    nEnergyImageLength;         // The length of energy picture, unit:byte
    char                    szEnergyImagePath[128];     // The path of energy picture
    UINT                    nColorImageLength;          // The length of color picture, unit:byte
    char                    szColorImagePath[128];      // The path of color picture
    UINT                    nColorOverlayImageLength;   // The length of color overlay picture, unit:byte
    char                    szColorOverlayImagePath[128];// The path of color overlay picture
    NET_PKG_OBJECT_INFO     stuObject[32];          	// Object array
    UINT                    nObjectCount;           	// The count of the Object
    BYTE                    byReserved[1024];        	// Reserved
} NET_PKG_VIEW_INFO;

// The package info fo X-ray
typedef struct tagNET_XRAY_PKG_INFO
{
    NET_TIME			    stuTime;		    	// The time 
    int                     nChannelIn;             // The associated in-channel of IPC, which begin form 0 and -1 represents invalid
    int                     nChannelOut;            // The associated out-channel of IPC, which begin form 0 and -1 represents invalid
    char                    szUser[128];            // User name
    NET_PKG_VIEW_INFO       stuViewInfo[2];         // View info array
    BYTE                    byReserved[1024];        // Reserved
} NET_XRAY_PKG_INFO;

// Output param of CLIENT_DoFindXRayPkg 
typedef struct tagNET_OUT_DO_FIND_XRAY_PKG
{
    DWORD                   dwSize;                 // Struct size
    UINT                    nMaxCount;              // Number of user allocated structures which need to beyond the nCount of NET_IN_DO_FIND_XRAY_PKG
    UINT                    nRetCount;              // Number of actually returned
    NET_XRAY_PKG_INFO*      pstuXRayPkgInfo;        // The package info fo X-ray.Cache size specified by user
} NET_OUT_DO_FIND_XRAY_PKG;


// Start find X-ray package info
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartFindXRayPkg(LLONG lLoginID, const NET_IN_START_FIND_XRAY_PKG* pInParam, NET_OUT_START_FIND_XRAY_PKG* pOutParam, int nWaitTime);

// Do find the X-ray package info, lFindID is the search ID returned by the CLIENT_StartFindXRayPkg interface
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoFindXRayPkg(LLONG lFindID, const NET_IN_DO_FIND_XRAY_PKG* pInParam, NET_OUT_DO_FIND_XRAY_PKG* pOutParam, int nWaitTime);

// Stop find the X-ray package info,lFindID is the search ID returned by the CLIENT_StartFindXRayPkg interface
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindXRayPkg(LLONG lFindID);

// Callback info of monitor wall scene
typedef struct tagNET_CB_MONITOR_WALL_SCENE
{
    char                        szCurrentCollectionName[32];    // Name of current collection
    DH_MONITORWALL_SCENE        stuScene;                       // Monitor wall scene
    BYTE                        byReserve[1024];                // Reserved
} NET_CB_MONITOR_WALL_SCENE;

// The callback function of monitor wall scene, lAttachHandle is the function CLIENT_AttachMonitorWallScene's return value 
typedef void (CALLBACK *fMonitorWallScene)(LLONG lAttachHandle, NET_CB_MONITOR_WALL_SCENE* pstResult, LDWORD dwUser);

// Input param of CLIENT_AttachMonitorWallScene 
typedef struct tagNET_IN_ATTACH_MONITOR_WALL_SCENE
{
    DWORD                           dwSize;                         // Struct size
    int                             nMonitorWallID;                 // Monitor wall ID
    fMonitorWallScene               cbMonitorWallScene;             // The callback function of monitor wall scene
    LDWORD                          dwUser;                         // User data
} NET_IN_ATTACH_MONITOR_WALL_SCENE;

// Output param of CLIENT_AttachMonitorWallScene 
typedef struct tagNET_OUT_ATTACH_MONITOR_WALL_SCENE
{
    DWORD                           dwSize;                         // Struct size
} NET_OUT_ATTACH_MONITOR_WALL_SCENE;

// Attach monitor wall scene
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachMonitorWallScene(LLONG lLoginID, NET_IN_ATTACH_MONITOR_WALL_SCENE* pInParam, NET_OUT_ATTACH_MONITOR_WALL_SCENE* pOutParam, const int nWaitTime);

// Detach monitor wall scene, lAttachHandle is the function CLIENT_AttachMonitorWallScene's return value 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachMonitorWallScene(LLONG lAttachHandle);

// Input param of CLIENT_GetSystemCaps
typedef struct tagNET_IN_SYSTEM_GETCAPS
{
	DWORD     dwSize;                   // Struct size
}NET_IN_SYSTEM_GETCAPS;

// Output param of CLIENT_GetSystemCaps
typedef struct tagNET_OUT_SYSTEM_GETCAPS
{
	DWORD               dwSize;                 // Struct size
	BOOL                bSupportCascadeCall;    // Support cascade call or not
	DWORD               dwCascadeType;          // Cascade type, it is effective if bSupportCascadeCall is TRUE
	                                            //The value is mask mode, and the first bit represents channel mode
}NET_OUT_SYSTEM_GETCAPS;

// Get systems caps
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSystemCaps(LLONG lLoginID, const NET_IN_SYSTEM_GETCAPS* pInParam, NET_OUT_SYSTEM_GETCAPS* pOutParam, const int nWaitTime);

// input parameter of interface  CLIENT_GetNMPDevInfo
typedef struct tagNET_IN_GET_NMPDEV_INFO
{
	DWORD			dwSize;			// struct size:assignment when init the struct
}NET_IN_GET_NMPDEV_INFO;

// Device information attached to the switch
typedef struct tagNET_NEM_CONNECT_DEVICE_INFO
{
	char		szAddress[40];				// Device address or domain name
	char		szProtocolType[32];			// Protocol type of connected device
	char		szDeviceType[64];			// Equipment type
	char		szMac[18];					// Device MAC address, colon + uppercase
	char		szName[64];					// Device Name
	char		szVendor[32];				// Equipment manufacturer
	BYTE		byReserved[126];			// Reserved byte
}NET_NEM_CONNECT_DEVICE_INFO;

// Neighbor device array
typedef struct tagNET_NEIGHBORS_INFO
{
	char						szRemotePortId[64];				// Neighbor device connection port description
	char						szRemoteDevice[128];			// Unique value of neighbor device
	NET_NEM_CONNECT_DEVICE_INFO	stuDeviceInfo;					// Device information
	BYTE						byReserved[128];				// Reserved byte
}NET_NEIGHBORS_INFO;

// Device status
typedef enum tagEM_DEV_STATUS
{
	EM_DEV_STATUS_UNKNOWN = -1,					// Unknown
	EM_DEV_STATUS_OFFLINE,						// Off line
	EM_DEV_STATUS_ONLINE,						// On  line
}EM_DEV_STATUS;

// port connection status
typedef enum tagEM_PORT_STATUS
{
	EM_PORT_STATUS_UNKNOWN = -1,				// Unknown
	EM_PORT_STATUS_DOWN,						// Down
	EM_PORT_STATUS_UP,							// Up
}EM_PORT_STATUS;

// port transport madia
typedef	enum tagEM_MEDIA_TYPE
{
	EM_MEDIA_TYPE_UNKNOWN,						// Unknown
	EM_MEDIA_TYPE_COPPER,						// Copper
	EM_MEDIA_TYPE_FIBER,						// Fiber
}EM_MEDIA_TYPE;

// Port duplex status
typedef enum tagEM_DUPLEX_MODE
{
	EM_DUPLEX_MODE_UNKNOWN,						// Unknown
	EM_DUPLEX_MODE_HALFDUPLEX,					// Halfduplex
	EM_DUPLEX_MODE_FULLDUPLEX,					// FullDuplex
}EM_DUPLEX_MODE;

// PoE status
typedef enum tagEM_POE_STATUS
{
	EM_POE_STATUS_UNKNOWN = -1,					// Unknown
	EM_POE_STATUS_NONENABLE,					// Non Enable
	EM_POE_STATUS_ENABLE,						// Enable
	EM_POE_STATUS_UNSUPPORTED,					// Unsupported
}EM_POE_STATUS;

// Port traffic status
typedef enum tagEM_FLOW_STATUS
{
	EM_FLOW_STATUS_UNKNOWN = -1,				// Unknown
	EM_FLOW_STATUS_NORMAL,						// Normal
	EM_FLOW_STATUS_ABNORMAL,					// Abnormal
}EM_FLOW_STATUS;

// Device port information
typedef struct tagNET_NMPDEVPORT_INFO
{
	DWORD			dwLocalPortId;				// Device connection port number
	EM_POE_STATUS	emPoEStatus;				//  PoE status
	char			szLocalPortDescr[64];		// Device connection port description
	int				nChassisId;					// Box ID of port
	int				nSlotId;					// Slot ID of port
	char			szAliasName[64];			// Device port alias
	DWORD			dwAggregationId;			// Aggregation ID (0 means it does not belong to aggregation
	DWORD			dwSpeed;					// Port negotiation rateUnitmbps
	EM_PORT_STATUS	emStatus;					// Port connection status
	EM_MEDIA_TYPE	emMedia;					// Port transport media
	EM_DUPLEX_MODE	emDuplexMode;				// Port duplex status
	float			fPoEPower;					// PoE power consumption
	TP_U64			dwInUcastPkts;				// Number of unicast received messages
	TP_U64			dwOutUcastPkts;				// Number of unicast messages send
	TP_U64			dwInBroadcastPkts;			// Number of broadcast received messages
	TP_U64			dwOutBroadcastPkts;			// Number of broadcast messages
	TP_U64			dwInMulticastPkts;			// Number of messages received by multicast
	TP_U64			dwOutMulticastPkts;			// Number of multicast messages send
	TP_U64			dwInDiscardPkts;			// Number of packet loss received
	TP_U64			dwOutDiscardPkts;			// Number of packet loss send
	INT64			nInPausePkts;				// Total number of received pause frames (- 1 indicates illegal value)
	INT64			nOutPausePkts;				// Total number of pause frames sent (- 1 indicates illegal value)
	INT64			nInFilterPkts;				// Total number of packets filtered (- 1 indicates illegal value)
	TP_U64			dwInOctets;					// Total bytes received
	TP_U64			dwOutOctets;				// Total bytes send
	TP_U64			dwInRate;					// Receive real time rateUnitByte
	TP_U64			dwOutRate;					// Send real time rateUnitByte
	EM_FLOW_STATUS	emFlowStatus;				// Port traffic status
	int				nRetNeighborsNum;					// Number of neighbor devices array
	NET_NEIGHBORS_INFO	stuNeighbors[255];		// Neighbor device array
	BYTE			byReserved[1024];			// Reserved byte
}NET_NMPDEVPORT_INFO;

// Device information
typedef struct tagNET_NMPDEV_INFO
{
	char			szAddress[40];				// Device address or domain name
	char			szDeviceClass[64];			// Device class
	char			szDeviceType[64];			// Device type
	char			szMac[18];					// Device MAC address, colon + uppercase
	BYTE			byReserved2[6];				// byte alignment
	char			szProtocolType[32];			// Protocol type of connected device
	char			szVersion[32];				// Device version No
	char			szSerialNo[64];				// Device serial number
	char			szName[64];					// Device name
	DWORD			dwRetPortNum;				// Number of device return ports
	int				nPortListMaxNum;			// Number of port information allocated by users
	NET_NMPDEVPORT_INFO	*pstuPorList;			// Port information group
	BOOL			bPoESupport;				// Whether Poe is supported
	float			fPoETotalPower;				// Total power consumption of PoE
	float			fPoERemainPower;			// Poe remaining power consumption
	DWORD			dwUptime;					// Power on operation time (unit: minute)
	int				nCPUUsage;					// CPU usage (percentage), - 1 is illegal
	EM_DEV_STATUS	emStatus;					// Device status
	char			szSubnetMask[40];			// Subnet mask
	char			szParent[128];				// Unique value of the parent device
	char			szVendor[32];				// Device manufacturer
	DWORD			dwPortNumber;				// Total port number of equipment
	BYTE			byReserved[1020];			// Reserved byte
}NET_NMPDEV_INFO;

// output parameter of interface  CLIENT_GetNMPDevInfo
typedef struct tagNET_OUT_GET_NMPDEV_INFO
{
	DWORD					dwSize;					// struct size:assignment when init the struct
	BYTE					byReserved[4];			// byte alignment
	NET_NMPDEV_INFO         stuNMPDevInfo;			// Device information
}NET_OUT_GET_NMPDEV_INFO;

// Get NMP Device info
CLIENT_NET_API BOOL	CALL_METHOD CLIENT_GetNMPDevInfo(LLONG lLoginID, const NET_IN_GET_NMPDEV_INFO *pInParam, NET_OUT_GET_NMPDEV_INFO *pOutParam, int nWaitTime);

///////////////////////////////////deprecated  Start///////////////////////////////////

// Search system server setup. This interface is invalid now please use  CLIENT_GetDevConfig
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryConfig(LLONG lLoginID, int nConfigType, char *pConfigbuf, int maxlen, int *nConfigbuflen, int waittime);

// Set system server setup. This interface is invalid now please use  CLIENT_SetDevConfig
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetupConfig(LLONG lLoginID, int nConfigType, char *pConfigbuf, int nConfigbuflen, int waittime);

// This interface is invalid now. 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Reset(LLONG lLoginID, BOOL bReset);

// Search COM protocol. This interface is invalid now please use  CLIENT_GetDevConfig
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryComProtocol(LLONG lLoginID, int nProtocolType, char *pProtocolBuffer, int maxlen, int *nProtocollen, int waittime);

// Begin audio talk. This interface is invalid now. Please use  CLIENT_StartTalkEx
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartTalk(LLONG lRealHandle, BOOL bCustomSend);

// Stop audio talk. This interface is invalid now , please use  CLIENT_StopTalkEx
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopTalk(LLONG lRealHandle);

// Send out self-defined audio talk data. This interface is invalid now, please use  CLIENT_TalkSendData
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SendTalkData_Custom(LLONG lRealHandle, char *pBuffer, DWORD dwBufSize);

// Set real-time preview buffer size
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetPlayerBufNumber(LLONG lRealHandle, DWORD dwBufNum);

// Download file by time
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetFileByTime(LLONG lLoginID, int nChannelID, LPNET_TIME lpStartTime, LPNET_TIME lpStopTime, char *sSavedFileName);

// Network playback control 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PlayBackControl(LLONG lPlayHandle, DWORD dwControlCode, DWORD dwInValue, DWORD *lpOutValue);

// Search device working status .This interface is invalid now, please use  CLIENT_QueryDevState
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDEVWorkState(LLONG lLoginID, LPNET_DEV_WORKSTATE lpWorkState, int waittime);

// Asynchronism search device log 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryLogCallback(LLONG lLoginID, fLogDataCallBack cbLogData, LDWORD dwUser);

// open or close record for mpt300,user malloc and free memory of pstRecIn and pstRecOut
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RecMngCtrlMpt300(LLONG lLoginID, const NET_IN_REC_MNG_CTRL_MPT300 *pstRecIn, NET_OUT_REC_MNG_CTRL_MPT300 *pstRecOut, int nWaitTime);

// Transmit Info Directly,user malloc and free memory of pstInTransmit and pstOutTransmit
CLIENT_NET_API BOOL CALL_METHOD CLIENT_TransmitInfoDirectly(LLONG lLoginID, const NET_IN_TRANSMIT_DIRECTLY *pstInTransmit, NET_OUT_TRANSMIT_DIRECTLY *pstOutTransmit, int nWaittime );

// call back for Transmit Info Directly
typedef void (CALLBACK *fTransmitInfoDirectlyCallBack)(LLONG lLoginID, LLONG lStartHandle, const char *pszOutBuf, DWORD dwBufLen, LDWORD dwUser);

// start Transmit Info Directly,user malloc and free memory of pstInTransmit and pstOutTransmit
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartTransmitInfoDirectly(LLONG lLoginID, const NET_IN_TRANSMIT_DIRECTLY *pstInTransmit, NET_OUT_TRANSMIT_DIRECTLY *pstOutTransmit, fTransmitInfoDirectlyCallBack cbDirectly, LDWORD dwUser, int nWaitTime );

// stop Transmit Info Directly,user malloc and free memory of pstInTransmit and pstOutTransmit
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopTransmitInfoDirectly(LLONG lStartHandle, const NET_IN_TRANSMIT_DIRECTLY *pstInTransmit, NET_OUT_TRANSMIT_DIRECTLY *pstOutTransmit, int nWaitTime );

// Get VK,This interface is deprecated now, please use CLIENT_AttachVK
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetVK(LLONG lLoginID, const NET_IN_GET_VKINFO* pInParam, NET_OUT_GET_VKINFO* pOutParam, int nWaitTime);

// GDPR Vserion
typedef enum tagEM_GDPR_VERSION
{
	EM_GDPR_VERSION_NON = 0,		// Non GDPR
	EM_GDPR_VERSION_V1,				// GDPR V1,support GDPR1.0 realplay and playback
	EM_GDPR_VERSION_V2,				// GDPR V2,support GDPR2.0 realplay and playback
}EM_GDPR_VERSION;

// Get GDPR Version,please use CLIENT_GetGDPRAbility instead
CLIENT_NET_API BOOL	CALL_METHOD CLIENT_GetGDPRVersion(LLONG lLoginID, EM_GDPR_VERSION* pVersion, int nWaitTime);
///////////////////////////////////deprecated  End///////////////////////////////////

#ifdef __cplusplus
}
#endif
#endif // DHNETSDK_H



